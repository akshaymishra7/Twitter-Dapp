{"ast":null,"code":"import { WebRTCPeer } from './peer.js';\nimport { WebRTCHandshake } from './handshake.js';\nimport { CustomEvent } from '@libp2p/interfaces/events';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:webrtc-peer:receiver');\nexport class WebRTCReceiver extends WebRTCPeer {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({ ...opts,\n      logPrefix: 'receiver'\n    });\n    this.handshake = new WebRTCReceiverHandshake({\n      log: this.log,\n      peerConnection: this.peerConnection,\n      wrtc: this.wrtc,\n      answerOptions: opts.answerOptions\n    });\n    this.handshake.addEventListener('signal', event => this.dispatchEvent(new CustomEvent('signal', {\n      detail: event.detail\n    })));\n    this.peerConnection.addEventListener('datachannel', event => {\n      this.handleDataChannelEvent(event);\n    });\n  }\n\n  handleSignal(signal) {\n    this.handshake.handleSignal(signal).catch(err => {\n      this.log('error handling signal %o %o', signal, err);\n    });\n  }\n\n}\n\nclass WebRTCReceiverHandshake extends WebRTCHandshake {\n  constructor(options) {\n    super(options);\n    this.options = options;\n    this.status = 'idle';\n    this.iceCandidates = [];\n  }\n\n  async handleRenegotiate() {\n    log.trace('renegotiate');\n    this.dispatchEvent(new CustomEvent('signal', {\n      detail: {\n        type: 'renegotiate'\n      }\n    }));\n  }\n\n  async handleOffer(signal) {\n    await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(signal)); // add any candidates we were sent before the offer arrived\n\n    for (const candidate of this.iceCandidates) {\n      await this.handleCandidate(candidate);\n    }\n\n    this.iceCandidates = [];\n    const answer = await this.peerConnection.createAnswer(this.options.answerOptions);\n    await this.peerConnection.setLocalDescription(answer);\n    log.trace('handle offer', this.peerConnection.localDescription);\n    this.dispatchEvent(new CustomEvent('signal', {\n      detail: this.peerConnection.localDescription ?? answer\n    }));\n  }\n\n  async handleCandidate(signal) {\n    if (this.peerConnection.remoteDescription == null || this.peerConnection.remoteDescription.type == null) {\n      // we haven't been sent an offer yet, cache the remote ICE candidates\n      this.iceCandidates.push(signal);\n      return;\n    }\n\n    await super.handleCandidate(signal);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["WebRTCPeer","WebRTCHandshake","CustomEvent","logger","log","WebRTCReceiver","constructor","opts","logPrefix","handshake","WebRTCReceiverHandshake","peerConnection","wrtc","answerOptions","addEventListener","event","dispatchEvent","detail","handleDataChannelEvent","handleSignal","signal","catch","err","options","status","iceCandidates","handleRenegotiate","trace","type","handleOffer","setRemoteDescription","RTCSessionDescription","candidate","handleCandidate","answer","createAnswer","setLocalDescription","localDescription","remoteDescription","push"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\webrtc-peer\\src\\receiver.ts"],"sourcesContent":["import { WebRTCPeer } from './peer.js'\nimport { WebRTCHandshake } from './handshake.js'\nimport { CustomEvent } from '@libp2p/interfaces/events'\nimport { logger } from '@libp2p/logger'\nimport type { WebRTCHandshakeOptions } from './handshake.js'\nimport type { WebRTCReceiverInit, OfferSignal, Signal, CandidateSignal } from './index.js'\n\nconst log = logger('libp2p:webrtc-peer:receiver')\n\nexport class WebRTCReceiver extends WebRTCPeer {\n  private readonly handshake: WebRTCReceiverHandshake\n\n  constructor (opts: WebRTCReceiverInit = {}) {\n    super({\n      ...opts,\n      logPrefix: 'receiver'\n    })\n\n    this.handshake = new WebRTCReceiverHandshake({\n      log: this.log,\n      peerConnection: this.peerConnection,\n      wrtc: this.wrtc,\n      answerOptions: opts.answerOptions\n    })\n\n    this.handshake.addEventListener('signal', event => this.dispatchEvent(new CustomEvent('signal', {\n      detail: event.detail\n    })))\n    this.peerConnection.addEventListener('datachannel', (event) => {\n      this.handleDataChannelEvent(event)\n    })\n  }\n\n  handleSignal (signal: Signal) {\n    this.handshake.handleSignal(signal).catch(err => {\n      this.log('error handling signal %o %o', signal, err)\n    })\n  }\n}\n\ninterface WebRTCReceiverHandshakeOptions extends WebRTCHandshakeOptions {\n  answerOptions?: RTCAnswerOptions\n}\n\nclass WebRTCReceiverHandshake extends WebRTCHandshake {\n  private readonly options: WebRTCReceiverHandshakeOptions\n  private iceCandidates: CandidateSignal[]\n\n  constructor (options: WebRTCReceiverHandshakeOptions) {\n    super(options)\n\n    this.options = options\n    this.status = 'idle'\n    this.iceCandidates = []\n  }\n\n  async handleRenegotiate () {\n    log.trace('renegotiate')\n\n    this.dispatchEvent(new CustomEvent<Signal>('signal', {\n      detail: {\n        type: 'renegotiate'\n      }\n    }))\n  }\n\n  async handleOffer (signal: OfferSignal) {\n    await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(signal))\n\n    // add any candidates we were sent before the offer arrived\n    for (const candidate of this.iceCandidates) {\n      await this.handleCandidate(candidate)\n    }\n    this.iceCandidates = []\n\n    const answer = await this.peerConnection.createAnswer(this.options.answerOptions)\n\n    await this.peerConnection.setLocalDescription(answer)\n\n    log.trace('handle offer', this.peerConnection.localDescription)\n\n    this.dispatchEvent(new CustomEvent('signal', {\n      detail: this.peerConnection.localDescription ?? answer\n    }))\n  }\n\n  async handleCandidate (signal: CandidateSignal) {\n    if (this.peerConnection.remoteDescription == null || this.peerConnection.remoteDescription.type == null) {\n      // we haven't been sent an offer yet, cache the remote ICE candidates\n      this.iceCandidates.push(signal)\n\n      return\n    }\n\n    await super.handleCandidate(signal)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}