{"ast":null,"code":"import errCode from 'err-code';\nimport { anySignal } from 'any-signal';\nimport FIFO from 'p-fifo';\nimport { setMaxListeners } from 'events';\nimport { codes } from '../../errors.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:dialer:dial-request');\nexport class DialRequest {\n  /**\n   * Manages running the `dialAction` on multiple provided `addrs` in parallel\n   * up to a maximum determined by the number of tokens returned\n   * from `dialer.getTokens`. Once a DialRequest is created, it can be\n   * started using `DialRequest.run(options)`. Once a single dial has succeeded,\n   * all other dials in the request will be cancelled.\n   */\n  constructor(options) {\n    const {\n      addrs,\n      dialAction,\n      dialer\n    } = options;\n    this.addrs = addrs;\n    this.dialer = dialer;\n    this.dialAction = dialAction;\n  }\n\n  async run() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const tokens = this.dialer.getTokens(this.addrs.length); // If no tokens are available, throw\n\n    if (tokens.length < 1) {\n      throw errCode(new Error('No dial tokens available'), codes.ERR_NO_DIAL_TOKENS);\n    }\n\n    const tokenHolder = new FIFO();\n\n    for (const token of tokens) {\n      void tokenHolder.push(token).catch(err => {\n        log.error(err);\n      });\n    }\n\n    const dialAbortControllers = this.addrs.map(() => {\n      const controller = new AbortController();\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, controller.signal);\n      } catch {}\n\n      return controller;\n    });\n\n    if (options.signal != null) {\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, options.signal);\n      } catch {}\n    }\n\n    let completedDials = 0;\n    let done = false;\n\n    try {\n      return await Promise.any(this.addrs.map(async (addr, i) => {\n        const token = await tokenHolder.shift(); // get token\n        // End attempt once another attempt succeeded\n\n        if (done) {\n          this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);\n          throw errCode(new Error('dialAction already succeeded'), codes.ERR_ALREADY_SUCCEEDED);\n        }\n\n        const controller = dialAbortControllers[i];\n\n        if (controller == null) {\n          throw errCode(new Error('dialAction did not come with an AbortController'), codes.ERR_INVALID_PARAMETERS);\n        }\n\n        let conn;\n\n        try {\n          const signal = controller.signal;\n          conn = await this.dialAction(addr, { ...options,\n            signal: options.signal != null ? anySignal([signal, options.signal]) : signal\n          }); // Remove the successful AbortController so it is not aborted\n\n          dialAbortControllers[i] = undefined;\n        } finally {\n          completedDials++; // If we have more or equal dials remaining than tokens, recycle the token, otherwise release it\n\n          if (this.addrs.length - completedDials >= tokens.length) {\n            void tokenHolder.push(token).catch(err => {\n              log.error(err);\n            });\n          } else {\n            this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);\n          }\n        }\n\n        if (conn == null) {\n          // Notify Promise.any that attempt was not successful\n          // to prevent from returning undefined despite there\n          // were successful dial attempts\n          throw errCode(new Error('dialAction led to empty object'), codes.ERR_TRANSPORT_DIAL_FAILED);\n        } else {\n          // This dial succeeded, don't attempt anything else\n          done = true;\n        }\n\n        return conn;\n      }));\n    } finally {\n      // success/failure happened, abort everything else\n      dialAbortControllers.forEach(c => {\n        if (c !== undefined) {\n          c.abort();\n        }\n      });\n      tokens.forEach(token => this.dialer.releaseToken(token)); // release tokens back to the dialer\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["errCode","anySignal","FIFO","setMaxListeners","codes","logger","log","DialRequest","constructor","options","addrs","dialAction","dialer","run","tokens","getTokens","length","Error","ERR_NO_DIAL_TOKENS","tokenHolder","token","push","catch","err","error","dialAbortControllers","map","controller","AbortController","Infinity","signal","completedDials","done","Promise","any","addr","i","shift","releaseToken","splice","indexOf","ERR_ALREADY_SUCCEEDED","ERR_INVALID_PARAMETERS","conn","undefined","ERR_TRANSPORT_DIAL_FAILED","forEach","c","abort"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\connection-manager\\dialer\\dial-request.ts"],"sourcesContent":["import errCode from 'err-code'\nimport { anySignal } from 'any-signal'\nimport FIFO from 'p-fifo'\nimport { setMaxListeners } from 'events'\nimport { codes } from '../../errors.js'\nimport { logger } from '@libp2p/logger'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Connection } from '@libp2p/interface-connection'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Dialer } from '@libp2p/interface-connection-manager'\n\nconst log = logger('libp2p:dialer:dial-request')\n\nexport interface DialAction {\n  (m: Multiaddr, options: AbortOptions): Promise<Connection>\n}\n\nexport interface DialRequestOptions {\n  addrs: Multiaddr[]\n  dialAction: DialAction\n  dialer: Dialer\n}\n\nexport class DialRequest {\n  private readonly addrs: Multiaddr[]\n  private readonly dialer: Dialer\n  private readonly dialAction: DialAction\n\n  /**\n   * Manages running the `dialAction` on multiple provided `addrs` in parallel\n   * up to a maximum determined by the number of tokens returned\n   * from `dialer.getTokens`. Once a DialRequest is created, it can be\n   * started using `DialRequest.run(options)`. Once a single dial has succeeded,\n   * all other dials in the request will be cancelled.\n   */\n  constructor (options: DialRequestOptions) {\n    const {\n      addrs,\n      dialAction,\n      dialer\n    } = options\n\n    this.addrs = addrs\n    this.dialer = dialer\n    this.dialAction = dialAction\n  }\n\n  async run (options: AbortOptions = {}): Promise<Connection> {\n    const tokens = this.dialer.getTokens(this.addrs.length)\n\n    // If no tokens are available, throw\n    if (tokens.length < 1) {\n      throw errCode(new Error('No dial tokens available'), codes.ERR_NO_DIAL_TOKENS)\n    }\n\n    const tokenHolder = new FIFO<number>()\n\n    for (const token of tokens) {\n      void tokenHolder.push(token).catch(err => {\n        log.error(err)\n      })\n    }\n\n    const dialAbortControllers: Array<(AbortController | undefined)> = this.addrs.map(() => {\n      const controller = new AbortController()\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, controller.signal)\n      } catch {}\n\n      return controller\n    })\n\n    if (options.signal != null) {\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, options.signal)\n      } catch {}\n    }\n\n    let completedDials = 0\n    let done = false\n\n    try {\n      return await Promise.any(this.addrs.map(async (addr, i) => {\n        const token = await tokenHolder.shift() // get token\n        // End attempt once another attempt succeeded\n        if (done) {\n          this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0])\n          throw errCode(new Error('dialAction already succeeded'), codes.ERR_ALREADY_SUCCEEDED)\n        }\n\n        const controller = dialAbortControllers[i]\n        if (controller == null) {\n          throw errCode(new Error('dialAction did not come with an AbortController'), codes.ERR_INVALID_PARAMETERS)\n        }\n        let conn\n        try {\n          const signal = controller.signal\n          conn = await this.dialAction(addr, { ...options, signal: (options.signal != null) ? anySignal([signal, options.signal]) : signal })\n          // Remove the successful AbortController so it is not aborted\n          dialAbortControllers[i] = undefined\n        } finally {\n          completedDials++\n          // If we have more or equal dials remaining than tokens, recycle the token, otherwise release it\n          if (this.addrs.length - completedDials >= tokens.length) {\n            void tokenHolder.push(token).catch(err => {\n              log.error(err)\n            })\n          } else {\n            this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0])\n          }\n        }\n\n        if (conn == null) {\n          // Notify Promise.any that attempt was not successful\n          // to prevent from returning undefined despite there\n          // were successful dial attempts\n          throw errCode(new Error('dialAction led to empty object'), codes.ERR_TRANSPORT_DIAL_FAILED)\n        } else {\n          // This dial succeeded, don't attempt anything else\n          done = true\n        }\n\n        return conn\n      }))\n    } finally {\n      // success/failure happened, abort everything else\n      dialAbortControllers.forEach(c => {\n        if (c !== undefined) {\n          c.abort()\n        }\n      })\n      tokens.forEach(token => this.dialer.releaseToken(token)) // release tokens back to the dialer\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}