{"ast":null,"code":"import errCode from 'err-code';\nimport { OPEN, CLOSING, CLOSED } from '@libp2p/interface-connection/status';\nimport { symbol } from '@libp2p/interface-connection';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:connection');\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\n\nexport class ConnectionImpl {\n  /**\n   * An implementation of the js-libp2p connection.\n   * Any libp2p transport should use an upgrader to return this connection.\n   */\n  constructor(init) {\n    const {\n      remoteAddr,\n      remotePeer,\n      newStream,\n      close,\n      getStreams,\n      stat\n    } = init;\n    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;\n    this.remoteAddr = remoteAddr;\n    this.remotePeer = remotePeer;\n    this.stat = { ...stat,\n      status: OPEN\n    };\n    this._newStream = newStream;\n    this._close = close;\n    this._getStreams = getStreams;\n    this.tags = [];\n    this._closing = false;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Connection';\n  }\n\n  get [symbol]() {\n    return true;\n  }\n  /**\n   * Get all the streams of the muxer\n   */\n\n\n  get streams() {\n    return this._getStreams();\n  }\n  /**\n   * Create a new stream from this connection\n   */\n\n\n  async newStream(protocols, options) {\n    if (this.stat.status === CLOSING) {\n      throw errCode(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED');\n    }\n\n    if (this.stat.status === CLOSED) {\n      throw errCode(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED');\n    }\n\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols];\n    }\n\n    const stream = await this._newStream(protocols, options);\n    stream.stat.direction = 'outbound';\n    return stream;\n  }\n  /**\n   * Add a stream when it is opened to the registry\n   */\n\n\n  addStream(stream) {\n    stream.stat.direction = 'inbound';\n  }\n  /**\n   * Remove stream registry after it is closed\n   */\n\n\n  removeStream(id) {}\n  /**\n   * Close the connection\n   */\n\n\n  async close() {\n    if (this.stat.status === CLOSED || this._closing) {\n      return;\n    }\n\n    this.stat.status = CLOSING; // close all streams - this can throw if we're not multiplexed\n\n    try {\n      this.streams.forEach(s => s.close());\n    } catch (err) {\n      log.error(err);\n    } // Close raw connection\n\n\n    this._closing = true;\n    await this._close();\n    this._closing = false;\n    this.stat.timeline.close = Date.now();\n    this.stat.status = CLOSED;\n  }\n\n}\nexport function createConnection(init) {\n  return new ConnectionImpl(init);\n}","map":{"version":3,"mappings":"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","names":["errCode","OPEN","CLOSING","CLOSED","symbol","logger","log","ConnectionImpl","constructor","init","remoteAddr","remotePeer","newStream","close","getStreams","stat","id","parseInt","String","Math","random","toString","Date","now","status","_newStream","_close","_getStreams","tags","_closing","Symbol","toStringTag","streams","protocols","options","Error","Array","isArray","stream","direction","addStream","removeStream","forEach","s","err","error","timeline","createConnection"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\connection\\index.ts"],"sourcesContent":["import type { Multiaddr } from '@multiformats/multiaddr'\nimport errCode from 'err-code'\nimport { OPEN, CLOSING, CLOSED } from '@libp2p/interface-connection/status'\nimport { symbol } from '@libp2p/interface-connection'\nimport type { Connection, ConnectionStat, Stream } from '@libp2p/interface-connection'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport { logger } from '@libp2p/logger'\nimport type { AbortOptions } from '@libp2p/interfaces'\n\nconst log = logger('libp2p:connection')\n\ninterface ConnectionInit {\n  remoteAddr: Multiaddr\n  remotePeer: PeerId\n  newStream: (protocols: string[], options?: AbortOptions) => Promise<Stream>\n  close: () => Promise<void>\n  getStreams: () => Stream[]\n  stat: ConnectionStat\n}\n\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\nexport class ConnectionImpl implements Connection {\n  /**\n   * Connection identifier.\n   */\n  public readonly id: string\n\n  /**\n   * Observed multiaddr of the remote peer\n   */\n  public readonly remoteAddr: Multiaddr\n\n  /**\n   * Remote peer id\n   */\n  public readonly remotePeer: PeerId\n\n  /**\n   * Connection metadata\n   */\n  public readonly stat: ConnectionStat\n\n  /**\n   * User provided tags\n   *\n   */\n  public tags: string[]\n\n  /**\n   * Reference to the new stream function of the multiplexer\n   */\n  private readonly _newStream: (protocols: string[], options?: AbortOptions) => Promise<Stream>\n\n  /**\n   * Reference to the close function of the raw connection\n   */\n  private readonly _close: () => Promise<void>\n\n  /**\n   * Reference to the getStreams function of the muxer\n   */\n  private readonly _getStreams: () => Stream[]\n\n  private _closing: boolean\n\n  /**\n   * An implementation of the js-libp2p connection.\n   * Any libp2p transport should use an upgrader to return this connection.\n   */\n  constructor (init: ConnectionInit) {\n    const { remoteAddr, remotePeer, newStream, close, getStreams, stat } = init\n\n    this.id = `${(parseInt(String(Math.random() * 1e9))).toString(36)}${Date.now()}`\n    this.remoteAddr = remoteAddr\n    this.remotePeer = remotePeer\n    this.stat = {\n      ...stat,\n      status: OPEN\n    }\n    this._newStream = newStream\n    this._close = close\n    this._getStreams = getStreams\n    this.tags = []\n    this._closing = false\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Connection'\n  }\n\n  get [symbol] () {\n    return true\n  }\n\n  /**\n   * Get all the streams of the muxer\n   */\n  get streams () {\n    return this._getStreams()\n  }\n\n  /**\n   * Create a new stream from this connection\n   */\n  async newStream (protocols: string | string[], options?: AbortOptions): Promise<Stream> {\n    if (this.stat.status === CLOSING) {\n      throw errCode(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED')\n    }\n\n    if (this.stat.status === CLOSED) {\n      throw errCode(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED')\n    }\n\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    const stream = await this._newStream(protocols, options)\n\n    stream.stat.direction = 'outbound'\n\n    return stream\n  }\n\n  /**\n   * Add a stream when it is opened to the registry\n   */\n  addStream (stream: Stream) {\n    stream.stat.direction = 'inbound'\n  }\n\n  /**\n   * Remove stream registry after it is closed\n   */\n  removeStream (id: string) {\n\n  }\n\n  /**\n   * Close the connection\n   */\n  async close () {\n    if (this.stat.status === CLOSED || this._closing) {\n      return\n    }\n\n    this.stat.status = CLOSING\n\n    // close all streams - this can throw if we're not multiplexed\n    try {\n      this.streams.forEach(s => s.close())\n    } catch (err) {\n      log.error(err)\n    }\n\n    // Close raw connection\n    this._closing = true\n    await this._close()\n    this._closing = false\n\n    this.stat.timeline.close = Date.now()\n    this.stat.status = CLOSED\n  }\n}\n\nexport function createConnection (init: ConnectionInit): Connection {\n  return new ConnectionImpl(init)\n}\n"]},"metadata":{},"sourceType":"module"}