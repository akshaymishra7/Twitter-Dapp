{"ast":null,"code":"import { NotFoundError } from '../errors.js';\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Key} Key\n */\n\n/**\n * @param {Key} key\n * @param {function (Key): Promise<boolean>} has\n * @param {Datastore} store\n * @returns {Promise<boolean>}\n */\n\nexport async function hasWithFallback(key, has, store) {\n  const result = await has(key);\n\n  if (result) {\n    return result;\n  } // Newer versions of level.js changed the key type from Uint8Array|string\n  // to Uint8Array  so fall back to trying Uint8Arrays if we are using level.js\n  // and the string version of the key did not work\n\n\n  const levelJs = findLevelJs(store);\n\n  if (!levelJs) {\n    return false;\n  }\n\n  return new Promise((resolve, reject) => {\n    // drop down to IndexDB API, otherwise level-js will monkey around with the keys/values\n    // @ts-ignore\n    const req = levelJs.store('readonly').get(key.toString());\n\n    req.transaction.onabort = () => {\n      reject(req.transaction.error);\n    };\n\n    req.transaction.oncomplete = () => {\n      resolve(Boolean(req.result));\n    };\n  });\n}\n/**\n * @param {import('interface-datastore').Key} key\n * @param {function (Key): Promise<Uint8Array>} get\n * @param {function (Key): Promise<boolean>} has\n * @param {import('interface-datastore').Datastore} store\n * @returns {Promise<Uint8Array>}\n */\n\nexport async function getWithFallback(key, get, has, store) {\n  if (await has(key)) {\n    return get(key);\n  } // Newer versions of level.js changed the key type from Uint8Array|string\n  // to Uint8Array so fall back to trying Uint8Arrays if we are using level.js\n  // and the string version of the key did not work\n\n\n  const levelJs = findLevelJs(store);\n\n  if (!levelJs) {\n    throw new NotFoundError();\n  }\n\n  return new Promise((resolve, reject) => {\n    // drop down to IndexDB API, otherwise level-js will monkey around with the keys/values\n    // @ts-ignore\n    const req = levelJs.store('readonly').get(key.toString());\n\n    req.transaction.onabort = () => {\n      reject(req.transaction.error);\n    };\n\n    req.transaction.oncomplete = () => {\n      if (req.result) {\n        return resolve(req.result);\n      }\n\n      reject(new NotFoundError());\n    };\n  });\n}\n/**\n * Level dbs wrap level dbs that wrap level dbs. Find a level-js\n * instance in the chain if one exists.\n *\n * @param {Datastore} store\n * @returns {Datastore | undefined}\n */\n\nfunction findLevelJs(store) {\n  let db = store; // @ts-ignore\n\n  while (db.db || db.child) {\n    // @ts-ignore\n    db = db.db || db.child; // `Level` is only present in the browser, in node it is LevelDOWN\n    // @ts-ignore\n\n    if (db.type === 'level-js' || db.constructor.name === 'Level') {\n      return db;\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-repo/src/utils/level.js"],"names":["NotFoundError","hasWithFallback","key","has","store","result","levelJs","findLevelJs","Promise","resolve","reject","req","get","toString","transaction","onabort","error","oncomplete","Boolean","getWithFallback","db","child","type","constructor","name"],"mappings":"AACA,SAASA,aAAT,QAA8B,cAA9B;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAeC,eAAf,CAAgCC,GAAhC,EAAqCC,GAArC,EAA0CC,KAA1C,EAAiD;AACtD,QAAMC,MAAM,GAAG,MAAMF,GAAG,CAACD,GAAD,CAAxB;;AAEA,MAAIG,MAAJ,EAAY;AACV,WAAOA,MAAP;AACD,GALqD,CAOtD;AACA;AACA;;;AACA,QAAMC,OAAO,GAAGC,WAAW,CAACH,KAAD,CAA3B;;AAEA,MAAI,CAACE,OAAL,EAAc;AACZ,WAAO,KAAP;AACD;;AAED,SAAO,IAAIE,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC;AACA;AACA,UAAMC,GAAG,GAAGL,OAAO,CAACF,KAAR,CAAc,UAAd,EAA0BQ,GAA1B,CAA8BV,GAAG,CAACW,QAAJ,EAA9B,CAAZ;;AACAF,IAAAA,GAAG,CAACG,WAAJ,CAAgBC,OAAhB,GAA0B,MAAM;AAC9BL,MAAAA,MAAM,CAACC,GAAG,CAACG,WAAJ,CAAgBE,KAAjB,CAAN;AACD,KAFD;;AAGAL,IAAAA,GAAG,CAACG,WAAJ,CAAgBG,UAAhB,GAA6B,MAAM;AACjCR,MAAAA,OAAO,CAACS,OAAO,CAACP,GAAG,CAACN,MAAL,CAAR,CAAP;AACD,KAFD;AAGD,GAVM,CAAP;AAWD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAec,eAAf,CAAgCjB,GAAhC,EAAqCU,GAArC,EAA0CT,GAA1C,EAA+CC,KAA/C,EAAsD;AAC3D,MAAI,MAAMD,GAAG,CAACD,GAAD,CAAb,EAAoB;AAClB,WAAOU,GAAG,CAACV,GAAD,CAAV;AACD,GAH0D,CAK3D;AACA;AACA;;;AACA,QAAMI,OAAO,GAAGC,WAAW,CAACH,KAAD,CAA3B;;AAEA,MAAI,CAACE,OAAL,EAAc;AACZ,UAAM,IAAIN,aAAJ,EAAN;AACD;;AAED,SAAO,IAAIQ,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC;AACA;AACA,UAAMC,GAAG,GAAGL,OAAO,CAACF,KAAR,CAAc,UAAd,EAA0BQ,GAA1B,CAA8BV,GAAG,CAACW,QAAJ,EAA9B,CAAZ;;AACAF,IAAAA,GAAG,CAACG,WAAJ,CAAgBC,OAAhB,GAA0B,MAAM;AAC9BL,MAAAA,MAAM,CAACC,GAAG,CAACG,WAAJ,CAAgBE,KAAjB,CAAN;AACD,KAFD;;AAGAL,IAAAA,GAAG,CAACG,WAAJ,CAAgBG,UAAhB,GAA6B,MAAM;AACjC,UAAIN,GAAG,CAACN,MAAR,EAAgB;AACd,eAAOI,OAAO,CAACE,GAAG,CAACN,MAAL,CAAd;AACD;;AAEDK,MAAAA,MAAM,CAAC,IAAIV,aAAJ,EAAD,CAAN;AACD,KAND;AAOD,GAdM,CAAP;AAeD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASO,WAAT,CAAsBH,KAAtB,EAA6B;AAC3B,MAAIgB,EAAE,GAAGhB,KAAT,CAD2B,CAG3B;;AACA,SAAOgB,EAAE,CAACA,EAAH,IAASA,EAAE,CAACC,KAAnB,EAA0B;AACxB;AACAD,IAAAA,EAAE,GAAGA,EAAE,CAACA,EAAH,IAASA,EAAE,CAACC,KAAjB,CAFwB,CAIxB;AACA;;AACA,QAAID,EAAE,CAACE,IAAH,KAAY,UAAZ,IAA0BF,EAAE,CAACG,WAAH,CAAeC,IAAf,KAAwB,OAAtD,EAA+D;AAC7D,aAAOJ,EAAP;AACD;AACF;AACF","sourcesContent":["\nimport { NotFoundError } from '../errors.js'\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Key} Key\n */\n\n/**\n * @param {Key} key\n * @param {function (Key): Promise<boolean>} has\n * @param {Datastore} store\n * @returns {Promise<boolean>}\n */\nexport async function hasWithFallback (key, has, store) {\n  const result = await has(key)\n\n  if (result) {\n    return result\n  }\n\n  // Newer versions of level.js changed the key type from Uint8Array|string\n  // to Uint8Array  so fall back to trying Uint8Arrays if we are using level.js\n  // and the string version of the key did not work\n  const levelJs = findLevelJs(store)\n\n  if (!levelJs) {\n    return false\n  }\n\n  return new Promise((resolve, reject) => {\n    // drop down to IndexDB API, otherwise level-js will monkey around with the keys/values\n    // @ts-ignore\n    const req = levelJs.store('readonly').get(key.toString())\n    req.transaction.onabort = () => {\n      reject(req.transaction.error)\n    }\n    req.transaction.oncomplete = () => {\n      resolve(Boolean(req.result))\n    }\n  })\n}\n\n/**\n * @param {import('interface-datastore').Key} key\n * @param {function (Key): Promise<Uint8Array>} get\n * @param {function (Key): Promise<boolean>} has\n * @param {import('interface-datastore').Datastore} store\n * @returns {Promise<Uint8Array>}\n */\nexport async function getWithFallback (key, get, has, store) {\n  if (await has(key)) {\n    return get(key)\n  }\n\n  // Newer versions of level.js changed the key type from Uint8Array|string\n  // to Uint8Array so fall back to trying Uint8Arrays if we are using level.js\n  // and the string version of the key did not work\n  const levelJs = findLevelJs(store)\n\n  if (!levelJs) {\n    throw new NotFoundError()\n  }\n\n  return new Promise((resolve, reject) => {\n    // drop down to IndexDB API, otherwise level-js will monkey around with the keys/values\n    // @ts-ignore\n    const req = levelJs.store('readonly').get(key.toString())\n    req.transaction.onabort = () => {\n      reject(req.transaction.error)\n    }\n    req.transaction.oncomplete = () => {\n      if (req.result) {\n        return resolve(req.result)\n      }\n\n      reject(new NotFoundError())\n    }\n  })\n}\n\n/**\n * Level dbs wrap level dbs that wrap level dbs. Find a level-js\n * instance in the chain if one exists.\n *\n * @param {Datastore} store\n * @returns {Datastore | undefined}\n */\nfunction findLevelJs (store) {\n  let db = store\n\n  // @ts-ignore\n  while (db.db || db.child) {\n    // @ts-ignore\n    db = db.db || db.child\n\n    // `Level` is only present in the browser, in node it is LevelDOWN\n    // @ts-ignore\n    if (db.type === 'level-js' || db.constructor.name === 'Level') {\n      return db\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}