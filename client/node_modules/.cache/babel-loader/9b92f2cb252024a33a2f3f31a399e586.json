{"ast":null,"code":"import { multiaddr } from '@multiformats/multiaddr';\nimport { P2P } from '@multiformats/mafmt';\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { symbol } from '@libp2p/interface-peer-discovery';\nconst log = logger('libp2p:bootstrap');\nconst DEFAULT_BOOTSTRAP_TAG_NAME = 'bootstrap';\nconst DEFAULT_BOOTSTRAP_TAG_VALUE = 50;\nconst DEFAULT_BOOTSTRAP_TAG_TTL = 120000;\nconst DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1000;\n/**\n * Emits 'peer' events on a regular interval for each peer in the provided list.\n */\n\nclass Bootstrap extends EventEmitter {\n  constructor(components) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      list: []\n    };\n\n    if (options.list == null || options.list.length === 0) {\n      throw new Error('Bootstrap requires a list of peer addresses');\n    }\n\n    super();\n    this.components = components;\n    this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;\n    this.list = [];\n\n    for (const candidate of options.list) {\n      if (!P2P.matches(candidate)) {\n        log.error('Invalid multiaddr');\n        continue;\n      }\n\n      const ma = multiaddr(candidate);\n      const peerIdStr = ma.getPeerId();\n\n      if (peerIdStr == null) {\n        log.error('Invalid bootstrap multiaddr without peer id');\n        continue;\n      }\n\n      const peerData = {\n        id: peerIdFromString(peerIdStr),\n        multiaddrs: [ma],\n        protocols: []\n      };\n      this.list.push(peerData);\n    }\n\n    this._init = options;\n  }\n\n  get [symbol]() {\n    return true;\n  }\n\n  get [Symbol.toStringTag]() {\n    return '@libp2p/bootstrap';\n  }\n\n  isStarted() {\n    return Boolean(this.timer);\n  }\n  /**\n   * Start emitting events\n   */\n\n\n  start() {\n    if (this.isStarted()) {\n      return;\n    }\n\n    log('Starting bootstrap node discovery, discovering peers after %s ms', this.timeout);\n    this.timer = setTimeout(() => {\n      void this._discoverBootstrapPeers().catch(err => {\n        log.error(err);\n      });\n    }, this.timeout);\n  }\n  /**\n   * Emit each address in the list as a PeerInfo\n   */\n\n\n  async _discoverBootstrapPeers() {\n    if (this.timer == null) {\n      return;\n    }\n\n    for (const peerData of this.list) {\n      await this.components.peerStore.tagPeer(peerData.id, this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME, {\n        value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,\n        ttl: this._init.tagTTL ?? DEFAULT_BOOTSTRAP_TAG_TTL\n      }); // check we are still running\n\n      if (this.timer == null) {\n        return;\n      }\n\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: peerData\n      }));\n    }\n  }\n  /**\n   * Stop emitting events\n   */\n\n\n  stop() {\n    if (this.timer != null) {\n      clearTimeout(this.timer);\n    }\n\n    this.timer = undefined;\n  }\n\n}\n\nBootstrap.tag = 'bootstrap';\nexport function bootstrap(init) {\n  return components => new Bootstrap(components, init);\n}","map":{"version":3,"mappings":"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","names":["multiaddr","P2P","CustomEvent","EventEmitter","logger","peerIdFromString","symbol","log","DEFAULT_BOOTSTRAP_TAG_NAME","DEFAULT_BOOTSTRAP_TAG_VALUE","DEFAULT_BOOTSTRAP_TAG_TTL","DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT","Bootstrap","constructor","components","options","list","length","Error","timeout","candidate","matches","error","ma","peerIdStr","getPeerId","peerData","id","multiaddrs","protocols","push","_init","Symbol","toStringTag","isStarted","Boolean","timer","start","setTimeout","_discoverBootstrapPeers","catch","err","peerStore","tagPeer","tagName","value","tagValue","ttl","tagTTL","dispatchEvent","detail","stop","clearTimeout","undefined","bootstrap","init"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\bootstrap\\src\\index.ts"],"sourcesContent":["import { multiaddr } from '@multiformats/multiaddr'\nimport { P2P } from '@multiformats/mafmt'\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events'\nimport { logger } from '@libp2p/logger'\nimport type { PeerDiscovery, PeerDiscoveryEvents } from '@libp2p/interface-peer-discovery'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { symbol } from '@libp2p/interface-peer-discovery'\nimport type { Startable } from '@libp2p/interfaces/dist/src/startable'\nimport type { PeerStore } from '@libp2p/interface-peer-store'\n\nconst log = logger('libp2p:bootstrap')\n\nconst DEFAULT_BOOTSTRAP_TAG_NAME = 'bootstrap'\nconst DEFAULT_BOOTSTRAP_TAG_VALUE = 50\nconst DEFAULT_BOOTSTRAP_TAG_TTL = 120000\nconst DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1000\n\nexport interface BootstrapInit {\n  /**\n   * The list of peer addresses in multi-address format\n   */\n  list: string[]\n\n  /**\n   * How long to wait before discovering bootstrap nodes\n   */\n  timeout?: number\n\n  /**\n   * Tag a bootstrap peer with this name before \"discovering\" it (default: 'bootstrap')\n   */\n  tagName?: string\n\n  /**\n   * The bootstrap peer tag will have this value (default: 50)\n   */\n  tagValue?: number\n\n  /**\n   * Cause the bootstrap peer tag to be removed after this number of ms (default: 2 minutes)\n   */\n  tagTTL?: number\n}\n\nexport interface BootstrapComponents {\n  peerStore: PeerStore\n}\n\n/**\n * Emits 'peer' events on a regular interval for each peer in the provided list.\n */\nclass Bootstrap extends EventEmitter<PeerDiscoveryEvents> implements PeerDiscovery, Startable {\n  static tag = 'bootstrap'\n\n  private timer?: ReturnType<typeof setTimeout>\n  private readonly list: PeerInfo[]\n  private readonly timeout: number\n  private readonly components: BootstrapComponents\n  private readonly _init: BootstrapInit\n\n  constructor (components: BootstrapComponents, options: BootstrapInit = { list: [] }) {\n    if (options.list == null || options.list.length === 0) {\n      throw new Error('Bootstrap requires a list of peer addresses')\n    }\n    super()\n\n    this.components = components\n    this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT\n    this.list = []\n\n    for (const candidate of options.list) {\n      if (!P2P.matches(candidate)) {\n        log.error('Invalid multiaddr')\n        continue\n      }\n\n      const ma = multiaddr(candidate)\n      const peerIdStr = ma.getPeerId()\n\n      if (peerIdStr == null) {\n        log.error('Invalid bootstrap multiaddr without peer id')\n        continue\n      }\n\n      const peerData: PeerInfo = {\n        id: peerIdFromString(peerIdStr),\n        multiaddrs: [ma],\n        protocols: []\n      }\n\n      this.list.push(peerData)\n    }\n\n    this._init = options\n  }\n\n  get [symbol] (): true {\n    return true\n  }\n\n  get [Symbol.toStringTag] (): '@libp2p/bootstrap' {\n    return '@libp2p/bootstrap'\n  }\n\n  isStarted (): boolean {\n    return Boolean(this.timer)\n  }\n\n  /**\n   * Start emitting events\n   */\n  start (): void {\n    if (this.isStarted()) {\n      return\n    }\n\n    log('Starting bootstrap node discovery, discovering peers after %s ms', this.timeout)\n    this.timer = setTimeout(() => {\n      void this._discoverBootstrapPeers()\n        .catch(err => {\n          log.error(err)\n        })\n    }, this.timeout)\n  }\n\n  /**\n   * Emit each address in the list as a PeerInfo\n   */\n  async _discoverBootstrapPeers (): Promise<void> {\n    if (this.timer == null) {\n      return\n    }\n\n    for (const peerData of this.list) {\n      await this.components.peerStore.tagPeer(peerData.id, this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME, {\n        value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,\n        ttl: this._init.tagTTL ?? DEFAULT_BOOTSTRAP_TAG_TTL\n      })\n\n      // check we are still running\n      if (this.timer == null) {\n        return\n      }\n\n      this.dispatchEvent(new CustomEvent<PeerInfo>('peer', { detail: peerData }))\n    }\n  }\n\n  /**\n   * Stop emitting events\n   */\n  stop (): void {\n    if (this.timer != null) {\n      clearTimeout(this.timer)\n    }\n\n    this.timer = undefined\n  }\n}\n\nexport function bootstrap (init: BootstrapInit): (components: BootstrapComponents) => PeerDiscovery {\n  return (components: BootstrapComponents) => new Bootstrap(components, init)\n}\n"]},"metadata":{},"sourceType":"module"}