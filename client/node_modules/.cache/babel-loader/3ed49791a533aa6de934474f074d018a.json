{"ast":null,"code":"import filter from 'it-filter';\nimport take from 'it-take';\nimport merge from 'it-merge';\nimport { BaseDatastore } from './base.js';\nimport * as Errors from './errors.js';\nimport { sortAll } from './utils.js';\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Key} Key\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('./types').KeyTransform} KeyTransform\n */\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixes\n *\n * @implements {Datastore}\n */\n\nexport class MountDatastore extends BaseDatastore {\n  /**\n   * @param {Array<{prefix: Key, datastore: Datastore}>} mounts\n   */\n  constructor(mounts) {\n    super();\n    this.mounts = mounts.slice();\n  }\n\n  async open() {\n    await Promise.all(this.mounts.map(m => m.datastore.open()));\n  }\n  /**\n   * Lookup the matching datastore for the given key\n   *\n   * @private\n   * @param {Key} key\n   * @returns {{datastore: Datastore, mountpoint: Key} | undefined}\n   */\n\n\n  _lookup(key) {\n    for (const mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix\n        };\n      }\n    }\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n\n\n  put(key, value, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.put(key, value, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  get(key, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw Errors.notFoundError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.get(key, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  has(key, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      return Promise.resolve(false);\n    }\n\n    return match.datastore.has(key, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  delete(key, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.delete(key, options);\n  }\n\n  async close() {\n    await Promise.all(this.mounts.map(m => {\n      return m.datastore.close();\n    }));\n  }\n  /**\n   * @returns {Batch}\n   */\n\n\n  batch() {\n    /** @type {Record<string, Batch>} */\n    const batchMounts = {};\n    /**\n     * @param {Key} key\n     */\n\n    const lookup = key => {\n      const match = this._lookup(key);\n\n      if (match == null) {\n        throw new Error('No datastore mounted for this key');\n      }\n\n      const m = match.mountpoint.toString();\n\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch();\n      }\n\n      return {\n        batch: batchMounts[m]\n      };\n    };\n\n    return {\n      put: (key, value) => {\n        const match = lookup(key);\n        match.batch.put(key, value);\n      },\n      delete: key => {\n        const match = lookup(key);\n        match.batch.delete(key);\n      },\n      commit: async options => {\n        await Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)));\n      }\n    };\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.query({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options);\n    });\n    /** @type AsyncIterable<Pair> */\n\n    let it = merge(...qs);\n    if (q.filters) q.filters.forEach(f => {\n      it = filter(it, f);\n    });\n    if (q.orders) q.orders.forEach(o => {\n      it = sortAll(it, o);\n    });\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >=\n      /** @type {number} */\n      q.offset);\n    }\n\n    if (q.limit != null) it = take(it, q.limit);\n    return it;\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n\n\n  queryKeys(q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.queryKeys({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options);\n    });\n    /** @type AsyncIterable<Key> */\n\n    let it = merge(...qs);\n    if (q.filters) q.filters.forEach(f => {\n      it = filter(it, f);\n    });\n    if (q.orders) q.orders.forEach(o => {\n      it = sortAll(it, o);\n    });\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >=\n      /** @type {number} */\n      q.offset);\n    }\n\n    if (q.limit != null) it = take(it, q.limit);\n    return it;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/datastore-core/src/mount.js"],"names":["filter","take","merge","BaseDatastore","Errors","sortAll","MountDatastore","constructor","mounts","slice","open","Promise","all","map","m","datastore","_lookup","key","mount","prefix","toString","isAncestorOf","mountpoint","put","value","options","match","dbWriteFailedError","Error","get","notFoundError","has","resolve","delete","dbDeleteFailedError","close","batch","batchMounts","lookup","commit","Object","keys","p","query","q","qs","filters","it","forEach","f","orders","o","offset","i","limit","queryKeys"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,WAAnB;AACA,OAAOC,IAAP,MAAiB,SAAjB;AACA,OAAOC,KAAP,MAAkB,UAAlB;AACA,SAASC,aAAT,QAA8B,WAA9B;AACA,OAAO,KAAKC,MAAZ,MAAwB,aAAxB;AACA,SACEC,OADF,QAEO,YAFP;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,cAAN,SAA6BH,aAA7B,CAA2C;AAChD;AACF;AACA;AACEI,EAAAA,WAAW,CAAEC,MAAF,EAAU;AACnB;AAEA,SAAKA,MAAL,GAAcA,MAAM,CAACC,KAAP,EAAd;AACD;;AAES,QAAJC,IAAI,GAAI;AACZ,UAAMC,OAAO,CAACC,GAAR,CAAY,KAAKJ,MAAL,CAAYK,GAAZ,CAAiBC,CAAD,IAAOA,CAAC,CAACC,SAAF,CAAYL,IAAZ,EAAvB,CAAZ,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEM,EAAAA,OAAO,CAAEC,GAAF,EAAO;AACZ,SAAK,MAAMC,KAAX,IAAoB,KAAKV,MAAzB,EAAiC;AAC/B,UAAIU,KAAK,CAACC,MAAN,CAAaC,QAAb,OAA4BH,GAAG,CAACG,QAAJ,EAA5B,IAA8CF,KAAK,CAACC,MAAN,CAAaE,YAAb,CAA0BJ,GAA1B,CAAlD,EAAkF;AAChF,eAAO;AACLF,UAAAA,SAAS,EAAEG,KAAK,CAACH,SADZ;AAELO,UAAAA,UAAU,EAAEJ,KAAK,CAACC;AAFb,SAAP;AAID;AACF;AACF;AAED;AACF;AACA;AACA;AACA;;;AACEI,EAAAA,GAAG,CAAEN,GAAF,EAAOO,KAAP,EAAcC,OAAd,EAAuB;AACxB,UAAMC,KAAK,GAAG,KAAKV,OAAL,CAAaC,GAAb,CAAd;;AACA,QAAIS,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAMtB,MAAM,CAACuB,kBAAP,CAA0B,IAAIC,KAAJ,CAAU,mCAAV,CAA1B,CAAN;AACD;;AAED,WAAOF,KAAK,CAACX,SAAN,CAAgBQ,GAAhB,CAAoBN,GAApB,EAAyBO,KAAzB,EAAgCC,OAAhC,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACEI,EAAAA,GAAG,CAAEZ,GAAF,EAAOQ,OAAP,EAAgB;AACjB,UAAMC,KAAK,GAAG,KAAKV,OAAL,CAAaC,GAAb,CAAd;;AACA,QAAIS,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAMtB,MAAM,CAAC0B,aAAP,CAAqB,IAAIF,KAAJ,CAAU,mCAAV,CAArB,CAAN;AACD;;AACD,WAAOF,KAAK,CAACX,SAAN,CAAgBc,GAAhB,CAAoBZ,GAApB,EAAyBQ,OAAzB,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACEM,EAAAA,GAAG,CAAEd,GAAF,EAAOQ,OAAP,EAAgB;AACjB,UAAMC,KAAK,GAAG,KAAKV,OAAL,CAAaC,GAAb,CAAd;;AACA,QAAIS,KAAK,IAAI,IAAb,EAAmB;AACjB,aAAOf,OAAO,CAACqB,OAAR,CAAgB,KAAhB,CAAP;AACD;;AACD,WAAON,KAAK,CAACX,SAAN,CAAgBgB,GAAhB,CAAoBd,GAApB,EAAyBQ,OAAzB,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACEQ,EAAAA,MAAM,CAAEhB,GAAF,EAAOQ,OAAP,EAAgB;AACpB,UAAMC,KAAK,GAAG,KAAKV,OAAL,CAAaC,GAAb,CAAd;;AACA,QAAIS,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAMtB,MAAM,CAAC8B,mBAAP,CAA2B,IAAIN,KAAJ,CAAU,mCAAV,CAA3B,CAAN;AACD;;AAED,WAAOF,KAAK,CAACX,SAAN,CAAgBkB,MAAhB,CAAuBhB,GAAvB,EAA4BQ,OAA5B,CAAP;AACD;;AAEU,QAALU,KAAK,GAAI;AACb,UAAMxB,OAAO,CAACC,GAAR,CAAY,KAAKJ,MAAL,CAAYK,GAAZ,CAAiBC,CAAD,IAAO;AACvC,aAAOA,CAAC,CAACC,SAAF,CAAYoB,KAAZ,EAAP;AACD,KAFiB,CAAZ,CAAN;AAGD;AAED;AACF;AACA;;;AACEC,EAAAA,KAAK,GAAI;AACP;AACA,UAAMC,WAAW,GAAG,EAApB;AACA;AACJ;AACA;;AACI,UAAMC,MAAM,GAAIrB,GAAD,IAAS;AACtB,YAAMS,KAAK,GAAG,KAAKV,OAAL,CAAaC,GAAb,CAAd;;AACA,UAAIS,KAAK,IAAI,IAAb,EAAmB;AACjB,cAAM,IAAIE,KAAJ,CAAU,mCAAV,CAAN;AACD;;AAED,YAAMd,CAAC,GAAGY,KAAK,CAACJ,UAAN,CAAiBF,QAAjB,EAAV;;AACA,UAAIiB,WAAW,CAACvB,CAAD,CAAX,IAAkB,IAAtB,EAA4B;AAC1BuB,QAAAA,WAAW,CAACvB,CAAD,CAAX,GAAiBY,KAAK,CAACX,SAAN,CAAgBqB,KAAhB,EAAjB;AACD;;AAED,aAAO;AACLA,QAAAA,KAAK,EAAEC,WAAW,CAACvB,CAAD;AADb,OAAP;AAGD,KAdD;;AAgBA,WAAO;AACLS,MAAAA,GAAG,EAAE,CAACN,GAAD,EAAMO,KAAN,KAAgB;AACnB,cAAME,KAAK,GAAGY,MAAM,CAACrB,GAAD,CAApB;AACAS,QAAAA,KAAK,CAACU,KAAN,CAAYb,GAAZ,CAAgBN,GAAhB,EAAqBO,KAArB;AACD,OAJI;AAKLS,MAAAA,MAAM,EAAGhB,GAAD,IAAS;AACf,cAAMS,KAAK,GAAGY,MAAM,CAACrB,GAAD,CAApB;AACAS,QAAAA,KAAK,CAACU,KAAN,CAAYH,MAAZ,CAAmBhB,GAAnB;AACD,OARI;AASLsB,MAAAA,MAAM,EAAE,MAAOd,OAAP,IAAmB;AACzB,cAAMd,OAAO,CAACC,GAAR,CAAY4B,MAAM,CAACC,IAAP,CAAYJ,WAAZ,EAAyBxB,GAAzB,CAA6B6B,CAAC,IAAIL,WAAW,CAACK,CAAD,CAAX,CAAeH,MAAf,CAAsBd,OAAtB,CAAlC,CAAZ,CAAN;AACD;AAXI,KAAP;AAaD;AAED;AACF;AACA;AACA;;;AACEkB,EAAAA,KAAK,CAAEC,CAAF,EAAKnB,OAAL,EAAc;AACjB,UAAMoB,EAAE,GAAG,KAAKrC,MAAL,CAAYK,GAAZ,CAAgBC,CAAC,IAAI;AAC9B,aAAOA,CAAC,CAACC,SAAF,CAAY4B,KAAZ,CAAkB;AACvBxB,QAAAA,MAAM,EAAEyB,CAAC,CAACzB,MADa;AAEvB2B,QAAAA,OAAO,EAAEF,CAAC,CAACE;AAFY,OAAlB,EAGJrB,OAHI,CAAP;AAID,KALU,CAAX;AAOA;;AACA,QAAIsB,EAAE,GAAG7C,KAAK,CAAC,GAAG2C,EAAJ,CAAd;AACA,QAAID,CAAC,CAACE,OAAN,EAAeF,CAAC,CAACE,OAAF,CAAUE,OAAV,CAAkBC,CAAC,IAAI;AAAEF,MAAAA,EAAE,GAAG/C,MAAM,CAAC+C,EAAD,EAAKE,CAAL,CAAX;AAAoB,KAA7C;AACf,QAAIL,CAAC,CAACM,MAAN,EAAcN,CAAC,CAACM,MAAF,CAASF,OAAT,CAAiBG,CAAC,IAAI;AAAEJ,MAAAA,EAAE,GAAG1C,OAAO,CAAC0C,EAAD,EAAKI,CAAL,CAAZ;AAAqB,KAA7C;;AACd,QAAIP,CAAC,CAACQ,MAAF,IAAY,IAAhB,EAAsB;AACpB,UAAIC,CAAC,GAAG,CAAR;AACAN,MAAAA,EAAE,GAAG/C,MAAM,CAAC+C,EAAD,EAAK,MAAMM,CAAC;AAAM;AAAuBT,MAAAA,CAAC,CAACQ,MAA3C,CAAX;AACD;;AACD,QAAIR,CAAC,CAACU,KAAF,IAAW,IAAf,EAAqBP,EAAE,GAAG9C,IAAI,CAAC8C,EAAD,EAAKH,CAAC,CAACU,KAAP,CAAT;AAErB,WAAOP,EAAP;AACD;AAED;AACF;AACA;AACA;;;AACEQ,EAAAA,SAAS,CAAEX,CAAF,EAAKnB,OAAL,EAAc;AACrB,UAAMoB,EAAE,GAAG,KAAKrC,MAAL,CAAYK,GAAZ,CAAgBC,CAAC,IAAI;AAC9B,aAAOA,CAAC,CAACC,SAAF,CAAYwC,SAAZ,CAAsB;AAC3BpC,QAAAA,MAAM,EAAEyB,CAAC,CAACzB,MADiB;AAE3B2B,QAAAA,OAAO,EAAEF,CAAC,CAACE;AAFgB,OAAtB,EAGJrB,OAHI,CAAP;AAID,KALU,CAAX;AAOA;;AACA,QAAIsB,EAAE,GAAG7C,KAAK,CAAC,GAAG2C,EAAJ,CAAd;AACA,QAAID,CAAC,CAACE,OAAN,EAAeF,CAAC,CAACE,OAAF,CAAUE,OAAV,CAAkBC,CAAC,IAAI;AAAEF,MAAAA,EAAE,GAAG/C,MAAM,CAAC+C,EAAD,EAAKE,CAAL,CAAX;AAAoB,KAA7C;AACf,QAAIL,CAAC,CAACM,MAAN,EAAcN,CAAC,CAACM,MAAF,CAASF,OAAT,CAAiBG,CAAC,IAAI;AAAEJ,MAAAA,EAAE,GAAG1C,OAAO,CAAC0C,EAAD,EAAKI,CAAL,CAAZ;AAAqB,KAA7C;;AACd,QAAIP,CAAC,CAACQ,MAAF,IAAY,IAAhB,EAAsB;AACpB,UAAIC,CAAC,GAAG,CAAR;AACAN,MAAAA,EAAE,GAAG/C,MAAM,CAAC+C,EAAD,EAAK,MAAMM,CAAC;AAAM;AAAuBT,MAAAA,CAAC,CAACQ,MAA3C,CAAX;AACD;;AACD,QAAIR,CAAC,CAACU,KAAF,IAAW,IAAf,EAAqBP,EAAE,GAAG9C,IAAI,CAAC8C,EAAD,EAAKH,CAAC,CAACU,KAAP,CAAT;AAErB,WAAOP,EAAP;AACD;;AAjL+C","sourcesContent":["import filter from 'it-filter'\nimport take from 'it-take'\nimport merge from 'it-merge'\nimport { BaseDatastore } from './base.js'\nimport * as Errors from './errors.js'\nimport {\n  sortAll\n} from './utils.js'\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Key} Key\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('./types').KeyTransform} KeyTransform\n */\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixes\n *\n * @implements {Datastore}\n */\nexport class MountDatastore extends BaseDatastore {\n  /**\n   * @param {Array<{prefix: Key, datastore: Datastore}>} mounts\n   */\n  constructor (mounts) {\n    super()\n\n    this.mounts = mounts.slice()\n  }\n\n  async open () {\n    await Promise.all(this.mounts.map((m) => m.datastore.open()))\n  }\n\n  /**\n   * Lookup the matching datastore for the given key\n   *\n   * @private\n   * @param {Key} key\n   * @returns {{datastore: Datastore, mountpoint: Key} | undefined}\n   */\n  _lookup (key) {\n    for (const mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n  put (key, value, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'))\n    }\n\n    return match.datastore.put(key, value, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  get (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.notFoundError(new Error('No datastore mounted for this key'))\n    }\n    return match.datastore.get(key, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  has (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      return Promise.resolve(false)\n    }\n    return match.datastore.has(key, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  delete (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'))\n    }\n\n    return match.datastore.delete(key, options)\n  }\n\n  async close () {\n    await Promise.all(this.mounts.map((m) => {\n      return m.datastore.close()\n    }))\n  }\n\n  /**\n   * @returns {Batch}\n   */\n  batch () {\n    /** @type {Record<string, Batch>} */\n    const batchMounts = {}\n    /**\n     * @param {Key} key\n     */\n    const lookup = (key) => {\n      const match = this._lookup(key)\n      if (match == null) {\n        throw new Error('No datastore mounted for this key')\n      }\n\n      const m = match.mountpoint.toString()\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch()\n      }\n\n      return {\n        batch: batchMounts[m]\n      }\n    }\n\n    return {\n      put: (key, value) => {\n        const match = lookup(key)\n        match.batch.put(key, value)\n      },\n      delete: (key) => {\n        const match = lookup(key)\n        match.batch.delete(key)\n      },\n      commit: async (options) => {\n        await Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)))\n      }\n    }\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query (q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.query({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options)\n    })\n\n    /** @type AsyncIterable<Pair> */\n    let it = merge(...qs)\n    if (q.filters) q.filters.forEach(f => { it = filter(it, f) })\n    if (q.orders) q.orders.forEach(o => { it = sortAll(it, o) })\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= /** @type {number} */ (q.offset))\n    }\n    if (q.limit != null) it = take(it, q.limit)\n\n    return it\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys (q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.queryKeys({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options)\n    })\n\n    /** @type AsyncIterable<Key> */\n    let it = merge(...qs)\n    if (q.filters) q.filters.forEach(f => { it = filter(it, f) })\n    if (q.orders) q.orders.forEach(o => { it = sortAll(it, o) })\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= /** @type {number} */ (q.offset))\n    }\n    if (q.limit != null) it = take(it, q.limit)\n\n    return it\n  }\n}\n"]},"metadata":{},"sourceType":"module"}