{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\nimport { CID } from 'multiformats/cid';\nimport errCode from 'err-code';\nimport debug from 'debug';\nimport first from 'it-first';\nimport { createUnsafe } from 'multiformats/block';\nimport * as cborg from 'cborg';\nimport * as dagPb from '@ipld/dag-pb';\nimport { cidToKey, keyToMultihash } from './utils/blockstore.js';\nimport { walkDag } from './utils/walk-dag.js';\nimport { PinTypes } from './pin-types.js';\nimport QuickLRU from 'quick-lru';\n/**\n * @typedef {import('./types').PinType} PinType\n * @typedef {import('./types').PinQueryType} PinQueryType\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('./types').PinOptions} PinOptions\n * @typedef {import('./types').AbortOptions} AbortOptions\n * @typedef {import('./types').Pins} Pins\n */\n\n/**\n * @typedef {object} PinInternal\n * @property {number} depth\n * @property {import('multiformats/cid').Version} [version]\n * @property {number} [codec]\n * @property {Record<string, any>} [metadata]\n */\n\n/**\n * @typedef {object} FetchCompleteDagOptions\n * @property {AbortSignal} [signal]\n * @property {number} [cidCacheMaxSize]\n */\n\nconst CID_CACHE_MAX_SIZE = 2048;\n/**\n * @param {string} type\n */\n\nfunction invalidPinTypeErr(type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n/**\n * @implements {Pins}\n */\n\n\nexport class PinManager {\n  /**\n   * @param {object} config\n   * @param {import('interface-datastore').Datastore} config.pinstore\n   * @param {import('interface-blockstore').Blockstore} config.blockstore\n   * @param {import('./types').loadCodec} config.loadCodec\n   */\n  constructor(_ref) {\n    let {\n      pinstore,\n      blockstore,\n      loadCodec\n    } = _ref;\n    this.pinstore = pinstore;\n    this.blockstore = blockstore;\n    this.loadCodec = loadCodec;\n    this.log = debug('ipfs:repo:pin');\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n\n\n  async pinDirectly(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    await this.blockstore.get(cid, options);\n    /** @type {PinInternal} */\n\n    const pin = {\n      depth: 0\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n\n    return this.pinstore.put(cidToKey(cid), cborg.encode(pin));\n  }\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n\n\n  unpin(cid, options) {\n    return this.pinstore.delete(cidToKey(cid), options);\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & FetchCompleteDagOptions & AbortOptions} [options]\n   */\n\n\n  async pinRecursively(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    await this.fetchCompleteDag(cid, options);\n    /** @type {PinInternal} */\n\n    const pin = {\n      depth: Infinity\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n\n    await this.pinstore.put(cidToKey(cid), cborg.encode(pin));\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  async *directKeys(options) {\n    for await (const entry of this.pinstore.query({\n      filters: [entry => {\n        const pin = cborg.decode(entry.value);\n        return pin.depth === 0;\n      }]\n    })) {\n      const pin = cborg.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec != null ? pin.codec : dagPb.code;\n      const multihash = keyToMultihash(entry.key);\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  async *recursiveKeys(options) {\n    for await (const entry of this.pinstore.query({\n      filters: [entry => {\n        const pin = cborg.decode(entry.value);\n        return pin.depth === Infinity;\n      }]\n    })) {\n      const pin = cborg.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec != null ? pin.codec : dagPb.code;\n      const multihash = keyToMultihash(entry.key);\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  async *indirectKeys(options) {\n    for await (const {\n      cid\n    } of this.recursiveKeys()) {\n      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {\n        // recursive pins override indirect pins\n        const types = [PinTypes.recursive];\n        const result = await this.isPinnedWithType(childCid, types);\n\n        if (result.pinned) {\n          continue;\n        }\n\n        yield childCid;\n      }\n    }\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinQueryType|PinQueryType[]} types\n   * @param {AbortOptions} [options]\n   */\n\n\n  async isPinnedWithType(cid, types, options) {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n\n    const all = types.includes(PinTypes.all);\n    const direct = types.includes(PinTypes.direct);\n    const recursive = types.includes(PinTypes.recursive);\n    const indirect = types.includes(PinTypes.indirect);\n\n    if (recursive || direct || all) {\n      const result = await first(this.pinstore.query({\n        prefix: cidToKey(cid).toString(),\n        filters: [entry => {\n          if (all) {\n            return true;\n          }\n\n          const pin = cborg.decode(entry.value);\n          return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);\n        }],\n        limit: 1\n      }));\n\n      if (result) {\n        const pin = cborg.decode(result.value);\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n          metadata: pin.metadata\n        };\n      }\n    }\n\n    const self = this;\n    /**\n     * @param {CID} key\n     * @param {AsyncIterable<{ cid: CID, metadata: any }>} source\n     */\n\n    async function* findChild(key, source) {\n      for await (const {\n        cid: parentCid\n      } of source) {\n        for await (const childCid of walkDag(parentCid, self.blockstore, self.loadCodec)) {\n          if (childCid.equals(key)) {\n            yield parentCid;\n            return;\n          }\n        }\n      }\n    }\n\n    if (all || indirect) {\n      // indirect (default)\n      // check each recursive key to see if multihash is under it\n      const parentCid = await first(findChild(cid, this.recursiveKeys()));\n\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: PinTypes.indirect,\n          parent: parentCid\n        };\n      }\n    }\n\n    return {\n      cid,\n      pinned: false\n    };\n  }\n  /**\n   * @param {CID} cid\n   * @param {FetchCompleteDagOptions} [options]\n   */\n\n\n  async fetchCompleteDag(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const seen = new QuickLRU({\n      maxSize: options.cidCacheMaxSize ?? CID_CACHE_MAX_SIZE\n    });\n    /**\n     * @param {CID} cid\n     * @param {AbortOptions} options\n     */\n\n    const walkDag = async (cid, options) => {\n      if (seen.has(cid.toString())) {\n        return;\n      }\n\n      seen.set(cid.toString(), true);\n      const bytes = await this.blockstore.get(cid, options);\n      const codec = await this.loadCodec(cid.code);\n      const block = createUnsafe({\n        bytes,\n        cid,\n        codec\n      });\n      await Promise.all([...block.links()].map(_ref2 => {\n        let [, childCid] = _ref2;\n        return walkDag(childCid, options);\n      }));\n    };\n\n    await walkDag(cid, options);\n  }\n  /**\n   * Throws an error if the pin type is invalid\n   *\n   * @param {any} type\n   * @returns {type is PinType}\n   */\n\n\n  static checkPinType(type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type);\n    }\n\n    return true;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-repo/src/pin-manager.js"],"names":["CID","errCode","debug","first","createUnsafe","cborg","dagPb","cidToKey","keyToMultihash","walkDag","PinTypes","QuickLRU","CID_CACHE_MAX_SIZE","invalidPinTypeErr","type","errMsg","Error","PinManager","constructor","pinstore","blockstore","loadCodec","log","directPins","Set","recursivePins","pinDirectly","cid","options","get","pin","depth","version","code","codec","metadata","put","encode","unpin","delete","pinRecursively","fetchCompleteDag","Infinity","directKeys","entry","query","filters","decode","value","multihash","key","create","recursiveKeys","indirectKeys","childCid","types","recursive","result","isPinnedWithType","pinned","Array","isArray","all","includes","direct","indirect","prefix","toString","limit","reason","self","findChild","source","parentCid","equals","parent","seen","maxSize","cidCacheMaxSize","has","set","bytes","block","Promise","links","map","checkPinType","Object","keys"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n\nimport { CID } from 'multiformats/cid'\nimport errCode from 'err-code'\nimport debug from 'debug'\nimport first from 'it-first'\nimport { createUnsafe } from 'multiformats/block'\nimport * as cborg from 'cborg'\nimport * as dagPb from '@ipld/dag-pb'\nimport {\n  cidToKey,\n  keyToMultihash\n} from './utils/blockstore.js'\nimport { walkDag } from './utils/walk-dag.js'\nimport { PinTypes } from './pin-types.js'\nimport QuickLRU from 'quick-lru'\n\n/**\n * @typedef {import('./types').PinType} PinType\n * @typedef {import('./types').PinQueryType} PinQueryType\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('./types').PinOptions} PinOptions\n * @typedef {import('./types').AbortOptions} AbortOptions\n * @typedef {import('./types').Pins} Pins\n */\n\n/**\n * @typedef {object} PinInternal\n * @property {number} depth\n * @property {import('multiformats/cid').Version} [version]\n * @property {number} [codec]\n * @property {Record<string, any>} [metadata]\n */\n\n/**\n * @typedef {object} FetchCompleteDagOptions\n * @property {AbortSignal} [signal]\n * @property {number} [cidCacheMaxSize]\n */\n\nconst CID_CACHE_MAX_SIZE = 2048\n\n/**\n * @param {string} type\n */\nfunction invalidPinTypeErr (type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE')\n}\n\n/**\n * @implements {Pins}\n */\nexport class PinManager {\n  /**\n   * @param {object} config\n   * @param {import('interface-datastore').Datastore} config.pinstore\n   * @param {import('interface-blockstore').Blockstore} config.blockstore\n   * @param {import('./types').loadCodec} config.loadCodec\n   */\n  constructor ({ pinstore, blockstore, loadCodec }) {\n    this.pinstore = pinstore\n    this.blockstore = blockstore\n    this.loadCodec = loadCodec\n    this.log = debug('ipfs:repo:pin')\n    this.directPins = new Set()\n    this.recursivePins = new Set()\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n  async pinDirectly (cid, options = {}) {\n    await this.blockstore.get(cid, options)\n\n    /** @type {PinInternal} */\n    const pin = {\n      depth: 0\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata\n    }\n\n    return this.pinstore.put(cidToKey(cid), cborg.encode(pin))\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n  unpin (cid, options) {\n    return this.pinstore.delete(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & FetchCompleteDagOptions & AbortOptions} [options]\n   */\n  async pinRecursively (cid, options = {}) {\n    await this.fetchCompleteDag(cid, options)\n\n    /** @type {PinInternal} */\n    const pin = {\n      depth: Infinity\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata\n    }\n\n    await this.pinstore.put(cidToKey(cid), cborg.encode(pin))\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * directKeys (options) {\n    for await (const entry of this.pinstore.query({\n      filters: [(entry) => {\n        const pin = cborg.decode(entry.value)\n\n        return pin.depth === 0\n      }]\n    })) {\n      const pin = cborg.decode(entry.value)\n      const version = pin.version || 0\n      const codec = pin.codec != null ? pin.codec : dagPb.code\n      const multihash = keyToMultihash(entry.key)\n\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      }\n    }\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * recursiveKeys (options) {\n    for await (const entry of this.pinstore.query({\n      filters: [(entry) => {\n        const pin = cborg.decode(entry.value)\n\n        return pin.depth === Infinity\n      }]\n    })) {\n      const pin = cborg.decode(entry.value)\n      const version = pin.version || 0\n      const codec = pin.codec != null ? pin.codec : dagPb.code\n      const multihash = keyToMultihash(entry.key)\n\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      }\n    }\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * indirectKeys (options) {\n    for await (const { cid } of this.recursiveKeys()) {\n      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {\n        // recursive pins override indirect pins\n        const types = [\n          PinTypes.recursive\n        ]\n\n        const result = await this.isPinnedWithType(childCid, types)\n\n        if (result.pinned) {\n          continue\n        }\n\n        yield childCid\n      }\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinQueryType|PinQueryType[]} types\n   * @param {AbortOptions} [options]\n   */\n  async isPinnedWithType (cid, types, options) {\n    if (!Array.isArray(types)) {\n      types = [types]\n    }\n\n    const all = types.includes(PinTypes.all)\n    const direct = types.includes(PinTypes.direct)\n    const recursive = types.includes(PinTypes.recursive)\n    const indirect = types.includes(PinTypes.indirect)\n\n    if (recursive || direct || all) {\n      const result = await first(this.pinstore.query({\n        prefix: cidToKey(cid).toString(),\n        filters: [entry => {\n          if (all) {\n            return true\n          }\n\n          const pin = cborg.decode(entry.value)\n\n          return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive)\n        }],\n        limit: 1\n      }))\n\n      if (result) {\n        const pin = cborg.decode(result.value)\n\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n          metadata: pin.metadata\n        }\n      }\n    }\n\n    const self = this\n\n    /**\n     * @param {CID} key\n     * @param {AsyncIterable<{ cid: CID, metadata: any }>} source\n     */\n    async function * findChild (key, source) {\n      for await (const { cid: parentCid } of source) {\n        for await (const childCid of walkDag(parentCid, self.blockstore, self.loadCodec)) {\n          if (childCid.equals(key)) {\n            yield parentCid\n            return\n          }\n        }\n      }\n    }\n\n    if (all || indirect) {\n      // indirect (default)\n      // check each recursive key to see if multihash is under it\n\n      const parentCid = await first(findChild(cid, this.recursiveKeys()))\n\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: PinTypes.indirect,\n          parent: parentCid\n        }\n      }\n    }\n\n    return {\n      cid,\n      pinned: false\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {FetchCompleteDagOptions} [options]\n   */\n  async fetchCompleteDag (cid, options = {}) {\n    const seen = new QuickLRU({ maxSize: options.cidCacheMaxSize ?? CID_CACHE_MAX_SIZE })\n\n    /**\n     * @param {CID} cid\n     * @param {AbortOptions} options\n     */\n    const walkDag = async (cid, options) => {\n      if (seen.has(cid.toString())) {\n        return\n      }\n\n      seen.set(cid.toString(), true)\n\n      const bytes = await this.blockstore.get(cid, options)\n      const codec = await this.loadCodec(cid.code)\n      const block = createUnsafe({ bytes, cid, codec })\n\n      await Promise.all(\n        [...block.links()].map(([, childCid]) => walkDag(childCid, options))\n      )\n    }\n\n    await walkDag(cid, options)\n  }\n\n  /**\n   * Throws an error if the pin type is invalid\n   *\n   * @param {any} type\n   * @returns {type is PinType}\n   */\n  static checkPinType (type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type)\n    }\n    return true\n  }\n}\n"]},"metadata":{},"sourceType":"module"}