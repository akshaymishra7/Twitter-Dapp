{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { isMultiaddr, multiaddr, resolvers } from '@multiformats/multiaddr';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { anySignal } from 'any-signal';\nimport { setMaxListeners } from 'events';\nimport { DialRequest } from './dial-request.js';\nimport { publicAddressesFirst } from '@libp2p/utils/address-sort';\nimport { trackedMap } from '@libp2p/tracked-map';\nimport { codes } from '../../errors.js';\nimport { DIAL_TIMEOUT, MAX_PARALLEL_DIALS, MAX_PER_PEER_DIALS, MAX_ADDRS_TO_DIAL } from '../../constants.js';\nimport { isPeerId } from '@libp2p/interface-peer-id';\nimport { getPeerAddress } from '../../get-peer.js';\nconst log = logger('libp2p:dialer');\nexport class DefaultDialer {\n  constructor(components) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.started = false;\n    this.addressSorter = init.addressSorter ?? publicAddressesFirst;\n    this.maxAddrsToDial = init.maxAddrsToDial ?? MAX_ADDRS_TO_DIAL;\n    this.timeout = init.dialTimeout ?? DIAL_TIMEOUT;\n    this.maxDialsPerPeer = init.maxDialsPerPeer ?? MAX_PER_PEER_DIALS;\n    this.tokens = [...new Array(init.maxParallelDials ?? MAX_PARALLEL_DIALS)].map((_, index) => index);\n    this.components = components;\n    this.pendingDials = trackedMap({\n      name: 'libp2p_dialler_pending_dials',\n      metrics: components.metrics\n    });\n    this.pendingDialTargets = trackedMap({\n      name: 'libp2p_dialler_pending_dial_targets',\n      metrics: components.metrics\n    });\n\n    for (const [key, value] of Object.entries(init.resolvers ?? {})) {\n      resolvers.set(key, value);\n    }\n  }\n\n  isStarted() {\n    return this.started;\n  }\n\n  async start() {\n    this.started = true;\n  }\n  /**\n   * Clears any pending dials\n   */\n\n\n  async stop() {\n    this.started = false;\n\n    for (const dial of this.pendingDials.values()) {\n      try {\n        dial.controller.abort();\n      } catch (err) {\n        log.error(err);\n      }\n    }\n\n    this.pendingDials.clear();\n\n    for (const pendingTarget of this.pendingDialTargets.values()) {\n      pendingTarget.abort();\n    }\n\n    this.pendingDialTargets.clear();\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   */\n\n\n  async dial(peerIdOrMultiaddr) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      peerId,\n      multiaddr\n    } = getPeerAddress(peerIdOrMultiaddr);\n\n    if (peerId != null) {\n      if (this.components.peerId.equals(peerId)) {\n        throw errCode(new Error('Tried to dial self'), codes.ERR_DIALED_SELF);\n      }\n\n      if (multiaddr != null) {\n        log('storing multiaddrs %p', peerId, multiaddr);\n        await this.components.peerStore.addressBook.add(peerId, [multiaddr]);\n      }\n\n      if (await this.components.connectionGater.denyDialPeer(peerId)) {\n        throw errCode(new Error('The dial request is blocked by gater.allowDialPeer'), codes.ERR_PEER_DIAL_INTERCEPTED);\n      }\n    }\n\n    log('creating dial target for %p', peerId); // resolving multiaddrs can involve dns lookups so allow them to be aborted\n\n    const controller = new AbortController();\n    const controllerId = randomId();\n    this.pendingDialTargets.set(controllerId, controller);\n    let signal = controller.signal; // merge with the passed signal, if any\n\n    if (options.signal != null) {\n      signal = anySignal([signal, options.signal]);\n    }\n\n    let dialTarget;\n\n    try {\n      dialTarget = await this._createDialTarget({\n        peerId,\n        multiaddr\n      }, { ...options,\n        signal\n      });\n    } finally {\n      // done resolving the multiaddrs so remove the abort controller\n      this.pendingDialTargets.delete(controllerId);\n    }\n\n    if (dialTarget.addrs.length === 0) {\n      throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES);\n    } // try to join an in-flight dial for this peer if one is available\n\n\n    const pendingDial = this.pendingDials.get(dialTarget.id) ?? this._createPendingDial(dialTarget, options);\n\n    try {\n      const connection = await pendingDial.promise;\n      log('dial succeeded to %s', dialTarget.id);\n      return connection;\n    } catch (err) {\n      log('dial failed to %s', dialTarget.id, err); // Error is a timeout\n\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT;\n      }\n\n      log.error(err);\n      throw err;\n    } finally {\n      pendingDial.destroy();\n    }\n  }\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   *\n   * If a multiaddr is received it should be the only address attempted.\n   *\n   * Multiaddrs not supported by the available transports will be filtered out.\n   */\n\n\n  async _createDialTarget(peerIdOrMultiaddr, options) {\n    let addrs = [];\n\n    if (isMultiaddr(peerIdOrMultiaddr.multiaddr)) {\n      addrs.push(peerIdOrMultiaddr.multiaddr);\n    } // only load addresses if a peer id was passed, otherwise only dial the passed multiaddr\n\n\n    if (!isMultiaddr(peerIdOrMultiaddr.multiaddr) && isPeerId(peerIdOrMultiaddr.peerId)) {\n      addrs.push(...(await this._loadAddresses(peerIdOrMultiaddr.peerId)));\n    }\n\n    addrs = (await Promise.all(addrs.map(async ma => await this._resolve(ma, options)))).flat() // Multiaddrs not supported by the available transports will be filtered out.\n    .filter(ma => Boolean(this.components.transportManager.transportForMultiaddr(ma))); // deduplicate addresses\n\n    addrs = [...new Set(addrs.map(ma => ma.toString()))].map(ma => multiaddr(ma));\n\n    if (addrs.length > this.maxAddrsToDial) {\n      throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES);\n    }\n\n    const peerId = isPeerId(peerIdOrMultiaddr.peerId) ? peerIdOrMultiaddr.peerId : undefined;\n\n    if (peerId != null) {\n      const peerIdMultiaddr = `/p2p/${peerId.toString()}`;\n      addrs = addrs.map(addr => {\n        const addressPeerId = addr.getPeerId();\n\n        if (addressPeerId == null || !peerId.equals(addressPeerId)) {\n          return addr.encapsulate(peerIdMultiaddr);\n        }\n\n        return addr;\n      });\n    }\n\n    return {\n      id: peerId == null ? randomId() : peerId.toString(),\n      addrs\n    };\n  }\n  /**\n   * Loads a list of addresses from the peer store for the passed peer id\n   */\n\n\n  async _loadAddresses(peer) {\n    const addresses = await this.components.peerStore.addressBook.get(peer);\n    return (await Promise.all(addresses.map(async address => {\n      const deny = await this.components.connectionGater.denyDialMultiaddr(peer, address.multiaddr);\n\n      if (deny) {\n        return false;\n      }\n\n      return address;\n    }))).filter(isTruthy) // Sort addresses so, for example, we try certified public address first\n    .sort(this.addressSorter).map(address => address.multiaddr);\n  }\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   */\n\n\n  _createPendingDial(dialTarget) {\n    var _this = this;\n\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction = async function (addr) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (options.signal?.aborted === true) {\n        throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n      }\n\n      return await _this.components.transportManager.dial(addr, options).catch(err => {\n        log.error('dial to %s failed', addr, err);\n        throw err;\n      });\n    };\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    }); // Combine the timeout signal and options.signal, if provided\n\n    const timeoutController = new TimeoutController(this.timeout);\n    const signals = [timeoutController.signal];\n    options.signal != null && signals.push(options.signal);\n    const signal = anySignal(signals); // this signal will potentially be used while dialing lots of\n    // peers so prevent MaxListenersExceededWarning appearing in the console\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, signal);\n    } catch {}\n\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options,\n        signal\n      }),\n      destroy: () => {\n        timeoutController.clear();\n        this.pendingDials.delete(dialTarget.id);\n      }\n    };\n    this.pendingDials.set(dialTarget.id, pendingDial);\n    return pendingDial;\n  }\n\n  getTokens(num) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);\n    const tokens = this.tokens.splice(0, total);\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n    return tokens;\n  }\n\n  releaseToken(token) {\n    // Guard against duplicate releases\n    if (this.tokens.includes(token)) {\n      return;\n    }\n\n    log('token %d released', token);\n    this.tokens.push(token);\n  }\n  /**\n   * Resolve multiaddr recursively\n   */\n\n\n  async _resolve(ma, options) {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr'); // Multiaddr is not resolvable? End recursion!\n\n    if (!resolvableProto) {\n      return [ma];\n    }\n\n    const resolvedMultiaddrs = await this._resolveRecord(ma, options);\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async nm => {\n      return await this._resolve(nm, options);\n    }));\n    const addrs = recursiveMultiaddrs.flat();\n    return addrs.reduce((array, newM) => {\n      if (array.find(m => m.equals(newM)) == null) {\n        array.push(newM);\n      }\n\n      return array;\n    }, []);\n  }\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   */\n\n\n  async _resolveRecord(ma, options) {\n    try {\n      ma = multiaddr(ma.toString()); // Use current multiaddr module\n\n      const multiaddrs = await ma.resolve(options);\n      return multiaddrs;\n    } catch (err) {\n      log.error(`multiaddr ${ma.toString()} could not be resolved`, err);\n      return [];\n    }\n  }\n\n}\n/**\n * Type safe version of `list.filter(Boolean)`\n */\n\nfunction isTruthy(e) {\n  return Boolean(e);\n}\n/**\n * Returns a random string\n */\n\n\nfunction randomId() {\n  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;\n}","map":{"version":3,"mappings":"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","names":["logger","errCode","isMultiaddr","multiaddr","resolvers","TimeoutController","anySignal","setMaxListeners","DialRequest","publicAddressesFirst","trackedMap","codes","DIAL_TIMEOUT","MAX_PARALLEL_DIALS","MAX_PER_PEER_DIALS","MAX_ADDRS_TO_DIAL","isPeerId","getPeerAddress","log","DefaultDialer","constructor","components","init","started","addressSorter","maxAddrsToDial","timeout","dialTimeout","maxDialsPerPeer","tokens","Array","maxParallelDials","map","_","index","pendingDials","name","metrics","pendingDialTargets","key","value","Object","entries","set","isStarted","start","stop","dial","values","controller","abort","err","error","clear","pendingTarget","peerIdOrMultiaddr","options","peerId","equals","Error","ERR_DIALED_SELF","peerStore","addressBook","add","connectionGater","denyDialPeer","ERR_PEER_DIAL_INTERCEPTED","AbortController","controllerId","randomId","signal","dialTarget","_createDialTarget","delete","addrs","length","ERR_NO_VALID_ADDRESSES","pendingDial","get","id","_createPendingDial","connection","promise","aborted","code","ERR_TIMEOUT","destroy","push","_loadAddresses","Promise","all","ma","_resolve","flat","filter","Boolean","transportManager","transportForMultiaddr","Set","toString","ERR_TOO_MANY_ADDRESSES","undefined","peerIdMultiaddr","addr","addressPeerId","getPeerId","encapsulate","peer","addresses","address","deny","denyDialMultiaddr","isTruthy","sort","dialAction","ERR_ALREADY_ABORTED","catch","dialRequest","dialer","timeoutController","signals","Infinity","run","getTokens","num","total","Math","min","splice","releaseToken","token","includes","resolvableProto","protoNames","resolvedMultiaddrs","_resolveRecord","recursiveMultiaddrs","nm","reduce","array","newM","find","m","multiaddrs","resolve","e","parseInt","String","random","Date","now"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\connection-manager\\dialer\\index.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { isMultiaddr, Multiaddr, Resolver, multiaddr, resolvers } from '@multiformats/multiaddr'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { anySignal } from 'any-signal'\nimport { setMaxListeners } from 'events'\nimport { DialAction, DialRequest } from './dial-request.js'\nimport { publicAddressesFirst } from '@libp2p/utils/address-sort'\nimport { trackedMap } from '@libp2p/tracked-map'\nimport { codes } from '../../errors.js'\nimport {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS,\n  MAX_ADDRS_TO_DIAL\n} from '../../constants.js'\nimport type { Connection, ConnectionGater } from '@libp2p/interface-connection'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport { isPeerId, PeerId } from '@libp2p/interface-peer-id'\nimport { getPeerAddress } from '../../get-peer.js'\nimport type { AddressSorter, PeerStore } from '@libp2p/interface-peer-store'\nimport type { Metrics } from '@libp2p/interface-metrics'\nimport type { Dialer } from '@libp2p/interface-connection-manager'\nimport type { TransportManager } from '@libp2p/interface-transport'\n\nconst log = logger('libp2p:dialer')\n\nexport interface DialTarget {\n  id: string\n  addrs: Multiaddr[]\n}\n\nexport interface PendingDial {\n  dialRequest: DialRequest\n  controller: TimeoutController\n  promise: Promise<Connection>\n  destroy: () => void\n}\n\nexport interface PendingDialTarget {\n  resolve: (value: any) => void\n  reject: (err: Error) => void\n}\n\nexport interface DialerInit {\n  /**\n   * Sort the known addresses of a peer before trying to dial\n   */\n  addressSorter?: AddressSorter\n\n  /**\n   * Number of max concurrent dials\n   */\n  maxParallelDials?: number\n\n  /**\n   * Number of max addresses to dial for a given peer\n   */\n  maxAddrsToDial?: number\n\n  /**\n   * How long a dial attempt is allowed to take\n   */\n  dialTimeout?: number\n\n  /**\n   * Number of max concurrent dials per peer\n   */\n  maxDialsPerPeer?: number\n\n  /**\n   * Multiaddr resolvers to use when dialing\n   */\n  resolvers?: Record<string, Resolver>\n}\n\nexport interface DefaultDialerComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  peerStore: PeerStore\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n}\n\nexport class DefaultDialer implements Startable, Dialer {\n  private readonly components: DefaultDialerComponents\n  private readonly addressSorter: AddressSorter\n  private readonly maxAddrsToDial: number\n  private readonly timeout: number\n  private readonly maxDialsPerPeer: number\n  public tokens: number[]\n  public pendingDials: Map<string, PendingDial>\n  public pendingDialTargets: Map<string, AbortController>\n  private started: boolean\n\n  constructor (components: DefaultDialerComponents, init: DialerInit = {}) {\n    this.started = false\n    this.addressSorter = init.addressSorter ?? publicAddressesFirst\n    this.maxAddrsToDial = init.maxAddrsToDial ?? MAX_ADDRS_TO_DIAL\n    this.timeout = init.dialTimeout ?? DIAL_TIMEOUT\n    this.maxDialsPerPeer = init.maxDialsPerPeer ?? MAX_PER_PEER_DIALS\n    this.tokens = [...new Array(init.maxParallelDials ?? MAX_PARALLEL_DIALS)].map((_, index) => index)\n    this.components = components\n    this.pendingDials = trackedMap({\n      name: 'libp2p_dialler_pending_dials',\n      metrics: components.metrics\n    })\n    this.pendingDialTargets = trackedMap({\n      name: 'libp2p_dialler_pending_dial_targets',\n      metrics: components.metrics\n    })\n\n    for (const [key, value] of Object.entries(init.resolvers ?? {})) {\n      resolvers.set(key, value)\n    }\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  async start () {\n    this.started = true\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  async stop () {\n    this.started = false\n\n    for (const dial of this.pendingDials.values()) {\n      try {\n        dial.controller.abort()\n      } catch (err: any) {\n        log.error(err)\n      }\n    }\n    this.pendingDials.clear()\n\n    for (const pendingTarget of this.pendingDialTargets.values()) {\n      pendingTarget.abort()\n    }\n    this.pendingDialTargets.clear()\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   */\n  async dial (peerIdOrMultiaddr: PeerId | Multiaddr, options: AbortOptions = {}): Promise<Connection> {\n    const { peerId, multiaddr } = getPeerAddress(peerIdOrMultiaddr)\n\n    if (peerId != null) {\n      if (this.components.peerId.equals(peerId)) {\n        throw errCode(new Error('Tried to dial self'), codes.ERR_DIALED_SELF)\n      }\n\n      if (multiaddr != null) {\n        log('storing multiaddrs %p', peerId, multiaddr)\n        await this.components.peerStore.addressBook.add(peerId, [multiaddr])\n      }\n\n      if (await this.components.connectionGater.denyDialPeer(peerId)) {\n        throw errCode(new Error('The dial request is blocked by gater.allowDialPeer'), codes.ERR_PEER_DIAL_INTERCEPTED)\n      }\n    }\n\n    log('creating dial target for %p', peerId)\n\n    // resolving multiaddrs can involve dns lookups so allow them to be aborted\n    const controller = new AbortController()\n    const controllerId = randomId()\n    this.pendingDialTargets.set(controllerId, controller)\n    let signal = controller.signal\n\n    // merge with the passed signal, if any\n    if (options.signal != null) {\n      signal = anySignal([signal, options.signal])\n    }\n\n    let dialTarget: DialTarget\n\n    try {\n      dialTarget = await this._createDialTarget({ peerId, multiaddr }, {\n        ...options,\n        signal\n      })\n    } finally {\n      // done resolving the multiaddrs so remove the abort controller\n      this.pendingDialTargets.delete(controllerId)\n    }\n\n    if (dialTarget.addrs.length === 0) {\n      throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES)\n    }\n\n    // try to join an in-flight dial for this peer if one is available\n    const pendingDial = this.pendingDials.get(dialTarget.id) ?? this._createPendingDial(dialTarget, options)\n\n    try {\n      const connection = await pendingDial.promise\n      log('dial succeeded to %s', dialTarget.id)\n      return connection\n    } catch (err: any) {\n      log('dial failed to %s', dialTarget.id, err)\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT\n      }\n      log.error(err)\n      throw err\n    } finally {\n      pendingDial.destroy()\n    }\n  }\n\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   *\n   * If a multiaddr is received it should be the only address attempted.\n   *\n   * Multiaddrs not supported by the available transports will be filtered out.\n   */\n  async _createDialTarget (peerIdOrMultiaddr: { peerId?: PeerId, multiaddr?: Multiaddr }, options: AbortOptions): Promise<DialTarget> {\n    let addrs: Multiaddr[] = []\n\n    if (isMultiaddr(peerIdOrMultiaddr.multiaddr)) {\n      addrs.push(peerIdOrMultiaddr.multiaddr)\n    }\n\n    // only load addresses if a peer id was passed, otherwise only dial the passed multiaddr\n    if (!isMultiaddr(peerIdOrMultiaddr.multiaddr) && isPeerId(peerIdOrMultiaddr.peerId)) {\n      addrs.push(...await this._loadAddresses(peerIdOrMultiaddr.peerId))\n    }\n\n    addrs = (await Promise.all(\n      addrs.map(async (ma) => await this._resolve(ma, options))\n    ))\n      .flat()\n      // Multiaddrs not supported by the available transports will be filtered out.\n      .filter(ma => Boolean(this.components.transportManager.transportForMultiaddr(ma)))\n\n    // deduplicate addresses\n    addrs = [...new Set(addrs.map(ma => ma.toString()))].map(ma => multiaddr(ma))\n\n    if (addrs.length > this.maxAddrsToDial) {\n      throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES)\n    }\n\n    const peerId = isPeerId(peerIdOrMultiaddr.peerId) ? peerIdOrMultiaddr.peerId : undefined\n\n    if (peerId != null) {\n      const peerIdMultiaddr = `/p2p/${peerId.toString()}`\n      addrs = addrs.map(addr => {\n        const addressPeerId = addr.getPeerId()\n\n        if (addressPeerId == null || !peerId.equals(addressPeerId)) {\n          return addr.encapsulate(peerIdMultiaddr)\n        }\n\n        return addr\n      })\n    }\n\n    return {\n      id: peerId == null ? randomId() : peerId.toString(),\n      addrs\n    }\n  }\n\n  /**\n   * Loads a list of addresses from the peer store for the passed peer id\n   */\n  async _loadAddresses (peer: PeerId): Promise<Multiaddr[]> {\n    const addresses = await this.components.peerStore.addressBook.get(peer)\n\n    return (await Promise.all(\n      addresses.map(async address => {\n        const deny = await this.components.connectionGater.denyDialMultiaddr(peer, address.multiaddr)\n\n        if (deny) {\n          return false\n        }\n\n        return address\n      })\n    ))\n      .filter(isTruthy)\n      // Sort addresses so, for example, we try certified public address first\n      .sort(this.addressSorter)\n      .map(address => address.multiaddr)\n  }\n\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   */\n  _createPendingDial (dialTarget: DialTarget, options: AbortOptions = {}): PendingDial {\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction: DialAction = async (addr, options = {}) => {\n      if (options.signal?.aborted === true) {\n        throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED)\n      }\n\n      return await this.components.transportManager.dial(addr, options).catch(err => {\n        log.error('dial to %s failed', addr, err)\n        throw err\n      })\n    }\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    })\n\n    // Combine the timeout signal and options.signal, if provided\n    const timeoutController = new TimeoutController(this.timeout)\n\n    const signals = [timeoutController.signal]\n    ;(options.signal != null) && signals.push(options.signal)\n    const signal = anySignal(signals)\n\n    // this signal will potentially be used while dialing lots of\n    // peers so prevent MaxListenersExceededWarning appearing in the console\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, signal)\n    } catch {}\n\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options, signal }),\n      destroy: () => {\n        timeoutController.clear()\n        this.pendingDials.delete(dialTarget.id)\n      }\n    }\n    this.pendingDials.set(dialTarget.id, pendingDial)\n\n    return pendingDial\n  }\n\n  getTokens (num: number) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length)\n    const tokens = this.tokens.splice(0, total)\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length)\n    return tokens\n  }\n\n  releaseToken (token: number) {\n    // Guard against duplicate releases\n    if (this.tokens.includes(token)) {\n      return\n    }\n\n    log('token %d released', token)\n    this.tokens.push(token)\n  }\n\n  /**\n   * Resolve multiaddr recursively\n   */\n  async _resolve (ma: Multiaddr, options: AbortOptions): Promise<Multiaddr[]> {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr')\n\n    // Multiaddr is not resolvable? End recursion!\n    if (!resolvableProto) {\n      return [ma]\n    }\n\n    const resolvedMultiaddrs = await this._resolveRecord(ma, options)\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async (nm) => {\n      return await this._resolve(nm, options)\n    }))\n\n    const addrs = recursiveMultiaddrs.flat()\n    return addrs.reduce<Multiaddr[]>((array, newM) => {\n      if (array.find(m => m.equals(newM)) == null) {\n        array.push(newM)\n      }\n      return array\n    }, ([]))\n  }\n\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   */\n  async _resolveRecord (ma: Multiaddr, options: AbortOptions): Promise<Multiaddr[]> {\n    try {\n      ma = multiaddr(ma.toString()) // Use current multiaddr module\n      const multiaddrs = await ma.resolve(options)\n      return multiaddrs\n    } catch (err) {\n      log.error(`multiaddr ${ma.toString()} could not be resolved`, err)\n      return []\n    }\n  }\n}\n\n/**\n * Type safe version of `list.filter(Boolean)`\n */\nfunction isTruthy <T> (e: T | false | null | undefined): e is T {\n  return Boolean(e)\n}\n\n/**\n * Returns a random string\n */\nfunction randomId (): string {\n  return `${(parseInt(String(Math.random() * 1e9), 10)).toString()}${Date.now()}`\n}\n"]},"metadata":{},"sourceType":"module"}