{"ast":null,"code":"import { Uint8ArrayList, isUint8ArrayList } from 'uint8arraylist';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { compare as uint8ArrayCompare } from 'uint8arrays/compare';\nconst ZERO_OFFSET = '0'.charCodeAt(0);\nconst USTAR_MAGIC = uint8ArrayFromString('ustar\\x00', 'binary');\nconst GNU_MAGIC = uint8ArrayFromString('ustar\\x20', 'binary');\nconst GNU_VER = uint8ArrayFromString('\\x20\\x00', 'binary');\nconst MAGIC_OFFSET = 257;\nconst VERSION_OFFSET = 263;\n\nconst clamp = function (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue;\n  index = ~~index; // Coerce to integer.\n\n  if (index >= len) return len;\n  if (index >= 0) return index;\n  index += len;\n  if (index >= 0) return index;\n  return 0;\n};\n\nconst toType = function (flag) {\n  switch (flag) {\n    case 0:\n      return 'file';\n\n    case 1:\n      return 'link';\n\n    case 2:\n      return 'symlink';\n\n    case 3:\n      return 'character-device';\n\n    case 4:\n      return 'block-device';\n\n    case 5:\n      return 'directory';\n\n    case 6:\n      return 'fifo';\n\n    case 7:\n      return 'contiguous-file';\n\n    case 72:\n      return 'pax-header';\n\n    case 55:\n      return 'pax-global-header';\n\n    case 27:\n      return 'gnu-long-link-path';\n\n    case 28:\n    case 30:\n      return 'gnu-long-path';\n\n    default:\n      return undefined;\n  }\n};\n\nconst indexOf = function (block, num, offset, end) {\n  for (; offset < end; offset++) {\n    if (block.get(offset) === num) return offset;\n  }\n\n  return end;\n};\n\nconst cksum = function (block) {\n  let sum = 8 * 32;\n\n  for (let i = 0; i < 148; i++) sum += block.get(i);\n\n  for (let j = 156; j < 512; j++) sum += block.get(j);\n\n  return sum;\n};\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\n\n\nfunction parse256(buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  let positive;\n\n  if (buf.get(0) === 0x80) {\n    positive = true;\n  } else if (buf.get(0) === 0xFF) {\n    positive = false;\n  } else {\n    return 0;\n  } // build up a base-256 tuple from the least sig to the highest\n\n\n  let zero = false;\n  const tuple = [];\n\n  for (let i = buf.length - 1; i > 0; i--) {\n    const byte = buf.get(i);\n    if (positive) tuple.push(byte);else if (zero && byte === 0) tuple.push(0);else if (zero) {\n      zero = false;\n      tuple.push(0x100 - byte);\n    } else tuple.push(0xFF - byte);\n  }\n\n  let sum = 0;\n  const l = tuple.length;\n\n  for (let i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i);\n  }\n\n  return positive ? sum : -1 * sum;\n}\n\nconst decodeOct = function (val, offset, length) {\n  val = val.sublist(offset, offset + length);\n  offset = 0; // If prefixed with 0x80 then parse as a base-256 integer\n\n  if ((val.get(offset) & 0x80) !== 0) {\n    return parse256(val);\n  } else {\n    // Older versions of tar can prefix with spaces\n    while (offset < val.length && val.get(offset) === 32) {\n      offset++;\n    }\n\n    const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);\n\n    while (offset < end && val.get(offset) === 0) {\n      offset++;\n    }\n\n    if (end === offset) {\n      return 0;\n    }\n\n    return parseInt(uint8ArrayToString(val.subarray(offset, end)), 8);\n  }\n};\n\nconst decodeStr = function (val, offset, length, encoding) {\n  return uint8ArrayToString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding);\n};\n\nexport function decodeLongPath(buf, encoding) {\n  const list = isUint8ArrayList(buf) ? buf : new Uint8ArrayList(buf);\n  return decodeStr(list, 0, buf.length, encoding);\n}\nexport function decodePax(buf, encoding) {\n  let list = isUint8ArrayList(buf) ? buf : new Uint8ArrayList(buf);\n  const result = {};\n\n  while (list.length > 0) {\n    let i = 0;\n\n    while (i < buf.length && list.get(i) !== 32) {\n      i++;\n    }\n\n    const len = parseInt(uint8ArrayToString(list.subarray(0, i)), 10);\n\n    if (len === 0) {\n      return result;\n    }\n\n    const b = uint8ArrayToString(list.subarray(i + 1, len - 1), encoding);\n    const keyIndex = b.indexOf('=');\n\n    if (keyIndex === -1) {\n      return result;\n    }\n\n    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);\n    list = list.sublist(len);\n  }\n\n  return result;\n}\nexport function decode(buf, filenameEncoding) {\n  const list = isUint8ArrayList(buf) ? buf : new Uint8ArrayList(buf);\n  let typeflag = list.get(156) === 0 ? 0 : list.get(156) - ZERO_OFFSET;\n  let name = decodeStr(list, 0, 100, filenameEncoding);\n  const mode = decodeOct(list, 100, 8);\n  const uid = decodeOct(list, 108, 8);\n  const gid = decodeOct(list, 116, 8);\n  const size = decodeOct(list, 124, 12);\n  const mtime = decodeOct(list, 136, 12);\n  const type = toType(typeflag);\n  const linkname = list.get(157) === 0 ? undefined : decodeStr(list, 157, 100, filenameEncoding);\n  const uname = decodeStr(list, 265, 32);\n  const gname = decodeStr(list, 297, 32);\n  const devmajor = decodeOct(list, 329, 8);\n  const devminor = decodeOct(list, 337, 8);\n  const c = cksum(list); // checksum is still initial value if header was null.\n\n  if (c === 8 * 32) {\n    return null;\n  } // valid checksum\n\n\n  if (c !== decodeOct(list, 148, 8)) {\n    throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?');\n  }\n\n  if (uint8ArrayCompare(USTAR_MAGIC, list.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (list.get(345) !== 0) {\n      name = decodeStr(list, 345, 155, filenameEncoding) + '/' + name;\n    }\n  } else if (uint8ArrayCompare(GNU_MAGIC, list.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0 && uint8ArrayCompare(GNU_VER, list.subarray(VERSION_OFFSET, VERSION_OFFSET + 2)) === 0) {// 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else {\n    throw new Error('Invalid tar header: unknown format.');\n  } // to support old tar versions that use trailing / to indicate dirs\n\n\n  if (typeflag === 0 && name != null && name[name.length - 1] === '/') {\n    typeflag = 5;\n  }\n\n  return {\n    name: name,\n    mode: mode,\n    uid: uid,\n    gid: gid,\n    size: size,\n    mtime: new Date(1000 * (mtime ?? 0)),\n    type: type,\n    linkname: linkname,\n    uname: uname,\n    gname: gname,\n    devmajor: devmajor,\n    devminor: devminor\n  };\n}","map":{"version":3,"mappings":"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","names":["Uint8ArrayList","isUint8ArrayList","toString","uint8ArrayToString","fromString","uint8ArrayFromString","compare","uint8ArrayCompare","ZERO_OFFSET","charCodeAt","USTAR_MAGIC","GNU_MAGIC","GNU_VER","MAGIC_OFFSET","VERSION_OFFSET","clamp","index","len","defaultValue","toType","flag","undefined","indexOf","block","num","offset","end","get","cksum","sum","i","j","parse256","buf","positive","zero","tuple","length","byte","push","l","Math","pow","decodeOct","val","sublist","parseInt","subarray","decodeStr","encoding","decodeLongPath","list","decodePax","result","b","keyIndex","slice","decode","filenameEncoding","typeflag","name","mode","uid","gid","size","mtime","type","linkname","uname","gname","devmajor","devminor","c","Error","Date"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-tar\\src\\extract-headers.ts"],"sourcesContent":["import { Uint8ArrayList, isUint8ArrayList } from 'uint8arraylist'\nimport { SupportedEncodings, toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { compare as uint8ArrayCompare } from 'uint8arrays/compare'\nimport type { TarEntryHeader } from '.'\n\nconst ZERO_OFFSET = '0'.charCodeAt(0)\nconst USTAR_MAGIC = uint8ArrayFromString('ustar\\x00', 'binary')\nconst GNU_MAGIC = uint8ArrayFromString('ustar\\x20', 'binary')\nconst GNU_VER = uint8ArrayFromString('\\x20\\x00', 'binary')\nconst MAGIC_OFFSET = 257\nconst VERSION_OFFSET = 263\n\nconst clamp = function (index: number, len: number, defaultValue: number) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nconst toType = function (flag: number) {\n  switch (flag) {\n    case 0:\n      return 'file'\n    case 1:\n      return 'link'\n    case 2:\n      return 'symlink'\n    case 3:\n      return 'character-device'\n    case 4:\n      return 'block-device'\n    case 5:\n      return 'directory'\n    case 6:\n      return 'fifo'\n    case 7:\n      return 'contiguous-file'\n    case 72:\n      return 'pax-header'\n    case 55:\n      return 'pax-global-header'\n    case 27:\n      return 'gnu-long-link-path'\n    case 28:\n    case 30:\n      return 'gnu-long-path'\n    default:\n      return undefined\n  }\n}\n\nconst indexOf = function (block: Uint8ArrayList, num: number, offset: number, end: number) {\n  for (; offset < end; offset++) {\n    if (block.get(offset) === num) return offset\n  }\n  return end\n}\n\nconst cksum = function (block: Uint8ArrayList) {\n  let sum = 8 * 32\n  for (let i = 0; i < 148; i++) sum += block.get(i)\n  for (let j = 156; j < 512; j++) sum += block.get(j)\n  return sum\n}\n\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\nfunction parse256 (buf: Uint8ArrayList): number {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  let positive\n  if (buf.get(0) === 0x80) {\n    positive = true\n  } else if (buf.get(0) === 0xFF) {\n    positive = false\n  } else {\n    return 0\n  }\n\n  // build up a base-256 tuple from the least sig to the highest\n  let zero = false\n  const tuple = []\n  for (let i = buf.length - 1; i > 0; i--) {\n    const byte = buf.get(i)\n    if (positive) tuple.push(byte)\n    else if (zero && byte === 0) tuple.push(0)\n    else if (zero) {\n      zero = false\n      tuple.push(0x100 - byte)\n    } else tuple.push(0xFF - byte)\n  }\n\n  let sum = 0\n  const l = tuple.length\n  for (let i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i)\n  }\n\n  return positive ? sum : -1 * sum\n}\n\nconst decodeOct = function (val: Uint8ArrayList, offset: number, length: number): number {\n  val = val.sublist(offset, offset + length)\n  offset = 0\n\n  // If prefixed with 0x80 then parse as a base-256 integer\n  if ((val.get(offset) & 0x80) !== 0) {\n    return parse256(val)\n  } else {\n    // Older versions of tar can prefix with spaces\n    while (offset < val.length && val.get(offset) === 32) {\n      offset++\n    }\n\n    const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)\n\n    while (offset < end && val.get(offset) === 0) {\n      offset++\n    }\n\n    if (end === offset) {\n      return 0\n    }\n\n    return parseInt(uint8ArrayToString(val.subarray(offset, end)), 8)\n  }\n}\n\nconst decodeStr = function (val: Uint8ArrayList, offset: number, length: number, encoding?: SupportedEncodings) {\n  return uint8ArrayToString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding)\n}\n\nexport function decodeLongPath (buf: Uint8ArrayList | Uint8Array, encoding?: SupportedEncodings) {\n  const list = isUint8ArrayList(buf) ? buf : new Uint8ArrayList(buf)\n  return decodeStr(list, 0, buf.length, encoding)\n}\n\nexport function decodePax (buf: Uint8ArrayList | Uint8Array, encoding?: SupportedEncodings) {\n  let list = isUint8ArrayList(buf) ? buf : new Uint8ArrayList(buf)\n  const result: Record<string, string> = {}\n\n  while (list.length > 0) {\n    let i = 0\n    while (i < buf.length && list.get(i) !== 32) {\n      i++\n    }\n\n    const len = parseInt(uint8ArrayToString(list.subarray(0, i)), 10)\n\n    if (len === 0) {\n      return result\n    }\n\n    const b = uint8ArrayToString(list.subarray(i + 1, len - 1), encoding)\n    const keyIndex = b.indexOf('=')\n\n    if (keyIndex === -1) {\n      return result\n    }\n\n    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)\n    list = list.sublist(len)\n  }\n\n  return result\n}\n\nexport function decode (buf: Uint8ArrayList | Uint8Array, filenameEncoding?: SupportedEncodings): TarEntryHeader | null {\n  const list = isUint8ArrayList(buf) ? buf : new Uint8ArrayList(buf)\n  let typeflag = list.get(156) === 0 ? 0 : list.get(156) - ZERO_OFFSET\n\n  let name = decodeStr(list, 0, 100, filenameEncoding)\n  const mode = decodeOct(list, 100, 8)\n  const uid = decodeOct(list, 108, 8)\n  const gid = decodeOct(list, 116, 8)\n  const size = decodeOct(list, 124, 12)\n  const mtime = decodeOct(list, 136, 12)\n  const type = toType(typeflag)\n  const linkname = list.get(157) === 0 ? undefined : decodeStr(list, 157, 100, filenameEncoding)\n  const uname = decodeStr(list, 265, 32)\n  const gname = decodeStr(list, 297, 32)\n  const devmajor = decodeOct(list, 329, 8)\n  const devminor = decodeOct(list, 337, 8)\n\n  const c = cksum(list)\n\n  // checksum is still initial value if header was null.\n  if (c === 8 * 32) {\n    return null\n  }\n\n  // valid checksum\n  if (c !== decodeOct(list, 148, 8)) {\n    throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')\n  }\n\n  if (uint8ArrayCompare(USTAR_MAGIC, list.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (list.get(345) !== 0) {\n      name = decodeStr(list, 345, 155, filenameEncoding) + '/' + name\n    }\n  } else if (uint8ArrayCompare(GNU_MAGIC, list.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0 &&\n             uint8ArrayCompare(GNU_VER, list.subarray(VERSION_OFFSET, VERSION_OFFSET + 2)) === 0) {\n    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else {\n    throw new Error('Invalid tar header: unknown format.')\n  }\n\n  // to support old tar versions that use trailing / to indicate dirs\n  if (typeflag === 0 && name != null && name[name.length - 1] === '/') {\n    typeflag = 5\n  }\n\n  return {\n    name: name,\n    mode: mode,\n    uid: uid,\n    gid: gid,\n    size: size,\n    mtime: new Date(1000 * (mtime ?? 0)),\n    type: type,\n    linkname: linkname,\n    uname: uname,\n    gname: gname,\n    devmajor: devmajor,\n    devminor: devminor\n  }\n}\n"]},"metadata":{},"sourceType":"module"}