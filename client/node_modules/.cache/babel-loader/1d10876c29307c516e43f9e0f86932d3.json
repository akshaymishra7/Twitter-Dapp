{"ast":null,"code":"import errCode from 'err-code';\nimport { CID } from 'multiformats/cid';\nimport resolve from './resolvers/index.js';\nimport last from 'it-last';\n\nconst toPathComponents = function () {\n  let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\n\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    };\n  }\n\n  const cid = CID.asCID(path);\n\n  if (cid) {\n    return {\n      cid,\n      toResolve: []\n    };\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n\n    const output = toPathComponents(path);\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH');\n};\n\nexport async function* walkPath(path, blockstore) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path);\n  let name = cid.toString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n    }\n\n    if (result.entry) {\n      yield result.entry;\n    }\n\n    if (!result.next) {\n      return;\n    }\n\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n}\nexport async function exporter(path, blockstore) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const result = await last(walkPath(path, blockstore, options));\n\n  if (!result) {\n    throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n  }\n\n  return result;\n}\nexport async function* recursive(path, blockstore) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const node = await exporter(path, blockstore, options);\n\n  if (!node) {\n    return;\n  }\n\n  yield node;\n\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n\n      if (file instanceof Uint8Array) {\n        continue;\n      }\n\n      if (file.type === 'directory') {\n        yield* recurse(file, options);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/client/node_modules/ipfs-unixfs-exporter/esm/src/index.js"],"names":["errCode","CID","resolve","last","toPathComponents","path","trim","match","filter","Boolean","cidAndRest","Uint8Array","cid","decode","toResolve","asCID","indexOf","substring","output","parse","slice","Error","walkPath","blockstore","options","name","toString","entryPath","startingDepth","length","result","entry","next","exporter","recursive","node","type","child","recurse","file","content"],"mappings":"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","sourcesContent":["import errCode from 'err-code';\nimport { CID } from 'multiformats/cid';\nimport resolve from './resolvers/index.js';\nimport last from 'it-last';\nconst toPathComponents = (path = '') => {\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    };\n  }\n  const cid = CID.asCID(path);\n  if (cid) {\n    return {\n      cid,\n      toResolve: []\n    };\n  }\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n    const output = toPathComponents(path);\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n  throw errCode(new Error(`Unknown path type ${ path }`), 'ERR_BAD_PATH');\n};\nexport async function* walkPath(path, blockstore, options = {}) {\n  let {cid, toResolve} = cidAndRest(path);\n  let name = cid.toString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${ path }`), 'ERR_NOT_FOUND');\n    }\n    if (result.entry) {\n      yield result.entry;\n    }\n    if (!result.next) {\n      return;\n    }\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n}\nexport async function exporter(path, blockstore, options = {}) {\n  const result = await last(walkPath(path, blockstore, options));\n  if (!result) {\n    throw errCode(new Error(`Could not resolve ${ path }`), 'ERR_NOT_FOUND');\n  }\n  return result;\n}\nexport async function* recursive(path, blockstore, options = {}) {\n  const node = await exporter(path, blockstore, options);\n  if (!node) {\n    return;\n  }\n  yield node;\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n      if (file instanceof Uint8Array) {\n        continue;\n      }\n      if (file.type === 'directory') {\n        yield* recurse(file, options);\n      }\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}