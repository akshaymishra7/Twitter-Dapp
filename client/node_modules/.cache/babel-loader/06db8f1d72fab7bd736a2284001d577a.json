{"ast":null,"code":"import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport errCode from 'err-code';\nimport { NotEnabledError } from '../errors.js';\nimport get from 'dlv';\n/**\n * @typedef {import('@libp2p/interface-pubsub').Message} Message\n * @typedef {import('@libp2p/interfaces/events').EventHandler<CustomEvent<Message>>} EventHandler\n * @typedef {import('@libp2p/interfaces/events').EventHandler<Message>} MessageEventHandler\n */\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-core-types/src/config').Config} [config.config]\n */\n\nexport function createPubsub(_ref) {\n  let {\n    network,\n    config\n  } = _ref;\n  const isEnabled = get(config || {}, 'Pubsub.Enabled', true);\n  /** @type {Record<string, MessageEventHandler[]>} */\n\n  const handlers = {};\n  /** @type {EventHandler | undefined} */\n\n  let onMessage;\n  return {\n    subscribe: isEnabled ? withTimeoutOption(subscribe) : notEnabled,\n    unsubscribe: isEnabled ? withTimeoutOption(unsubscribe) : notEnabled,\n    publish: isEnabled ? withTimeoutOption(publish) : notEnabled,\n    ls: isEnabled ? withTimeoutOption(ls) : notEnabled,\n    peers: isEnabled ? withTimeoutOption(peers) : notEnabled\n  };\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"subscribe\"]}\n   */\n\n  async function subscribe(topic, handler) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      libp2p\n    } = await network.use(options);\n    libp2p.pubsub.subscribe(topic); // listen for 'message' events if we aren't already\n\n    if (onMessage == null) {\n      onMessage = evt => {\n        const msg = evt.detail;\n\n        if (handlers[msg.topic]) {\n          handlers[msg.topic].forEach(handler => {\n            if (typeof handler === 'function') {\n              handler(msg);\n              return;\n            }\n\n            if (handler != null && handler.handleEvent != null) {\n              handler.handleEvent(msg);\n            }\n          });\n        }\n      };\n\n      libp2p.pubsub.addEventListener('message', onMessage);\n    } // store handler for future invocation\n\n\n    if (handler != null) {\n      if (handlers[topic] == null) {\n        handlers[topic] = [];\n      }\n\n      handlers[topic].push(handler);\n    }\n  }\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"unsubscribe\"]}\n   */\n\n\n  async function unsubscribe(topic, handler) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      libp2p\n    } = await network.use(options); // remove handler from local map\n\n    if (handler != null && handlers[topic] != null) {\n      handlers[topic] = handlers[topic].filter(h => h !== handler);\n\n      if (handlers[topic].length === 0) {\n        delete handlers[topic];\n      }\n    } // remove all handlers\n\n\n    if (typeof handler !== 'function') {\n      delete handlers[topic];\n    } // no more handlers for this topic, unsubscribe\n\n\n    if (handlers[topic] == null) {\n      libp2p.pubsub.unsubscribe(topic);\n    } // no more pubsub handlers, remove message listener\n\n\n    if (Object.keys(handlers).length === 0) {\n      libp2p.pubsub.removeEventListener('message', onMessage);\n      onMessage = undefined;\n    }\n  }\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"publish\"]}\n   */\n\n\n  async function publish(topic, data) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      libp2p\n    } = await network.use(options);\n\n    if (!data) {\n      throw errCode(new Error('argument \"data\" is required'), 'ERR_ARG_REQUIRED');\n    }\n\n    await libp2p.pubsub.publish(topic, data);\n  }\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"ls\"]}\n   */\n\n\n  async function ls() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      libp2p\n    } = await network.use(options);\n    return libp2p.pubsub.getTopics();\n  }\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"peers\"]}\n   */\n\n\n  async function peers(topic) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      libp2p\n    } = await network.use(options);\n    return libp2p.pubsub.getSubscribers(topic);\n  }\n}\n\nconst notEnabled = async () => {\n  // eslint-disable-line require-await\n  throw new NotEnabledError('pubsub not enabled');\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/pubsub.js"],"names":["withTimeoutOption","errCode","NotEnabledError","get","createPubsub","network","config","isEnabled","handlers","onMessage","subscribe","notEnabled","unsubscribe","publish","ls","peers","topic","handler","options","libp2p","use","pubsub","evt","msg","detail","forEach","handleEvent","addEventListener","push","filter","h","length","Object","keys","removeEventListener","undefined","data","Error","getTopics","getSubscribers"],"mappings":"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","sourcesContent":["import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport errCode from 'err-code'\nimport { NotEnabledError } from '../errors.js'\nimport get from 'dlv'\n\n/**\n * @typedef {import('@libp2p/interface-pubsub').Message} Message\n * @typedef {import('@libp2p/interfaces/events').EventHandler<CustomEvent<Message>>} EventHandler\n * @typedef {import('@libp2p/interfaces/events').EventHandler<Message>} MessageEventHandler\n */\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-core-types/src/config').Config} [config.config]\n */\nexport function createPubsub ({ network, config }) {\n  const isEnabled = get(config || {}, 'Pubsub.Enabled', true)\n\n  /** @type {Record<string, MessageEventHandler[]>} */\n  const handlers = {}\n  /** @type {EventHandler | undefined} */\n  let onMessage\n\n  return {\n    subscribe: isEnabled ? withTimeoutOption(subscribe) : notEnabled,\n    unsubscribe: isEnabled ? withTimeoutOption(unsubscribe) : notEnabled,\n    publish: isEnabled ? withTimeoutOption(publish) : notEnabled,\n    ls: isEnabled ? withTimeoutOption(ls) : notEnabled,\n    peers: isEnabled ? withTimeoutOption(peers) : notEnabled\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"subscribe\"]}\n   */\n  async function subscribe (topic, handler, options = {}) {\n    const { libp2p } = await network.use(options)\n\n    libp2p.pubsub.subscribe(topic)\n\n    // listen for 'message' events if we aren't already\n    if (onMessage == null) {\n      onMessage = (evt) => {\n        const msg = evt.detail\n\n        if (handlers[msg.topic]) {\n          handlers[msg.topic].forEach(handler => {\n            if (typeof handler === 'function') {\n              handler(msg)\n              return\n            }\n\n            if (handler != null && handler.handleEvent != null) {\n              handler.handleEvent(msg)\n            }\n          })\n        }\n      }\n\n      libp2p.pubsub.addEventListener('message', onMessage)\n    }\n\n    // store handler for future invocation\n    if (handler != null) {\n      if (handlers[topic] == null) {\n        handlers[topic] = []\n      }\n\n      handlers[topic].push(handler)\n    }\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"unsubscribe\"]}\n   */\n  async function unsubscribe (topic, handler, options = {}) {\n    const { libp2p } = await network.use(options)\n\n    // remove handler from local map\n    if (handler != null && handlers[topic] != null) {\n      handlers[topic] = handlers[topic].filter(h => h !== handler)\n\n      if (handlers[topic].length === 0) {\n        delete handlers[topic]\n      }\n    }\n\n    // remove all handlers\n    if (typeof handler !== 'function') {\n      delete handlers[topic]\n    }\n\n    // no more handlers for this topic, unsubscribe\n    if (handlers[topic] == null) {\n      libp2p.pubsub.unsubscribe(topic)\n    }\n\n    // no more pubsub handlers, remove message listener\n    if (Object.keys(handlers).length === 0) {\n      libp2p.pubsub.removeEventListener('message', onMessage)\n      onMessage = undefined\n    }\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"publish\"]}\n   */\n  async function publish (topic, data, options = {}) {\n    const { libp2p } = await network.use(options)\n    if (!data) {\n      throw errCode(new Error('argument \"data\" is required'), 'ERR_ARG_REQUIRED')\n    }\n\n    await libp2p.pubsub.publish(topic, data)\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"ls\"]}\n   */\n  async function ls (options = {}) {\n    const { libp2p } = await network.use(options)\n\n    return libp2p.pubsub.getTopics()\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"peers\"]}\n   */\n  async function peers (topic, options = {}) {\n    const { libp2p } = await network.use(options)\n\n    return libp2p.pubsub.getSubscribers(topic)\n  }\n}\n\nconst notEnabled = async () => { // eslint-disable-line require-await\n  throw new NotEnabledError('pubsub not enabled')\n}\n"]},"metadata":{},"sourceType":"module"}