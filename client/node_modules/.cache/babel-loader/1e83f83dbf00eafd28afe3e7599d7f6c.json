{"ast":null,"code":"import { unmarshalPublicKey, unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { NoiseHandshakePayload } from './proto/payload.js';\nexport async function getPayload(localPeer, staticPublicKey, extensions) {\n  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));\n\n  if (localPeer.publicKey == null) {\n    throw new Error('PublicKey was missing from local PeerId');\n  }\n\n  return createHandshakePayload(localPeer.publicKey, signedPayload, extensions);\n}\nexport function createHandshakePayload(libp2pPublicKey, signedPayload, extensions) {\n  return NoiseHandshakePayload.encode({\n    identityKey: libp2pPublicKey,\n    identitySig: signedPayload,\n    extensions: extensions ?? {\n      webtransportCerthashes: []\n    }\n  }).subarray();\n}\nexport async function signPayload(peerId, payload) {\n  if (peerId.privateKey == null) {\n    throw new Error('PrivateKey was missing from PeerId');\n  }\n\n  const privateKey = await unmarshalPrivateKey(peerId.privateKey);\n  return await privateKey.sign(payload);\n}\nexport async function getPeerIdFromPayload(payload) {\n  return await peerIdFromKeys(payload.identityKey);\n}\nexport function decodePayload(payload) {\n  return NoiseHandshakePayload.decode(payload);\n}\nexport function getHandshakePayload(publicKey) {\n  const prefix = uint8ArrayFromString('noise-libp2p-static-key:');\n  return uint8ArrayConcat([prefix, publicKey], prefix.length + publicKey.length);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\n\nexport async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {\n  // Unmarshaling from PublicKey protobuf\n  const payloadPeerId = await peerIdFromKeys(payload.identityKey);\n\n  if (!payloadPeerId.equals(remotePeer)) {\n    throw new Error(`Payload identity key ${payloadPeerId.toString()} does not match expected remote peer ${remotePeer.toString()}`);\n  }\n\n  const generatedPayload = getHandshakePayload(noiseStaticKey);\n\n  if (payloadPeerId.publicKey == null) {\n    throw new Error('PublicKey was missing from PeerId');\n  }\n\n  if (payload.identitySig == null) {\n    throw new Error('Signature was missing from message');\n  }\n\n  const publicKey = unmarshalPublicKey(payloadPeerId.publicKey);\n  const valid = await publicKey.verify(generatedPayload, payload.identitySig);\n\n  if (!valid) {\n    throw new Error(\"Static key doesn't match to peer that signed payload!\");\n  }\n\n  return payloadPeerId;\n}\nexport function isValidPublicKey(pk) {\n  if (!(pk instanceof Uint8Array)) {\n    return false;\n  }\n\n  if (pk.length !== 32) {\n    return false;\n  }\n\n  return true;\n}","map":{"version":3,"mappings":"AAAA,SAASA,kBAAT,EAA6BC,mBAA7B,QAAwD,qBAAxD;AAEA,SAASC,cAAT,QAA+B,iBAA/B;AACA,SAASC,MAAM,IAAIC,gBAAnB,QAA2C,oBAA3C;AACA,SAASC,UAAU,IAAIC,oBAAvB,QAAmD,yBAAnD;AAEA,SAA0BC,qBAA1B,QAAuD,oBAAvD;AAEA,OAAO,eAAeC,UAAf,CACLC,SADK,EAELC,eAFK,EAGLC,UAHK,EAGuB;AAE5B,QAAMC,aAAa,GAAG,MAAMC,WAAW,CAACJ,SAAD,EAAYK,mBAAmB,CAACJ,eAAD,CAA/B,CAAvC;;AAEA,MAAID,SAAS,CAACM,SAAV,IAAuB,IAA3B,EAAiC;AAC/B,UAAM,IAAIC,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAED,SAAOC,sBAAsB,CAC3BR,SAAS,CAACM,SADiB,EAE3BH,aAF2B,EAG3BD,UAH2B,CAA7B;AAKD;AAED,OAAM,SAAUM,sBAAV,CACJC,eADI,EAEJN,aAFI,EAGJD,UAHI,EAGwB;AAE5B,SAAOJ,qBAAqB,CAACY,MAAtB,CAA6B;AAClCC,eAAW,EAAEF,eADqB;AAElCG,eAAW,EAAET,aAFqB;AAGlCD,cAAU,EAAEA,UAAU,IAAI;AAAEW,4BAAsB,EAAE;AAA1B;AAHQ,GAA7B,EAIJC,QAJI,EAAP;AAKD;AAED,OAAO,eAAeV,WAAf,CAA4BW,MAA5B,EAA4CC,OAA5C,EAA0D;AAC/D,MAAID,MAAM,CAACE,UAAP,IAAqB,IAAzB,EAA+B;AAC7B,UAAM,IAAIV,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,QAAMU,UAAU,GAAG,MAAMzB,mBAAmB,CAACuB,MAAM,CAACE,UAAR,CAA5C;AAEA,SAAO,MAAMA,UAAU,CAACC,IAAX,CAAgBF,OAAhB,CAAb;AACD;AAED,OAAO,eAAeG,oBAAf,CAAqCH,OAArC,EAAmE;AACxE,SAAO,MAAMvB,cAAc,CAACuB,OAAO,CAACL,WAAT,CAA3B;AACD;AAED,OAAM,SAAUS,aAAV,CAAyBJ,OAAzB,EAAoD;AACxD,SAAOlB,qBAAqB,CAACuB,MAAtB,CAA6BL,OAA7B,CAAP;AACD;AAED,OAAM,SAAUX,mBAAV,CAA+BC,SAA/B,EAA+C;AACnD,QAAMgB,MAAM,GAAGzB,oBAAoB,CAAC,0BAAD,CAAnC;AACA,SAAOF,gBAAgB,CAAC,CAAC2B,MAAD,EAAShB,SAAT,CAAD,EAAsBgB,MAAM,CAACC,MAAP,GAAgBjB,SAAS,CAACiB,MAAhD,CAAvB;AACD;AAED;;;;;;;;;AAQA,OAAO,eAAeC,mBAAf,CACLC,cADK,EAELT,OAFK,EAGLU,UAHK,EAGa;AAElB;AACA,QAAMC,aAAa,GAAG,MAAMlC,cAAc,CAACuB,OAAO,CAACL,WAAT,CAA1C;;AACA,MAAI,CAACgB,aAAa,CAACC,MAAd,CAAqBF,UAArB,CAAL,EAAuC;AACrC,UAAM,IAAInB,KAAJ,CAAU,wBAAwBoB,aAAa,CAACE,QAAd,EAAwB,wCAAwCH,UAAU,CAACG,QAAX,EAAqB,EAAvH,CAAN;AACD;;AACD,QAAMC,gBAAgB,GAAGzB,mBAAmB,CAACoB,cAAD,CAA5C;;AAEA,MAAIE,aAAa,CAACrB,SAAd,IAA2B,IAA/B,EAAqC;AACnC,UAAM,IAAIC,KAAJ,CAAU,mCAAV,CAAN;AACD;;AAED,MAAIS,OAAO,CAACJ,WAAR,IAAuB,IAA3B,EAAiC;AAC/B,UAAM,IAAIL,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,QAAMD,SAAS,GAAGf,kBAAkB,CAACoC,aAAa,CAACrB,SAAf,CAApC;AAEA,QAAMyB,KAAK,GAAG,MAAMzB,SAAS,CAAC0B,MAAV,CAAiBF,gBAAjB,EAAmCd,OAAO,CAACJ,WAA3C,CAApB;;AAEA,MAAI,CAACmB,KAAL,EAAY;AACV,UAAM,IAAIxB,KAAJ,CAAU,uDAAV,CAAN;AACD;;AAED,SAAOoB,aAAP;AACD;AAED,OAAM,SAAUM,gBAAV,CAA4BC,EAA5B,EAAqC;AACzC,MAAI,EAAEA,EAAE,YAAYC,UAAhB,CAAJ,EAAiC;AAC/B,WAAO,KAAP;AACD;;AAED,MAAID,EAAE,CAACX,MAAH,KAAc,EAAlB,EAAsB;AACpB,WAAO,KAAP;AACD;;AAED,SAAO,IAAP;AACD","names":["unmarshalPublicKey","unmarshalPrivateKey","peerIdFromKeys","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","NoiseHandshakePayload","getPayload","localPeer","staticPublicKey","extensions","signedPayload","signPayload","getHandshakePayload","publicKey","Error","createHandshakePayload","libp2pPublicKey","encode","identityKey","identitySig","webtransportCerthashes","subarray","peerId","payload","privateKey","sign","getPeerIdFromPayload","decodePayload","decode","prefix","length","verifySignedPayload","noiseStaticKey","remotePeer","payloadPeerId","equals","toString","generatedPayload","valid","verify","isValidPublicKey","pk","Uint8Array"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-noise\\src\\utils.ts"],"sourcesContent":["import { unmarshalPublicKey, unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { bytes } from './@types/basic.js'\nimport { NoiseExtensions, NoiseHandshakePayload } from './proto/payload.js'\n\nexport async function getPayload (\n  localPeer: PeerId,\n  staticPublicKey: bytes,\n  extensions?: NoiseExtensions\n): Promise<bytes> {\n  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey))\n\n  if (localPeer.publicKey == null) {\n    throw new Error('PublicKey was missing from local PeerId')\n  }\n\n  return createHandshakePayload(\n    localPeer.publicKey,\n    signedPayload,\n    extensions\n  )\n}\n\nexport function createHandshakePayload (\n  libp2pPublicKey: Uint8Array,\n  signedPayload: Uint8Array,\n  extensions?: NoiseExtensions\n): bytes {\n  return NoiseHandshakePayload.encode({\n    identityKey: libp2pPublicKey,\n    identitySig: signedPayload,\n    extensions: extensions ?? { webtransportCerthashes: [] }\n  }).subarray()\n}\n\nexport async function signPayload (peerId: PeerId, payload: bytes): Promise<bytes> {\n  if (peerId.privateKey == null) {\n    throw new Error('PrivateKey was missing from PeerId')\n  }\n\n  const privateKey = await unmarshalPrivateKey(peerId.privateKey)\n\n  return await privateKey.sign(payload)\n}\n\nexport async function getPeerIdFromPayload (payload: NoiseHandshakePayload): Promise<PeerId> {\n  return await peerIdFromKeys(payload.identityKey)\n}\n\nexport function decodePayload (payload: bytes | Uint8Array): NoiseHandshakePayload {\n  return NoiseHandshakePayload.decode(payload)\n}\n\nexport function getHandshakePayload (publicKey: bytes): bytes {\n  const prefix = uint8ArrayFromString('noise-libp2p-static-key:')\n  return uint8ArrayConcat([prefix, publicKey], prefix.length + publicKey.length)\n}\n\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\nexport async function verifySignedPayload (\n  noiseStaticKey: bytes,\n  payload: NoiseHandshakePayload,\n  remotePeer: PeerId\n): Promise<PeerId> {\n  // Unmarshaling from PublicKey protobuf\n  const payloadPeerId = await peerIdFromKeys(payload.identityKey)\n  if (!payloadPeerId.equals(remotePeer)) {\n    throw new Error(`Payload identity key ${payloadPeerId.toString()} does not match expected remote peer ${remotePeer.toString()}`)\n  }\n  const generatedPayload = getHandshakePayload(noiseStaticKey)\n\n  if (payloadPeerId.publicKey == null) {\n    throw new Error('PublicKey was missing from PeerId')\n  }\n\n  if (payload.identitySig == null) {\n    throw new Error('Signature was missing from message')\n  }\n\n  const publicKey = unmarshalPublicKey(payloadPeerId.publicKey)\n\n  const valid = await publicKey.verify(generatedPayload, payload.identitySig)\n\n  if (!valid) {\n    throw new Error(\"Static key doesn't match to peer that signed payload!\")\n  }\n\n  return payloadPeerId\n}\n\nexport function isValidPublicKey (pk: bytes): boolean {\n  if (!(pk instanceof Uint8Array)) {\n    return false\n  }\n\n  if (pk.length !== 32) {\n    return false\n  }\n\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}