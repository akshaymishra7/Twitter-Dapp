{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport merge from 'it-merge';\nimport { queryErrorEvent } from './query/events.js';\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';\nimport { symbol } from '@libp2p/interface-peer-discovery';\nconst log = logger('libp2p:kad-dht');\n/**\n * A DHT implementation modelled after Kademlia with S/Kademlia modifications.\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\n\nexport class DualKadDHT extends EventEmitter {\n  constructor(components, wan, lan) {\n    super();\n    this.components = components;\n    this.wan = wan;\n    this.lan = lan; // handle peers being discovered during processing of DHT messages\n\n    this.wan.addEventListener('peer', evt => {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: evt.detail\n      }));\n    });\n    this.lan.addEventListener('peer', evt => {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: evt.detail\n      }));\n    });\n  }\n\n  get [symbol]() {\n    return true;\n  }\n\n  get [Symbol.toStringTag]() {\n    return '@libp2p/dual-kad-dht';\n  }\n  /**\n   * Is this DHT running.\n   */\n\n\n  isStarted() {\n    return this.wan.isStarted() && this.lan.isStarted();\n  }\n  /**\n   * If 'server' this node will respond to DHT queries, if 'client' this node will not\n   */\n\n\n  async getMode() {\n    return await this.wan.getMode();\n  }\n  /**\n   * If 'server' this node will respond to DHT queries, if 'client' this node will not\n   */\n\n\n  async setMode(mode) {\n    await this.wan.setMode(mode);\n  }\n  /**\n   * Start listening to incoming connections.\n   */\n\n\n  async start() {\n    await Promise.all([this.lan.start(), this.wan.start()]);\n  }\n  /**\n   * Stop accepting incoming connections and sending outgoing\n   * messages.\n   */\n\n\n  async stop() {\n    await Promise.all([this.lan.stop(), this.wan.stop()]);\n  }\n  /**\n   * Store the given key/value pair in the DHT\n   */\n\n\n  async *put(key, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for await (const event of merge(this.lan.put(key, value, options), this.wan.put(key, value, options))) {\n      yield event;\n    }\n  }\n  /**\n   * Get the value that corresponds to the passed key\n   */\n\n\n  async *get(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let queriedPeers = false;\n    let foundValue = false;\n\n    for await (const event of merge(this.lan.get(key, options), this.wan.get(key, options))) {\n      yield event;\n\n      if (event.name === 'DIALING_PEER') {\n        queriedPeers = true;\n      }\n\n      if (event.name === 'VALUE') {\n        queriedPeers = true;\n\n        if (event.value != null) {\n          foundValue = true;\n        }\n      }\n\n      if (event.name === 'SENDING_QUERY') {\n        queriedPeers = true;\n      }\n    }\n\n    if (!queriedPeers) {\n      throw new CodeError('No peers found in routing table!', 'ERR_NO_PEERS_IN_ROUTING_TABLE');\n    }\n\n    if (!foundValue) {\n      yield queryErrorEvent({\n        from: this.components.peerId,\n        error: new CodeError('Not found', 'ERR_NOT_FOUND')\n      });\n    }\n  } // ----------- Content Routing\n\n  /**\n   * Announce to the network that we can provide given key's value\n   */\n\n\n  async *provide(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let sent = 0;\n    let success = 0;\n    const errors = [];\n    const dhts = [this.lan]; // only run provide on the wan if we are in server mode\n\n    if ((await this.wan.getMode()) === 'server') {\n      dhts.push(this.wan);\n    }\n\n    for await (const event of merge(...dhts.map(dht => dht.provide(key, options)))) {\n      yield event;\n\n      if (event.name === 'SENDING_QUERY') {\n        sent++;\n      }\n\n      if (event.name === 'QUERY_ERROR') {\n        errors.push(event.error);\n      }\n\n      if (event.name === 'PEER_RESPONSE' && event.messageName === 'ADD_PROVIDER') {\n        log('sent provider record for %s to %p', key, event.from);\n        success++;\n      }\n    }\n\n    if (success === 0) {\n      if (errors.length > 0) {\n        // if all sends failed, throw an error to inform the caller\n        throw new CodeError(`Failed to provide to ${errors.length} of ${sent} peers`, 'ERR_PROVIDES_FAILED', {\n          errors\n        });\n      }\n\n      throw new CodeError('Failed to provide - no peers found', 'ERR_PROVIDES_FAILED');\n    }\n  }\n  /**\n   * Search the dht for up to `K` providers of the given CID\n   */\n\n\n  async *findProviders(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* merge(this.lan.findProviders(key, options), this.wan.findProviders(key, options));\n  } // ----------- Peer Routing -----------\n\n  /**\n   * Search for a peer with the given ID\n   */\n\n\n  async *findPeer(id) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let queriedPeers = false;\n\n    for await (const event of merge(this.lan.findPeer(id, options), this.wan.findPeer(id, options))) {\n      yield event;\n\n      if (event.name === 'SENDING_QUERY' || event.name === 'FINAL_PEER') {\n        queriedPeers = true;\n      }\n    }\n\n    if (!queriedPeers) {\n      throw new CodeError('Peer lookup failed', 'ERR_LOOKUP_FAILED');\n    }\n  }\n  /**\n   * Kademlia 'node lookup' operation\n   */\n\n\n  async *getClosestPeers(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* merge(this.lan.getClosestPeers(key, options), this.wan.getClosestPeers(key, options));\n  }\n\n  async refreshRoutingTable() {\n    await Promise.all([this.lan.refreshRoutingTable(), this.wan.refreshRoutingTable()]);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","CodeError","merge","queryErrorEvent","EventEmitter","CustomEvent","symbol","log","DualKadDHT","constructor","components","wan","lan","addEventListener","evt","dispatchEvent","detail","Symbol","toStringTag","isStarted","getMode","setMode","mode","start","Promise","all","stop","put","key","value","options","event","get","queriedPeers","foundValue","name","from","peerId","error","provide","sent","success","errors","dhts","push","map","dht","messageName","length","findProviders","findPeer","id","getClosestPeers","refreshRoutingTable"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\dual-kad-dht.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport merge from 'it-merge'\nimport { queryErrorEvent } from './query/events.js'\nimport type { KadDHT } from './kad-dht.js'\nimport type { DualDHT, QueryEvent, QueryOptions } from '@libp2p/interface-dht'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events'\nimport type { CID } from 'multiformats'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { PeerDiscoveryEvents } from '@libp2p/interface-peer-discovery'\nimport { symbol } from '@libp2p/interface-peer-discovery'\nimport type { KadDHTComponents } from './index.js'\n\nconst log = logger('libp2p:kad-dht')\n\n/**\n * A DHT implementation modelled after Kademlia with S/Kademlia modifications.\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\nexport class DualKadDHT extends EventEmitter<PeerDiscoveryEvents> implements DualDHT {\n  public readonly wan: KadDHT\n  public readonly lan: KadDHT\n  public readonly components: KadDHTComponents\n\n  constructor (components: KadDHTComponents, wan: KadDHT, lan: KadDHT) {\n    super()\n\n    this.components = components\n    this.wan = wan\n    this.lan = lan\n\n    // handle peers being discovered during processing of DHT messages\n    this.wan.addEventListener('peer', (evt) => {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: evt.detail\n      }))\n    })\n    this.lan.addEventListener('peer', (evt) => {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: evt.detail\n      }))\n    })\n  }\n\n  get [symbol] (): true {\n    return true\n  }\n\n  get [Symbol.toStringTag] (): '@libp2p/dual-kad-dht' {\n    return '@libp2p/dual-kad-dht'\n  }\n\n  /**\n   * Is this DHT running.\n   */\n  isStarted (): boolean {\n    return this.wan.isStarted() && this.lan.isStarted()\n  }\n\n  /**\n   * If 'server' this node will respond to DHT queries, if 'client' this node will not\n   */\n  async getMode (): Promise<'client' | 'server'> {\n    return await this.wan.getMode()\n  }\n\n  /**\n   * If 'server' this node will respond to DHT queries, if 'client' this node will not\n   */\n  async setMode (mode: 'client' | 'server'): Promise<void> {\n    await this.wan.setMode(mode)\n  }\n\n  /**\n   * Start listening to incoming connections.\n   */\n  async start (): Promise<void> {\n    await Promise.all([\n      this.lan.start(),\n      this.wan.start()\n    ])\n  }\n\n  /**\n   * Stop accepting incoming connections and sending outgoing\n   * messages.\n   */\n  async stop (): Promise<void> {\n    await Promise.all([\n      this.lan.stop(),\n      this.wan.stop()\n    ])\n  }\n\n  /**\n   * Store the given key/value pair in the DHT\n   */\n  async * put (key: Uint8Array, value: Uint8Array, options: QueryOptions = {}): AsyncGenerator<QueryEvent> {\n    for await (const event of merge(\n      this.lan.put(key, value, options),\n      this.wan.put(key, value, options)\n    )) {\n      yield event\n    }\n  }\n\n  /**\n   * Get the value that corresponds to the passed key\n   */\n  async * get (key: Uint8Array, options: QueryOptions = {}): AsyncGenerator<QueryEvent> {\n    let queriedPeers = false\n    let foundValue = false\n\n    for await (const event of merge(\n      this.lan.get(key, options),\n      this.wan.get(key, options)\n    )) {\n      yield event\n\n      if (event.name === 'DIALING_PEER') {\n        queriedPeers = true\n      }\n\n      if (event.name === 'VALUE') {\n        queriedPeers = true\n\n        if (event.value != null) {\n          foundValue = true\n        }\n      }\n\n      if (event.name === 'SENDING_QUERY') {\n        queriedPeers = true\n      }\n    }\n\n    if (!queriedPeers) {\n      throw new CodeError('No peers found in routing table!', 'ERR_NO_PEERS_IN_ROUTING_TABLE')\n    }\n\n    if (!foundValue) {\n      yield queryErrorEvent({\n        from: this.components.peerId,\n        error: new CodeError('Not found', 'ERR_NOT_FOUND')\n      })\n    }\n  }\n\n  // ----------- Content Routing\n\n  /**\n   * Announce to the network that we can provide given key's value\n   */\n  async * provide (key: CID, options: AbortOptions = {}): AsyncGenerator<QueryEvent> {\n    let sent = 0\n    let success = 0\n    const errors = []\n\n    const dhts = [this.lan]\n\n    // only run provide on the wan if we are in server mode\n    if ((await this.wan.getMode()) === 'server') {\n      dhts.push(this.wan)\n    }\n\n    for await (const event of merge(...dhts.map(dht => dht.provide(key, options)))) {\n      yield event\n\n      if (event.name === 'SENDING_QUERY') {\n        sent++\n      }\n\n      if (event.name === 'QUERY_ERROR') {\n        errors.push(event.error)\n      }\n\n      if (event.name === 'PEER_RESPONSE' && event.messageName === 'ADD_PROVIDER') {\n        log('sent provider record for %s to %p', key, event.from)\n        success++\n      }\n    }\n\n    if (success === 0) {\n      if (errors.length > 0) {\n        // if all sends failed, throw an error to inform the caller\n        throw new CodeError(`Failed to provide to ${errors.length} of ${sent} peers`, 'ERR_PROVIDES_FAILED', { errors })\n      }\n\n      throw new CodeError('Failed to provide - no peers found', 'ERR_PROVIDES_FAILED')\n    }\n  }\n\n  /**\n   * Search the dht for up to `K` providers of the given CID\n   */\n  async * findProviders (key: CID, options: QueryOptions = {}): AsyncGenerator<QueryEvent, void, undefined> {\n    yield * merge(\n      this.lan.findProviders(key, options),\n      this.wan.findProviders(key, options)\n    )\n  }\n\n  // ----------- Peer Routing -----------\n\n  /**\n   * Search for a peer with the given ID\n   */\n  async * findPeer (id: PeerId, options: QueryOptions = {}): AsyncGenerator<QueryEvent> {\n    let queriedPeers = false\n\n    for await (const event of merge(\n      this.lan.findPeer(id, options),\n      this.wan.findPeer(id, options)\n    )) {\n      yield event\n\n      if (event.name === 'SENDING_QUERY' || event.name === 'FINAL_PEER') {\n        queriedPeers = true\n      }\n    }\n\n    if (!queriedPeers) {\n      throw new CodeError('Peer lookup failed', 'ERR_LOOKUP_FAILED')\n    }\n  }\n\n  /**\n   * Kademlia 'node lookup' operation\n   */\n  async * getClosestPeers (key: Uint8Array, options: QueryOptions = {}): AsyncGenerator<QueryEvent, void, undefined> {\n    yield * merge(\n      this.lan.getClosestPeers(key, options),\n      this.wan.getClosestPeers(key, options)\n    )\n  }\n\n  async refreshRoutingTable (): Promise<void> {\n    await Promise.all([\n      this.lan.refreshRoutingTable(),\n      this.wan.refreshRoutingTable()\n    ])\n  }\n}\n"]},"metadata":{},"sourceType":"module"}