{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { createRepo } from 'ipfs-core-config/repo';\nimport getDefaultConfig from 'ipfs-core-config/config';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { isPeerId } from '@libp2p/interface-peer-id';\nimport mergeOpts from 'merge-options';\nimport { profiles as configProfiles } from './config/profiles.js';\nimport { NotEnabledError, NotInitializedError } from '../errors.js';\nimport { createLibp2p } from './libp2p.js';\nimport { ERR_REPO_NOT_INITIALIZED } from 'ipfs-repo/errors';\nimport { createEd25519PeerId, createRSAPeerId } from '@libp2p/peer-id-factory';\nimport errCode from 'err-code';\nimport { unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport { Key } from 'interface-datastore/key';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nconst log = logger('ipfs:components:peer:storage');\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('@libp2p/crypto/keys').KeyTypes} KeyType\n * @typedef {import('@libp2p/interface-keychain').KeyChain} Keychain\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nexport class Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor(peerId, keychain, repo, print, isNew) {\n    this.print = print;\n    this.peerId = peerId;\n    this.keychain = keychain;\n    this.repo = repo;\n    this.print = print;\n    this.isNew = isNew;\n  }\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n   * @param {IPFSOptions} options\n   */\n\n\n  static async start(print, codecs, options) {\n    const {\n      repoAutoMigrate,\n      repo: inputRepo,\n      onMigrationProgress\n    } = options;\n    const repo = typeof inputRepo === 'string' || inputRepo == null ? createRepo(print, codecs, {\n      path: inputRepo,\n      autoMigrate: repoAutoMigrate,\n      onMigrationProgress: onMigrationProgress\n    }) : inputRepo;\n    const {\n      peerId,\n      keychain,\n      isNew\n    } = await loadRepo(print, repo, options); // TODO: throw error?\n    // @ts-expect-error On start, keychain will always be available\n\n    return new Storage(peerId, keychain, repo, print, isNew);\n  }\n\n}\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\n\nconst loadRepo = async (print, repo, options) => {\n  if (!repo.closed) {\n    return { ...(await configureRepo(repo, options)),\n      isNew: false\n    };\n  }\n\n  try {\n    await repo.open();\n    return { ...(await configureRepo(repo, options)),\n      isNew: false\n    };\n  } catch (\n  /** @type {any} */\n  err) {\n    if (err.code !== ERR_REPO_NOT_INITIALIZED) {\n      throw err;\n    }\n\n    if (options.init && options.init.allowNew === false) {\n      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it');\n    }\n\n    return { ...(await initRepo(print, repo, options)),\n      isNew: true\n    };\n  }\n};\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nconst initRepo = async (print, repo, options) => {\n  const initOptions = options.init || {}; // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n\n  const exists = await repo.exists();\n  log('repo exists?', exists);\n\n  if (exists === true) {\n    throw new Error('repo already exists');\n  } // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.\n\n\n  const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);\n  const identity = peerIdToIdentity(peerId);\n  log('peer identity: %s', identity.PeerID); // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n\n  const config = { ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),\n    Identity: identity\n  };\n  await repo.init(config); // 4. Open initialized repo.\n\n  await repo.open();\n  log('repo opened');\n  /** @type {import('./libp2p').KeychainConfig} */\n\n  const keychainConfig = {\n    pass: options.pass\n  };\n\n  try {\n    keychainConfig.dek = await repo.config.get('Keychain.DEK');\n  } catch (\n  /** @type {any} */\n  err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err;\n    }\n  } // Create libp2p for Keychain creation\n\n\n  const libp2p = await createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig\n  });\n\n  if (!(await repo.datastore.has(new Key('/info/self')))) {\n    await libp2p.keychain.importPeer('self', peerId);\n  }\n\n  await repo.config.set('Keychain', {\n    // @ts-expect-error private field\n    DEK: libp2p.keychain.init.dek\n  });\n  return {\n    peerId,\n    keychain: libp2p.keychain\n  };\n};\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>}\n */\n\n\nconst decodePeerId = async peerId => {\n  log('using user-supplied private-key');\n\n  if (isPeerId(peerId)) {\n    return peerId;\n  }\n\n  const rawPrivateKey = uint8ArrayFromString(peerId, 'base64pad');\n  const key = await unmarshalPrivateKey(rawPrivateKey);\n  return await peerIdFromKeys(key.public.bytes, key.bytes);\n};\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\n\n\nconst initPeerId = (print, _ref) => {\n  let {\n    algorithm = 'Ed25519',\n    bits = 2048\n  } = _ref;\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm);\n\n  if (algorithm === 'Ed25519') {\n    return createEd25519PeerId();\n  }\n\n  if (algorithm === 'RSA') {\n    return createRSAPeerId({\n      bits\n    });\n  }\n\n  throw errCode(new Error('Unknown PeerId algorithm'), 'ERR_UNKNOWN_PEER_ID_ALGORITHM');\n};\n/**\n * @param {PeerId} peerId\n */\n\n\nconst peerIdToIdentity = peerId => {\n  if (peerId.privateKey == null) {\n    throw errCode(new Error('Private key missing'), 'ERR_MISSING_PRIVATE_KEY');\n  }\n\n  return {\n    PeerID: peerId.toString(),\n\n    /** @type {string} */\n    PrivKey: uint8ArrayToString(peerId.privateKey, 'base64pad')\n  };\n};\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nconst configureRepo = async (repo, options) => {\n  const config = options.config;\n  const profiles = options.init && options.init.profiles || [];\n  const pass = options.pass;\n  const original = await repo.config.getAll();\n  const changed = mergeConfigs(applyProfiles(original, profiles), config);\n\n  if (original !== changed) {\n    await repo.config.replace(changed);\n  }\n\n  if (!changed.Identity || !changed.Identity.PrivKey) {\n    throw new NotInitializedError('No private key was found in the config, please intialize the repo');\n  }\n\n  const buf = uint8ArrayFromString(changed.Identity.PrivKey, 'base64pad');\n  const key = await unmarshalPrivateKey(buf);\n  const peerId = await peerIdFromKeys(key.public.bytes, key.bytes);\n  const libp2p = await createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  });\n  return {\n    peerId,\n    keychain: libp2p.keychain\n  };\n};\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\n\n\nconst mergeConfigs = (config, changes) => changes ? mergeOptions(config, changes) : config;\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\n\n\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configProfiles[name];\n\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`);\n    }\n\n    log('applying profile %s', name);\n    return profile.transform(config);\n  }, config);\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/storage.js"],"names":["logger","createRepo","getDefaultConfig","fromString","uint8ArrayFromString","toString","uint8ArrayToString","peerIdFromKeys","isPeerId","mergeOpts","profiles","configProfiles","NotEnabledError","NotInitializedError","createLibp2p","ERR_REPO_NOT_INITIALIZED","createEd25519PeerId","createRSAPeerId","errCode","unmarshalPrivateKey","Key","mergeOptions","bind","ignoreUndefined","log","Storage","constructor","peerId","keychain","repo","print","isNew","start","codecs","options","repoAutoMigrate","inputRepo","onMigrationProgress","path","autoMigrate","loadRepo","closed","configureRepo","open","err","code","init","allowNew","initRepo","initOptions","exists","Error","privateKey","decodePeerId","initPeerId","identity","peerIdToIdentity","PeerID","config","applyProfiles","Identity","keychainConfig","pass","dek","get","libp2p","undefined","multiaddrs","datastore","has","importPeer","set","DEK","rawPrivateKey","key","public","bytes","algorithm","bits","PrivKey","original","getAll","changed","mergeConfigs","replace","buf","Keychain","changes","reduce","name","profile","transform"],"mappings":"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","sourcesContent":["import { logger } from '@libp2p/logger'\nimport { createRepo } from 'ipfs-core-config/repo'\nimport getDefaultConfig from 'ipfs-core-config/config'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { isPeerId } from '@libp2p/interface-peer-id'\nimport mergeOpts from 'merge-options'\nimport { profiles as configProfiles } from './config/profiles.js'\nimport { NotEnabledError, NotInitializedError } from '../errors.js'\nimport { createLibp2p } from './libp2p.js'\nimport { ERR_REPO_NOT_INITIALIZED } from 'ipfs-repo/errors'\nimport { createEd25519PeerId, createRSAPeerId } from '@libp2p/peer-id-factory'\nimport errCode from 'err-code'\nimport { unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport { Key } from 'interface-datastore/key'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('ipfs:components:peer:storage')\n\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('@libp2p/crypto/keys').KeyTypes} KeyType\n * @typedef {import('@libp2p/interface-keychain').KeyChain} Keychain\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nexport class Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor (peerId, keychain, repo, print, isNew) {\n    this.print = print\n    this.peerId = peerId\n    this.keychain = keychain\n    this.repo = repo\n    this.print = print\n    this.isNew = isNew\n  }\n\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n   * @param {IPFSOptions} options\n   */\n  static async start (print, codecs, options) {\n    const { repoAutoMigrate, repo: inputRepo, onMigrationProgress } = options\n\n    const repo = (typeof inputRepo === 'string' || inputRepo == null)\n      ? createRepo(print, codecs, {\n        path: inputRepo,\n        autoMigrate: repoAutoMigrate,\n        onMigrationProgress: onMigrationProgress\n      })\n      : inputRepo\n\n    const { peerId, keychain, isNew } = await loadRepo(print, repo, options)\n\n    // TODO: throw error?\n    // @ts-expect-error On start, keychain will always be available\n    return new Storage(peerId, keychain, repo, print, isNew)\n  }\n}\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\nconst loadRepo = async (print, repo, options) => {\n  if (!repo.closed) {\n    return { ...await configureRepo(repo, options), isNew: false }\n  }\n\n  try {\n    await repo.open()\n\n    return { ...await configureRepo(repo, options), isNew: false }\n  } catch (/** @type {any} */ err) {\n    if (err.code !== ERR_REPO_NOT_INITIALIZED) {\n      throw err\n    }\n\n    if (options.init && options.init.allowNew === false) {\n      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it')\n    }\n\n    return { ...await initRepo(print, repo, options), isNew: true }\n  }\n}\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst initRepo = async (print, repo, options) => {\n  const initOptions = options.init || {}\n\n  // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n  const exists = await repo.exists()\n  log('repo exists?', exists)\n\n  if (exists === true) {\n    throw new Error('repo already exists')\n  }\n\n  // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.\n  const peerId = initOptions.privateKey\n    ? await decodePeerId(initOptions.privateKey)\n    : await initPeerId(print, initOptions)\n\n  const identity = peerIdToIdentity(peerId)\n\n  log('peer identity: %s', identity.PeerID)\n\n  // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n  const config = {\n    ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),\n    Identity: identity\n  }\n  await repo.init(config)\n\n  // 4. Open initialized repo.\n  await repo.open()\n\n  log('repo opened')\n\n  /** @type {import('./libp2p').KeychainConfig} */\n  const keychainConfig = {\n    pass: options.pass\n  }\n\n  try {\n    keychainConfig.dek = await repo.config.get('Keychain.DEK')\n  } catch (/** @type {any} */ err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err\n    }\n  }\n\n  // Create libp2p for Keychain creation\n  const libp2p = await createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig\n  })\n\n  if (!(await repo.datastore.has(new Key('/info/self')))) {\n    await libp2p.keychain.importPeer('self', peerId)\n  }\n\n  await repo.config.set('Keychain', {\n    // @ts-expect-error private field\n    DEK: libp2p.keychain.init.dek\n  })\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>}\n */\nconst decodePeerId = async (peerId) => {\n  log('using user-supplied private-key')\n  if (isPeerId(peerId)) {\n    return peerId\n  }\n\n  const rawPrivateKey = uint8ArrayFromString(peerId, 'base64pad')\n  const key = await unmarshalPrivateKey(rawPrivateKey)\n  return await peerIdFromKeys(key.public.bytes, key.bytes)\n}\n\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\nconst initPeerId = (print, { algorithm = 'Ed25519', bits = 2048 }) => {\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm)\n\n  if (algorithm === 'Ed25519') {\n    return createEd25519PeerId()\n  }\n\n  if (algorithm === 'RSA') {\n    return createRSAPeerId({ bits })\n  }\n\n  throw errCode(new Error('Unknown PeerId algorithm'), 'ERR_UNKNOWN_PEER_ID_ALGORITHM')\n}\n\n/**\n * @param {PeerId} peerId\n */\nconst peerIdToIdentity = (peerId) => {\n  if (peerId.privateKey == null) {\n    throw errCode(new Error('Private key missing'), 'ERR_MISSING_PRIVATE_KEY')\n  }\n\n  return {\n    PeerID: peerId.toString(),\n    /** @type {string} */\n    PrivKey: uint8ArrayToString(peerId.privateKey, 'base64pad')\n  }\n}\n\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst configureRepo = async (repo, options) => {\n  const config = options.config\n  const profiles = (options.init && options.init.profiles) || []\n  const pass = options.pass\n  const original = await repo.config.getAll()\n  const changed = mergeConfigs(applyProfiles(original, profiles), config)\n\n  if (original !== changed) {\n    await repo.config.replace(changed)\n  }\n\n  if (!changed.Identity || !changed.Identity.PrivKey) {\n    throw new NotInitializedError('No private key was found in the config, please intialize the repo')\n  }\n\n  const buf = uint8ArrayFromString(changed.Identity.PrivKey, 'base64pad')\n  const key = await unmarshalPrivateKey(buf)\n  const peerId = await peerIdFromKeys(key.public.bytes, key.bytes)\n  const libp2p = await createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  })\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\nconst mergeConfigs = (config, changes) =>\n  changes ? mergeOptions(config, changes) : config\n\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configProfiles[name]\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`)\n    }\n    log('applying profile %s', name)\n    return profile.transform(config)\n  }, config)\n}\n"]},"metadata":{},"sourceType":"module"}