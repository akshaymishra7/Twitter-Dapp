{"ast":null,"code":"import { pushableV } from 'it-pushable';\nimport { abortableSource } from 'abortable-iterator';\nimport { encode } from './encode.js';\nimport { Decoder } from './decode.js';\nimport { MessageTypes, MessageTypeNames } from './message-types.js';\nimport { createStream } from './stream.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays';\nimport { logger } from '@libp2p/logger';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { RateLimiterMemory } from 'rate-limiter-flexible';\nimport { anySignal } from 'any-signal';\nconst log = logger('libp2p:mplex');\nconst MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;\nconst MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;\nconst MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4; // 4MB\n\nconst DISCONNECT_THRESHOLD = 5;\n\nfunction printMessage(msg) {\n  const output = { ...msg,\n    type: `${MessageTypeNames[msg.type]} (${msg.type})`\n  };\n\n  if (msg.type === MessageTypes.NEW_STREAM) {\n    output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());\n  }\n\n  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {\n    output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), 'base16');\n  }\n\n  return output;\n}\n\nexport class MplexStreamMuxer {\n  constructor(init) {\n    this.protocol = '/mplex/6.7.0';\n    init = init ?? {};\n    this._streamId = 0;\n    this._streams = {\n      /**\n       * Stream to ids map\n       */\n      initiators: new Map(),\n\n      /**\n       * Stream to ids map\n       */\n      receivers: new Map()\n    };\n    this._init = init;\n    /**\n     * An iterable sink\n     */\n\n    this.sink = this._createSink();\n    /**\n     * An iterable source\n     */\n\n    const source = this._createSource();\n\n    this._source = source;\n    this.source = source;\n    /**\n     * Close controller\n     */\n\n    this.closeController = new AbortController();\n    this.rateLimiter = new RateLimiterMemory({\n      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,\n      duration: 1\n    });\n  }\n  /**\n   * Returns a Map of streams and their ids\n   */\n\n\n  get streams() {\n    // Inbound and Outbound streams may have the same ids, so we need to make those unique\n    const streams = [];\n\n    for (const stream of this._streams.initiators.values()) {\n      streams.push(stream);\n    }\n\n    for (const stream of this._streams.receivers.values()) {\n      streams.push(stream);\n    }\n\n    return streams;\n  }\n  /**\n   * Initiate a new stream with the given name. If no name is\n   * provided, the id of the stream will be used.\n   */\n\n\n  newStream(name) {\n    if (this.closeController.signal.aborted) {\n      throw new Error('Muxer already closed');\n    }\n\n    const id = this._streamId++;\n    name = name == null ? id.toString() : name.toString();\n    const registry = this._streams.initiators;\n    return this._newStream({\n      id,\n      name,\n      type: 'initiator',\n      registry\n    });\n  }\n  /**\n   * Close or abort all tracked streams and stop the muxer\n   */\n\n\n  close(err) {\n    if (this.closeController.signal.aborted) return;\n\n    if (err != null) {\n      this.streams.forEach(s => {\n        s.abort(err);\n      });\n    } else {\n      this.streams.forEach(s => {\n        s.close();\n      });\n    }\n\n    this.closeController.abort();\n  }\n  /**\n   * Called whenever an inbound stream is created\n   */\n\n\n  _newReceiverStream(options) {\n    const {\n      id,\n      name\n    } = options;\n    const registry = this._streams.receivers;\n    return this._newStream({\n      id,\n      name,\n      type: 'receiver',\n      registry\n    });\n  }\n\n  _newStream(options) {\n    const {\n      id,\n      name,\n      type,\n      registry\n    } = options;\n    log('new %s stream %s', type, id);\n\n    if (type === 'initiator' && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {\n      throw new CodeError('Too many outbound streams open', 'ERR_TOO_MANY_OUTBOUND_STREAMS');\n    }\n\n    if (registry.has(id)) {\n      throw new Error(`${type} stream ${id} already exists!`);\n    }\n\n    const send = msg => {\n      if (log.enabled) {\n        log.trace('%s stream %s send', type, id, printMessage(msg));\n      }\n\n      this._source.push(msg);\n    };\n\n    const onEnd = () => {\n      log('%s stream with id %s and protocol %s ended', type, id, stream.stat.protocol);\n      registry.delete(id);\n\n      if (this._init.onStreamEnd != null) {\n        this._init.onStreamEnd(stream);\n      }\n    };\n\n    const stream = createStream({\n      id,\n      name,\n      send,\n      type,\n      onEnd,\n      maxMsgSize: this._init.maxMsgSize\n    });\n    registry.set(id, stream);\n    return stream;\n  }\n  /**\n   * Creates a sink with an abortable source. Incoming messages will\n   * also have their size restricted. All messages will be varint decoded.\n   */\n\n\n  _createSink() {\n    const sink = async source => {\n      const signal = anySignal([this.closeController.signal, this._init.signal]);\n\n      try {\n        source = abortableSource(source, signal);\n        const decoder = new Decoder(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);\n\n        for await (const chunk of source) {\n          for (const msg of decoder.write(chunk)) {\n            await this._handleIncoming(msg);\n          }\n        }\n\n        this._source.end();\n      } catch (err) {\n        log('error in sink', err);\n\n        this._source.end(err); // End the source with an error\n\n      } finally {\n        signal.clear();\n      }\n    };\n\n    return sink;\n  }\n  /**\n   * Creates a source that restricts outgoing message sizes\n   * and varint encodes them\n   */\n\n\n  _createSource() {\n    const onEnd = err => {\n      this.close(err);\n    };\n\n    const source = pushableV({\n      objectMode: true,\n      onEnd\n    });\n    return Object.assign(encode(source, this._init.minSendBytes), {\n      push: source.push,\n      end: source.end,\n      return: source.return\n    });\n  }\n\n  async _handleIncoming(message) {\n    const {\n      id,\n      type\n    } = message;\n\n    if (log.enabled) {\n      log.trace('incoming message', printMessage(message));\n    } // Create a new stream?\n\n\n    if (message.type === MessageTypes.NEW_STREAM) {\n      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {\n        log('too many inbound streams open'); // not going to allow this stream, send the reset message manually\n        // instead of setting it up just to tear it down\n\n        this._source.push({\n          id,\n          type: MessageTypes.RESET_RECEIVER\n        }); // if we've hit our stream limit, and the remote keeps trying to open\n        // more new streams, if they are doing this very quickly maybe they\n        // are attacking us and we should close the connection\n\n\n        try {\n          await this.rateLimiter.consume('new-stream', 1);\n        } catch {\n          log('rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection'); // since there's no backpressure in mplex, the only thing we can really do to protect ourselves is close the connection\n\n          this._source.end(new Error('Too many open streams'));\n\n          return;\n        }\n\n        return;\n      }\n\n      const stream = this._newReceiverStream({\n        id,\n        name: uint8ArrayToString(message.data instanceof Uint8Array ? message.data : message.data.subarray())\n      });\n\n      if (this._init.onIncomingStream != null) {\n        this._init.onIncomingStream(stream);\n      }\n\n      return;\n    }\n\n    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;\n    const stream = list.get(id);\n\n    if (stream == null) {\n      log('missing stream %s for message type %s', id, MessageTypeNames[type]);\n      return;\n    }\n\n    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;\n\n    switch (type) {\n      case MessageTypes.MESSAGE_INITIATOR:\n      case MessageTypes.MESSAGE_RECEIVER:\n        if (stream.sourceReadableLength() > maxBufferSize) {\n          // Stream buffer has got too large, reset the stream\n          this._source.push({\n            id: message.id,\n            type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR\n          }); // Inform the stream consumer they are not fast enough\n\n\n          const error = new CodeError('Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers', 'ERR_STREAM_INPUT_BUFFER_FULL');\n          stream.abort(error);\n          return;\n        } // We got data from the remote, push it into our local stream\n\n\n        stream.sourcePush(message.data);\n        break;\n\n      case MessageTypes.CLOSE_INITIATOR:\n      case MessageTypes.CLOSE_RECEIVER:\n        // We should expect no more data from the remote, stop reading\n        stream.closeRead();\n        break;\n\n      case MessageTypes.RESET_INITIATOR:\n      case MessageTypes.RESET_RECEIVER:\n        // Stop reading and writing to the stream immediately\n        stream.reset();\n        break;\n\n      default:\n        log('unknown message type %s', type);\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["pushableV","abortableSource","encode","Decoder","MessageTypes","MessageTypeNames","createStream","toString","uint8ArrayToString","logger","CodeError","RateLimiterMemory","anySignal","log","MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION","MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION","MAX_STREAM_BUFFER_SIZE","DISCONNECT_THRESHOLD","printMessage","msg","output","type","NEW_STREAM","data","Uint8Array","subarray","MESSAGE_INITIATOR","MESSAGE_RECEIVER","MplexStreamMuxer","constructor","init","_streamId","_streams","initiators","Map","receivers","_init","sink","_createSink","source","_createSource","_source","closeController","AbortController","rateLimiter","points","disconnectThreshold","duration","streams","stream","values","push","newStream","name","signal","aborted","Error","id","registry","_newStream","close","err","forEach","s","abort","_newReceiverStream","options","size","maxOutboundStreams","has","send","enabled","trace","onEnd","stat","protocol","delete","onStreamEnd","maxMsgSize","set","decoder","maxUnprocessedMessageQueueSize","chunk","write","_handleIncoming","end","clear","objectMode","Object","assign","minSendBytes","return","message","maxInboundStreams","RESET_RECEIVER","consume","onIncomingStream","list","get","maxBufferSize","maxStreamBufferSize","sourceReadableLength","RESET_INITIATOR","error","sourcePush","CLOSE_INITIATOR","CLOSE_RECEIVER","closeRead","reset"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\mplex\\src\\mplex.ts"],"sourcesContent":["import { pushableV } from 'it-pushable'\nimport { abortableSource } from 'abortable-iterator'\nimport { encode } from './encode.js'\nimport { Decoder } from './decode.js'\nimport { MessageTypes, MessageTypeNames, Message } from './message-types.js'\nimport { createStream } from './stream.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays'\nimport { logger } from '@libp2p/logger'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { RateLimiterMemory } from 'rate-limiter-flexible'\nimport type { Sink } from 'it-stream-types'\nimport type { StreamMuxer, StreamMuxerInit } from '@libp2p/interface-stream-muxer'\nimport type { Stream } from '@libp2p/interface-connection'\nimport type { MplexInit } from './index.js'\nimport { anySignal } from 'any-signal'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst log = logger('libp2p:mplex')\n\nconst MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024\nconst MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024\nconst MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4 // 4MB\nconst DISCONNECT_THRESHOLD = 5\n\nfunction printMessage (msg: Message): any {\n  const output: any = {\n    ...msg,\n    type: `${MessageTypeNames[msg.type]} (${msg.type})`\n  }\n\n  if (msg.type === MessageTypes.NEW_STREAM) {\n    output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray())\n  }\n\n  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {\n    output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), 'base16')\n  }\n\n  return output\n}\n\nexport interface MplexStream extends Stream {\n  sourceReadableLength: () => number\n  sourcePush: (data: Uint8ArrayList) => void\n}\n\ninterface MplexStreamMuxerInit extends MplexInit, StreamMuxerInit {}\n\nexport class MplexStreamMuxer implements StreamMuxer {\n  public protocol = '/mplex/6.7.0'\n\n  public sink: Sink<Uint8Array>\n  public source: AsyncIterable<Uint8Array>\n\n  private _streamId: number\n  private readonly _streams: { initiators: Map<number, MplexStream>, receivers: Map<number, MplexStream> }\n  private readonly _init: MplexStreamMuxerInit\n  private readonly _source: { push: (val: Message) => void, end: (err?: Error) => void }\n  private readonly closeController: AbortController\n  private readonly rateLimiter: RateLimiterMemory\n\n  constructor (init?: MplexStreamMuxerInit) {\n    init = init ?? {}\n\n    this._streamId = 0\n    this._streams = {\n      /**\n       * Stream to ids map\n       */\n      initiators: new Map<number, MplexStream>(),\n      /**\n       * Stream to ids map\n       */\n      receivers: new Map<number, MplexStream>()\n    }\n    this._init = init\n\n    /**\n     * An iterable sink\n     */\n    this.sink = this._createSink()\n\n    /**\n     * An iterable source\n     */\n    const source = this._createSource()\n    this._source = source\n    this.source = source\n\n    /**\n     * Close controller\n     */\n    this.closeController = new AbortController()\n\n    this.rateLimiter = new RateLimiterMemory({\n      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,\n      duration: 1\n    })\n  }\n\n  /**\n   * Returns a Map of streams and their ids\n   */\n  get streams (): Stream[] {\n    // Inbound and Outbound streams may have the same ids, so we need to make those unique\n    const streams: Stream[] = []\n    for (const stream of this._streams.initiators.values()) {\n      streams.push(stream)\n    }\n\n    for (const stream of this._streams.receivers.values()) {\n      streams.push(stream)\n    }\n    return streams\n  }\n\n  /**\n   * Initiate a new stream with the given name. If no name is\n   * provided, the id of the stream will be used.\n   */\n  newStream (name?: string): Stream {\n    if (this.closeController.signal.aborted) {\n      throw new Error('Muxer already closed')\n    }\n    const id = this._streamId++\n    name = name == null ? id.toString() : name.toString()\n    const registry = this._streams.initiators\n    return this._newStream({ id, name, type: 'initiator', registry })\n  }\n\n  /**\n   * Close or abort all tracked streams and stop the muxer\n   */\n  close (err?: Error | undefined): void {\n    if (this.closeController.signal.aborted) return\n\n    if (err != null) {\n      this.streams.forEach(s => { s.abort(err) })\n    } else {\n      this.streams.forEach(s => { s.close() })\n    }\n    this.closeController.abort()\n  }\n\n  /**\n   * Called whenever an inbound stream is created\n   */\n  _newReceiverStream (options: { id: number, name: string }): MplexStream {\n    const { id, name } = options\n    const registry = this._streams.receivers\n    return this._newStream({ id, name, type: 'receiver', registry })\n  }\n\n  _newStream (options: { id: number, name: string, type: 'initiator' | 'receiver', registry: Map<number, MplexStream> }): MplexStream {\n    const { id, name, type, registry } = options\n\n    log('new %s stream %s', type, id)\n\n    if (type === 'initiator' && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {\n      throw new CodeError('Too many outbound streams open', 'ERR_TOO_MANY_OUTBOUND_STREAMS')\n    }\n\n    if (registry.has(id)) {\n      throw new Error(`${type} stream ${id} already exists!`)\n    }\n\n    const send = (msg: Message): void => {\n      if (log.enabled) {\n        log.trace('%s stream %s send', type, id, printMessage(msg))\n      }\n\n      this._source.push(msg)\n    }\n\n    const onEnd = (): void => {\n      log('%s stream with id %s and protocol %s ended', type, id, stream.stat.protocol)\n      registry.delete(id)\n\n      if (this._init.onStreamEnd != null) {\n        this._init.onStreamEnd(stream)\n      }\n    }\n\n    const stream = createStream({ id, name, send, type, onEnd, maxMsgSize: this._init.maxMsgSize })\n    registry.set(id, stream)\n    return stream\n  }\n\n  /**\n   * Creates a sink with an abortable source. Incoming messages will\n   * also have their size restricted. All messages will be varint decoded.\n   */\n  _createSink (): Sink<Uint8Array> {\n    const sink: Sink<Uint8Array> = async source => {\n      const signal = anySignal([this.closeController.signal, this._init.signal])\n\n      try {\n        source = abortableSource(source, signal)\n\n        const decoder = new Decoder(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize)\n\n        for await (const chunk of source) {\n          for (const msg of decoder.write(chunk)) {\n            await this._handleIncoming(msg)\n          }\n        }\n\n        this._source.end()\n      } catch (err: any) {\n        log('error in sink', err)\n        this._source.end(err) // End the source with an error\n      } finally {\n        signal.clear()\n      }\n    }\n\n    return sink\n  }\n\n  /**\n   * Creates a source that restricts outgoing message sizes\n   * and varint encodes them\n   */\n  _createSource (): any {\n    const onEnd = (err?: Error): void => {\n      this.close(err)\n    }\n    const source = pushableV<Message>({\n      objectMode: true,\n      onEnd\n    })\n\n    return Object.assign(encode(source, this._init.minSendBytes), {\n      push: source.push,\n      end: source.end,\n      return: source.return\n    })\n  }\n\n  async _handleIncoming (message: Message): Promise<void> {\n    const { id, type } = message\n\n    if (log.enabled) {\n      log.trace('incoming message', printMessage(message))\n    }\n\n    // Create a new stream?\n    if (message.type === MessageTypes.NEW_STREAM) {\n      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {\n        log('too many inbound streams open')\n\n        // not going to allow this stream, send the reset message manually\n        // instead of setting it up just to tear it down\n        this._source.push({\n          id,\n          type: MessageTypes.RESET_RECEIVER\n        })\n\n        // if we've hit our stream limit, and the remote keeps trying to open\n        // more new streams, if they are doing this very quickly maybe they\n        // are attacking us and we should close the connection\n        try {\n          await this.rateLimiter.consume('new-stream', 1)\n        } catch {\n          log('rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection')\n          // since there's no backpressure in mplex, the only thing we can really do to protect ourselves is close the connection\n          this._source.end(new Error('Too many open streams'))\n          return\n        }\n\n        return\n      }\n\n      const stream = this._newReceiverStream({ id, name: uint8ArrayToString(message.data instanceof Uint8Array ? message.data : message.data.subarray()) })\n\n      if (this._init.onIncomingStream != null) {\n        this._init.onIncomingStream(stream)\n      }\n\n      return\n    }\n\n    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers\n    const stream = list.get(id)\n\n    if (stream == null) {\n      log('missing stream %s for message type %s', id, MessageTypeNames[type])\n\n      return\n    }\n\n    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE\n\n    switch (type) {\n      case MessageTypes.MESSAGE_INITIATOR:\n      case MessageTypes.MESSAGE_RECEIVER:\n        if (stream.sourceReadableLength() > maxBufferSize) {\n          // Stream buffer has got too large, reset the stream\n          this._source.push({\n            id: message.id,\n            type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR\n          })\n\n          // Inform the stream consumer they are not fast enough\n          const error = new CodeError('Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers', 'ERR_STREAM_INPUT_BUFFER_FULL')\n          stream.abort(error)\n\n          return\n        }\n\n        // We got data from the remote, push it into our local stream\n        stream.sourcePush(message.data)\n        break\n      case MessageTypes.CLOSE_INITIATOR:\n      case MessageTypes.CLOSE_RECEIVER:\n        // We should expect no more data from the remote, stop reading\n        stream.closeRead()\n        break\n      case MessageTypes.RESET_INITIATOR:\n      case MessageTypes.RESET_RECEIVER:\n        // Stop reading and writing to the stream immediately\n        stream.reset()\n        break\n      default:\n        log('unknown message type %s', type)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}