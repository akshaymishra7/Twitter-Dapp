{"ast":null,"code":"// @ts-expect-error\nimport SparseArray from 'sparse-array';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nexport class Bucket {\n  constructor(options, parent) {\n    let posAtParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._options = options;\n    this._popCount = 0;\n    this._parent = parent;\n    this._posAtParent = posAtParent;\n    this._children = new SparseArray();\n    this.key = null;\n  }\n\n  async put(key, value) {\n    const place = await this._findNewBucketAndPos(key);\n    await place.bucket._putAt(place, key, value);\n  }\n\n  async get(key) {\n    const child = await this._findChild(key);\n\n    if (child != null) {\n      return child.value;\n    }\n  }\n\n  async del(key) {\n    const place = await this._findPlace(key);\n\n    const child = place.bucket._at(place.pos);\n\n    if (child != null && child.key === key) {\n      place.bucket._delAt(place.pos);\n    }\n  }\n\n  leafCount() {\n    const children = this._children.compactArray();\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount();\n      }\n\n      return acc + 1;\n    }, 0);\n  }\n\n  childrenCount() {\n    return this._children.length;\n  }\n\n  onlyChild() {\n    return this._children.get(0);\n  }\n\n  *eachLeafSeries() {\n    const children = this._children.compactArray();\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield* child.eachLeafSeries();\n      } else {\n        yield child;\n      }\n    }\n  }\n\n  serialize(map, reduce) {\n    const acc = []; // serialize to a custom non-sparse representation\n\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child != null) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce));\n        } else {\n          acc.push(map(child, index));\n        }\n      }\n\n      return acc;\n    }, acc));\n  }\n\n  async asyncTransform(asyncMap, asyncReduce) {\n    return await asyncTransformBucket(this, asyncMap, asyncReduce);\n  }\n\n  toJSON() {\n    return this.serialize(mapNode, reduceNodes);\n  }\n\n  prettyPrint() {\n    return JSON.stringify(this.toJSON(), null, '  ');\n  }\n\n  tableSize() {\n    return Math.pow(2, this._options.bits);\n  }\n\n  async _findChild(key) {\n    const result = await this._findPlace(key);\n\n    const child = result.bucket._at(result.pos);\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined;\n    }\n\n    if (child != null && child.key === key) {\n      return child;\n    }\n  }\n\n  async _findPlace(key) {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key);\n\n    const index = await hashValue.take(this._options.bits);\n\n    const child = this._children.get(index);\n\n    if (child instanceof Bucket) {\n      return await child._findPlace(hashValue);\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    };\n  }\n\n  async _findNewBucketAndPos(key) {\n    const place = await this._findPlace(key);\n\n    if (place.existingChild != null && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos);\n\n      place.bucket._putObjectAt(place.pos, bucket); // put the previous value\n\n\n      const newPlace = await bucket._findPlace(place.existingChild.hash);\n\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);\n\n      return await bucket._findNewBucketAndPos(place.hash);\n    } // no conflict, we found the place\n\n\n    return place;\n  }\n\n  _putAt(place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    });\n  }\n\n  _putObjectAt(pos, object) {\n    if (this._children.get(pos) == null) {\n      this._popCount++;\n    }\n\n    this._children.set(pos, object);\n  }\n\n  _delAt(pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position');\n    }\n\n    if (this._children.get(pos) != null) {\n      this._popCount--;\n    }\n\n    this._children.unset(pos);\n\n    this._level();\n  }\n\n  _level() {\n    if (this._parent != null && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists);\n\n        if (onlyChild != null && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash;\n          hash.untake(this._options.bits);\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          };\n\n          this._parent._putAt(place, onlyChild.key, onlyChild.value);\n        }\n      } else {\n        this._parent._delAt(this._posAtParent);\n      }\n    }\n  }\n\n  _at(index) {\n    return this._children.get(index);\n  }\n\n}\n\nfunction exists(o) {\n  return Boolean(o);\n}\n\nfunction mapNode(node, _) {\n  return node.key;\n}\n\nfunction reduceNodes(nodes) {\n  return nodes;\n}\n\nasync function asyncTransformBucket(bucket, asyncMap, asyncReduce) {\n  const output = [];\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce);\n    } else {\n      const mappedChildren = await asyncMap(child);\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      });\n    }\n  }\n\n  return await asyncReduce(output);\n}","map":{"version":3,"mappings":"AAAA;AACA,OAAOA,WAAP,MAAwB,cAAxB;AACA,SAASC,UAAU,IAAIC,oBAAvB,QAAmD,yBAAnD;AAgCA,OAAM,MAAOC,MAAP,CAAa;AASjBC,cAAaC,OAAb,EAAqCC,MAArC,EAAwE;AAAA,QAAfC,WAAe,uEAAD,CAAC;AACtE,SAAKC,QAAL,GAAgBH,OAAhB;AACA,SAAKI,SAAL,GAAiB,CAAjB;AACA,SAAKC,OAAL,GAAeJ,MAAf;AACA,SAAKK,YAAL,GAAoBJ,WAApB;AACA,SAAKK,SAAL,GAAiB,IAAIZ,WAAJ,EAAjB;AACA,SAAKa,GAAL,GAAW,IAAX;AACD;;AAEQ,QAAHC,GAAG,CAAED,GAAF,EAAeE,KAAf,EAAuB;AAC9B,UAAMC,KAAK,GAAG,MAAM,KAAKC,oBAAL,CAA0BJ,GAA1B,CAApB;AAEA,UAAMG,KAAK,CAACE,MAAN,CAAaC,MAAb,CAAoBH,KAApB,EAA2BH,GAA3B,EAAgCE,KAAhC,CAAN;AACD;;AAEQ,QAAHK,GAAG,CAAEP,GAAF,EAAa;AACpB,UAAMQ,KAAK,GAAG,MAAM,KAAKC,UAAL,CAAgBT,GAAhB,CAApB;;AAEA,QAAIQ,KAAK,IAAI,IAAb,EAAmB;AACjB,aAAOA,KAAK,CAACN,KAAb;AACD;AACF;;AAEQ,QAAHQ,GAAG,CAAEV,GAAF,EAAa;AACpB,UAAMG,KAAK,GAAG,MAAM,KAAKQ,UAAL,CAAgBX,GAAhB,CAApB;;AACA,UAAMQ,KAAK,GAAGL,KAAK,CAACE,MAAN,CAAaO,GAAb,CAAiBT,KAAK,CAACU,GAAvB,CAAd;;AAEA,QAAIL,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAACR,GAAN,KAAcA,GAAnC,EAAwC;AACtCG,WAAK,CAACE,MAAN,CAAaS,MAAb,CAAoBX,KAAK,CAACU,GAA1B;AACD;AACF;;AAEDE,WAAS;AACP,UAAMC,QAAQ,GAAG,KAAKjB,SAAL,CAAekB,YAAf,EAAjB;;AAEA,WAAOD,QAAQ,CAACE,MAAT,CAAgB,CAACC,GAAD,EAAMX,KAAN,KAAe;AACpC,UAAIA,KAAK,YAAYlB,MAArB,EAA6B;AAC3B,eAAO6B,GAAG,GAAGX,KAAK,CAACO,SAAN,EAAb;AACD;;AAED,aAAOI,GAAG,GAAG,CAAb;AACD,KANM,EAMJ,CANI,CAAP;AAOD;;AAEDC,eAAa;AACX,WAAO,KAAKrB,SAAL,CAAesB,MAAtB;AACD;;AAEDC,WAAS;AACP,WAAO,KAAKvB,SAAL,CAAeQ,GAAf,CAAmB,CAAnB,CAAP;AACD;;AAEe,GAAdgB,cAAc;AACd,UAAMP,QAAQ,GAAG,KAAKjB,SAAL,CAAekB,YAAf,EAAjB;;AAEA,SAAK,MAAMT,KAAX,IAAoBQ,QAApB,EAA8B;AAC5B,UAAIR,KAAK,YAAYlB,MAArB,EAA6B;AAC3B,eAAQkB,KAAK,CAACe,cAAN,EAAR;AACD,OAFD,MAEO;AACL,cAAMf,KAAN;AACD;AACF;AACF;;AAEDgB,WAAS,CAAEC,GAAF,EAAoDP,MAApD,EAAiF;AACxF,UAAMC,GAAG,GAAQ,EAAjB,CADwF,CAExF;;AACA,WAAOD,MAAM,CAAC,KAAKnB,SAAL,CAAemB,MAAf,CAAsB,CAACC,GAAD,EAAMX,KAAN,EAAakB,KAAb,KAAsB;AACxD,UAAIlB,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAIA,KAAK,YAAYlB,MAArB,EAA6B;AAC3B6B,aAAG,CAACQ,IAAJ,CAASnB,KAAK,CAACgB,SAAN,CAAgBC,GAAhB,EAAqBP,MAArB,CAAT;AACD,SAFD,MAEO;AACLC,aAAG,CAACQ,IAAJ,CAASF,GAAG,CAACjB,KAAD,EAAQkB,KAAR,CAAZ;AACD;AACF;;AACD,aAAOP,GAAP;AACD,KATa,EASXA,GATW,CAAD,CAAb;AAUD;;AAEmB,QAAdS,cAAc,CAAEC,QAAF,EAAqDC,WAArD,EAAgG;AAClH,WAAO,MAAMC,oBAAoB,CAAC,IAAD,EAAOF,QAAP,EAAiBC,WAAjB,CAAjC;AACD;;AAEDE,QAAM;AACJ,WAAO,KAAKR,SAAL,CAAeS,OAAf,EAAwBC,WAAxB,CAAP;AACD;;AAEDC,aAAW;AACT,WAAOC,IAAI,CAACC,SAAL,CAAe,KAAKL,MAAL,EAAf,EAA8B,IAA9B,EAAoC,IAApC,CAAP;AACD;;AAEDM,WAAS;AACP,WAAOC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,KAAK7C,QAAL,CAAc8C,IAA1B,CAAP;AACD;;AAEe,QAAVhC,UAAU,CAAET,GAAF,EAAa;AAC3B,UAAM0C,MAAM,GAAG,MAAM,KAAK/B,UAAL,CAAgBX,GAAhB,CAArB;;AACA,UAAMQ,KAAK,GAAGkC,MAAM,CAACrC,MAAP,CAAcO,GAAd,CAAkB8B,MAAM,CAAC7B,GAAzB,CAAd;;AAEA,QAAIL,KAAK,YAAYlB,MAArB,EAA6B;AAC3B;AACA;AACA,aAAOqD,SAAP;AACD;;AAED,QAAInC,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAACR,GAAN,KAAcA,GAAnC,EAAwC;AACtC,aAAOQ,KAAP;AACD;AACF;;AAEe,QAAVG,UAAU,CAAEX,GAAF,EAA4B;AAC1C,UAAM4C,SAAS,GAAG,KAAKjD,QAAL,CAAckD,IAAd,CAAmB,OAAO7C,GAAP,KAAe,QAAf,GAA0BX,oBAAoB,CAACW,GAAD,CAA9C,GAAsDA,GAAzE,CAAlB;;AACA,UAAM0B,KAAK,GAAG,MAAMkB,SAAS,CAACE,IAAV,CAAe,KAAKnD,QAAL,CAAc8C,IAA7B,CAApB;;AAEA,UAAMjC,KAAK,GAAG,KAAKT,SAAL,CAAeQ,GAAf,CAAmBmB,KAAnB,CAAd;;AAEA,QAAIlB,KAAK,YAAYlB,MAArB,EAA6B;AAC3B,aAAO,MAAMkB,KAAK,CAACG,UAAN,CAAiBiC,SAAjB,CAAb;AACD;;AAED,WAAO;AACLvC,YAAM,EAAE,IADH;AAELQ,SAAG,EAAEa,KAFA;AAGLmB,UAAI,EAAED,SAHD;AAILG,mBAAa,EAAEvC;AAJV,KAAP;AAMD;;AAEyB,QAApBJ,oBAAoB,CAAEJ,GAAF,EAA4B;AACpD,UAAMG,KAAK,GAAG,MAAM,KAAKQ,UAAL,CAAgBX,GAAhB,CAApB;;AAEA,QAAKG,KAAK,CAAC4C,aAAN,IAAuB,IAAxB,IAAiC5C,KAAK,CAAC4C,aAAN,CAAoB/C,GAApB,KAA4BA,GAAjE,EAAsE;AACpE;AACA,YAAMK,MAAM,GAAG,IAAIf,MAAJ,CAAW,KAAKK,QAAhB,EAA0BQ,KAAK,CAACE,MAAhC,EAAwCF,KAAK,CAACU,GAA9C,CAAf;;AACAV,WAAK,CAACE,MAAN,CAAa2C,YAAb,CAA0B7C,KAAK,CAACU,GAAhC,EAAqCR,MAArC,EAHoE,CAKpE;;;AACA,YAAM4C,QAAQ,GAAG,MAAM5C,MAAM,CAACM,UAAP,CAAkBR,KAAK,CAAC4C,aAAN,CAAoBF,IAAtC,CAAvB;;AACAI,cAAQ,CAAC5C,MAAT,CAAgBC,MAAhB,CAAuB2C,QAAvB,EAAiC9C,KAAK,CAAC4C,aAAN,CAAoB/C,GAArD,EAA0DG,KAAK,CAAC4C,aAAN,CAAoB7C,KAA9E;;AAEA,aAAO,MAAMG,MAAM,CAACD,oBAAP,CAA4BD,KAAK,CAAC0C,IAAlC,CAAb;AACD,KAbmD,CAepD;;;AACA,WAAO1C,KAAP;AACD;;AAEDG,QAAM,CAAEH,KAAF,EAA4BH,GAA5B,EAAyCE,KAAzC,EAAiD;AACrD,SAAK8C,YAAL,CAAkB7C,KAAK,CAACU,GAAxB,EAA6B;AAC3Bb,SAAG,EAAEA,GADsB;AAE3BE,WAAK,EAAEA,KAFoB;AAG3B2C,UAAI,EAAE1C,KAAK,CAAC0C;AAHe,KAA7B;AAKD;;AAEDG,cAAY,CAAEnC,GAAF,EAAeqC,MAAf,EAAiD;AAC3D,QAAI,KAAKnD,SAAL,CAAeQ,GAAf,CAAmBM,GAAnB,KAA2B,IAA/B,EAAqC;AACnC,WAAKjB,SAAL;AACD;;AACD,SAAKG,SAAL,CAAeoD,GAAf,CAAmBtC,GAAnB,EAAwBqC,MAAxB;AACD;;AAEDpC,QAAM,CAAED,GAAF,EAAa;AACjB,QAAIA,GAAG,KAAK,CAAC,CAAb,EAAgB;AACd,YAAM,IAAIuC,KAAJ,CAAU,kBAAV,CAAN;AACD;;AAED,QAAI,KAAKrD,SAAL,CAAeQ,GAAf,CAAmBM,GAAnB,KAA2B,IAA/B,EAAqC;AACnC,WAAKjB,SAAL;AACD;;AACD,SAAKG,SAAL,CAAesD,KAAf,CAAqBxC,GAArB;;AACA,SAAKyC,MAAL;AACD;;AAEDA,QAAM;AACJ,QAAI,KAAKzD,OAAL,IAAgB,IAAhB,IAAwB,KAAKD,SAAL,IAAkB,CAA9C,EAAiD;AAC/C,UAAI,KAAKA,SAAL,KAAmB,CAAvB,EAA0B;AACxB;AACA,cAAM0B,SAAS,GAAG,KAAKvB,SAAL,CAAewD,IAAf,CAAoBC,MAApB,CAAlB;;AAEA,YAAKlC,SAAS,IAAI,IAAd,IAAuB,EAAEA,SAAS,YAAYhC,MAAvB,CAA3B,EAA2D;AACzD,gBAAMuD,IAAI,GAAGvB,SAAS,CAACuB,IAAvB;AACAA,cAAI,CAACY,MAAL,CAAY,KAAK9D,QAAL,CAAc8C,IAA1B;AACA,gBAAMtC,KAAK,GAAG;AACZU,eAAG,EAAE,KAAKf,YADE;AAEZ+C,gBAAI,EAAEA,IAFM;AAGZxC,kBAAM,EAAE,KAAKR;AAHD,WAAd;;AAKA,eAAKA,OAAL,CAAaS,MAAb,CAAoBH,KAApB,EAA2BmB,SAAS,CAACtB,GAArC,EAA0CsB,SAAS,CAACpB,KAApD;AACD;AACF,OAdD,MAcO;AACL,aAAKL,OAAL,CAAaiB,MAAb,CAAoB,KAAKhB,YAAzB;AACD;AACF;AACF;;AAEDc,KAAG,CAAEc,KAAF,EAAe;AAChB,WAAO,KAAK3B,SAAL,CAAeQ,GAAf,CAAmBmB,KAAnB,CAAP;AACD;;AA/MgB;;AAkNnB,SAAS8B,MAAT,CAAiBE,CAAjB,EAAuB;AACrB,SAAOC,OAAO,CAACD,CAAD,CAAd;AACD;;AAED,SAASzB,OAAT,CAAkB2B,IAAlB,EAA6BC,CAA7B,EAAsC;AACpC,SAAOD,IAAI,CAAC5D,GAAZ;AACD;;AAED,SAASkC,WAAT,CAAsB4B,KAAtB,EAAgC;AAC9B,SAAOA,KAAP;AACD;;AAED,eAAe/B,oBAAf,CAAwC1B,MAAxC,EAA2DwB,QAA3D,EAA8GC,WAA9G,EAAyJ;AACvJ,QAAMiC,MAAM,GAAG,EAAf;;AAEA,OAAK,MAAMvD,KAAX,IAAoBH,MAAM,CAACN,SAAP,CAAiBkB,YAAjB,EAApB,EAAqD;AACnD,QAAIT,KAAK,YAAYlB,MAArB,EAA6B;AAC3B,YAAMyC,oBAAoB,CAACvB,KAAD,EAAQqB,QAAR,EAAkBC,WAAlB,CAA1B;AACD,KAFD,MAEO;AACL,YAAMkC,cAAc,GAAG,MAAMnC,QAAQ,CAACrB,KAAD,CAArC;AAEAuD,YAAM,CAACpC,IAAP,CAAY;AACVsC,gBAAQ,EAAE5D,MAAM,CAACN,SAAP,CAAiBkE,QAAjB,EADA;AAEVjD,gBAAQ,EAAEgD;AAFA,OAAZ;AAID;AACF;;AAED,SAAO,MAAMlC,WAAW,CAACiC,MAAD,CAAxB;AACD","names":["SparseArray","fromString","uint8ArrayFromString","Bucket","constructor","options","parent","posAtParent","_options","_popCount","_parent","_posAtParent","_children","key","put","value","place","_findNewBucketAndPos","bucket","_putAt","get","child","_findChild","del","_findPlace","_at","pos","_delAt","leafCount","children","compactArray","reduce","acc","childrenCount","length","onlyChild","eachLeafSeries","serialize","map","index","push","asyncTransform","asyncMap","asyncReduce","asyncTransformBucket","toJSON","mapNode","reduceNodes","prettyPrint","JSON","stringify","tableSize","Math","pow","bits","result","undefined","hashValue","hash","take","existingChild","_putObjectAt","newPlace","object","set","Error","unset","_level","find","exists","untake","o","Boolean","node","_","nodes","output","mappedChildren","bitField"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\hamt-sharding\\src\\bucket.ts"],"sourcesContent":["// @ts-expect-error\nimport SparseArray from 'sparse-array'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { InfiniteHash } from './consumable-hash.js'\n\nexport interface BucketChild<V> {\n  key: string\n  value: V\n  hash: InfiniteHash\n}\n\ninterface SA<B> {\n  length: number\n  compactArray: () => B[]\n  get: (i: number) => B\n  set: (i: number, value: B) => void\n  reduce: <A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B\n  find: (fn: (item: B) => boolean) => B | undefined\n  bitField: () => number[]\n  unset: (i: number) => void\n}\n\nexport interface BucketPosition<T> {\n  bucket: Bucket<T>\n  pos: number\n  hash: InfiniteHash\n  existingChild?: BucketChild<T>\n}\n\nexport interface BucketOptions {\n  bits: number\n  hash: (value: Uint8Array | InfiniteHash) => InfiniteHash\n}\n\nexport class Bucket<T> {\n  _options: BucketOptions\n  _popCount: number\n  _parent?: Bucket<T>\n  _posAtParent: number\n  _children: SA<Bucket<T> | BucketChild<T>>\n\n  key: string | null\n\n  constructor (options: BucketOptions, parent?: Bucket<T>, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n    this._children = new SparseArray()\n    this.key = null\n  }\n\n  async put (key: string, value: T) {\n    const place = await this._findNewBucketAndPos(key)\n\n    await place.bucket._putAt(place, key, value)\n  }\n\n  async get (key: string) {\n    const child = await this._findChild(key)\n\n    if (child != null) {\n      return child.value\n    }\n  }\n\n  async del (key: string) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child != null && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  leafCount (): number {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount () {\n    return this._children.length\n  }\n\n  onlyChild () {\n    return this._children.get(0)\n  }\n\n  * eachLeafSeries (): Iterable<BucketChild<T>> {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n  }\n\n  serialize (map: (value: BucketChild<T>, index: number) => T, reduce: (reduced: any) => any) {\n    const acc: T[] = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child != null) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  async asyncTransform (asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<any>) {\n    return await asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON () {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint () {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize () {\n    return Math.pow(2, this._options.bits)\n  }\n\n  async _findChild (key: string) {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child != null && child.key === key) {\n      return child\n    }\n  }\n\n  async _findPlace (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return await child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  async _findNewBucketAndPos (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const place = await this._findPlace(key)\n\n    if ((place.existingChild != null) && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return await bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  _putAt (place: BucketPosition<T>, key: string, value: T) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    })\n  }\n\n  _putObjectAt (pos: number, object: Bucket<T> | BucketChild<T>) {\n    if (this._children.get(pos) == null) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  _delAt (pos: number) {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos) != null) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level () {\n    if (this._parent != null && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if ((onlyChild != null) && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  _at (index: number) {\n    return this._children.get(index)\n  }\n}\n\nfunction exists (o: any) {\n  return Boolean(o)\n}\n\nfunction mapNode (node: any, _: number) {\n  return node.key\n}\n\nfunction reduceNodes (nodes: any) {\n  return nodes\n}\n\nasync function asyncTransformBucket<T> (bucket: Bucket<T>, asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<any>) {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return await asyncReduce(output)\n}\n"]},"metadata":{},"sourceType":"module"}