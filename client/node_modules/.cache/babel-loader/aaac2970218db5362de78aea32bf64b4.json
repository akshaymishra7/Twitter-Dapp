{"ast":null,"code":"import varint from 'varint';\nimport { encode as dagCborEncode } from '@ipld/dag-cbor';\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./coding').CarEncoder} CarEncoder\n * @typedef {import('./coding').IteratorChannel_Writer<Uint8Array>} IteratorChannel_Writer\n */\n\n/**\n * Create a header from an array of roots.\n *\n * @param {CID[]} roots\n * @returns {Uint8Array}\n */\n\nexport function createHeader(roots) {\n  const headerBytes = dagCborEncode({\n    version: 1,\n    roots\n  });\n  const varintBytes = varint.encode(headerBytes.length);\n  const header = new Uint8Array(varintBytes.length + headerBytes.length);\n  header.set(varintBytes, 0);\n  header.set(headerBytes, varintBytes.length);\n  return header;\n}\n/**\n * @param {IteratorChannel_Writer} writer\n * @returns {CarEncoder}\n */\n\nfunction createEncoder(writer) {\n  // none of this is wrapped in a mutex, that needs to happen above this to\n  // avoid overwrites\n  return {\n    /**\n     * @param {CID[]} roots\n     * @returns {Promise<void>}\n     */\n    async setRoots(roots) {\n      const bytes = createHeader(roots);\n      await writer.write(bytes);\n    },\n\n    /**\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n    async writeBlock(block) {\n      const {\n        cid,\n        bytes\n      } = block;\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)));\n      await writer.write(cid.bytes);\n\n      if (bytes.length) {\n        // zero-length blocks are valid, but it'd be safer if we didn't write them\n        await writer.write(bytes);\n      }\n    },\n\n    /**\n     * @returns {Promise<void>}\n     */\n    async close() {\n      await writer.end();\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    }\n\n  };\n}\n\nexport { createEncoder };","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/@ipld/car/src/encoder.js"],"names":["varint","encode","dagCborEncode","createHeader","roots","headerBytes","version","varintBytes","length","header","Uint8Array","set","createEncoder","writer","setRoots","bytes","write","writeBlock","block","cid","close","end"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,SAASC,MAAM,IAAIC,aAAnB,QAAwC,gBAAxC;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,YAAT,CAAuBC,KAAvB,EAA8B;AACnC,QAAMC,WAAW,GAAGH,aAAa,CAAC;AAAEI,IAAAA,OAAO,EAAE,CAAX;AAAcF,IAAAA;AAAd,GAAD,CAAjC;AACA,QAAMG,WAAW,GAAGP,MAAM,CAACC,MAAP,CAAcI,WAAW,CAACG,MAA1B,CAApB;AACA,QAAMC,MAAM,GAAG,IAAIC,UAAJ,CAAeH,WAAW,CAACC,MAAZ,GAAqBH,WAAW,CAACG,MAAhD,CAAf;AACAC,EAAAA,MAAM,CAACE,GAAP,CAAWJ,WAAX,EAAwB,CAAxB;AACAE,EAAAA,MAAM,CAACE,GAAP,CAAWN,WAAX,EAAwBE,WAAW,CAACC,MAApC;AACA,SAAOC,MAAP;AACD;AAED;AACA;AACA;AACA;;AACA,SAASG,aAAT,CAAwBC,MAAxB,EAAgC;AAC9B;AACA;AAEA,SAAO;AACL;AACJ;AACA;AACA;AACI,UAAMC,QAAN,CAAgBV,KAAhB,EAAuB;AACrB,YAAMW,KAAK,GAAGZ,YAAY,CAACC,KAAD,CAA1B;AACA,YAAMS,MAAM,CAACG,KAAP,CAAaD,KAAb,CAAN;AACD,KARI;;AAUL;AACJ;AACA;AACA;AACI,UAAME,UAAN,CAAkBC,KAAlB,EAAyB;AACvB,YAAM;AAAEC,QAAAA,GAAF;AAAOJ,QAAAA;AAAP,UAAiBG,KAAvB;AACA,YAAML,MAAM,CAACG,KAAP,CAAa,IAAIN,UAAJ,CAAeV,MAAM,CAACC,MAAP,CAAckB,GAAG,CAACJ,KAAJ,CAAUP,MAAV,GAAmBO,KAAK,CAACP,MAAvC,CAAf,CAAb,CAAN;AACA,YAAMK,MAAM,CAACG,KAAP,CAAaG,GAAG,CAACJ,KAAjB,CAAN;;AACA,UAAIA,KAAK,CAACP,MAAV,EAAkB;AAChB;AACA,cAAMK,MAAM,CAACG,KAAP,CAAaD,KAAb,CAAN;AACD;AACF,KAtBI;;AAwBL;AACJ;AACA;AACI,UAAMK,KAAN,GAAe;AACb,YAAMP,MAAM,CAACQ,GAAP,EAAN;AACA;AACA;AACD;;AA/BI,GAAP;AAiCD;;AAED,SAAST,aAAT","sourcesContent":["import varint from 'varint'\nimport { encode as dagCborEncode } from '@ipld/dag-cbor'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./coding').CarEncoder} CarEncoder\n * @typedef {import('./coding').IteratorChannel_Writer<Uint8Array>} IteratorChannel_Writer\n */\n\n/**\n * Create a header from an array of roots.\n *\n * @param {CID[]} roots\n * @returns {Uint8Array}\n */\nexport function createHeader (roots) {\n  const headerBytes = dagCborEncode({ version: 1, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n  const header = new Uint8Array(varintBytes.length + headerBytes.length)\n  header.set(varintBytes, 0)\n  header.set(headerBytes, varintBytes.length)\n  return header\n}\n\n/**\n * @param {IteratorChannel_Writer} writer\n * @returns {CarEncoder}\n */\nfunction createEncoder (writer) {\n  // none of this is wrapped in a mutex, that needs to happen above this to\n  // avoid overwrites\n\n  return {\n    /**\n     * @param {CID[]} roots\n     * @returns {Promise<void>}\n     */\n    async setRoots (roots) {\n      const bytes = createHeader(roots)\n      await writer.write(bytes)\n    },\n\n    /**\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n    async writeBlock (block) {\n      const { cid, bytes } = block\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)))\n      await writer.write(cid.bytes)\n      if (bytes.length) {\n        // zero-length blocks are valid, but it'd be safer if we didn't write them\n        await writer.write(bytes)\n      }\n    },\n\n    /**\n     * @returns {Promise<void>}\n     */\n    async close () {\n      await writer.end()\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    }\n  }\n}\n\nexport { createEncoder }\n"]},"metadata":{},"sourceType":"module"}