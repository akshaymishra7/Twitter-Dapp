{"ast":null,"code":"import { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays';\nimport { logger } from '../logger.js';\nimport { Nonce } from '../nonce.js';\nexport class AbstractHandshake {\n  constructor(crypto) {\n    this.crypto = crypto;\n  }\n\n  encryptWithAd(cs, ad, plaintext) {\n    const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n    cs.n.increment();\n    return e;\n  }\n\n  decryptWithAd(cs, ad, ciphertext, dst) {\n    const {\n      plaintext,\n      valid\n    } = this.decrypt(cs.k, cs.n, ad, ciphertext, dst);\n    if (valid) cs.n.increment();\n    return {\n      plaintext,\n      valid\n    };\n  } // Cipher state related\n\n\n  hasKey(cs) {\n    return !this.isEmptyKey(cs.k);\n  }\n\n  createEmptyKey() {\n    return new Uint8Array(32);\n  }\n\n  isEmptyKey(k) {\n    const emptyKey = this.createEmptyKey();\n    return uint8ArrayEquals(emptyKey, k);\n  }\n\n  encrypt(k, n, ad, plaintext) {\n    n.assertValue();\n    return this.crypto.chaCha20Poly1305Encrypt(plaintext, n.getBytes(), ad, k);\n  }\n\n  encryptAndHash(ss, plaintext) {\n    let ciphertext;\n\n    if (this.hasKey(ss.cs)) {\n      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n    } else {\n      ciphertext = plaintext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return ciphertext;\n  }\n\n  decrypt(k, n, ad, ciphertext, dst) {\n    n.assertValue();\n    const encryptedMessage = this.crypto.chaCha20Poly1305Decrypt(ciphertext, n.getBytes(), ad, k, dst);\n\n    if (encryptedMessage) {\n      return {\n        plaintext: encryptedMessage,\n        valid: true\n      };\n    } else {\n      return {\n        plaintext: new Uint8Array(0),\n        valid: false\n      };\n    }\n  }\n\n  decryptAndHash(ss, ciphertext) {\n    let plaintext;\n    let valid = true;\n\n    if (this.hasKey(ss.cs)) {\n      ({\n        plaintext,\n        valid\n      } = this.decryptWithAd(ss.cs, ss.h, ciphertext));\n    } else {\n      plaintext = ciphertext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return {\n      plaintext,\n      valid\n    };\n  }\n\n  dh(privateKey, publicKey) {\n    try {\n      const derivedU8 = this.crypto.generateX25519SharedKey(privateKey, publicKey);\n\n      if (derivedU8.length === 32) {\n        return derivedU8;\n      }\n\n      return derivedU8.subarray(0, 32);\n    } catch (e) {\n      const err = e;\n      logger.error(err);\n      return new Uint8Array(32);\n    }\n  }\n\n  mixHash(ss, data) {\n    ss.h = this.getHash(ss.h, data);\n  }\n\n  getHash(a, b) {\n    const u = this.crypto.hashSHA256(uint8ArrayConcat([a, b], a.length + b.length));\n    return u;\n  }\n\n  mixKey(ss, ikm) {\n    const [ck, tempK] = this.crypto.getHKDF(ss.ck, ikm);\n    ss.cs = this.initializeKey(tempK);\n    ss.ck = ck;\n  }\n\n  initializeKey(k) {\n    return {\n      k,\n      n: new Nonce()\n    };\n  } // Symmetric state related\n\n\n  initializeSymmetric(protocolName) {\n    const protocolNameBytes = uint8ArrayFromString(protocolName, 'utf-8');\n    const h = this.hashProtocolName(protocolNameBytes);\n    const ck = h;\n    const key = this.createEmptyKey();\n    const cs = this.initializeKey(key);\n    return {\n      cs,\n      ck,\n      h\n    };\n  }\n\n  hashProtocolName(protocolName) {\n    if (protocolName.length <= 32) {\n      const h = new Uint8Array(32);\n      h.set(protocolName);\n      return h;\n    } else {\n      return this.getHash(protocolName, new Uint8Array(0));\n    }\n  }\n\n  split(ss) {\n    const [tempk1, tempk2] = this.crypto.getHKDF(ss.ck, new Uint8Array(0));\n    const cs1 = this.initializeKey(tempk1);\n    const cs2 = this.initializeKey(tempk2);\n    return {\n      cs1,\n      cs2\n    };\n  }\n\n  writeMessageRegular(cs, payload) {\n    const ciphertext = this.encryptWithAd(cs, new Uint8Array(0), payload);\n    const ne = this.createEmptyKey();\n    const ns = new Uint8Array(0);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  readMessageRegular(cs, message) {\n    return this.decryptWithAd(cs, new Uint8Array(0), message.ciphertext);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["equals","uint8ArrayEquals","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","logger","Nonce","AbstractHandshake","constructor","crypto","encryptWithAd","cs","ad","plaintext","e","encrypt","k","n","increment","decryptWithAd","ciphertext","dst","valid","decrypt","hasKey","isEmptyKey","createEmptyKey","Uint8Array","emptyKey","assertValue","chaCha20Poly1305Encrypt","getBytes","encryptAndHash","ss","h","mixHash","encryptedMessage","chaCha20Poly1305Decrypt","decryptAndHash","dh","privateKey","publicKey","derivedU8","generateX25519SharedKey","length","subarray","err","error","data","getHash","a","b","u","hashSHA256","mixKey","ikm","ck","tempK","getHKDF","initializeKey","initializeSymmetric","protocolName","protocolNameBytes","hashProtocolName","key","set","split","tempk1","tempk2","cs1","cs2","writeMessageRegular","payload","ne","ns","readMessageRegular","message"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-noise\\src\\handshakes\\abstract-handshake.ts"],"sourcesContent":["import { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays'\nimport type { bytes, bytes32 } from '../@types/basic.js'\nimport type { CipherState, MessageBuffer, SymmetricState } from '../@types/handshake.js'\nimport type { ICryptoInterface } from '../crypto.js'\nimport { logger } from '../logger.js'\nimport { Nonce } from '../nonce.js'\n\nexport interface DecryptedResult {\n  plaintext: bytes\n  valid: boolean\n}\n\nexport interface SplitState {\n  cs1: CipherState\n  cs2: CipherState\n}\n\nexport abstract class AbstractHandshake {\n  public crypto: ICryptoInterface\n\n  constructor (crypto: ICryptoInterface) {\n    this.crypto = crypto\n  }\n\n  public encryptWithAd (cs: CipherState, ad: Uint8Array, plaintext: Uint8Array): bytes {\n    const e = this.encrypt(cs.k, cs.n, ad, plaintext)\n    cs.n.increment()\n\n    return e\n  }\n\n  public decryptWithAd (cs: CipherState, ad: Uint8Array, ciphertext: Uint8Array, dst?: Uint8Array): DecryptedResult {\n    const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext, dst)\n    if (valid) cs.n.increment()\n\n    return { plaintext, valid }\n  }\n\n  // Cipher state related\n  protected hasKey (cs: CipherState): boolean {\n    return !this.isEmptyKey(cs.k)\n  }\n\n  protected createEmptyKey (): bytes32 {\n    return new Uint8Array(32)\n  }\n\n  protected isEmptyKey (k: bytes32): boolean {\n    const emptyKey = this.createEmptyKey()\n    return uint8ArrayEquals(emptyKey, k)\n  }\n\n  protected encrypt (k: bytes32, n: Nonce, ad: Uint8Array, plaintext: Uint8Array): bytes {\n    n.assertValue()\n\n    return this.crypto.chaCha20Poly1305Encrypt(plaintext, n.getBytes(), ad, k)\n  }\n\n  protected encryptAndHash (ss: SymmetricState, plaintext: bytes): bytes {\n    let ciphertext\n    if (this.hasKey(ss.cs)) {\n      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext)\n    } else {\n      ciphertext = plaintext\n    }\n\n    this.mixHash(ss, ciphertext)\n    return ciphertext\n  }\n\n  protected decrypt (k: bytes32, n: Nonce, ad: bytes, ciphertext: bytes, dst?: Uint8Array): DecryptedResult {\n    n.assertValue()\n\n    const encryptedMessage = this.crypto.chaCha20Poly1305Decrypt(ciphertext, n.getBytes(), ad, k, dst)\n\n    if (encryptedMessage) {\n      return {\n        plaintext: encryptedMessage,\n        valid: true\n      }\n    } else {\n      return {\n        plaintext: new Uint8Array(0),\n        valid: false\n      }\n    }\n  }\n\n  protected decryptAndHash (ss: SymmetricState, ciphertext: bytes): DecryptedResult {\n    let plaintext: bytes; let valid = true\n    if (this.hasKey(ss.cs)) {\n      ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext))\n    } else {\n      plaintext = ciphertext\n    }\n\n    this.mixHash(ss, ciphertext)\n    return { plaintext, valid }\n  }\n\n  protected dh (privateKey: bytes32, publicKey: bytes32): bytes32 {\n    try {\n      const derivedU8 = this.crypto.generateX25519SharedKey(privateKey, publicKey)\n\n      if (derivedU8.length === 32) {\n        return derivedU8\n      }\n\n      return derivedU8.subarray(0, 32)\n    } catch (e) {\n      const err = e as Error\n      logger.error(err)\n      return new Uint8Array(32)\n    }\n  }\n\n  protected mixHash (ss: SymmetricState, data: bytes): void {\n    ss.h = this.getHash(ss.h, data)\n  }\n\n  protected getHash (a: Uint8Array, b: Uint8Array): bytes32 {\n    const u = this.crypto.hashSHA256(uint8ArrayConcat([a, b], a.length + b.length))\n    return u\n  }\n\n  protected mixKey (ss: SymmetricState, ikm: bytes32): void {\n    const [ck, tempK] = this.crypto.getHKDF(ss.ck, ikm)\n    ss.cs = this.initializeKey(tempK)\n    ss.ck = ck\n  }\n\n  protected initializeKey (k: bytes32): CipherState {\n    return { k, n: new Nonce() }\n  }\n\n  // Symmetric state related\n\n  protected initializeSymmetric (protocolName: string): SymmetricState {\n    const protocolNameBytes = uint8ArrayFromString(protocolName, 'utf-8')\n    const h = this.hashProtocolName(protocolNameBytes)\n\n    const ck = h\n    const key = this.createEmptyKey()\n    const cs: CipherState = this.initializeKey(key)\n\n    return { cs, ck, h }\n  }\n\n  protected hashProtocolName (protocolName: Uint8Array): bytes32 {\n    if (protocolName.length <= 32) {\n      const h = new Uint8Array(32)\n      h.set(protocolName)\n      return h\n    } else {\n      return this.getHash(protocolName, new Uint8Array(0))\n    }\n  }\n\n  protected split (ss: SymmetricState): SplitState {\n    const [tempk1, tempk2] = this.crypto.getHKDF(ss.ck, new Uint8Array(0))\n    const cs1 = this.initializeKey(tempk1)\n    const cs2 = this.initializeKey(tempk2)\n\n    return { cs1, cs2 }\n  }\n\n  protected writeMessageRegular (cs: CipherState, payload: bytes): MessageBuffer {\n    const ciphertext = this.encryptWithAd(cs, new Uint8Array(0), payload)\n    const ne = this.createEmptyKey()\n    const ns = new Uint8Array(0)\n\n    return { ne, ns, ciphertext }\n  }\n\n  protected readMessageRegular (cs: CipherState, message: MessageBuffer): DecryptedResult {\n    return this.decryptWithAd(cs, new Uint8Array(0), message.ciphertext)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}