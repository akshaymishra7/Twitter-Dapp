{"ast":null,"code":"import { CodeError } from '@libp2p/interfaces/errors';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport * as hmac from '../hmac/index.js';\nconst cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    keySize: 32\n  }\n};\n/**\n * Generates a set of keys for each party by stretching the shared key.\n * (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n */\n\nexport async function keyStretcher(cipherType, hash, secret) {\n  const cipher = cipherMap[cipherType];\n\n  if (cipher == null) {\n    const allowed = Object.keys(cipherMap).join(' / ');\n    throw new CodeError(`unknown cipher type '${cipherType}'. Must be ${allowed}`, 'ERR_INVALID_CIPHER_TYPE');\n  }\n\n  if (hash == null) {\n    throw new CodeError('missing hash type', 'ERR_MISSING_HASH_TYPE');\n  }\n\n  const cipherKeySize = cipher.keySize;\n  const ivSize = cipher.ivSize;\n  const hmacKeySize = 20;\n  const seed = uint8ArrayFromString('key expansion');\n  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n  const m = await hmac.create(hash, secret);\n  let a = await m.digest(seed);\n  const result = [];\n  let j = 0;\n\n  while (j < resultLength) {\n    const b = await m.digest(uint8ArrayConcat([a, seed]));\n    let todo = b.length;\n\n    if (j + todo > resultLength) {\n      todo = resultLength - j;\n    }\n\n    result.push(b);\n    j += todo;\n    a = await m.digest(a);\n  }\n\n  const half = resultLength / 2;\n  const resultBuffer = uint8ArrayConcat(result);\n  const r1 = resultBuffer.subarray(0, half);\n  const r2 = resultBuffer.subarray(half, resultLength);\n\n  const createKey = res => ({\n    iv: res.subarray(0, ivSize),\n    cipherKey: res.subarray(ivSize, ivSize + cipherKeySize),\n    macKey: res.subarray(ivSize + cipherKeySize)\n  });\n\n  return {\n    k1: createKey(r1),\n    k2: createKey(r2)\n  };\n}","map":{"version":3,"mappings":"AAAA,SAASA,SAAT,QAA0B,2BAA1B;AACA,SAASC,MAAM,IAAIC,gBAAnB,QAA2C,oBAA3C;AACA,SAASC,UAAU,IAAIC,oBAAvB,QAAmD,yBAAnD;AACA,OAAO,KAAKC,IAAZ,MAAsB,kBAAtB;AAGA,MAAMC,SAAS,GAAG;AAChB,aAAW;AACTC,UAAM,EAAE,EADC;AAETC,WAAO,EAAE;AAFA,GADK;AAKhB,aAAW;AACTD,UAAM,EAAE,EADC;AAETC,WAAO,EAAE;AAFA,GALK;AAShBC,UAAQ,EAAE;AACRF,UAAM,EAAE,CADA;AAERC,WAAO,EAAE;AAFD;AATM,CAAlB;AAeA;;;;;AAIA,OAAO,eAAeE,YAAf,CAA6BC,UAA7B,EAA6EC,IAA7E,EAAiHC,MAAjH,EAAmI;AACxI,QAAMC,MAAM,GAAGR,SAAS,CAACK,UAAD,CAAxB;;AAEA,MAAIG,MAAM,IAAI,IAAd,EAAoB;AAClB,UAAMC,OAAO,GAAGC,MAAM,CAACC,IAAP,CAAYX,SAAZ,EAAuBY,IAAvB,CAA4B,KAA5B,CAAhB;AACA,UAAM,IAAIlB,SAAJ,CAAc,wBAAwBW,UAAU,cAAcI,OAAO,EAArE,EAAyE,yBAAzE,CAAN;AACD;;AAED,MAAIH,IAAI,IAAI,IAAZ,EAAkB;AAChB,UAAM,IAAIZ,SAAJ,CAAc,mBAAd,EAAmC,uBAAnC,CAAN;AACD;;AAED,QAAMmB,aAAa,GAAGL,MAAM,CAACN,OAA7B;AACA,QAAMD,MAAM,GAAGO,MAAM,CAACP,MAAtB;AACA,QAAMa,WAAW,GAAG,EAApB;AACA,QAAMC,IAAI,GAAGjB,oBAAoB,CAAC,eAAD,CAAjC;AACA,QAAMkB,YAAY,GAAG,KAAKf,MAAM,GAAGY,aAAT,GAAyBC,WAA9B,CAArB;AAEA,QAAMG,CAAC,GAAG,MAAMlB,IAAI,CAACmB,MAAL,CAAYZ,IAAZ,EAAkBC,MAAlB,CAAhB;AACA,MAAIY,CAAC,GAAG,MAAMF,CAAC,CAACG,MAAF,CAASL,IAAT,CAAd;AAEA,QAAMM,MAAM,GAAG,EAAf;AACA,MAAIC,CAAC,GAAG,CAAR;;AAEA,SAAOA,CAAC,GAAGN,YAAX,EAAyB;AACvB,UAAMO,CAAC,GAAG,MAAMN,CAAC,CAACG,MAAF,CAASxB,gBAAgB,CAAC,CAACuB,CAAD,EAAIJ,IAAJ,CAAD,CAAzB,CAAhB;AACA,QAAIS,IAAI,GAAGD,CAAC,CAACE,MAAb;;AAEA,QAAIH,CAAC,GAAGE,IAAJ,GAAWR,YAAf,EAA6B;AAC3BQ,UAAI,GAAGR,YAAY,GAAGM,CAAtB;AACD;;AAEDD,UAAM,CAACK,IAAP,CAAYH,CAAZ;AACAD,KAAC,IAAIE,IAAL;AACAL,KAAC,GAAG,MAAMF,CAAC,CAACG,MAAF,CAASD,CAAT,CAAV;AACD;;AAED,QAAMQ,IAAI,GAAGX,YAAY,GAAG,CAA5B;AACA,QAAMY,YAAY,GAAGhC,gBAAgB,CAACyB,MAAD,CAArC;AACA,QAAMQ,EAAE,GAAGD,YAAY,CAACE,QAAb,CAAsB,CAAtB,EAAyBH,IAAzB,CAAX;AACA,QAAMI,EAAE,GAAGH,YAAY,CAACE,QAAb,CAAsBH,IAAtB,EAA4BX,YAA5B,CAAX;;AAEA,QAAMgB,SAAS,GAAIC,GAAD,KAAmC;AACnDC,MAAE,EAAED,GAAG,CAACH,QAAJ,CAAa,CAAb,EAAgB7B,MAAhB,CAD+C;AAEnDkC,aAAS,EAAEF,GAAG,CAACH,QAAJ,CAAa7B,MAAb,EAAqBA,MAAM,GAAGY,aAA9B,CAFwC;AAGnDuB,UAAM,EAAEH,GAAG,CAACH,QAAJ,CAAa7B,MAAM,GAAGY,aAAtB;AAH2C,GAAnC,CAAlB;;AAMA,SAAO;AACLwB,MAAE,EAAEL,SAAS,CAACH,EAAD,CADR;AAELS,MAAE,EAAEN,SAAS,CAACD,EAAD;AAFR,GAAP;AAID","names":["CodeError","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","hmac","cipherMap","ivSize","keySize","Blowfish","keyStretcher","cipherType","hash","secret","cipher","allowed","Object","keys","join","cipherKeySize","hmacKeySize","seed","resultLength","m","create","a","digest","result","j","b","todo","length","push","half","resultBuffer","r1","subarray","r2","createKey","res","iv","cipherKey","macKey","k1","k2"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\crypto\\src\\keys\\key-stretcher.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport * as hmac from '../hmac/index.js'\nimport type { EnhancedKey, EnhancedKeyPair } from './interface.js'\n\nconst cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    keySize: 32\n  }\n}\n\n/**\n * Generates a set of keys for each party by stretching the shared key.\n * (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n */\nexport async function keyStretcher (cipherType: 'AES-128' | 'AES-256' | 'Blowfish', hash: 'SHA1' | 'SHA256' | 'SHA512', secret: Uint8Array): Promise<EnhancedKeyPair> {\n  const cipher = cipherMap[cipherType]\n\n  if (cipher == null) {\n    const allowed = Object.keys(cipherMap).join(' / ')\n    throw new CodeError(`unknown cipher type '${cipherType}'. Must be ${allowed}`, 'ERR_INVALID_CIPHER_TYPE')\n  }\n\n  if (hash == null) {\n    throw new CodeError('missing hash type', 'ERR_MISSING_HASH_TYPE')\n  }\n\n  const cipherKeySize = cipher.keySize\n  const ivSize = cipher.ivSize\n  const hmacKeySize = 20\n  const seed = uint8ArrayFromString('key expansion')\n  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize)\n\n  const m = await hmac.create(hash, secret)\n  let a = await m.digest(seed)\n\n  const result = []\n  let j = 0\n\n  while (j < resultLength) {\n    const b = await m.digest(uint8ArrayConcat([a, seed]))\n    let todo = b.length\n\n    if (j + todo > resultLength) {\n      todo = resultLength - j\n    }\n\n    result.push(b)\n    j += todo\n    a = await m.digest(a)\n  }\n\n  const half = resultLength / 2\n  const resultBuffer = uint8ArrayConcat(result)\n  const r1 = resultBuffer.subarray(0, half)\n  const r2 = resultBuffer.subarray(half, resultLength)\n\n  const createKey = (res: Uint8Array): EnhancedKey => ({\n    iv: res.subarray(0, ivSize),\n    cipherKey: res.subarray(ivSize, ivSize + cipherKeySize),\n    macKey: res.subarray(ivSize + cipherKeySize)\n  })\n\n  return {\n    k1: createKey(r1),\n    k2: createKey(r2)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}