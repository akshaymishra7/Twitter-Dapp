{"ast":null,"code":"import { peerIdFromString } from '@libp2p/peer-id';\nimport { mapIterable } from './util.js';\n/**\n * We can't use PeerIds as list entries because list entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```JavaScript\n * import { peerList } from '@libp2p/peer-collections'\n *\n * const list = peerList()\n * list.push(peerId)\n * ```\n */\n\nexport class PeerList {\n  constructor(list) {\n    this.list = [];\n\n    if (list != null) {\n      for (const value of list) {\n        this.list.push(value.toString());\n      }\n    }\n  }\n\n  [Symbol.iterator]() {\n    return mapIterable(this.list.entries(), val => {\n      return peerIdFromString(val[1]);\n    });\n  }\n\n  concat(list) {\n    const output = new PeerList(this);\n\n    for (const value of list) {\n      output.push(value);\n    }\n\n    return output;\n  }\n\n  entries() {\n    return mapIterable(this.list.entries(), val => {\n      return [val[0], peerIdFromString(val[1])];\n    });\n  }\n\n  every(predicate) {\n    return this.list.every((str, index) => {\n      return predicate(peerIdFromString(str), index, this);\n    });\n  }\n\n  filter(predicate) {\n    const output = new PeerList();\n    this.list.forEach((str, index) => {\n      const peerId = peerIdFromString(str);\n\n      if (predicate(peerId, index, this)) {\n        output.push(peerId);\n      }\n    });\n    return output;\n  }\n\n  find(predicate) {\n    const str = this.list.find((str, index) => {\n      return predicate(peerIdFromString(str), index, this);\n    });\n\n    if (str == null) {\n      return undefined;\n    }\n\n    return peerIdFromString(str);\n  }\n\n  findIndex(predicate) {\n    return this.list.findIndex((str, index) => {\n      return predicate(peerIdFromString(str), index, this);\n    });\n  }\n\n  forEach(predicate) {\n    this.list.forEach((str, index) => {\n      predicate(peerIdFromString(str), index, this);\n    });\n  }\n\n  includes(peerId) {\n    return this.list.includes(peerId.toString());\n  }\n\n  indexOf(peerId) {\n    return this.list.indexOf(peerId.toString());\n  }\n\n  pop() {\n    const str = this.list.pop();\n\n    if (str == null) {\n      return undefined;\n    }\n\n    return peerIdFromString(str);\n  }\n\n  push() {\n    for (var _len = arguments.length, peerIds = new Array(_len), _key = 0; _key < _len; _key++) {\n      peerIds[_key] = arguments[_key];\n    }\n\n    for (const peerId of peerIds) {\n      this.list.push(peerId.toString());\n    }\n  }\n\n  shift() {\n    const str = this.list.shift();\n\n    if (str == null) {\n      return undefined;\n    }\n\n    return peerIdFromString(str);\n  }\n\n  unshift() {\n    let len = this.list.length;\n\n    for (var _len2 = arguments.length, peerIds = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      peerIds[_key2] = arguments[_key2];\n    }\n\n    for (let i = peerIds.length - 1; i > -1; i--) {\n      len = this.list.unshift(peerIds[i].toString());\n    }\n\n    return len;\n  }\n\n  get length() {\n    return this.list.length;\n  }\n\n}","map":{"version":3,"mappings":"AACA,SAASA,gBAAT,QAAiC,iBAAjC;AACA,SAASC,WAAT,QAA4B,WAA5B;AAEA;;;;;;;;;;;;;;;;;;AAiBA,OAAM,MAAOC,QAAP,CAAe;AAGnBC,cAAaC,IAAb,EAA+C;AAC7C,SAAKA,IAAL,GAAY,EAAZ;;AAEA,QAAIA,IAAI,IAAI,IAAZ,EAAkB;AAChB,WAAK,MAAMC,KAAX,IAAoBD,IAApB,EAA0B;AACxB,aAAKA,IAAL,CAAUE,IAAV,CAAeD,KAAK,CAACE,QAAN,EAAf;AACD;AACF;AACF;;AAEe,GAAfC,MAAM,CAACC,QAAQ,IAAC;AACf,WAAOR,WAAW,CAChB,KAAKG,IAAL,CAAUM,OAAV,EADgB,EAEfC,GAAD,IAAQ;AACN,aAAOX,gBAAgB,CAACW,GAAG,CAAC,CAAD,CAAJ,CAAvB;AACD,KAJe,CAAlB;AAMD;;AAEDC,QAAM,CAAER,IAAF,EAAgB;AACpB,UAAMS,MAAM,GAAG,IAAIX,QAAJ,CAAa,IAAb,CAAf;;AAEA,SAAK,MAAMG,KAAX,IAAoBD,IAApB,EAA0B;AACxBS,YAAM,CAACP,IAAP,CAAYD,KAAZ;AACD;;AAED,WAAOQ,MAAP;AACD;;AAEDH,SAAO;AACL,WAAOT,WAAW,CAChB,KAAKG,IAAL,CAAUM,OAAV,EADgB,EAEfC,GAAD,IAAQ;AACN,aAAO,CAACA,GAAG,CAAC,CAAD,CAAJ,EAASX,gBAAgB,CAACW,GAAG,CAAC,CAAD,CAAJ,CAAzB,CAAP;AACD,KAJe,CAAlB;AAMD;;AAEDG,OAAK,CAAEC,SAAF,EAAsE;AACzE,WAAO,KAAKX,IAAL,CAAUU,KAAV,CAAgB,CAACE,GAAD,EAAMC,KAAN,KAAe;AACpC,aAAOF,SAAS,CAACf,gBAAgB,CAACgB,GAAD,CAAjB,EAAwBC,KAAxB,EAA+B,IAA/B,CAAhB;AACD,KAFM,CAAP;AAGD;;AAEDC,QAAM,CAAEH,SAAF,EAAsE;AAC1E,UAAMF,MAAM,GAAG,IAAIX,QAAJ,EAAf;AAEA,SAAKE,IAAL,CAAUe,OAAV,CAAkB,CAACH,GAAD,EAAMC,KAAN,KAAe;AAC/B,YAAMG,MAAM,GAAGpB,gBAAgB,CAACgB,GAAD,CAA/B;;AAEA,UAAID,SAAS,CAACK,MAAD,EAASH,KAAT,EAAgB,IAAhB,CAAb,EAAoC;AAClCJ,cAAM,CAACP,IAAP,CAAYc,MAAZ;AACD;AACF,KAND;AAQA,WAAOP,MAAP;AACD;;AAEDQ,MAAI,CAAEN,SAAF,EAAsE;AACxE,UAAMC,GAAG,GAAG,KAAKZ,IAAL,CAAUiB,IAAV,CAAe,CAACL,GAAD,EAAMC,KAAN,KAAe;AACxC,aAAOF,SAAS,CAACf,gBAAgB,CAACgB,GAAD,CAAjB,EAAwBC,KAAxB,EAA+B,IAA/B,CAAhB;AACD,KAFW,CAAZ;;AAIA,QAAID,GAAG,IAAI,IAAX,EAAiB;AACf,aAAOM,SAAP;AACD;;AAED,WAAOtB,gBAAgB,CAACgB,GAAD,CAAvB;AACD;;AAEDO,WAAS,CAAER,SAAF,EAAsE;AAC7E,WAAO,KAAKX,IAAL,CAAUmB,SAAV,CAAoB,CAACP,GAAD,EAAMC,KAAN,KAAe;AACxC,aAAOF,SAAS,CAACf,gBAAgB,CAACgB,GAAD,CAAjB,EAAwBC,KAAxB,EAA+B,IAA/B,CAAhB;AACD,KAFM,CAAP;AAGD;;AAEDE,SAAO,CAAEJ,SAAF,EAAmE;AACxE,SAAKX,IAAL,CAAUe,OAAV,CAAkB,CAACH,GAAD,EAAMC,KAAN,KAAe;AAC/BF,eAAS,CAACf,gBAAgB,CAACgB,GAAD,CAAjB,EAAwBC,KAAxB,EAA+B,IAA/B,CAAT;AACD,KAFD;AAGD;;AAEDO,UAAQ,CAAEJ,MAAF,EAAgB;AACtB,WAAO,KAAKhB,IAAL,CAAUoB,QAAV,CAAmBJ,MAAM,CAACb,QAAP,EAAnB,CAAP;AACD;;AAEDkB,SAAO,CAAEL,MAAF,EAAgB;AACrB,WAAO,KAAKhB,IAAL,CAAUqB,OAAV,CAAkBL,MAAM,CAACb,QAAP,EAAlB,CAAP;AACD;;AAEDmB,KAAG;AACD,UAAMV,GAAG,GAAG,KAAKZ,IAAL,CAAUsB,GAAV,EAAZ;;AAEA,QAAIV,GAAG,IAAI,IAAX,EAAiB;AACf,aAAOM,SAAP;AACD;;AAED,WAAOtB,gBAAgB,CAACgB,GAAD,CAAvB;AACD;;AAEDV,MAAI,GAAsB;AAAA,sCAAjBqB,OAAiB;AAAjBA,aAAiB;AAAA;;AACxB,SAAK,MAAMP,MAAX,IAAqBO,OAArB,EAA8B;AAC5B,WAAKvB,IAAL,CAAUE,IAAV,CAAec,MAAM,CAACb,QAAP,EAAf;AACD;AACF;;AAEDqB,OAAK;AACH,UAAMZ,GAAG,GAAG,KAAKZ,IAAL,CAAUwB,KAAV,EAAZ;;AAEA,QAAIZ,GAAG,IAAI,IAAX,EAAiB;AACf,aAAOM,SAAP;AACD;;AAED,WAAOtB,gBAAgB,CAACgB,GAAD,CAAvB;AACD;;AAEDa,SAAO,GAAsB;AAC3B,QAAIC,GAAG,GAAG,KAAK1B,IAAL,CAAU2B,MAApB;;AAD2B,uCAAjBJ,OAAiB;AAAjBA,aAAiB;AAAA;;AAG3B,SAAK,IAAIK,CAAC,GAAGL,OAAO,CAACI,MAAR,GAAiB,CAA9B,EAAiCC,CAAC,GAAG,CAAC,CAAtC,EAAyCA,CAAC,EAA1C,EAA8C;AAC5CF,SAAG,GAAG,KAAK1B,IAAL,CAAUyB,OAAV,CAAkBF,OAAO,CAACK,CAAD,CAAP,CAAWzB,QAAX,EAAlB,CAAN;AACD;;AAED,WAAOuB,GAAP;AACD;;AAES,MAANC,MAAM;AACR,WAAO,KAAK3B,IAAL,CAAU2B,MAAjB;AACD;;AAnIkB","names":["peerIdFromString","mapIterable","PeerList","constructor","list","value","push","toString","Symbol","iterator","entries","val","concat","output","every","predicate","str","index","filter","forEach","peerId","find","undefined","findIndex","includes","indexOf","pop","peerIds","shift","unshift","len","length","i"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\peer-collections\\src\\list.ts"],"sourcesContent":["import type { PeerId } from '@libp2p/interface-peer-id'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { mapIterable } from './util.js'\n\n/**\n * We can't use PeerIds as list entries because list entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```JavaScript\n * import { peerList } from '@libp2p/peer-collections'\n *\n * const list = peerList()\n * list.push(peerId)\n * ```\n */\nexport class PeerList {\n  private readonly list: string[]\n\n  constructor (list?: PeerList | Iterable<PeerId>) {\n    this.list = []\n\n    if (list != null) {\n      for (const value of list) {\n        this.list.push(value.toString())\n      }\n    }\n  }\n\n  [Symbol.iterator] (): IterableIterator<PeerId> {\n    return mapIterable<[number, string], PeerId>(\n      this.list.entries(),\n      (val) => {\n        return peerIdFromString(val[1])\n      }\n    )\n  }\n\n  concat (list: PeerList): PeerList {\n    const output = new PeerList(this)\n\n    for (const value of list) {\n      output.push(value)\n    }\n\n    return output\n  }\n\n  entries (): IterableIterator<[number, PeerId]> {\n    return mapIterable<[number, string], [number, PeerId]>(\n      this.list.entries(),\n      (val) => {\n        return [val[0], peerIdFromString(val[1])]\n      }\n    )\n  }\n\n  every (predicate: (peerId: PeerId, index: number, arr: PeerList) => boolean): boolean {\n    return this.list.every((str, index) => {\n      return predicate(peerIdFromString(str), index, this)\n    })\n  }\n\n  filter (predicate: (peerId: PeerId, index: number, arr: PeerList) => boolean): PeerList {\n    const output = new PeerList()\n\n    this.list.forEach((str, index) => {\n      const peerId = peerIdFromString(str)\n\n      if (predicate(peerId, index, this)) {\n        output.push(peerId)\n      }\n    })\n\n    return output\n  }\n\n  find (predicate: (peerId: PeerId, index: number, arr: PeerList) => boolean): PeerId | undefined {\n    const str = this.list.find((str, index) => {\n      return predicate(peerIdFromString(str), index, this)\n    })\n\n    if (str == null) {\n      return undefined\n    }\n\n    return peerIdFromString(str)\n  }\n\n  findIndex (predicate: (peerId: PeerId, index: number, arr: PeerList) => boolean): number {\n    return this.list.findIndex((str, index) => {\n      return predicate(peerIdFromString(str), index, this)\n    })\n  }\n\n  forEach (predicate: (peerId: PeerId, index: number, arr: PeerList) => void): void {\n    this.list.forEach((str, index) => {\n      predicate(peerIdFromString(str), index, this)\n    })\n  }\n\n  includes (peerId: PeerId): boolean {\n    return this.list.includes(peerId.toString())\n  }\n\n  indexOf (peerId: PeerId): number {\n    return this.list.indexOf(peerId.toString())\n  }\n\n  pop (): PeerId | undefined {\n    const str = this.list.pop()\n\n    if (str == null) {\n      return undefined\n    }\n\n    return peerIdFromString(str)\n  }\n\n  push (...peerIds: PeerId[]): void {\n    for (const peerId of peerIds) {\n      this.list.push(peerId.toString())\n    }\n  }\n\n  shift (): PeerId | undefined {\n    const str = this.list.shift()\n\n    if (str == null) {\n      return undefined\n    }\n\n    return peerIdFromString(str)\n  }\n\n  unshift (...peerIds: PeerId[]): number {\n    let len = this.list.length\n\n    for (let i = peerIds.length - 1; i > -1; i--) {\n      len = this.list.unshift(peerIds[i].toString())\n    }\n\n    return len\n  }\n\n  get length (): number {\n    return this.list.length\n  }\n}\n"]},"metadata":{},"sourceType":"module"}