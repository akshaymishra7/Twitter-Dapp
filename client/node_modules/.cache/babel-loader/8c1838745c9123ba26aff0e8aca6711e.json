{"ast":null,"code":"import PQueue from 'p-queue';\nimport pTimeout from 'p-timeout';\nimport impl from './node.js';\nconst mutexes = {};\nlet implementation;\n\nasync function createReleaseable(queue, options) {\n  let res;\n  const p = new Promise(resolve => {\n    res = resolve;\n  });\n  void queue.add(async () => await pTimeout((async () => {\n    return await new Promise(resolve => {\n      res(() => {\n        resolve();\n      });\n    });\n  })(), {\n    milliseconds: options.timeout\n  }));\n  return await p;\n}\n\nconst createMutex = (name, options) => {\n  if (implementation.isWorker === true) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options)\n    };\n  }\n\n  const masterQueue = new PQueue({\n    concurrency: 1\n  });\n  let readQueue;\n  return {\n    async readLock() {\n      // If there's already a read queue, just add the task to it\n      if (readQueue != null) {\n        return await createReleaseable(readQueue, options);\n      } // Create a new read queue\n\n\n      readQueue = new PQueue({\n        concurrency: options.concurrency,\n        autoStart: false\n      });\n      const localReadQueue = readQueue; // Add the task to the read queue\n\n      const readPromise = createReleaseable(readQueue, options);\n      void masterQueue.add(async () => {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start(); // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n\n        return await localReadQueue.onIdle().then(() => {\n          if (readQueue === localReadQueue) {\n            readQueue = null;\n          }\n        });\n      });\n      return await readPromise;\n    },\n\n    async writeLock() {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null;\n      return await createReleaseable(masterQueue, options);\n    }\n\n  };\n};\n\nconst defaultOptions = {\n  name: 'lock',\n  concurrency: Infinity,\n  timeout: 84600000,\n  singleProcess: false\n};\nexport default function createMortice(options) {\n  const opts = Object.assign({}, defaultOptions, options);\n\n  if (implementation == null) {\n    implementation = impl(opts);\n\n    if (implementation.isWorker !== true) {\n      // we are master, set up worker requests\n      implementation.addEventListener('requestReadLock', event => {\n        if (mutexes[event.data.name] == null) {\n          return;\n        }\n\n        void mutexes[event.data.name].readLock().then(async release => await event.data.handler().finally(() => release()));\n      });\n      implementation.addEventListener('requestWriteLock', async event => {\n        if (mutexes[event.data.name] == null) {\n          return;\n        }\n\n        void mutexes[event.data.name].writeLock().then(async release => await event.data.handler().finally(() => release()));\n      });\n    }\n  }\n\n  if (mutexes[opts.name] == null) {\n    mutexes[opts.name] = createMutex(opts.name, opts);\n  }\n\n  return mutexes[opts.name];\n}","map":{"version":3,"mappings":"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","names":["PQueue","pTimeout","impl","mutexes","implementation","createReleaseable","queue","options","res","p","Promise","resolve","add","milliseconds","timeout","createMutex","name","isWorker","readLock","writeLock","masterQueue","concurrency","readQueue","autoStart","localReadQueue","readPromise","start","onIdle","then","defaultOptions","Infinity","singleProcess","createMortice","opts","Object","assign","addEventListener","event","data","release","handler","finally"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\mortice\\src\\index.ts"],"sourcesContent":["import PQueue from 'p-queue'\nimport pTimeout from 'p-timeout'\nimport impl from './node.js'\n\nexport interface MorticeOptions {\n  name?: string\n  timeout?: number\n  concurrency?: number\n  singleProcess?: boolean\n}\n\nexport interface Mortice {\n  readLock: () => Promise<Release>\n  writeLock: () => Promise<Release>\n}\n\nexport interface Release {\n  (): void\n}\n\nexport interface MorticeImplementation {\n  isWorker: boolean\n  readLock: (name: string, options: MorticeOptions) => Mortice['readLock']\n  writeLock: (name: string, options: MorticeOptions) => Mortice['writeLock']\n}\n\nconst mutexes: Record<string, Mortice> = {}\nlet implementation: any\n\nasync function createReleaseable (queue: PQueue, options: Required<MorticeOptions>): Promise<Release> {\n  let res: (release: Release) => void\n\n  const p = new Promise<Release>((resolve) => {\n    res = resolve\n  })\n\n  void queue.add(async () => await pTimeout((async () => {\n    return await new Promise<void>((resolve) => {\n      res(() => {\n        resolve()\n      })\n    })\n  })(), {\n    milliseconds: options.timeout\n  }))\n\n  return await p\n}\n\nconst createMutex = (name: string, options: Required<MorticeOptions>): Mortice => {\n  if (implementation.isWorker === true) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options)\n    }\n  }\n\n  const masterQueue = new PQueue({ concurrency: 1 })\n  let readQueue: PQueue | null\n\n  return {\n    async readLock () {\n      // If there's already a read queue, just add the task to it\n      if (readQueue != null) {\n        return await createReleaseable(readQueue, options)\n      }\n\n      // Create a new read queue\n      readQueue = new PQueue({\n        concurrency: options.concurrency,\n        autoStart: false\n      })\n      const localReadQueue = readQueue\n\n      // Add the task to the read queue\n      const readPromise = createReleaseable(readQueue, options)\n\n      void masterQueue.add(async () => {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start()\n\n        // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n        return await localReadQueue.onIdle()\n          .then(() => {\n            if (readQueue === localReadQueue) {\n              readQueue = null\n            }\n          })\n      })\n\n      return await readPromise\n    },\n    async writeLock () {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null\n\n      return await createReleaseable(masterQueue, options)\n    }\n  }\n}\n\nconst defaultOptions = {\n  name: 'lock',\n  concurrency: Infinity,\n  timeout: 84600000,\n  singleProcess: false\n}\n\ninterface EventData {\n  name: string\n  handler: () => Promise<void>\n}\n\nexport default function createMortice (options?: MorticeOptions) {\n  const opts: Required<MorticeOptions> = Object.assign({}, defaultOptions, options)\n\n  if (implementation == null) {\n    implementation = impl(opts)\n\n    if (implementation.isWorker !== true) {\n      // we are master, set up worker requests\n      implementation.addEventListener('requestReadLock', (event: MessageEvent<EventData>) => {\n        if (mutexes[event.data.name] == null) {\n          return\n        }\n\n        void mutexes[event.data.name].readLock()\n          .then(async release => await event.data.handler().finally(() => release()))\n      })\n\n      implementation.addEventListener('requestWriteLock', async (event: MessageEvent<EventData>) => {\n        if (mutexes[event.data.name] == null) {\n          return\n        }\n\n        void mutexes[event.data.name].writeLock()\n          .then(async release => await event.data.handler().finally(() => release()))\n      })\n    }\n  }\n\n  if (mutexes[opts.name] == null) {\n    mutexes[opts.name] = createMutex(opts.name, opts)\n  }\n\n  return mutexes[opts.name]\n}\n"]},"metadata":{},"sourceType":"module"}