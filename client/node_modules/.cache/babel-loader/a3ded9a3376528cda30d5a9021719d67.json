{"ast":null,"code":"import { Uint8ArrayList } from 'uint8arraylist';\nimport * as lp from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport first from 'it-first';\nimport { abortableSource } from 'abortable-iterator';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { MAX_PROTOCOL_LENGTH } from './constants.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:mss');\nconst NewLine = uint8ArrayFromString('\\n');\nexport function encode(buffer) {\n  const list = new Uint8ArrayList(buffer, NewLine);\n  return lp.encode.single(list);\n}\n/**\n * `write` encodes and writes a single buffer\n */\n\nexport function write(writer, buffer) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const encoded = encode(buffer);\n\n  if (options.writeBytes === true) {\n    writer.push(encoded.subarray());\n  } else {\n    writer.push(encoded);\n  }\n}\n/**\n * `writeAll` behaves like `write`, except it encodes an array of items as a single write\n */\n\nexport function writeAll(writer, buffers) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const list = new Uint8ArrayList();\n\n  for (const buf of buffers) {\n    list.append(encode(buf));\n  }\n\n  if (options.writeBytes === true) {\n    writer.push(list.subarray());\n  } else {\n    writer.push(list);\n  }\n}\nexport async function read(reader, options) {\n  let byteLength = 1; // Read single byte chunks until the length is known\n\n  const varByteSource = {\n    [Symbol.asyncIterator]: () => varByteSource,\n    next: async () => await reader.next(byteLength)\n  };\n  let input = varByteSource; // If we have been passed an abort signal, wrap the input source in an abortable\n  // iterator that will throw if the operation is aborted\n\n  if (options?.signal != null) {\n    input = abortableSource(varByteSource, options.signal);\n  } // Once the length has been parsed, read chunk for that length\n\n\n  const onLength = l => {\n    byteLength = l;\n  };\n\n  const buf = await pipe(input, source => lp.decode(source, {\n    onLength,\n    maxDataLength: MAX_PROTOCOL_LENGTH\n  }), async source => await first(source));\n\n  if (buf == null || buf.length === 0) {\n    throw new CodeError('no buffer returned', 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n  }\n\n  if (buf.get(buf.byteLength - 1) !== NewLine[0]) {\n    log.error('Invalid mss message - missing newline - %s', buf.subarray());\n    throw new CodeError('missing newline', 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n  }\n\n  return buf.sublist(0, -1); // Remove newline\n}\nexport async function readString(reader, options) {\n  const buf = await read(reader, options);\n  return uint8ArrayToString(buf.subarray());\n}","map":{"version":3,"mappings":"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","names":["Uint8ArrayList","lp","pipe","CodeError","fromString","uint8ArrayFromString","first","abortableSource","toString","uint8ArrayToString","MAX_PROTOCOL_LENGTH","logger","log","NewLine","encode","buffer","list","single","write","writer","options","encoded","writeBytes","push","subarray","writeAll","buffers","buf","append","read","reader","byteLength","varByteSource","Symbol","asyncIterator","next","input","signal","onLength","l","source","decode","maxDataLength","length","get","error","sublist","readString"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\multistream-select\\src\\multistream.ts"],"sourcesContent":["\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport * as lp from 'it-length-prefixed'\nimport { pipe } from 'it-pipe'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport first from 'it-first'\nimport { abortableSource } from 'abortable-iterator'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { Pushable } from 'it-pushable'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Source } from 'it-stream-types'\nimport type { Reader } from 'it-reader'\nimport type { MultistreamSelectInit } from '.'\nimport { MAX_PROTOCOL_LENGTH } from './constants.js'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('libp2p:mss')\n\nconst NewLine = uint8ArrayFromString('\\n')\n\nexport function encode (buffer: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  const list = new Uint8ArrayList(buffer, NewLine)\n\n  return lp.encode.single(list)\n}\n\n/**\n * `write` encodes and writes a single buffer\n */\nexport function write (writer: Pushable<any>, buffer: Uint8Array | Uint8ArrayList, options: MultistreamSelectInit = {}): void {\n  const encoded = encode(buffer)\n\n  if (options.writeBytes === true) {\n    writer.push(encoded.subarray())\n  } else {\n    writer.push(encoded)\n  }\n}\n\n/**\n * `writeAll` behaves like `write`, except it encodes an array of items as a single write\n */\nexport function writeAll (writer: Pushable<any>, buffers: Uint8Array[], options: MultistreamSelectInit = {}): void {\n  const list = new Uint8ArrayList()\n\n  for (const buf of buffers) {\n    list.append(encode(buf))\n  }\n\n  if (options.writeBytes === true) {\n    writer.push(list.subarray())\n  } else {\n    writer.push(list)\n  }\n}\n\nexport async function read (reader: Reader, options?: AbortOptions): Promise<Uint8ArrayList> {\n  let byteLength = 1 // Read single byte chunks until the length is known\n  const varByteSource = { // No return impl - we want the reader to remain readable\n    [Symbol.asyncIterator]: () => varByteSource,\n    next: async () => await reader.next(byteLength)\n  }\n\n  let input: Source<Uint8ArrayList> = varByteSource\n\n  // If we have been passed an abort signal, wrap the input source in an abortable\n  // iterator that will throw if the operation is aborted\n  if (options?.signal != null) {\n    input = abortableSource(varByteSource, options.signal)\n  }\n\n  // Once the length has been parsed, read chunk for that length\n  const onLength = (l: number): void => {\n    byteLength = l\n  }\n\n  const buf = await pipe(\n    input,\n    (source) => lp.decode(source, { onLength, maxDataLength: MAX_PROTOCOL_LENGTH }),\n    async (source) => await first(source)\n  )\n\n  if (buf == null || buf.length === 0) {\n    throw new CodeError('no buffer returned', 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE')\n  }\n\n  if (buf.get(buf.byteLength - 1) !== NewLine[0]) {\n    log.error('Invalid mss message - missing newline - %s', buf.subarray())\n    throw new CodeError('missing newline', 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE')\n  }\n\n  return buf.sublist(0, -1) // Remove newline\n}\n\nexport async function readString (reader: Reader, options?: AbortOptions): Promise<string> {\n  const buf = await read(reader, options)\n\n  return uint8ArrayToString(buf.subarray())\n}\n"]},"metadata":{},"sourceType":"module"}