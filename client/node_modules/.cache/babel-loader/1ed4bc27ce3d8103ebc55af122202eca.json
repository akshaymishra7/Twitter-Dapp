{"ast":null,"code":"export const symbol = Symbol.for('@libp2p/connection');\nexport function isConnection(other) {\n  return other != null && Boolean(other[symbol]);\n}","map":{"version":3,"mappings":"AA8JA,OAAO,MAAMA,MAAM,GAAGC,MAAM,CAACC,GAAP,CAAW,oBAAX,CAAf;AAEP,OAAM,SAAUC,YAAV,CAAwBC,KAAxB,EAAkC;AACtC,SAAOA,KAAK,IAAI,IAAT,IAAiBC,OAAO,CAACD,KAAK,CAACJ,MAAD,CAAN,CAA/B;AACD","names":["symbol","Symbol","for","isConnection","other","Boolean"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\node_modules\\@libp2p\\interface-connection\\src\\index.ts"],"sourcesContent":["import type { Multiaddr } from '@multiformats/multiaddr'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type * as Status from './status.js'\nimport type { Duplex } from 'it-stream-types'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface ConnectionTimeline {\n  open: number\n  upgraded?: number\n  close?: number\n}\n\n/**\n * Outbound conections are opened by the local node, inbound streams are opened by the remote\n */\nexport type Direction = 'inbound' | 'outbound'\n\nexport interface ConnectionStat {\n  /**\n   * Outbound conections are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the connection\n   */\n  timeline: ConnectionTimeline\n\n  /**\n   * Once a multiplexer has been negotiated for this stream, it will be set on the stat object\n   */\n  multiplexer?: string\n\n  /**\n   * Once a connection encrypter has been negotiated for this stream, it will be set on the stat object\n   */\n  encryption?: string\n\n  /**\n   * The current status of the connection\n   */\n  status: keyof typeof Status\n}\n\nexport interface StreamTimeline {\n  open: number\n  close?: number\n}\n\nexport interface StreamStat {\n  /**\n   * Outbound streams are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the stream\n   */\n  timeline: StreamTimeline\n\n  /**\n   * Once a protocol has been negotiated for this stream, it will be set on the stat object\n   */\n  protocol?: string\n}\n\n/**\n * A Stream is a data channel between two peers that\n * can be written to and read from at both ends.\n *\n * It may be encrypted and multiplexed depending on the\n * configuration of the nodes.\n */\nexport interface Stream extends Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array> {\n  /**\n   * Closes the stream for **reading** *and* **writing**.\n   *\n   * Any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `CLOSE` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink and the source will return normally.\n   */\n  close: () => void\n\n  /**\n   * Closes the stream for **reading**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * This function is called automatically by the muxer when it receives a `CLOSE` message from the remote.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeRead: () => void\n\n  /**\n   * Closes the stream for **writing**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeWrite: () => void\n\n  /**\n   * Closes the stream for **reading** *and* **writing**. This should be called when a *local error* has occurred.\n   *\n   * Note, if called without an error any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `RESET` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink will return and the source will throw if an error is passed or return normally if not.\n   */\n  abort: (err: Error) => void\n\n  /**\n   * Closes the stream *immediately* for **reading** *and* **writing**. This should be called when a *remote error* has occurred.\n   *\n   * This function is called automatically by the muxer when it receives a `RESET` message from the remote.\n   *\n   * The sink will return and the source will throw.\n   */\n  reset: () => void\n\n  /**\n   * Unique identifier for a stream. Identifiers are not unique across muxers.\n   */\n  id: string\n\n  /**\n   * Stats about this stream\n   */\n  stat: StreamStat\n\n  /**\n   * User defined stream metadata\n   */\n  metadata: Record<string, any>\n}\n\n/**\n * A Connection is a high-level representation of a connection\n * to a remote peer that may have been secured by encryption and\n * multiplexed, depending on the configuration of the nodes\n * between which the connection is made.\n */\nexport interface Connection {\n  id: string\n  stat: ConnectionStat\n  remoteAddr: Multiaddr\n  remotePeer: PeerId\n  tags: string[]\n  streams: Stream[]\n\n  newStream: (multicodecs: string | string[], options?: AbortOptions) => Promise<Stream>\n  addStream: (stream: Stream) => void\n  removeStream: (id: string) => void\n  close: () => Promise<void>\n}\n\nexport const symbol = Symbol.for('@libp2p/connection')\n\nexport function isConnection (other: any): other is Connection {\n  return other != null && Boolean(other[symbol])\n}\n\n/**\n * @deprecated Please use the version from `@libp2p/interface-connection-gater` instead, this will be removed in a future release\n */\nexport interface ConnectionGater {\n  /**\n   * denyDialMultiaddr tests whether we're permitted to Dial the\n   * specified peer.\n   *\n   * This is called by the dialer.connectToPeer implementation before\n   * dialling a peer.\n   *\n   * Return true to prevent dialing the passed peer.\n   */\n  denyDialPeer: (peerId: PeerId) => Promise<boolean>\n\n  /**\n   * denyDialMultiaddr tests whether we're permitted to dial the specified\n   * multiaddr for the given peer.\n   *\n   * This is called by the dialer.connectToPeer implementation after it has\n   * resolved the peer's addrs, and prior to dialling each.\n   *\n   * Return true to prevent dialing the passed peer on the passed multiaddr.\n   */\n  denyDialMultiaddr: (peerId: PeerId, multiaddr: Multiaddr) => Promise<boolean>\n\n  /**\n   * denyInboundConnection tests whether an incipient inbound connection is allowed.\n   *\n   * This is called by the upgrader, or by the transport directly (e.g. QUIC,\n   * Bluetooth), straight after it has accepted a connection from its socket.\n   *\n   * Return true to deny the incoming passed connection.\n   */\n  denyInboundConnection: (maConn: MultiaddrConnection) => Promise<boolean>\n\n  /**\n   * denyOutboundConnection tests whether an incipient outbound connection is allowed.\n   *\n   * This is called by the upgrader, or by the transport directly (e.g. QUIC,\n   * Bluetooth), straight after it has created a connection with its socket.\n   *\n   * Return true to deny the incoming passed connection.\n   */\n  denyOutboundConnection: (peerId: PeerId, maConn: MultiaddrConnection) => Promise<boolean>\n\n  /**\n   * denyInboundEncryptedConnection tests whether a given connection, now encrypted,\n   * is allowed.\n   *\n   * This is called by the upgrader, after it has performed the security\n   * handshake, and before it negotiates the muxer, or by the directly by the\n   * transport, at the exact same checkpoint.\n   *\n   * Return true to deny the passed secured connection.\n   */\n  denyInboundEncryptedConnection: (peerId: PeerId, maConn: MultiaddrConnection) => Promise<boolean>\n\n  /**\n   * denyOutboundEncryptedConnection tests whether a given connection, now encrypted,\n   * is allowed.\n   *\n   * This is called by the upgrader, after it has performed the security\n   * handshake, and before it negotiates the muxer, or by the directly by the\n   * transport, at the exact same checkpoint.\n   *\n   * Return true to deny the passed secured connection.\n   */\n  denyOutboundEncryptedConnection: (peerId: PeerId, maConn: MultiaddrConnection) => Promise<boolean>\n\n  /**\n   * denyInboundUpgradedConnection tests whether a fully capable connection is allowed.\n   *\n   * This is called after encryption has been negotiated and the connection has been\n   * multiplexed, if a multiplexer is configured.\n   *\n   * Return true to deny the passed upgraded connection.\n   */\n  denyInboundUpgradedConnection: (peerId: PeerId, maConn: MultiaddrConnection) => Promise<boolean>\n\n  /**\n   * denyOutboundUpgradedConnection tests whether a fully capable connection is allowed.\n   *\n   * This is called after encryption has been negotiated and the connection has been\n   * multiplexed, if a multiplexer is configured.\n   *\n   * Return true to deny the passed upgraded connection.\n   */\n  denyOutboundUpgradedConnection: (peerId: PeerId, maConn: MultiaddrConnection) => Promise<boolean>\n\n  /**\n   * Used by the address book to filter passed addresses.\n   *\n   * Return true to allow storing the passed multiaddr for the passed peer.\n   */\n  filterMultiaddrForPeer: (peer: PeerId, multiaddr: Multiaddr) => Promise<boolean>\n}\n\nexport interface ConnectionProtector {\n\n  /**\n   * Takes a given Connection and creates a private encryption stream\n   * between its two peers from the PSK the Protector instance was\n   * created with.\n   */\n  protect: (connection: MultiaddrConnection) => Promise<MultiaddrConnection>\n}\n\nexport interface MultiaddrConnectionTimeline {\n  open: number\n  upgraded?: number\n  close?: number\n}\n\n/**\n * A MultiaddrConnection is returned by transports after dialing\n * a peer. It is a low-level primitive and is the raw connection\n * without encryption or stream multiplexing.\n */\nexport interface MultiaddrConnection extends Duplex<Uint8Array> {\n  close: (err?: Error) => Promise<void>\n  remoteAddr: Multiaddr\n  timeline: MultiaddrConnectionTimeline\n}\n"]},"metadata":{},"sourceType":"module"}