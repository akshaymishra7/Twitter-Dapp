{"ast":null,"code":"import _get from 'just-safe-get';\nimport debug from 'debug';\nimport errCode from 'err-code';\nimport * as migrator from 'ipfs-repo-migrations';\nimport bytes from 'bytes';\nimport merge from 'merge-options';\nimport * as CONSTANTS from './constants.js';\nimport { version } from './version.js';\nimport { config } from './config.js';\nimport { spec } from './spec.js';\nimport { apiAddr } from './api-addr.js';\nimport { createIdStore } from './idstore.js';\nimport defaultOptions from './default-options.js';\nimport defaultDatastore from './default-datastore.js';\nimport * as ERRORS from './errors.js';\nimport { PinManager } from './pin-manager.js';\nimport { createPinnedBlockstore } from './pinned-blockstore.js'; // @ts-ignore - no types\n\nimport mortice from 'mortice';\nimport { gc } from './gc.js';\nconst log = debug('ipfs:repo');\nconst noLimit = Number.MAX_SAFE_INTEGER;\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate';\n/**\n * @typedef {import('./types').Options} Options\n * @typedef {import('./types').RepoLock} RepoLock\n * @typedef {import('./types').LockCloser} LockCloser\n * @typedef {import('./types').GCLock} GCLock\n * @typedef {import('./types').Stat} Stat\n * @typedef {import('./types').Config} Config\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').Backends} Backends\n * @typedef {import('./types').IPFSRepo} IPFSRepo\n */\n\n/**\n * IPFSRepo implements all required functionality to read and write to an ipfs repo.\n */\n\nclass Repo {\n  /**\n   * @param {string} path - Where this repo is stored\n   * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n   * @param {Backends} backends - backends used by this repo\n   * @param {Partial<Options>} [options] - Configuration\n   */\n  constructor(path, loadCodec, backends, options) {\n    if (typeof path !== 'string') {\n      throw new Error('missing repo path');\n    }\n\n    if (typeof loadCodec !== 'function') {\n      throw new Error('missing codec loader');\n    }\n    /** @type {Options} */\n\n\n    this.options = merge(defaultOptions, options);\n    this.closed = true;\n    this.path = path;\n    this.root = backends.root;\n    this.datastore = backends.datastore;\n    this.keys = backends.keys;\n    const blockstore = backends.blocks;\n    const pinstore = backends.pins;\n    this.pins = new PinManager({\n      pinstore,\n      blockstore,\n      loadCodec\n    }); // this blockstore will not delete blocks that have been pinned\n\n    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore); // this blockstore will extract blocks from multihashes with the identity codec\n\n    this.blocks = createIdStore(pinnedBlockstore);\n    this.version = version(this.root);\n    this.config = config(this.root);\n    this.spec = spec(this.root);\n    this.apiAddr = apiAddr(this.root);\n    /** @type {GCLock} */\n\n    this.gcLock = mortice({\n      name: path,\n      singleProcess: this.options.repoOwner !== false\n    });\n    this.gc = gc({\n      gcLock: this.gcLock,\n      pins: this.pins,\n      blockstore: this.blocks,\n      root: this.root,\n      loadCodec\n    });\n  }\n  /**\n   * Initialize a new repo.\n   *\n   * @param {import('./types').Config} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n\n\n  async init(config) {\n    log('initializing at: %s', this.path);\n    await this._openRoot();\n    await this.config.replace(buildConfig(config));\n    await this.spec.set(buildDatastoreSpec(config));\n    await this.version.set(CONSTANTS.repoVersion);\n  }\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  async isInitialized() {\n    if (!this.closed) {\n      // repo is open, must be initialized\n      return true;\n    }\n\n    try {\n      // have to open the root datastore in the browser before\n      // we can check whether it's been initialized\n      await this._openRoot();\n      await this._checkInitialized();\n      await this.root.close();\n      return true;\n    } catch (\n    /** @type {any} */\n    err) {\n      // FIXME: do not use exceptions for flow control\n      return false;\n    }\n  }\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async open() {\n    if (!this.closed) {\n      throw errCode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN);\n    }\n\n    log('opening at: %s', this.path); // check if the repo is already initialized\n\n    try {\n      await this._openRoot();\n      await this._checkInitialized();\n      this._lockfile = await this._openLock();\n      log('acquired repo.lock');\n      const isCompatible = await this.version.check(CONSTANTS.repoVersion);\n\n      if (!isCompatible) {\n        if (await this._isAutoMigrationEnabled()) {\n          await this._migrate(CONSTANTS.repoVersion, {\n            root: this.root,\n            datastore: this.datastore,\n            pins: this.pins.pinstore,\n            blocks: this.pins.blockstore,\n            keys: this.keys\n          });\n        } else {\n          throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.');\n        }\n      }\n\n      log('creating datastore');\n      await this.datastore.open();\n      log('creating blocks');\n      await this.blocks.open();\n      log('creating keystore');\n      await this.keys.open();\n      log('creating pins');\n      await this.pins.pinstore.open();\n      this.closed = false;\n      log('all opened');\n    } catch (\n    /** @type {any} */\n    err) {\n      if (this._lockfile) {\n        try {\n          await this._closeLock();\n          this._lockfile = null;\n        } catch (\n        /** @type {any} */\n        err2) {\n          log('error removing lock', err2);\n        }\n      }\n\n      throw err;\n    }\n  }\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   *\n   * @private\n   */\n\n\n  async _openRoot() {\n    try {\n      await this.root.open();\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.message !== 'Already open') {\n        throw err;\n      }\n    }\n  }\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @private\n   * @returns {Promise<LockCloser>}\n   */\n\n\n  async _openLock() {\n    const lockfile = await this.options.repoLock.lock(this.path);\n\n    if (typeof lockfile.close !== 'function') {\n      throw errCode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION');\n    }\n\n    return lockfile;\n  }\n  /**\n   * Closes the lock on the repo\n   *\n   * @private\n   */\n\n\n  _closeLock() {\n    return this._lockfile && this._lockfile.close();\n  }\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @private\n   */\n\n\n  async _checkInitialized() {\n    log('init check');\n    let config;\n\n    try {\n      [config] = await Promise.all([this.config.exists(), this.spec.exists(), this.version.exists()]);\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: this.path\n        });\n      }\n\n      throw err;\n    }\n\n    if (!config) {\n      throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: this.path\n      });\n    }\n  }\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async close() {\n    if (this.closed) {\n      throw errCode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED);\n    }\n\n    log('closing at: %s', this.path);\n\n    try {\n      // Delete api, ignoring irrelevant errors\n      await this.apiAddr.delete();\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n        throw err;\n      }\n    }\n\n    await Promise.all([this.root, this.blocks, this.keys, this.datastore, this.pins.pinstore].map(store => store && store.close()));\n    log('unlocking');\n    this.closed = true;\n    await this._closeLock();\n  }\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  exists() {\n    return this.version.exists();\n  }\n  /**\n   * Get repo status.\n   *\n   * @returns {Promise<Stat>}\n   */\n\n\n  async stat() {\n    if (this.datastore && this.keys) {\n      const [storageMax, blocks, version, datastore, keys] = await Promise.all([this._storageMaxStat(), this._blockStat(), this.version.get(), getSize(this.datastore), getSize(this.keys)]);\n      const size = blocks.size + datastore + keys;\n      return {\n        repoPath: this.path,\n        storageMax,\n        version: version,\n        numObjects: blocks.count,\n        repoSize: size\n      };\n    }\n\n    throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n      path: this.path\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  async _isAutoMigrationEnabled() {\n    if (this.options.autoMigrate !== undefined) {\n      return this.options.autoMigrate;\n    } // TODO we need to figure out the priority here, between repo options and config.\n\n\n    let autoMigrateConfig;\n\n    try {\n      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);\n    } catch (\n    /** @type {any} */\n    e) {\n      if (e.code === ERRORS.NotFoundError.code) {\n        autoMigrateConfig = true; // Config's default value is True\n      } else {\n        throw e;\n      }\n    }\n\n    return autoMigrateConfig;\n  }\n  /**\n   * Internal migration\n   *\n   * @private\n   * @param {number} toVersion\n   * @param {Backends} backends\n   */\n\n\n  async _migrate(toVersion, backends) {\n    const currentRepoVersion = await this.version.get();\n\n    if (currentRepoVersion > toVersion) {\n      log(`reverting to version ${toVersion}`);\n      return migrator.revert(this.path, backends, this.options, toVersion, {\n        ignoreLock: true,\n        onProgress: this.options.onMigrationProgress\n      });\n    } else {\n      log(`migrating to version ${toVersion}`);\n      return migrator.migrate(this.path, backends, this.options, toVersion, {\n        ignoreLock: true,\n        onProgress: this.options.onMigrationProgress\n      });\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  async _storageMaxStat() {\n    try {\n      const max =\n      /** @type {number} */\n      await this.config.get('Datastore.StorageMax');\n      return BigInt(bytes(max));\n    } catch (\n    /** @type {any} */\n    err) {\n      return BigInt(noLimit);\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  async _blockStat() {\n    let count = BigInt(0);\n    let size = BigInt(0);\n\n    if (this.blocks) {\n      for await (const {\n        key,\n        value\n      } of this.blocks.query({})) {\n        count += BigInt(1);\n        size += BigInt(value.byteLength);\n        size += BigInt(key.bytes.byteLength);\n      }\n    }\n\n    return {\n      count,\n      size\n    };\n  }\n\n}\n/**\n * @param {Datastore} datastore\n */\n\n\nasync function getSize(datastore) {\n  let sum = BigInt(0);\n\n  for await (const block of datastore.query({})) {\n    sum += BigInt(block.value.byteLength);\n    sum += BigInt(block.key.uint8Array().byteLength);\n  }\n\n  return sum;\n}\n/**\n * @param {string} path - Where this repo is stored\n * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n * @param {import('./types').Backends} backends - backends used by this repo\n * @param {Partial<Options>} [options] - Configuration\n * @returns {import('./types').IPFSRepo}\n */\n\n\nexport function createRepo(path, loadCodec, backends, options) {\n  return new Repo(path, loadCodec, backends, options);\n}\n/**\n * @param {import('./types').Config} _config\n */\n\nfunction buildConfig(_config) {\n  _config.Datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore'));\n  return _config;\n}\n/**\n * @param {import('./types').Config} _config\n */\n\n\nfunction buildDatastoreSpec(_config) {\n  /** @type { {type: string, mounts: Array<{mountpoint: string, type: string, prefix: string, child: {type: string, path: 'string', sync: boolean, shardFunc: string}}>}} */\n  const spec = { ...defaultDatastore.Spec,\n    ..._get(_config, 'Datastore.Spec')\n  };\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map(mounting => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  };\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-repo/src/index.js"],"names":["_get","debug","errCode","migrator","bytes","merge","CONSTANTS","version","config","spec","apiAddr","createIdStore","defaultOptions","defaultDatastore","ERRORS","PinManager","createPinnedBlockstore","mortice","gc","log","noLimit","Number","MAX_SAFE_INTEGER","AUTO_MIGRATE_CONFIG_KEY","Repo","constructor","path","loadCodec","backends","options","Error","closed","root","datastore","keys","blockstore","blocks","pinstore","pins","pinnedBlockstore","gcLock","name","singleProcess","repoOwner","init","_openRoot","replace","buildConfig","set","buildDatastoreSpec","repoVersion","isInitialized","_checkInitialized","close","err","open","ERR_REPO_ALREADY_OPEN","_lockfile","_openLock","isCompatible","check","_isAutoMigrationEnabled","_migrate","InvalidRepoVersionError","_closeLock","err2","message","lockfile","repoLock","lock","Promise","all","exists","code","ERR_REPO_NOT_INITIALIZED","ERR_REPO_ALREADY_CLOSED","delete","startsWith","map","store","stat","storageMax","_storageMaxStat","_blockStat","get","getSize","size","repoPath","numObjects","count","repoSize","autoMigrate","undefined","autoMigrateConfig","e","NotFoundError","toVersion","currentRepoVersion","revert","ignoreLock","onProgress","onMigrationProgress","migrate","max","BigInt","key","value","query","byteLength","sum","block","uint8Array","createRepo","_config","Datastore","Object","assign","Spec","type","mounts","mounting","mountpoint","child","shardFunc"],"mappings":"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","sourcesContent":["import _get from 'just-safe-get'\nimport debug from 'debug'\nimport errCode from 'err-code'\nimport * as migrator from 'ipfs-repo-migrations'\nimport bytes from 'bytes'\nimport merge from 'merge-options'\nimport * as CONSTANTS from './constants.js'\nimport { version } from './version.js'\nimport { config } from './config.js'\nimport { spec } from './spec.js'\nimport { apiAddr } from './api-addr.js'\nimport { createIdStore } from './idstore.js'\nimport defaultOptions from './default-options.js'\nimport defaultDatastore from './default-datastore.js'\nimport * as ERRORS from './errors.js'\nimport { PinManager } from './pin-manager.js'\nimport { createPinnedBlockstore } from './pinned-blockstore.js'\n// @ts-ignore - no types\nimport mortice from 'mortice'\nimport { gc } from './gc.js'\n\nconst log = debug('ipfs:repo')\n\nconst noLimit = Number.MAX_SAFE_INTEGER\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate'\n\n/**\n * @typedef {import('./types').Options} Options\n * @typedef {import('./types').RepoLock} RepoLock\n * @typedef {import('./types').LockCloser} LockCloser\n * @typedef {import('./types').GCLock} GCLock\n * @typedef {import('./types').Stat} Stat\n * @typedef {import('./types').Config} Config\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').Backends} Backends\n * @typedef {import('./types').IPFSRepo} IPFSRepo\n */\n\n/**\n * IPFSRepo implements all required functionality to read and write to an ipfs repo.\n */\nclass Repo {\n  /**\n   * @param {string} path - Where this repo is stored\n   * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n   * @param {Backends} backends - backends used by this repo\n   * @param {Partial<Options>} [options] - Configuration\n   */\n  constructor (path, loadCodec, backends, options) {\n    if (typeof path !== 'string') {\n      throw new Error('missing repo path')\n    }\n\n    if (typeof loadCodec !== 'function') {\n      throw new Error('missing codec loader')\n    }\n\n    /** @type {Options} */\n    this.options = merge(defaultOptions, options)\n    this.closed = true\n    this.path = path\n    this.root = backends.root\n    this.datastore = backends.datastore\n    this.keys = backends.keys\n\n    const blockstore = backends.blocks\n    const pinstore = backends.pins\n\n    this.pins = new PinManager({ pinstore, blockstore, loadCodec })\n\n    // this blockstore will not delete blocks that have been pinned\n    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore)\n\n    // this blockstore will extract blocks from multihashes with the identity codec\n    this.blocks = createIdStore(pinnedBlockstore)\n\n    this.version = version(this.root)\n    this.config = config(this.root)\n    this.spec = spec(this.root)\n    this.apiAddr = apiAddr(this.root)\n\n    /** @type {GCLock} */\n    this.gcLock = mortice({\n      name: path,\n      singleProcess: this.options.repoOwner !== false\n    })\n\n    this.gc = gc({ gcLock: this.gcLock, pins: this.pins, blockstore: this.blocks, root: this.root, loadCodec })\n  }\n\n  /**\n   * Initialize a new repo.\n   *\n   * @param {import('./types').Config} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n  async init (config) {\n    log('initializing at: %s', this.path)\n    await this._openRoot()\n    await this.config.replace(buildConfig(config))\n    await this.spec.set(buildDatastoreSpec(config))\n    await this.version.set(CONSTANTS.repoVersion)\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @returns {Promise<boolean>}\n   */\n  async isInitialized () {\n    if (!this.closed) {\n      // repo is open, must be initialized\n      return true\n    }\n\n    try {\n      // have to open the root datastore in the browser before\n      // we can check whether it's been initialized\n      await this._openRoot()\n      await this._checkInitialized()\n      await this.root.close()\n\n      return true\n    } catch (/** @type {any} */ err) {\n      // FIXME: do not use exceptions for flow control\n      return false\n    }\n  }\n\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n  async open () {\n    if (!this.closed) {\n      throw errCode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN)\n    }\n    log('opening at: %s', this.path)\n\n    // check if the repo is already initialized\n    try {\n      await this._openRoot()\n      await this._checkInitialized()\n\n      this._lockfile = await this._openLock()\n      log('acquired repo.lock')\n\n      const isCompatible = await this.version.check(CONSTANTS.repoVersion)\n\n      if (!isCompatible) {\n        if (await this._isAutoMigrationEnabled()) {\n          await this._migrate(CONSTANTS.repoVersion, {\n            root: this.root,\n            datastore: this.datastore,\n            pins: this.pins.pinstore,\n            blocks: this.pins.blockstore,\n            keys: this.keys\n          })\n        } else {\n          throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.')\n        }\n      }\n\n      log('creating datastore')\n      await this.datastore.open()\n\n      log('creating blocks')\n      await this.blocks.open()\n\n      log('creating keystore')\n      await this.keys.open()\n\n      log('creating pins')\n      await this.pins.pinstore.open()\n\n      this.closed = false\n      log('all opened')\n    } catch (/** @type {any} */ err) {\n      if (this._lockfile) {\n        try {\n          await this._closeLock()\n          this._lockfile = null\n        } catch (/** @type {any} */ err2) {\n          log('error removing lock', err2)\n        }\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   *\n   * @private\n   */\n  async _openRoot () {\n    try {\n      await this.root.open()\n    } catch (/** @type {any} */ err) {\n      if (err.message !== 'Already open') {\n        throw err\n      }\n    }\n  }\n\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @private\n   * @returns {Promise<LockCloser>}\n   */\n  async _openLock () {\n    const lockfile = await this.options.repoLock.lock(this.path)\n\n    if (typeof lockfile.close !== 'function') {\n      throw errCode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION')\n    }\n\n    return lockfile\n  }\n\n  /**\n   * Closes the lock on the repo\n   *\n   * @private\n   */\n  _closeLock () {\n    return this._lockfile && this._lockfile.close()\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @private\n   */\n  async _checkInitialized () {\n    log('init check')\n    let config\n    try {\n      [config] = await Promise.all([\n        this.config.exists(),\n        this.spec.exists(),\n        this.version.exists()\n      ])\n    } catch (/** @type {any} */ err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: this.path\n        })\n      }\n\n      throw err\n    }\n\n    if (!config) {\n      throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: this.path\n      })\n    }\n  }\n\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this.closed) {\n      throw errCode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED)\n    }\n    log('closing at: %s', this.path)\n\n    try {\n      // Delete api, ignoring irrelevant errors\n      await this.apiAddr.delete()\n    } catch (/** @type {any} */ err) {\n      if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n        throw err\n      }\n    }\n\n    await Promise.all([\n      this.root,\n      this.blocks,\n      this.keys,\n      this.datastore,\n      this.pins.pinstore\n    ].map((store) => store && store.close()))\n\n    log('unlocking')\n    this.closed = true\n    await this._closeLock()\n  }\n\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<boolean>}\n   */\n  exists () {\n    return this.version.exists()\n  }\n\n  /**\n   * Get repo status.\n   *\n   * @returns {Promise<Stat>}\n   */\n  async stat () {\n    if (this.datastore && this.keys) {\n      const [storageMax, blocks, version, datastore, keys] = await Promise.all([\n        this._storageMaxStat(),\n        this._blockStat(),\n        this.version.get(),\n        getSize(this.datastore),\n        getSize(this.keys)\n      ])\n      const size = blocks.size + datastore + keys\n\n      return {\n        repoPath: this.path,\n        storageMax,\n        version: version,\n        numObjects: blocks.count,\n        repoSize: size\n      }\n    }\n    throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n      path: this.path\n    })\n  }\n\n  /**\n   * @private\n   */\n  async _isAutoMigrationEnabled () {\n    if (this.options.autoMigrate !== undefined) {\n      return this.options.autoMigrate\n    }\n\n    // TODO we need to figure out the priority here, between repo options and config.\n    let autoMigrateConfig\n    try {\n      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY)\n    } catch (/** @type {any} */ e) {\n      if (e.code === ERRORS.NotFoundError.code) {\n        autoMigrateConfig = true // Config's default value is True\n      } else {\n        throw e\n      }\n    }\n\n    return autoMigrateConfig\n  }\n\n  /**\n   * Internal migration\n   *\n   * @private\n   * @param {number} toVersion\n   * @param {Backends} backends\n   */\n  async _migrate (toVersion, backends) {\n    const currentRepoVersion = await this.version.get()\n\n    if (currentRepoVersion > toVersion) {\n      log(`reverting to version ${toVersion}`)\n      return migrator.revert(this.path, backends, this.options, toVersion, {\n        ignoreLock: true,\n        onProgress: this.options.onMigrationProgress\n      })\n    } else {\n      log(`migrating to version ${toVersion}`)\n      return migrator.migrate(this.path, backends, this.options, toVersion, {\n        ignoreLock: true,\n        onProgress: this.options.onMigrationProgress\n      })\n    }\n  }\n\n  /**\n   * @private\n   */\n  async _storageMaxStat () {\n    try {\n      const max = /** @type {number} */(await this.config.get('Datastore.StorageMax'))\n      return BigInt(bytes(max))\n    } catch (/** @type {any} */ err) {\n      return BigInt(noLimit)\n    }\n  }\n\n  /**\n   * @private\n   */\n  async _blockStat () {\n    let count = BigInt(0)\n    let size = BigInt(0)\n\n    if (this.blocks) {\n      for await (const { key, value } of this.blocks.query({})) {\n        count += BigInt(1)\n        size += BigInt(value.byteLength)\n        size += BigInt(key.bytes.byteLength)\n      }\n    }\n\n    return { count, size }\n  }\n}\n\n/**\n * @param {Datastore} datastore\n */\nasync function getSize (datastore) {\n  let sum = BigInt(0)\n  for await (const block of datastore.query({})) {\n    sum += BigInt(block.value.byteLength)\n    sum += BigInt(block.key.uint8Array().byteLength)\n  }\n  return sum\n}\n\n/**\n * @param {string} path - Where this repo is stored\n * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n * @param {import('./types').Backends} backends - backends used by this repo\n * @param {Partial<Options>} [options] - Configuration\n * @returns {import('./types').IPFSRepo}\n */\nexport function createRepo (path, loadCodec, backends, options) {\n  return new Repo(path, loadCodec, backends, options)\n}\n\n/**\n * @param {import('./types').Config} _config\n */\nfunction buildConfig (_config) {\n  _config.Datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore'))\n\n  return _config\n}\n\n/**\n * @param {import('./types').Config} _config\n */\nfunction buildDatastoreSpec (_config) {\n  /** @type { {type: string, mounts: Array<{mountpoint: string, type: string, prefix: string, child: {type: string, path: 'string', sync: boolean, shardFunc: string}}>}} */\n  const spec = {\n    ...defaultDatastore.Spec,\n    ..._get(_config, 'Datastore.Spec')\n  }\n\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map((mounting) => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  }\n}\n"]},"metadata":{},"sourceType":"module"}