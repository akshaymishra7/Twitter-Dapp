{"ast":null,"code":"import { CodeError } from '@libp2p/interfaces/errors';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\n/**\n * Checks a record and ensures it is still valid.\n * It runs the needed validators.\n * If verification fails the returned Promise will reject with the error.\n */\n\nexport async function verifyRecord(validators, record) {\n  const key = record.key;\n  const keyString = uint8ArrayToString(key);\n  const parts = keyString.split('/');\n\n  if (parts.length < 3) {\n    // No validator available\n    return;\n  }\n\n  const validator = validators[parts[1].toString()];\n\n  if (validator == null) {\n    const errMsg = 'Invalid record keytype';\n    throw new CodeError(errMsg, 'ERR_INVALID_RECORD_KEY_TYPE');\n  }\n\n  await validator(key, record.value);\n}\n/**\n * Validator for public key records.\n * Verifies that the passed in record value is the PublicKey\n * that matches the passed in key.\n * If validation fails the returned Promise will reject with the error.\n *\n * @param {Uint8Array} key - A valid key is of the form `'/pk/<keymultihash>'`\n * @param {Uint8Array} publicKey - The public key to validate against (protobuf encoded).\n */\n\nconst validatePublicKeyRecord = async (key, publicKey) => {\n  if (!(key instanceof Uint8Array)) {\n    throw new CodeError('\"key\" must be a Uint8Array', 'ERR_INVALID_RECORD_KEY_NOT_BUFFER');\n  }\n\n  if (key.byteLength < 5) {\n    throw new CodeError('invalid public key record', 'ERR_INVALID_RECORD_KEY_TOO_SHORT');\n  }\n\n  const prefix = uint8ArrayToString(key.subarray(0, 4));\n\n  if (prefix !== '/pk/') {\n    throw new CodeError('key was not prefixed with /pk/', 'ERR_INVALID_RECORD_KEY_BAD_PREFIX');\n  }\n\n  const keyhash = key.slice(4);\n  const publicKeyHash = await sha256.digest(publicKey);\n\n  if (!uint8ArrayEquals(keyhash, publicKeyHash.bytes)) {\n    throw new CodeError('public key does not match passed in key', 'ERR_INVALID_RECORD_HASH_MISMATCH');\n  }\n};\n\nexport const validators = {\n  pk: validatePublicKeyRecord\n};","map":{"version":3,"mappings":"AAAA,SAASA,SAAT,QAA0B,2BAA1B;AACA,SAASC,QAAQ,IAAIC,kBAArB,QAA+C,uBAA/C;AAGA,SAASC,MAAT,QAAuB,0BAAvB;AACA,SAASC,MAAM,IAAIC,gBAAnB,QAA2C,oBAA3C;AAEA;;;;;;AAKA,OAAO,eAAeC,YAAf,CAA6BC,UAA7B,EAAqDC,MAArD,EAAyE;AAC9E,QAAMC,GAAG,GAAGD,MAAM,CAACC,GAAnB;AACA,QAAMC,SAAS,GAAGR,kBAAkB,CAACO,GAAD,CAApC;AACA,QAAME,KAAK,GAAGD,SAAS,CAACE,KAAV,CAAgB,GAAhB,CAAd;;AAEA,MAAID,KAAK,CAACE,MAAN,GAAe,CAAnB,EAAsB;AACpB;AACA;AACD;;AAED,QAAMC,SAAS,GAAGP,UAAU,CAACI,KAAK,CAAC,CAAD,CAAL,CAASV,QAAT,EAAD,CAA5B;;AAEA,MAAIa,SAAS,IAAI,IAAjB,EAAuB;AACrB,UAAMC,MAAM,GAAG,wBAAf;AAEA,UAAM,IAAIf,SAAJ,CAAce,MAAd,EAAsB,6BAAtB,CAAN;AACD;;AAED,QAAMD,SAAS,CAACL,GAAD,EAAMD,MAAM,CAACQ,KAAb,CAAf;AACD;AAED;;;;;;;;;;AASA,MAAMC,uBAAuB,GAAG,OAAOR,GAAP,EAAwBS,SAAxB,KAAgE;AAC9F,MAAI,EAAET,GAAG,YAAYU,UAAjB,CAAJ,EAAkC;AAChC,UAAM,IAAInB,SAAJ,CAAc,4BAAd,EAA4C,mCAA5C,CAAN;AACD;;AAED,MAAIS,GAAG,CAACW,UAAJ,GAAiB,CAArB,EAAwB;AACtB,UAAM,IAAIpB,SAAJ,CAAc,2BAAd,EAA2C,kCAA3C,CAAN;AACD;;AAED,QAAMqB,MAAM,GAAGnB,kBAAkB,CAACO,GAAG,CAACa,QAAJ,CAAa,CAAb,EAAgB,CAAhB,CAAD,CAAjC;;AAEA,MAAID,MAAM,KAAK,MAAf,EAAuB;AACrB,UAAM,IAAIrB,SAAJ,CAAc,gCAAd,EAAgD,mCAAhD,CAAN;AACD;;AAED,QAAMuB,OAAO,GAAGd,GAAG,CAACe,KAAJ,CAAU,CAAV,CAAhB;AAEA,QAAMC,aAAa,GAAG,MAAMtB,MAAM,CAACuB,MAAP,CAAcR,SAAd,CAA5B;;AAEA,MAAI,CAACb,gBAAgB,CAACkB,OAAD,EAAUE,aAAa,CAACE,KAAxB,CAArB,EAAqD;AACnD,UAAM,IAAI3B,SAAJ,CAAc,yCAAd,EAAyD,kCAAzD,CAAN;AACD;AACF,CAtBD;;AAwBA,OAAO,MAAMO,UAAU,GAAe;AACpCqB,IAAE,EAAEX;AADgC,CAA/B","names":["CodeError","toString","uint8ArrayToString","sha256","equals","uint8ArrayEquals","verifyRecord","validators","record","key","keyString","parts","split","length","validator","errMsg","value","validatePublicKeyRecord","publicKey","Uint8Array","byteLength","prefix","subarray","keyhash","slice","publicKeyHash","digest","bytes","pk"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\record\\src\\validators.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { Libp2pRecord } from './index.js'\nimport type { Validators } from '@libp2p/interface-dht'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\n\n/**\n * Checks a record and ensures it is still valid.\n * It runs the needed validators.\n * If verification fails the returned Promise will reject with the error.\n */\nexport async function verifyRecord (validators: Validators, record: Libp2pRecord): Promise<void> {\n  const key = record.key\n  const keyString = uint8ArrayToString(key)\n  const parts = keyString.split('/')\n\n  if (parts.length < 3) {\n    // No validator available\n    return\n  }\n\n  const validator = validators[parts[1].toString()]\n\n  if (validator == null) {\n    const errMsg = 'Invalid record keytype'\n\n    throw new CodeError(errMsg, 'ERR_INVALID_RECORD_KEY_TYPE')\n  }\n\n  await validator(key, record.value)\n}\n\n/**\n * Validator for public key records.\n * Verifies that the passed in record value is the PublicKey\n * that matches the passed in key.\n * If validation fails the returned Promise will reject with the error.\n *\n * @param {Uint8Array} key - A valid key is of the form `'/pk/<keymultihash>'`\n * @param {Uint8Array} publicKey - The public key to validate against (protobuf encoded).\n */\nconst validatePublicKeyRecord = async (key: Uint8Array, publicKey: Uint8Array): Promise<void> => {\n  if (!(key instanceof Uint8Array)) {\n    throw new CodeError('\"key\" must be a Uint8Array', 'ERR_INVALID_RECORD_KEY_NOT_BUFFER')\n  }\n\n  if (key.byteLength < 5) {\n    throw new CodeError('invalid public key record', 'ERR_INVALID_RECORD_KEY_TOO_SHORT')\n  }\n\n  const prefix = uint8ArrayToString(key.subarray(0, 4))\n\n  if (prefix !== '/pk/') {\n    throw new CodeError('key was not prefixed with /pk/', 'ERR_INVALID_RECORD_KEY_BAD_PREFIX')\n  }\n\n  const keyhash = key.slice(4)\n\n  const publicKeyHash = await sha256.digest(publicKey)\n\n  if (!uint8ArrayEquals(keyhash, publicKeyHash.bytes)) {\n    throw new CodeError('public key does not match passed in key', 'ERR_INVALID_RECORD_HASH_MISMATCH')\n  }\n}\n\nexport const validators: Validators = {\n  pk: validatePublicKeyRecord\n}\n"]},"metadata":{},"sourceType":"module"}