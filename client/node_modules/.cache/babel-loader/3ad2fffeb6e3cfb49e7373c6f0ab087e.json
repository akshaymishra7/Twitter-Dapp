{"ast":null,"code":"export function computeScoreWeights(peer, pstats, params, peerIPs, topicStrToLabel) {\n  let score = 0;\n  const byTopic = new Map(); // topic stores\n\n  Object.entries(pstats.topics).forEach(_ref => {\n    let [topic, tstats] = _ref;\n    // the topic parameters\n    // Aggregate by known topicLabel or throw to 'unknown'. This prevent too high cardinality\n    const topicLabel = topicStrToLabel.get(topic) ?? 'unknown';\n    const topicParams = params.topics[topic];\n\n    if (topicParams === undefined) {\n      // we are not scoring this topic\n      return;\n    }\n\n    let topicScores = byTopic.get(topicLabel);\n\n    if (!topicScores) {\n      topicScores = {\n        p1w: 0,\n        p2w: 0,\n        p3w: 0,\n        p3bw: 0,\n        p4w: 0\n      };\n      byTopic.set(topicLabel, topicScores);\n    }\n\n    let p1w = 0;\n    let p2w = 0;\n    let p3w = 0;\n    let p3bw = 0;\n    let p4w = 0; // P1: time in Mesh\n\n    if (tstats.inMesh) {\n      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap);\n      p1w += p1 * topicParams.timeInMeshWeight;\n    } // P2: first message deliveries\n\n\n    let p2 = tstats.firstMessageDeliveries;\n\n    if (p2 > topicParams.firstMessageDeliveriesCap) {\n      p2 = topicParams.firstMessageDeliveriesCap;\n    }\n\n    p2w += p2 * topicParams.firstMessageDeliveriesWeight; // P3: mesh message deliveries\n\n    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {\n      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;\n      const p3 = deficit * deficit;\n      p3w += p3 * topicParams.meshMessageDeliveriesWeight;\n    } // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n\n\n    const p3b = tstats.meshFailurePenalty;\n    p3bw += p3b * topicParams.meshFailurePenaltyWeight; // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;\n    p4w += p4 * topicParams.invalidMessageDeliveriesWeight; // update score, mixing with topic weight\n\n    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight;\n    topicScores.p1w += p1w;\n    topicScores.p2w += p2w;\n    topicScores.p3w += p3w;\n    topicScores.p3bw += p3bw;\n    topicScores.p4w += p4w;\n  }); // apply the topic score cap, if any\n\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap; // Proportionally apply cap to all individual contributions\n\n    const capF = params.topicScoreCap / score;\n\n    for (const ws of byTopic.values()) {\n      ws.p1w *= capF;\n      ws.p2w *= capF;\n      ws.p3w *= capF;\n      ws.p3bw *= capF;\n      ws.p4w *= capF;\n    }\n  }\n\n  let p5w = 0;\n  let p6w = 0;\n  let p7w = 0; // P5: application-specific score\n\n  const p5 = params.appSpecificScore(peer);\n  p5w += p5 * params.appSpecificWeight; // P6: IP colocation factor\n\n  pstats.knownIPs.forEach(ip => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return;\n    } // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n\n\n    const peersInIP = peerIPs.get(ip);\n    const numPeersInIP = peersInIP ? peersInIP.size : 0;\n\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold;\n      const p6 = surplus * surplus;\n      p6w += p6 * params.IPColocationFactorWeight;\n    }\n  }); // P7: behavioural pattern penalty\n\n  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;\n  p7w += p7 * params.behaviourPenaltyWeight;\n  score += p5w + p6w + p7w;\n  return {\n    byTopic,\n    p5w,\n    p6w,\n    p7w,\n    score\n  };\n}\nexport function computeAllPeersScoreWeights(peerIdStrs, peerStats, params, peerIPs, topicStrToLabel) {\n  const sw = {\n    byTopic: new Map(),\n    p5w: [],\n    p6w: [],\n    p7w: [],\n    score: []\n  };\n\n  for (const peerIdStr of peerIdStrs) {\n    const pstats = peerStats.get(peerIdStr);\n\n    if (pstats) {\n      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel);\n\n      for (const [topic, swPeerTopic] of swPeer.byTopic) {\n        let swTopic = sw.byTopic.get(topic);\n\n        if (!swTopic) {\n          swTopic = {\n            p1w: [],\n            p2w: [],\n            p3w: [],\n            p3bw: [],\n            p4w: []\n          };\n          sw.byTopic.set(topic, swTopic);\n        }\n\n        swTopic.p1w.push(swPeerTopic.p1w);\n        swTopic.p2w.push(swPeerTopic.p2w);\n        swTopic.p3w.push(swPeerTopic.p3w);\n        swTopic.p3bw.push(swPeerTopic.p3bw);\n        swTopic.p4w.push(swPeerTopic.p4w);\n      }\n\n      sw.p5w.push(swPeer.p5w);\n      sw.p6w.push(swPeer.p6w);\n      sw.p7w.push(swPeer.p7w);\n      sw.score.push(swPeer.score);\n    } else {\n      sw.p5w.push(0);\n      sw.p6w.push(0);\n      sw.p7w.push(0);\n      sw.score.push(0);\n    }\n  }\n\n  return sw;\n}","map":{"version":3,"mappings":"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","names":["computeScoreWeights","peer","pstats","params","peerIPs","topicStrToLabel","score","byTopic","Map","Object","entries","topics","forEach","topic","tstats","topicLabel","get","topicParams","undefined","topicScores","p1w","p2w","p3w","p3bw","p4w","set","inMesh","p1","Math","max","meshTime","timeInMeshQuantum","timeInMeshCap","timeInMeshWeight","p2","firstMessageDeliveries","firstMessageDeliveriesCap","firstMessageDeliveriesWeight","meshMessageDeliveriesActive","meshMessageDeliveries","meshMessageDeliveriesThreshold","deficit","p3","meshMessageDeliveriesWeight","p3b","meshFailurePenalty","meshFailurePenaltyWeight","p4","invalidMessageDeliveries","invalidMessageDeliveriesWeight","topicWeight","topicScoreCap","capF","ws","values","p5w","p6w","p7w","p5","appSpecificScore","appSpecificWeight","knownIPs","ip","IPColocationFactorWhitelist","has","peersInIP","numPeersInIP","size","IPColocationFactorThreshold","surplus","p6","IPColocationFactorWeight","p7","behaviourPenalty","behaviourPenaltyWeight","computeAllPeersScoreWeights","peerIdStrs","peerStats","sw","peerIdStr","swPeer","swPeerTopic","swTopic","push"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\score\\scoreMetrics.ts"],"sourcesContent":["import type { PeerScoreParams } from './peer-score-params.js'\nimport type { PeerStats } from './peer-stats.js'\n\ntype TopicLabel = string\ntype TopicStr = string\ntype TopicStrToLabel = Map<TopicStr, TopicLabel>\n\nexport interface TopicScoreWeights<T> {\n  p1w: T\n  p2w: T\n  p3w: T\n  p3bw: T\n  p4w: T\n}\nexport interface ScoreWeights<T> {\n  byTopic: Map<TopicLabel, TopicScoreWeights<T>>\n  p5w: T\n  p6w: T\n  p7w: T\n  score: T\n}\n\nexport function computeScoreWeights(\n  peer: string,\n  pstats: PeerStats,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>,\n  topicStrToLabel: TopicStrToLabel\n): ScoreWeights<number> {\n  let score = 0\n\n  const byTopic = new Map<TopicLabel, TopicScoreWeights<number>>()\n\n  // topic stores\n  Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n    // the topic parameters\n    // Aggregate by known topicLabel or throw to 'unknown'. This prevent too high cardinality\n    const topicLabel = topicStrToLabel.get(topic) ?? 'unknown'\n    const topicParams = params.topics[topic]\n    if (topicParams === undefined) {\n      // we are not scoring this topic\n      return\n    }\n\n    let topicScores = byTopic.get(topicLabel)\n    if (!topicScores) {\n      topicScores = {\n        p1w: 0,\n        p2w: 0,\n        p3w: 0,\n        p3bw: 0,\n        p4w: 0\n      }\n      byTopic.set(topicLabel, topicScores)\n    }\n\n    let p1w = 0\n    let p2w = 0\n    let p3w = 0\n    let p3bw = 0\n    let p4w = 0\n\n    // P1: time in Mesh\n    if (tstats.inMesh) {\n      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap)\n      p1w += p1 * topicParams.timeInMeshWeight\n    }\n\n    // P2: first message deliveries\n    let p2 = tstats.firstMessageDeliveries\n    if (p2 > topicParams.firstMessageDeliveriesCap) {\n      p2 = topicParams.firstMessageDeliveriesCap\n    }\n    p2w += p2 * topicParams.firstMessageDeliveriesWeight\n\n    // P3: mesh message deliveries\n    if (\n      tstats.meshMessageDeliveriesActive &&\n      tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold\n    ) {\n      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries\n      const p3 = deficit * deficit\n      p3w += p3 * topicParams.meshMessageDeliveriesWeight\n    }\n\n    // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n    const p3b = tstats.meshFailurePenalty\n    p3bw += p3b * topicParams.meshFailurePenaltyWeight\n\n    // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries\n    p4w += p4 * topicParams.invalidMessageDeliveriesWeight\n\n    // update score, mixing with topic weight\n    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight\n\n    topicScores.p1w += p1w\n    topicScores.p2w += p2w\n    topicScores.p3w += p3w\n    topicScores.p3bw += p3bw\n    topicScores.p4w += p4w\n  })\n\n  // apply the topic score cap, if any\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap\n\n    // Proportionally apply cap to all individual contributions\n    const capF = params.topicScoreCap / score\n    for (const ws of byTopic.values()) {\n      ws.p1w *= capF\n      ws.p2w *= capF\n      ws.p3w *= capF\n      ws.p3bw *= capF\n      ws.p4w *= capF\n    }\n  }\n\n  let p5w = 0\n  let p6w = 0\n  let p7w = 0\n\n  // P5: application-specific score\n  const p5 = params.appSpecificScore(peer)\n  p5w += p5 * params.appSpecificWeight\n\n  // P6: IP colocation factor\n  pstats.knownIPs.forEach((ip) => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return\n    }\n\n    // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n    const peersInIP = peerIPs.get(ip)\n    const numPeersInIP = peersInIP ? peersInIP.size : 0\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold\n      const p6 = surplus * surplus\n      p6w += p6 * params.IPColocationFactorWeight\n    }\n  })\n\n  // P7: behavioural pattern penalty\n  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty\n  p7w += p7 * params.behaviourPenaltyWeight\n\n  score += p5w + p6w + p7w\n\n  return {\n    byTopic,\n    p5w,\n    p6w,\n    p7w,\n    score\n  }\n}\n\nexport function computeAllPeersScoreWeights(\n  peerIdStrs: Iterable<string>,\n  peerStats: Map<string, PeerStats>,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>,\n  topicStrToLabel: TopicStrToLabel\n): ScoreWeights<number[]> {\n  const sw: ScoreWeights<number[]> = {\n    byTopic: new Map(),\n    p5w: [],\n    p6w: [],\n    p7w: [],\n    score: []\n  }\n\n  for (const peerIdStr of peerIdStrs) {\n    const pstats = peerStats.get(peerIdStr)\n    if (pstats) {\n      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel)\n\n      for (const [topic, swPeerTopic] of swPeer.byTopic) {\n        let swTopic = sw.byTopic.get(topic)\n        if (!swTopic) {\n          swTopic = {\n            p1w: [],\n            p2w: [],\n            p3w: [],\n            p3bw: [],\n            p4w: []\n          }\n          sw.byTopic.set(topic, swTopic)\n        }\n\n        swTopic.p1w.push(swPeerTopic.p1w)\n        swTopic.p2w.push(swPeerTopic.p2w)\n        swTopic.p3w.push(swPeerTopic.p3w)\n        swTopic.p3bw.push(swPeerTopic.p3bw)\n        swTopic.p4w.push(swPeerTopic.p4w)\n      }\n\n      sw.p5w.push(swPeer.p5w)\n      sw.p6w.push(swPeer.p6w)\n      sw.p7w.push(swPeer.p7w)\n      sw.score.push(swPeer.score)\n    } else {\n      sw.p5w.push(0)\n      sw.p6w.push(0)\n      sw.p7w.push(0)\n      sw.score.push(0)\n    }\n  }\n\n  return sw\n}\n"]},"metadata":{},"sourceType":"module"}