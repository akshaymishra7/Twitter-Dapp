{"ast":null,"code":"/* eslint max-depth: [\"error\", 6] */\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { unsigned } from 'uint8-varint';\nimport errCode from 'err-code';\nimport { isAsyncIterable } from './utils.js'; // Maximum length of the length section of the message\n\nexport const MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\n\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4;\nvar ReadMode;\n\n(function (ReadMode) {\n  ReadMode[ReadMode[\"LENGTH\"] = 0] = \"LENGTH\";\n  ReadMode[ReadMode[\"DATA\"] = 1] = \"DATA\";\n})(ReadMode || (ReadMode = {}));\n\nconst defaultDecoder = buf => {\n  const length = unsigned.decode(buf);\n  defaultDecoder.bytes = unsigned.encodingLength(length);\n  return length;\n};\n\ndefaultDecoder.bytes = 0;\nexport function decode(source, options) {\n  const buffer = new Uint8ArrayList();\n  let mode = ReadMode.LENGTH;\n  let dataLength = -1;\n  const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;\n  const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;\n\n  function* maybeYield() {\n    while (buffer.byteLength > 0) {\n      if (mode === ReadMode.LENGTH) {\n        // read length, ignore errors for short reads\n        try {\n          dataLength = lengthDecoder(buffer);\n\n          if (dataLength < 0) {\n            throw errCode(new Error('invalid message length'), 'ERR_INVALID_MSG_LENGTH');\n          }\n\n          if (dataLength > maxDataLength) {\n            throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG');\n          }\n\n          const dataLengthLength = lengthDecoder.bytes;\n          buffer.consume(dataLengthLength);\n\n          if (options?.onLength != null) {\n            options.onLength(dataLength);\n          }\n\n          mode = ReadMode.DATA;\n        } catch (err) {\n          if (err instanceof RangeError) {\n            if (buffer.byteLength > maxLengthLength) {\n              throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG');\n            }\n\n            break;\n          }\n\n          throw err;\n        }\n      }\n\n      if (mode === ReadMode.DATA) {\n        if (buffer.byteLength < dataLength) {\n          // not enough data, wait for more\n          break;\n        }\n\n        const data = buffer.sublist(0, dataLength);\n        buffer.consume(dataLength);\n\n        if (options?.onData != null) {\n          options.onData(data);\n        }\n\n        yield data;\n        mode = ReadMode.LENGTH;\n      }\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return async function* () {\n      for await (const buf of source) {\n        buffer.append(buf);\n        yield* maybeYield();\n      }\n\n      if (buffer.byteLength > 0) {\n        throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n      }\n    }();\n  }\n\n  return function* () {\n    for (const buf of source) {\n      buffer.append(buf);\n      yield* maybeYield();\n    }\n\n    if (buffer.byteLength > 0) {\n      throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n    }\n  }();\n}\n\ndecode.fromReader = (reader, options) => {\n  let byteLength = 1; // Read single byte chunks until the length is known\n\n  const varByteSource = async function* () {\n    while (true) {\n      try {\n        const {\n          done,\n          value\n        } = await reader.next(byteLength);\n\n        if (done === true) {\n          return;\n        }\n\n        if (value != null) {\n          yield value;\n        }\n      } catch (err) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return {\n            done: true,\n            value: null\n          };\n        }\n\n        throw err;\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1;\n      }\n    }\n  }();\n  /**\n   * Once the length has been parsed, read chunk for that length\n   */\n\n\n  const onLength = l => {\n    byteLength = l;\n  };\n\n  return decode(varByteSource, { ...(options ?? {}),\n    onLength\n  });\n};","map":{"version":3,"mappings":"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","names":["Uint8ArrayList","unsigned","errCode","isAsyncIterable","MAX_LENGTH_LENGTH","MAX_DATA_LENGTH","ReadMode","defaultDecoder","buf","length","decode","bytes","encodingLength","source","options","buffer","mode","LENGTH","dataLength","lengthDecoder","maxLengthLength","maxDataLength","maybeYield","byteLength","Error","dataLengthLength","consume","onLength","DATA","err","RangeError","data","sublist","onData","append","fromReader","reader","varByteSource","done","value","next","code","l"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\multistream-select\\node_modules\\it-length-prefixed\\src\\decode.ts"],"sourcesContent":["/* eslint max-depth: [\"error\", 6] */\n\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { unsigned } from 'uint8-varint'\nimport errCode from 'err-code'\nimport type { LengthDecoderFunction } from './index.js'\nimport type { Reader } from 'it-reader'\nimport { isAsyncIterable } from './utils.js'\nimport type { Source } from 'it-stream-types'\n\nexport interface ReadState {\n  dataLength: number\n}\n\nexport interface DecoderOptions {\n  lengthDecoder?: LengthDecoderFunction\n  onData?: (data: Uint8ArrayList) => void\n  onLength?: (length: number) => void\n  maxLengthLength?: number\n  maxDataLength?: number\n}\n\nexport interface ReadResult {\n  mode: string\n  chunk?: Uint8ArrayList\n  buffer: Uint8ArrayList\n  state?: ReadState\n  data?: Uint8ArrayList\n}\n\n// Maximum length of the length section of the message\nexport const MAX_LENGTH_LENGTH = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4\n\nenum ReadMode {\n  LENGTH,\n  DATA\n}\n\nconst defaultDecoder: LengthDecoderFunction = (buf) => {\n  const length = unsigned.decode(buf)\n  defaultDecoder.bytes = unsigned.encodingLength(length)\n\n  return length\n}\ndefaultDecoder.bytes = 0\n\nexport function decode (source: Iterable<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): Generator<Uint8ArrayList, void, unknown>\nexport function decode (source: Source<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): AsyncGenerator<Uint8ArrayList, void, unknown>\nexport function decode (source: Source<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): Generator<Uint8ArrayList, void, unknown> | AsyncGenerator<Uint8ArrayList, void, unknown> {\n  const buffer = new Uint8ArrayList()\n  let mode = ReadMode.LENGTH\n  let dataLength = -1\n\n  const lengthDecoder = options?.lengthDecoder ?? defaultDecoder\n  const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  function * maybeYield (): Generator<Uint8ArrayList> {\n    while (buffer.byteLength > 0) {\n      if (mode === ReadMode.LENGTH) {\n        // read length, ignore errors for short reads\n        try {\n          dataLength = lengthDecoder(buffer)\n\n          if (dataLength < 0) {\n            throw errCode(new Error('invalid message length'), 'ERR_INVALID_MSG_LENGTH')\n          }\n\n          if (dataLength > maxDataLength) {\n            throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG')\n          }\n\n          const dataLengthLength = lengthDecoder.bytes\n          buffer.consume(dataLengthLength)\n\n          if (options?.onLength != null) {\n            options.onLength(dataLength)\n          }\n\n          mode = ReadMode.DATA\n        } catch (err: any) {\n          if (err instanceof RangeError) {\n            if (buffer.byteLength > maxLengthLength) {\n              throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG')\n            }\n\n            break\n          }\n\n          throw err\n        }\n      }\n\n      if (mode === ReadMode.DATA) {\n        if (buffer.byteLength < dataLength) {\n          // not enough data, wait for more\n          break\n        }\n\n        const data = buffer.sublist(0, dataLength)\n        buffer.consume(dataLength)\n\n        if (options?.onData != null) {\n          options.onData(data)\n        }\n\n        yield data\n\n        mode = ReadMode.LENGTH\n      }\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const buf of source) {\n        buffer.append(buf)\n\n        yield * maybeYield()\n      }\n\n      if (buffer.byteLength > 0) {\n        throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF')\n      }\n    })()\n  }\n\n  return (function * () {\n    for (const buf of source) {\n      buffer.append(buf)\n\n      yield * maybeYield()\n    }\n\n    if (buffer.byteLength > 0) {\n      throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF')\n    }\n  })()\n}\n\ndecode.fromReader = (reader: Reader, options?: DecoderOptions) => {\n  let byteLength = 1 // Read single byte chunks until the length is known\n\n  const varByteSource = (async function * () {\n    while (true) {\n      try {\n        const { done, value } = await reader.next(byteLength)\n\n        if (done === true) {\n          return\n        }\n\n        if (value != null) {\n          yield value\n        }\n      } catch (err: any) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return { done: true, value: null }\n        }\n        throw err\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1\n      }\n    }\n  }())\n\n  /**\n   * Once the length has been parsed, read chunk for that length\n   */\n  const onLength = (l: number): void => { byteLength = l }\n  return decode(varByteSource, {\n    ...(options ?? {}),\n    onLength\n  })\n}\n"]},"metadata":{},"sourceType":"module"}