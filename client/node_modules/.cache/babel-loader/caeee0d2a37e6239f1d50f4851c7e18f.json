{"ast":null,"code":"import { connect } from 'it-ws/client';\nimport { multiaddrToUri as toUri } from '@multiformats/multiaddr-to-uri';\nimport { AbortError } from '@libp2p/interfaces/errors';\nimport pDefer from 'p-defer';\nimport { logger } from '@libp2p/logger';\nimport { isBrowser, isWebWorker } from 'wherearewe';\nimport { createListener } from './listener.js';\nimport { socketToMaConn } from './socket-to-conn.js';\nimport * as filters from './filters.js';\nimport { symbol } from '@libp2p/interface-transport';\nconst log = logger('libp2p:websockets');\n\nclass WebSockets {\n  constructor(init) {\n    this.init = init;\n  }\n\n  get [Symbol.toStringTag]() {\n    return '@libp2p/websockets';\n  }\n\n  get [symbol]() {\n    return true;\n  }\n\n  async dial(ma, options) {\n    log('dialing %s', ma);\n    options = options ?? {};\n    const socket = await this._connect(ma, options);\n    const maConn = socketToMaConn(socket, ma);\n    log('new outbound connection %s', maConn.remoteAddr);\n    const conn = await options.upgrader.upgradeOutbound(maConn);\n    log('outbound connection %s upgraded', maConn.remoteAddr);\n    return conn;\n  }\n\n  async _connect(ma, options) {\n    if (options?.signal?.aborted === true) {\n      throw new AbortError();\n    }\n\n    const cOpts = ma.toOptions();\n    log('dialing %s:%s', cOpts.host, cOpts.port);\n    const errorPromise = pDefer();\n\n    const errfn = err => {\n      log.error('connection error:', err);\n      errorPromise.reject(err);\n    };\n\n    const rawSocket = connect(toUri(ma), this.init);\n\n    if (rawSocket.socket.on != null) {\n      rawSocket.socket.on('error', errfn);\n    } else {\n      rawSocket.socket.onerror = errfn;\n    }\n\n    if (options.signal == null) {\n      await Promise.race([rawSocket.connected(), errorPromise.promise]);\n      log('connected %s', ma);\n      return rawSocket;\n    } // Allow abort via signal during connect\n\n\n    let onAbort;\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError());\n        rawSocket.close().catch(err => {\n          log.error('error closing raw socket', err);\n        });\n      }; // Already aborted?\n\n\n      if (options?.signal?.aborted === true) {\n        onAbort();\n        return;\n      }\n\n      options?.signal?.addEventListener('abort', onAbort);\n    });\n\n    try {\n      await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);\n    } finally {\n      if (onAbort != null) {\n        options?.signal?.removeEventListener('abort', onAbort);\n      }\n    }\n\n    log('connected %s', ma);\n    return rawSocket;\n  }\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`\n   */\n\n\n  createListener(options) {\n    return createListener({ ...this.init,\n      ...options\n    });\n  }\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n   * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n   */\n\n\n  filter(multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n\n    if (this.init?.filter != null) {\n      return this.init?.filter(multiaddrs);\n    } // Browser\n\n\n    if (isBrowser || isWebWorker) {\n      return filters.wss(multiaddrs);\n    }\n\n    return filters.all(multiaddrs);\n  }\n\n}\n\nexport function webSockets() {\n  let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return () => {\n    return new WebSockets(init);\n  };\n}","map":{"version":3,"mappings":"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","names":["connect","multiaddrToUri","toUri","AbortError","pDefer","logger","isBrowser","isWebWorker","createListener","socketToMaConn","filters","symbol","log","WebSockets","constructor","init","Symbol","toStringTag","dial","ma","options","socket","_connect","maConn","remoteAddr","conn","upgrader","upgradeOutbound","signal","aborted","cOpts","toOptions","host","port","errorPromise","errfn","err","error","reject","rawSocket","on","onerror","Promise","race","connected","promise","onAbort","abort","resolve","close","catch","addEventListener","removeEventListener","filter","multiaddrs","Array","isArray","wss","all","webSockets"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\websockets\\src\\index.ts"],"sourcesContent":["import { connect, WebSocketOptions } from 'it-ws/client'\nimport { multiaddrToUri as toUri } from '@multiformats/multiaddr-to-uri'\nimport { AbortError } from '@libp2p/interfaces/errors'\nimport pDefer from 'p-defer'\nimport { logger } from '@libp2p/logger'\nimport { isBrowser, isWebWorker } from 'wherearewe'\nimport { createListener } from './listener.js'\nimport { socketToMaConn } from './socket-to-conn.js'\nimport * as filters from './filters.js'\nimport { Transport, MultiaddrFilter, symbol, CreateListenerOptions, DialOptions, Listener } from '@libp2p/interface-transport'\nimport type { Connection } from '@libp2p/interface-connection'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { DuplexWebSocket } from 'it-ws/duplex'\nimport type { ClientOptions } from 'ws'\nimport type { Server } from 'http'\n\nconst log = logger('libp2p:websockets')\n\nexport interface WebSocketsInit extends AbortOptions, WebSocketOptions {\n  filter?: MultiaddrFilter\n  websocket?: ClientOptions\n  server?: Server\n}\n\nclass WebSockets implements Transport {\n  private readonly init?: WebSocketsInit\n\n  constructor (init?: WebSocketsInit) {\n    this.init = init\n  }\n\n  get [Symbol.toStringTag] (): string {\n    return '@libp2p/websockets'\n  }\n\n  get [symbol] (): true {\n    return true\n  }\n\n  async dial (ma: Multiaddr, options: DialOptions): Promise<Connection> {\n    log('dialing %s', ma)\n    options = options ?? {}\n\n    const socket = await this._connect(ma, options)\n    const maConn = socketToMaConn(socket, ma)\n    log('new outbound connection %s', maConn.remoteAddr)\n\n    const conn = await options.upgrader.upgradeOutbound(maConn)\n    log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  async _connect (ma: Multiaddr, options: AbortOptions): Promise<DuplexWebSocket> {\n    if (options?.signal?.aborted === true) {\n      throw new AbortError()\n    }\n    const cOpts = ma.toOptions()\n    log('dialing %s:%s', cOpts.host, cOpts.port)\n\n    const errorPromise = pDefer()\n    const errfn = (err: any): void => {\n      log.error('connection error:', err)\n\n      errorPromise.reject(err)\n    }\n\n    const rawSocket = connect(toUri(ma), this.init)\n\n    if (rawSocket.socket.on != null) {\n      rawSocket.socket.on('error', errfn)\n    } else {\n      rawSocket.socket.onerror = errfn\n    }\n\n    if (options.signal == null) {\n      await Promise.race([rawSocket.connected(), errorPromise.promise])\n\n      log('connected %s', ma)\n      return rawSocket\n    }\n\n    // Allow abort via signal during connect\n    let onAbort\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError())\n        rawSocket.close().catch(err => {\n          log.error('error closing raw socket', err)\n        })\n      }\n\n      // Already aborted?\n      if (options?.signal?.aborted === true) {\n        onAbort(); return\n      }\n\n      options?.signal?.addEventListener('abort', onAbort)\n    })\n\n    try {\n      await Promise.race([abort, errorPromise.promise, rawSocket.connected()])\n    } finally {\n      if (onAbort != null) {\n        options?.signal?.removeEventListener('abort', onAbort)\n      }\n    }\n\n    log('connected %s', ma)\n    return rawSocket\n  }\n\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`\n   */\n  createListener (options: CreateListenerOptions): Listener {\n    return createListener({ ...this.init, ...options })\n  }\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n   * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n   */\n  filter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    if (this.init?.filter != null) {\n      return this.init?.filter(multiaddrs)\n    }\n\n    // Browser\n    if (isBrowser || isWebWorker) {\n      return filters.wss(multiaddrs)\n    }\n\n    return filters.all(multiaddrs)\n  }\n}\n\nexport function webSockets (init: WebSocketsInit = {}): (components?: any) => Transport {\n  return () => {\n    return new WebSockets(init)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}