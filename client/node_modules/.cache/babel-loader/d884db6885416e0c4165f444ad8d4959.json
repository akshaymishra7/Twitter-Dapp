{"ast":null,"code":"import errCode from 'err-code';\nimport { NotEnabledError } from '../errors.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { CID } from 'multiformats/cid';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base36 } from 'multiformats/bases/base36';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { peerIdFromString } from '@libp2p/peer-id';\n/**\n * @typedef {import('@libp2p/interface-dht').QueryEvent} QueryEvent\n * @typedef {import('./network').Network} Network\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nconst IPNS_PREFIX = '/ipns/';\n/**\n * @param {string} str\n */\n\nfunction toDHTKey(str) {\n  if (str.startsWith(IPNS_PREFIX)) {\n    str = str.substring(IPNS_PREFIX.length);\n  }\n  /** @type {Uint8Array|undefined} */\n\n\n  let buf;\n\n  if (str[0] === '1' || str[0] === 'Q') {\n    // ed25519 key or hash of rsa key\n    str = `z${str}`;\n  }\n\n  if (str[0] === 'z') {\n    buf = base58btc.decode(str);\n  }\n\n  if (str[0] === 'k') {\n    // base36 encoded string\n    buf = base36.decode(str);\n  }\n\n  if (!buf) {\n    throw new Error('Could not parse string');\n  }\n\n  if (buf[0] !== 0x01 && buf[1] !== 0x72) {\n    // prefix key with CIDv1 and libp2p-key codec\n    buf = uint8ArrayConcat([[0x01, 0x72], buf]);\n  }\n\n  if (buf.length !== 40) {\n    throw new Error('Incorrect length ' + buf.length);\n  }\n\n  return uint8ArrayConcat([uint8ArrayFromString(IPNS_PREFIX), buf.subarray(2)]);\n}\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {PeerId} config.peerId\n */\n\n\nexport function createDht(_ref) {\n  let {\n    network,\n    repo,\n    peerId\n  } = _ref;\n  const {\n    get,\n    put,\n    findProvs,\n    findPeer,\n    provide,\n    query\n  } = {\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"get\"]}\n     */\n    async *get(key) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n      }\n\n      yield* libp2p.dht.get(dhtKey, options);\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"put\"]}\n     */\n    async *put(key, value, options) {\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n      }\n\n      yield* libp2p.dht.put(dhtKey, value, options);\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"findProvs\"]}\n     */\n    async *findProvs(cid) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n      }\n\n      yield* libp2p.dht.findProviders(cid, {\n        signal: options.signal\n      });\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"findPeer\"]}\n     */\n    async *findPeer(peerIdToFind) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n      }\n\n      yield* libp2p.dht.findPeer(peerIdToFind, {\n        signal: options.signal\n      });\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"provide\"]}\n     */\n    async *provide(cid) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        recursive: false\n      };\n      const {\n        libp2p\n      } = await use(network, peerId, options); // ensure blocks are actually local\n\n      const hasBlock = await repo.blocks.has(cid);\n\n      if (!hasBlock) {\n        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND');\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET');\n      }\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n      }\n\n      yield* libp2p.dht.provide(cid);\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"query\"]}\n     */\n    async *query(peerIdToQuery) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      let bytes;\n      const asCid = CID.asCID(peerIdToQuery);\n\n      if (asCid != null) {\n        bytes = asCid.multihash.bytes;\n      } else {\n        bytes = peerIdFromString(peerIdToQuery.toString()).toBytes();\n      }\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n      }\n\n      yield* libp2p.dht.getClosestPeers(bytes, options);\n    }\n\n  };\n  return {\n    get: withTimeoutOption(get),\n    put: withTimeoutOption(put),\n    findProvs: withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption(findPeer),\n    provide: withTimeoutOption(provide),\n    query: withTimeoutOption(query)\n  };\n}\n/**\n * @param {import('../types').NetworkService} network\n * @param {PeerId} peerId\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n * @returns {Promise<Network>}\n */\n\nconst use = async (network, peerId, options) => {\n  const net = await network.use(options);\n\n  if (net.libp2p.dht != null) {\n    return net;\n  } else {\n    const fn = async function* () {\n      yield {\n        from: peerId,\n        name: 'QUERY_ERROR',\n        type: 3,\n        error: new NotEnabledError('dht not enabled')\n      };\n    };\n\n    return {\n      libp2p: {\n        dht: {\n          // @ts-expect-error incomplete implementation\n          get: fn,\n          // @ts-expect-error incomplete implementation\n          put: fn,\n          // @ts-expect-error incomplete implementation\n          findProviders: fn,\n          // @ts-expect-error incomplete implementation\n          findPeer: fn,\n          // @ts-expect-error incomplete implementation\n          provide: fn,\n          // @ts-expect-error incomplete implementation\n          getClosestPeers: fn\n        }\n      }\n    };\n  }\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/dht.js"],"names":["errCode","NotEnabledError","withTimeoutOption","CID","base58btc","base36","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","peerIdFromString","IPNS_PREFIX","toDHTKey","str","startsWith","substring","length","buf","decode","Error","subarray","createDht","network","repo","peerId","get","put","findProvs","findPeer","provide","query","key","options","libp2p","use","dhtKey","Uint8Array","dht","value","cid","findProviders","signal","peerIdToFind","recursive","hasBlock","blocks","has","peerIdToQuery","bytes","asCid","asCID","multihash","toString","toBytes","getClosestPeers","net","fn","from","name","type","error"],"mappings":"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","sourcesContent":["import errCode from 'err-code'\nimport { NotEnabledError } from '../errors.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { CID } from 'multiformats/cid'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { base36 } from 'multiformats/bases/base36'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { peerIdFromString } from '@libp2p/peer-id'\n\n/**\n * @typedef {import('@libp2p/interface-dht').QueryEvent} QueryEvent\n * @typedef {import('./network').Network} Network\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nconst IPNS_PREFIX = '/ipns/'\n\n/**\n * @param {string} str\n */\nfunction toDHTKey (str) {\n  if (str.startsWith(IPNS_PREFIX)) {\n    str = str.substring(IPNS_PREFIX.length)\n  }\n\n  /** @type {Uint8Array|undefined} */\n  let buf\n\n  if (str[0] === '1' || str[0] === 'Q') {\n    // ed25519 key or hash of rsa key\n    str = `z${str}`\n  }\n\n  if (str[0] === 'z') {\n    buf = base58btc.decode(str)\n  }\n\n  if (str[0] === 'k') {\n    // base36 encoded string\n    buf = base36.decode(str)\n  }\n\n  if (!buf) {\n    throw new Error('Could not parse string')\n  }\n\n  if (buf[0] !== 0x01 && buf[1] !== 0x72) {\n    // prefix key with CIDv1 and libp2p-key codec\n    buf = uint8ArrayConcat([\n      [0x01, 0x72],\n      buf\n    ])\n  }\n\n  if (buf.length !== 40) {\n    throw new Error('Incorrect length ' + buf.length)\n  }\n\n  return uint8ArrayConcat([\n    uint8ArrayFromString(IPNS_PREFIX),\n    buf.subarray(2)\n  ])\n}\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {PeerId} config.peerId\n */\nexport function createDht ({ network, repo, peerId }) {\n  const { get, put, findProvs, findPeer, provide, query } = {\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"get\"]}\n     */\n    async * get (key, options = {}) {\n      const { libp2p } = await use(network, peerId, options)\n\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key)\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.get(dhtKey, options)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"put\"]}\n     */\n    async * put (key, value, options) {\n      const { libp2p } = await use(network, peerId, options)\n\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key)\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.put(dhtKey, value, options)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"findProvs\"]}\n     */\n    async * findProvs (cid, options = {}) {\n      const { libp2p } = await use(network, peerId, options)\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.findProviders(cid, {\n        signal: options.signal\n      })\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"findPeer\"]}\n     */\n    async * findPeer (peerIdToFind, options = {}) {\n      const { libp2p } = await use(network, peerId, options)\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.findPeer(peerIdToFind, {\n        signal: options.signal\n      })\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"provide\"]}\n     */\n    async * provide (cid, options = { recursive: false }) {\n      const { libp2p } = await use(network, peerId, options)\n\n      // ensure blocks are actually local\n      const hasBlock = await repo.blocks.has(cid)\n\n      if (!hasBlock) {\n        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND')\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET')\n      }\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.provide(cid)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"query\"]}\n     */\n    async * query (peerIdToQuery, options = {}) {\n      const { libp2p } = await use(network, peerId, options)\n      let bytes\n      const asCid = CID.asCID(peerIdToQuery)\n\n      if (asCid != null) {\n        bytes = asCid.multihash.bytes\n      } else {\n        bytes = peerIdFromString(peerIdToQuery.toString()).toBytes()\n      }\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.getClosestPeers(bytes, options)\n    }\n  }\n\n  return {\n    get: withTimeoutOption(get),\n    put: withTimeoutOption(put),\n    findProvs: withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption(findPeer),\n    provide: withTimeoutOption(provide),\n    query: withTimeoutOption(query)\n  }\n}\n\n/**\n * @param {import('../types').NetworkService} network\n * @param {PeerId} peerId\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n * @returns {Promise<Network>}\n */\nconst use = async (network, peerId, options) => {\n  const net = await network.use(options)\n  if (net.libp2p.dht != null) {\n    return net\n  } else {\n    const fn = async function * () {\n      yield {\n        from: peerId,\n        name: 'QUERY_ERROR',\n        type: 3,\n        error: new NotEnabledError('dht not enabled')\n      }\n    }\n\n    return {\n      libp2p: {\n        dht: {\n          // @ts-expect-error incomplete implementation\n          get: fn,\n          // @ts-expect-error incomplete implementation\n          put: fn,\n          // @ts-expect-error incomplete implementation\n          findProviders: fn,\n          // @ts-expect-error incomplete implementation\n          findPeer: fn,\n          // @ts-expect-error incomplete implementation\n          provide: fn,\n          // @ts-expect-error incomplete implementation\n          getClosestPeers: fn\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}