{"ast":null,"code":"import errCode from 'err-code';\nimport defer from 'p-defer';\nconst MAX_BUFFERED_AMOUNT = 64 * 1024;\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000;\nexport class WebRTCDataChannel {\n  constructor(channel, opts) {\n    this.label = channel.label;\n    this.open = defer();\n    this.channel = channel;\n    this.channel.binaryType = 'arraybuffer';\n    this.log = opts.log;\n\n    if (typeof this.channel.bufferedAmountLowThreshold === 'number') {\n      this.channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;\n    }\n\n    channel.addEventListener('message', event => {\n      opts.onMessage(event);\n    });\n    channel.addEventListener('bufferedamountlow', () => {\n      this.log('stop backpressure: bufferedAmount %d', this.channel.bufferedAmount);\n      this.open.resolve();\n    });\n    channel.addEventListener('open', () => {\n      this.open.resolve();\n      opts.onOpen();\n    });\n    channel.addEventListener('close', () => {\n      opts.onClose();\n    });\n    channel.addEventListener('error', event => {\n      // @ts-expect-error ChannelErrorEvent is just an Event in the types?\n      if (event.error?.message === 'Transport channel closed') {\n        return this.close();\n      } // @ts-expect-error ChannelErrorEvent is just an Event in the types?\n\n\n      opts.log.error('channel encounter an error in state \"%s\" message: \"%s\" detail: \"%s', channel.readyState, event.error?.message, event.error?.errorDetail); // eslint-disable-line @typescript-eslint/restrict-template-expressions\n      // @ts-expect-error ChannelErrorEvent is just an Event in the types?\n\n      const err = event.error instanceof Error // @ts-expect-error ChannelErrorEvent is just an Event in the types?\n      ? event.error // @ts-expect-error ChannelErrorEvent is just an Event in the types?\n      : new Error(`datachannel error: ${event.error?.message} ${event.error?.errorDetail}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions\n\n      opts.onError(errCode(err, 'ERR_DATA_CHANNEL'));\n    }); // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n\n    let isClosing = false;\n    this.closingInterval = setInterval(() => {\n      if (channel.readyState === 'closing') {\n        if (isClosing) {\n          opts.onClose(); // closing timed out: equivalent to onclose firing\n        }\n\n        isClosing = true;\n      } else {\n        isClosing = false;\n      }\n    }, CHANNEL_CLOSING_TIMEOUT);\n  }\n\n  async send(data) {\n    await this.open.promise;\n    this.channel.send(data);\n\n    if (this.channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n      this.log('start backpressure: bufferedAmount %d', this.channel.bufferedAmount);\n      this.open = defer();\n    }\n  }\n\n  close() {\n    clearInterval(this.closingInterval);\n    this.channel.close();\n  }\n\n  get bufferedAmount() {\n    return this.channel.bufferedAmount;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["errCode","defer","MAX_BUFFERED_AMOUNT","CHANNEL_CLOSING_TIMEOUT","WebRTCDataChannel","constructor","channel","opts","label","open","binaryType","log","bufferedAmountLowThreshold","addEventListener","event","onMessage","bufferedAmount","resolve","onOpen","onClose","error","message","close","readyState","errorDetail","err","Error","onError","isClosing","closingInterval","setInterval","send","data","promise","clearInterval"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\webrtc-peer\\src\\channel.ts"],"sourcesContent":["import errCode from 'err-code'\nimport defer, { DeferredPromise } from 'p-defer'\nimport type { Logger } from '@libp2p/logger'\n\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\n\nexport interface WebRTCDataChannelOptions {\n  onMessage: (event: MessageEvent<Uint8Array>) => void\n  onOpen: () => void\n  onClose: () => void\n  onError: (err: Error) => void\n  log: Logger\n}\n\nexport class WebRTCDataChannel {\n  public label: string\n  private readonly channel: RTCDataChannel\n  private readonly closingInterval: NodeJS.Timer\n  private open: DeferredPromise<void>\n  private readonly log: Logger\n\n  constructor (channel: RTCDataChannel, opts: WebRTCDataChannelOptions) {\n    this.label = channel.label\n    this.open = defer()\n    this.channel = channel\n    this.channel.binaryType = 'arraybuffer'\n    this.log = opts.log\n\n    if (typeof this.channel.bufferedAmountLowThreshold === 'number') {\n      this.channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\n    }\n\n    channel.addEventListener('message', event => {\n      opts.onMessage(event)\n    })\n    channel.addEventListener('bufferedamountlow', () => {\n      this.log('stop backpressure: bufferedAmount %d', this.channel.bufferedAmount)\n      this.open.resolve()\n    })\n    channel.addEventListener('open', () => {\n      this.open.resolve()\n      opts.onOpen()\n    })\n    channel.addEventListener('close', () => {\n      opts.onClose()\n    })\n    channel.addEventListener('error', event => {\n      // @ts-expect-error ChannelErrorEvent is just an Event in the types?\n      if (event.error?.message === 'Transport channel closed') {\n        return this.close()\n      }\n\n      // @ts-expect-error ChannelErrorEvent is just an Event in the types?\n      opts.log.error('channel encounter an error in state \"%s\" message: \"%s\" detail: \"%s', channel.readyState, event.error?.message, event.error?.errorDetail) // eslint-disable-line @typescript-eslint/restrict-template-expressions\n\n      // @ts-expect-error ChannelErrorEvent is just an Event in the types?\n      const err = event.error instanceof Error\n        // @ts-expect-error ChannelErrorEvent is just an Event in the types?\n        ? event.error\n        // @ts-expect-error ChannelErrorEvent is just an Event in the types?\n        : new Error(`datachannel error: ${event.error?.message} ${event.error?.errorDetail}`) // eslint-disable-line @typescript-eslint/restrict-template-expressions\n\n      opts.onError(errCode(err, 'ERR_DATA_CHANNEL'))\n    })\n\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n    let isClosing = false\n    this.closingInterval = setInterval(() => { // No \"onclosing\" event\n      if (channel.readyState === 'closing') {\n        if (isClosing) {\n          opts.onClose() // closing timed out: equivalent to onclose firing\n        }\n        isClosing = true\n      } else {\n        isClosing = false\n      }\n    }, CHANNEL_CLOSING_TIMEOUT)\n  }\n\n  async send (data: Uint8Array) {\n    await this.open.promise\n\n    this.channel.send(data)\n\n    if (this.channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n      this.log('start backpressure: bufferedAmount %d', this.channel.bufferedAmount)\n      this.open = defer()\n    }\n  }\n\n  close () {\n    clearInterval(this.closingInterval)\n    this.channel.close()\n  }\n\n  get bufferedAmount () {\n    return this.channel.bufferedAmount\n  }\n}\n"]},"metadata":{},"sourceType":"module"}