{"ast":null,"code":"import { CID } from 'multiformats/cid';\nimport { ipfs } from './pin.js'; // @ts-ignore\n\nimport fnv1a from 'fnv1a';\nimport varint from 'varint';\nimport * as dagPb from '@ipld/dag-pb';\nimport { DEFAULT_FANOUT, MAX_ITEMS, EMPTY_KEY } from './utils.js';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { compare as uint8ArrayCompare } from 'uint8arrays/compare';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { sha256 } from 'multiformats/hashes/sha2';\nconst PinSet = ipfs.pin.Set;\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\n\nfunction readHeader(rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data;\n\n  if (!rootData) {\n    throw new Error('No data present');\n  }\n\n  const hdrLength = varint.decode(rootData);\n  const vBytes = varint.decode.bytes ?? 0;\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  });\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`);\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n/**\n * @param {number} seed\n * @param {CID} key\n */\n\n\nfunction hash(seed, key) {\n  const buffer = new Uint8Array(4);\n  const dataView = new DataView(buffer.buffer);\n  dataView.setUint32(0, seed, true);\n  const encodedKey = uint8ArrayFromString(key.toString());\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength);\n  return fnv1a(uint8ArrayToString(data));\n}\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\n\n\nasync function* walkItems(blockstore, node) {\n  const pbh = readHeader(node);\n  let idx = 0;\n\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      // the first pbh.header.fanout links are fanout bins\n      // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n      const linkHash = link.Hash;\n\n      if (!EMPTY_KEY.equals(linkHash)) {\n        // walk the links of this fanout bin\n        const buf = await blockstore.get(linkHash);\n        const node = dagPb.decode(buf);\n        yield* walkItems(blockstore, node);\n      }\n    } else {\n      // otherwise, the link is a pin\n      yield link.Hash;\n    }\n\n    idx++;\n  }\n}\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\n\n\nexport async function* loadSet(blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name);\n\n  if (!link) {\n    throw new Error('No link found with name ' + name);\n  }\n\n  const buf = await blockstore.get(link.Hash);\n  const node = dagPb.decode(buf);\n  yield* walkItems(blockstore, node);\n}\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\n\nfunction storeItems(blockstore, items) {\n  return storePins(items, 0);\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n\n  async function storePins(pins, depth) {\n    const pbHeader = PinSet.encode({\n      version: 1,\n      fanout: DEFAULT_FANOUT,\n      seed: depth\n    }).finish();\n    const header = varint.encode(pbHeader.length);\n    const headerBuf = uint8ArrayConcat([header, pbHeader]);\n    const fanoutLinks = [];\n\n    for (let i = 0; i < DEFAULT_FANOUT; i++) {\n      fanoutLinks.push({\n        Name: '',\n        Tsize: 1,\n        Hash: EMPTY_KEY\n      });\n    }\n\n    if (pins.length <= MAX_ITEMS) {\n      const nodes = pins.map(item => {\n        return {\n          link: {\n            Name: '',\n            Tsize: 1,\n            Hash: item.key\n          },\n          data: item.data || new Uint8Array()\n        };\n      }) // sorting makes any ordering of `pins` produce the same DAGNode\n      .sort((a, b) => {\n        return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes);\n      });\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link));\n      const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)]);\n      return {\n        Data: rootData,\n        Links: rootLinks\n      };\n    } else {\n      // If the array of pins is > MAX_ITEMS, we:\n      //  - distribute the pins among `DEFAULT_FANOUT` bins\n      //    - create a DAGNode for each bin\n      //      - add each pin as a DAGLink to that bin\n      //  - create a root DAGNode\n      //    - add each bin as a DAGLink\n      //  - send that root DAGNode via callback\n      // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n      // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n      /** @type {Pin[][]} */\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % DEFAULT_FANOUT; // @ts-ignore\n\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n        return bins;\n      }, []);\n      let idx = 0;\n\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1);\n        await storeChild(child, idx);\n        idx++;\n      }\n\n      return {\n        Data: headerBuf,\n        Links: fanoutLinks\n      };\n    }\n    /**\n     * @param {PBNode} child\n     * @param {number} binIdx\n     */\n\n\n    async function storeChild(child, binIdx) {\n      const buf = dagPb.encode(child);\n      const digest = await sha256.digest(buf);\n      const cid = CID.createV0(digest);\n      await blockstore.put(cid, buf);\n      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length;\n      fanoutLinks[binIdx] = {\n        Name: '',\n        Tsize: size,\n        Hash: cid\n      };\n    }\n  }\n}\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\n\n\nexport async function storeSet(blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid\n    };\n  }));\n  const buf = dagPb.encode(rootNode);\n  const digest = await sha256.digest(buf);\n  const cid = CID.createV0(digest);\n  await blockstore.put(cid, buf);\n  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length;\n  return {\n    Name: type,\n    Tsize: size,\n    Hash: cid\n  };\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-repo-migrations/src/migrations/migration-9/pin-set.js"],"names":["CID","ipfs","fnv1a","varint","dagPb","DEFAULT_FANOUT","MAX_ITEMS","EMPTY_KEY","concat","uint8ArrayConcat","compare","uint8ArrayCompare","toString","uint8ArrayToString","fromString","uint8ArrayFromString","sha256","PinSet","pin","Set","readHeader","rootNode","rootData","Data","Error","hdrLength","decode","vBytes","bytes","length","hdrSlice","slice","header","toObject","defaults","arrays","longs","Number","objects","version","fanout","Links","data","hash","seed","key","buffer","Uint8Array","dataView","DataView","setUint32","encodedKey","byteLength","walkItems","blockstore","node","pbh","idx","link","linkHash","Hash","equals","buf","get","loadSet","name","find","l","Name","storeItems","items","storePins","pins","depth","pbHeader","encode","finish","headerBuf","fanoutLinks","i","push","Tsize","nodes","map","item","sort","a","b","rootLinks","bins","reduce","n","bin","child","storeChild","binIdx","digest","cid","createV0","put","size","acc","curr","storeSet","type","cids"],"mappings":"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","sourcesContent":["\nimport { CID } from 'multiformats/cid'\nimport { ipfs } from './pin.js'\n// @ts-ignore\nimport fnv1a from 'fnv1a'\nimport varint from 'varint'\nimport * as dagPb from '@ipld/dag-pb'\nimport { DEFAULT_FANOUT, MAX_ITEMS, EMPTY_KEY } from './utils.js'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { compare as uint8ArrayCompare } from 'uint8arrays/compare'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\nconst PinSet = ipfs.pin.Set\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\nfunction readHeader (rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data\n\n  if (!rootData) {\n    throw new Error('No data present')\n  }\n\n  const hdrLength = varint.decode(rootData)\n  const vBytes = varint.decode.bytes ?? 0\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length')\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length')\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes)\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  })\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`)\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout')\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  }\n}\n\n/**\n * @param {number} seed\n * @param {CID} key\n */\nfunction hash (seed, key) {\n  const buffer = new Uint8Array(4)\n  const dataView = new DataView(buffer.buffer)\n  dataView.setUint32(0, seed, true)\n  const encodedKey = uint8ArrayFromString(key.toString())\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength)\n\n  return fnv1a(uint8ArrayToString(data))\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\nasync function * walkItems (blockstore, node) {\n  const pbh = readHeader(node)\n  let idx = 0\n\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      // the first pbh.header.fanout links are fanout bins\n      // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n      const linkHash = link.Hash\n\n      if (!EMPTY_KEY.equals(linkHash)) {\n        // walk the links of this fanout bin\n        const buf = await blockstore.get(linkHash)\n        const node = dagPb.decode(buf)\n\n        yield * walkItems(blockstore, node)\n      }\n    } else {\n      // otherwise, the link is a pin\n      yield link.Hash\n    }\n\n    idx++\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\nexport async function * loadSet (blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name)\n\n  if (!link) {\n    throw new Error('No link found with name ' + name)\n  }\n\n  const buf = await blockstore.get(link.Hash)\n  const node = dagPb.decode(buf)\n\n  yield * walkItems(blockstore, node)\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\nfunction storeItems (blockstore, items) {\n  return storePins(items, 0)\n\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n  async function storePins (pins, depth) {\n    const pbHeader = PinSet.encode({\n      version: 1,\n      fanout: DEFAULT_FANOUT,\n      seed: depth\n    }).finish()\n\n    const header = varint.encode(pbHeader.length)\n    const headerBuf = uint8ArrayConcat([header, pbHeader])\n    const fanoutLinks = []\n\n    for (let i = 0; i < DEFAULT_FANOUT; i++) {\n      fanoutLinks.push({\n        Name: '',\n        Tsize: 1,\n        Hash: EMPTY_KEY\n      })\n    }\n\n    if (pins.length <= MAX_ITEMS) {\n      const nodes = pins\n        .map(item => {\n          return ({\n            link: {\n              Name: '',\n              Tsize: 1,\n              Hash: item.key\n            },\n            data: item.data || new Uint8Array()\n          })\n        })\n        // sorting makes any ordering of `pins` produce the same DAGNode\n        .sort((a, b) => {\n          return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes)\n        })\n\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link))\n      const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)])\n\n      return {\n        Data: rootData,\n        Links: rootLinks\n      }\n    } else {\n      // If the array of pins is > MAX_ITEMS, we:\n      //  - distribute the pins among `DEFAULT_FANOUT` bins\n      //    - create a DAGNode for each bin\n      //      - add each pin as a DAGLink to that bin\n      //  - create a root DAGNode\n      //    - add each bin as a DAGLink\n      //  - send that root DAGNode via callback\n      // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n      // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n      /** @type {Pin[][]} */\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % DEFAULT_FANOUT\n        // @ts-ignore\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin]\n        return bins\n      }, [])\n\n      let idx = 0\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1)\n\n        await storeChild(child, idx)\n\n        idx++\n      }\n\n      return {\n        Data: headerBuf,\n        Links: fanoutLinks\n      }\n    }\n\n    /**\n     * @param {PBNode} child\n     * @param {number} binIdx\n     */\n    async function storeChild (child, binIdx) {\n      const buf = dagPb.encode(child)\n      const digest = await sha256.digest(buf)\n      const cid = CID.createV0(digest)\n\n      await blockstore.put(cid, buf)\n\n      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length\n\n      fanoutLinks[binIdx] = {\n        Name: '',\n        Tsize: size,\n        Hash: cid\n      }\n    }\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\nexport async function storeSet (blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid\n    }\n  }))\n  const buf = dagPb.encode(rootNode)\n  const digest = await sha256.digest(buf)\n  const cid = CID.createV0(digest)\n\n  await blockstore.put(cid, buf)\n\n  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length\n\n  return {\n    Name: type,\n    Tsize: size,\n    Hash: cid\n  }\n}\n"]},"metadata":{},"sourceType":"module"}