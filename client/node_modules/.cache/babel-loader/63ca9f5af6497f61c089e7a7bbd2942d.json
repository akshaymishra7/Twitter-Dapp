{"ast":null,"code":"import { TieredDatastore } from 'datastore-core/tiered';\nimport get from 'dlv';\nimport { IpnsPubsubDatastore } from './pubsub-datastore.js';\nimport { OfflineDatastore } from './offline-datastore.js';\nimport { DHTDatastore } from './dht-datastore.js';\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {object} arg\n * @param {import('libp2p').Libp2p} arg.libp2p\n * @param {import('ipfs-repo').IPFSRepo} arg.repo\n * @param {import('@libp2p/interface-peer-id').PeerId} arg.peerId\n * @param {object} arg.options\n */\n\nexport function createRouting(_ref) {\n  let {\n    libp2p,\n    repo,\n    peerId,\n    options\n  } = _ref;\n  // Setup online routing for IPNS with a tiered routing composed by a DHT and a Pubsub router (if properly enabled)\n\n  /** @type {any[]} */\n  const ipnsStores = []; // Add IPNS pubsub if enabled\n\n  let pubsubDs;\n\n  if (get(options, 'EXPERIMENTAL.ipnsPubsub', false)) {\n    pubsubDs = new IpnsPubsubDatastore(libp2p.pubsub, repo.datastore, peerId);\n    ipnsStores.push(pubsubDs);\n  } // Add DHT datastore if enabled\n\n\n  if (get(options, 'offline', false) !== true && ['dht', 'dhtclient', 'dhtserver'].includes(get(options, 'config.Routing.Type', 'none'))) {\n    ipnsStores.push(new DHTDatastore(libp2p.dht));\n  } // Add an offline datastore if we are offline or no other datastores are configured\n\n\n  if (get(options, 'offline', false) || ipnsStores.length === 0) {\n    const offlineDatastore = new OfflineDatastore(repo.datastore);\n    ipnsStores.push(offlineDatastore);\n  } // Create ipns routing with a set of datastores\n\n\n  return new TieredDatastore(ipnsStores);\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/ipns/routing/config.js"],"names":["TieredDatastore","get","IpnsPubsubDatastore","OfflineDatastore","DHTDatastore","createRouting","libp2p","repo","peerId","options","ipnsStores","pubsubDs","pubsub","datastore","push","includes","dht","length","offlineDatastore"],"mappings":"AAAA,SAASA,eAAT,QAAgC,uBAAhC;AACA,OAAOC,GAAP,MAAgB,KAAhB;AACA,SAASC,mBAAT,QAAoC,uBAApC;AACA,SAASC,gBAAT,QAAiC,wBAAjC;AACA,SAASC,YAAT,QAA6B,oBAA7B;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,aAAT,OAA2D;AAAA,MAAnC;AAAEC,IAAAA,MAAF;AAAUC,IAAAA,IAAV;AAAgBC,IAAAA,MAAhB;AAAwBC,IAAAA;AAAxB,GAAmC;AAChE;;AACA;AACA,QAAMC,UAAU,GAAG,EAAnB,CAHgE,CAKhE;;AACA,MAAIC,QAAJ;;AACA,MAAIV,GAAG,CAACQ,OAAD,EAAU,yBAAV,EAAqC,KAArC,CAAP,EAAoD;AAClDE,IAAAA,QAAQ,GAAG,IAAIT,mBAAJ,CAAwBI,MAAM,CAACM,MAA/B,EAAuCL,IAAI,CAACM,SAA5C,EAAuDL,MAAvD,CAAX;AACAE,IAAAA,UAAU,CAACI,IAAX,CAAgBH,QAAhB;AACD,GAV+D,CAYhE;;;AACA,MAAIV,GAAG,CAACQ,OAAD,EAAU,SAAV,EAAqB,KAArB,CAAH,KAAmC,IAAnC,IAA2C,CAAC,KAAD,EAAQ,WAAR,EAAqB,WAArB,EAAkCM,QAAlC,CAA2Cd,GAAG,CAACQ,OAAD,EAAU,qBAAV,EAAiC,MAAjC,CAA9C,CAA/C,EAAwI;AACtIC,IAAAA,UAAU,CAACI,IAAX,CAAgB,IAAIV,YAAJ,CAAiBE,MAAM,CAACU,GAAxB,CAAhB;AACD,GAf+D,CAiBhE;;;AACA,MAAIf,GAAG,CAACQ,OAAD,EAAU,SAAV,EAAqB,KAArB,CAAH,IAAkCC,UAAU,CAACO,MAAX,KAAsB,CAA5D,EAA+D;AAC7D,UAAMC,gBAAgB,GAAG,IAAIf,gBAAJ,CAAqBI,IAAI,CAACM,SAA1B,CAAzB;AACAH,IAAAA,UAAU,CAACI,IAAX,CAAgBI,gBAAhB;AACD,GArB+D,CAuBhE;;;AACA,SAAO,IAAIlB,eAAJ,CAAoBU,UAApB,CAAP;AACD","sourcesContent":["import { TieredDatastore } from 'datastore-core/tiered'\nimport get from 'dlv'\nimport { IpnsPubsubDatastore } from './pubsub-datastore.js'\nimport { OfflineDatastore } from './offline-datastore.js'\nimport { DHTDatastore } from './dht-datastore.js'\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {object} arg\n * @param {import('libp2p').Libp2p} arg.libp2p\n * @param {import('ipfs-repo').IPFSRepo} arg.repo\n * @param {import('@libp2p/interface-peer-id').PeerId} arg.peerId\n * @param {object} arg.options\n */\nexport function createRouting ({ libp2p, repo, peerId, options }) {\n  // Setup online routing for IPNS with a tiered routing composed by a DHT and a Pubsub router (if properly enabled)\n  /** @type {any[]} */\n  const ipnsStores = []\n\n  // Add IPNS pubsub if enabled\n  let pubsubDs\n  if (get(options, 'EXPERIMENTAL.ipnsPubsub', false)) {\n    pubsubDs = new IpnsPubsubDatastore(libp2p.pubsub, repo.datastore, peerId)\n    ipnsStores.push(pubsubDs)\n  }\n\n  // Add DHT datastore if enabled\n  if (get(options, 'offline', false) !== true && ['dht', 'dhtclient', 'dhtserver'].includes(get(options, 'config.Routing.Type', 'none'))) {\n    ipnsStores.push(new DHTDatastore(libp2p.dht))\n  }\n\n  // Add an offline datastore if we are offline or no other datastores are configured\n  if (get(options, 'offline', false) || ipnsStores.length === 0) {\n    const offlineDatastore = new OfflineDatastore(repo.datastore)\n    ipnsStores.push(offlineDatastore)\n  }\n\n  // Create ipns routing with a set of datastores\n  return new TieredDatastore(ipnsStores)\n}\n"]},"metadata":{},"sourceType":"module"}