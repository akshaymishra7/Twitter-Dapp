{"ast":null,"code":"import * as dagPB from '@ipld/dag-pb';\nimport { CID } from 'multiformats/cid';\nimport { logger } from '@libp2p/logger';\nimport { UnixFS } from 'ipfs-unixfs';\nimport { generatePath, updateHamtDirectory } from './hamt-utils.js';\nimport errCode from 'err-code';\nconst log = logger('ipfs:mfs:core:utils:remove-link');\n/**\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} RemoveLinkOptions\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {CID} [parentCid]\n * @property {PBNode} [parent]\n *\n * @typedef {object} RemoveLinkOptionsInternal\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {PBNode} parent\n */\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptions} options\n */\n\nexport async function removeLink(context, options) {\n  let parent = options.parent;\n\n  if (options.parentCid) {\n    const parentCid = CID.asCID(options.parentCid);\n\n    if (parentCid === null) {\n      throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n    }\n\n    log(`Loading parent node ${parentCid}`);\n    const block = await context.repo.blocks.get(parentCid);\n    parent = dagPB.decode(block);\n  }\n\n  if (!parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n  }\n\n  if (!parent.Data) {\n    throw errCode(new Error('Parent node had no data'), 'ERR_INVALID_NODE');\n  }\n\n  const meta = UnixFS.unmarshal(parent.Data);\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`);\n    return removeFromShardedDirectory(context, { ...options,\n      parent\n    });\n  }\n\n  log(`Removing link ${options.name} regular directory`);\n  return removeFromDirectory(context, { ...options,\n    parent\n  });\n}\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\n\nconst removeFromDirectory = async (context, options) => {\n  // Remove existing link if it exists\n  options.parent.Links = options.parent.Links.filter(link => {\n    return link.Name !== options.name;\n  });\n  const parentBlock = await dagPB.encode(options.parent);\n  const hasher = await context.hashers.getHasher(options.hashAlg);\n  const hash = await hasher.digest(parentBlock);\n  const parentCid = CID.create(options.cidVersion, dagPB.code, hash);\n  await context.repo.blocks.put(parentCid, parentBlock);\n  log(`Updated regular directory ${parentCid}`);\n  return {\n    node: options.parent,\n    cid: parentCid\n  };\n};\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket,\n    path\n  } = await generatePath(context, options.name, options.parent);\n  await rootBucket.del(options.name);\n  const {\n    node\n  } = await updateShard(context, path, options.name, options);\n  return updateHamtDirectory(context, node.Links, rootBucket, options);\n};\n/**\n * @param {MfsContext} context\n * @param {{ bucket: Bucket, prefix: string, node?: PBNode }[]} positions\n * @param {string} name\n * @param {RemoveLinkOptionsInternal} options\n * @returns {Promise<{ node: PBNode, cid: CID, size: number }>}\n */\n\n\nconst updateShard = async (context, positions, name, options) => {\n  const last = positions.pop();\n\n  if (!last) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n  }\n\n  const {\n    bucket,\n    prefix,\n    node\n  } = last;\n\n  if (!node) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n  }\n\n  const link = node.Links.find(link => (link.Name || '').substring(0, 2) === prefix);\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${name}`), 'ERR_NOT_FOUND');\n  }\n\n  if (link.Name === `${prefix}${name}`) {\n    log(`Removing existing link ${link.Name}`);\n    const links = node.Links.filter(nodeLink => {\n      return nodeLink.Name !== link.Name;\n    });\n    await bucket.del(name);\n    return updateHamtDirectory(context, links, bucket, options);\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${name}`);\n  const result = await updateShard(context, positions, name, options);\n  let cid = result.cid;\n  let size = result.size;\n  let newName = prefix;\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`); // convert shard back to normal dir\n\n    const link = result.node.Links[0];\n    newName = `${prefix}${(link.Name || '').substring(2)}`;\n    cid = link.Hash;\n    size = link.Tsize || 0;\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`);\n  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options);\n};\n/**\n * @param {MfsContext} context\n * @param {Bucket} bucket\n * @param {PBNode} parent\n * @param {string} oldName\n * @param {string} newName\n * @param {number} size\n * @param {CID} cid\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  // Remove existing link if it exists\n  const parentLinks = parent.Links.filter(link => {\n    return link.Name !== oldName;\n  });\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  });\n  return updateHamtDirectory(context, parentLinks, bucket, options);\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/files/utils/remove-link.js"],"names":["dagPB","CID","logger","UnixFS","generatePath","updateHamtDirectory","errCode","log","removeLink","context","options","parent","parentCid","asCID","Error","block","repo","blocks","get","decode","name","Data","meta","unmarshal","type","removeFromShardedDirectory","removeFromDirectory","Links","filter","link","Name","parentBlock","encode","hasher","hashers","getHasher","hashAlg","hash","digest","create","cidVersion","code","put","node","cid","rootBucket","path","del","updateShard","positions","last","pop","bucket","prefix","find","substring","links","nodeLink","result","size","newName","length","Hash","Tsize","updateShardParent","oldName","parentLinks","push"],"mappings":"AACA,OAAO,KAAKA,KAAZ,MAAuB,cAAvB;AACA,SAASC,GAAT,QAAoB,kBAApB;AACA,SAASC,MAAT,QAAuB,gBAAvB;AACA,SAASC,MAAT,QAAuB,aAAvB;AACA,SACEC,YADF,EAEEC,mBAFF,QAGO,iBAHP;AAIA,OAAOC,OAAP,MAAoB,UAApB;AAEA,MAAMC,GAAG,GAAGL,MAAM,CAAC,iCAAD,CAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA,OAAO,eAAeM,UAAf,CAA2BC,OAA3B,EAAoCC,OAApC,EAA6C;AAClD,MAAIC,MAAM,GAAGD,OAAO,CAACC,MAArB;;AAEA,MAAID,OAAO,CAACE,SAAZ,EAAuB;AACrB,UAAMA,SAAS,GAAGX,GAAG,CAACY,KAAJ,CAAUH,OAAO,CAACE,SAAlB,CAAlB;;AACA,QAAIA,SAAS,KAAK,IAAlB,EAAwB;AACtB,YAAMN,OAAO,CAAC,IAAIQ,KAAJ,CAAU,kCAAV,CAAD,EAAgD,mBAAhD,CAAb;AACD;;AAEDP,IAAAA,GAAG,CAAE,uBAAsBK,SAAU,EAAlC,CAAH;AACA,UAAMG,KAAK,GAAG,MAAMN,OAAO,CAACO,IAAR,CAAaC,MAAb,CAAoBC,GAApB,CAAwBN,SAAxB,CAApB;AACAD,IAAAA,MAAM,GAAGX,KAAK,CAACmB,MAAN,CAAaJ,KAAb,CAAT;AACD;;AAED,MAAI,CAACJ,MAAL,EAAa;AACX,UAAML,OAAO,CAAC,IAAIQ,KAAJ,CAAU,4CAAV,CAAD,EAA0D,gBAA1D,CAAb;AACD;;AAED,MAAI,CAACJ,OAAO,CAACU,IAAb,EAAmB;AACjB,UAAMd,OAAO,CAAC,IAAIQ,KAAJ,CAAU,oCAAV,CAAD,EAAkD,mBAAlD,CAAb;AACD;;AAED,MAAI,CAACH,MAAM,CAACU,IAAZ,EAAkB;AAChB,UAAMf,OAAO,CAAC,IAAIQ,KAAJ,CAAU,yBAAV,CAAD,EAAuC,kBAAvC,CAAb;AACD;;AAED,QAAMQ,IAAI,GAAGnB,MAAM,CAACoB,SAAP,CAAiBZ,MAAM,CAACU,IAAxB,CAAb;;AAEA,MAAIC,IAAI,CAACE,IAAL,KAAc,wBAAlB,EAA4C;AAC1CjB,IAAAA,GAAG,CAAE,YAAWG,OAAO,CAACU,IAAK,yBAA1B,CAAH;AAEA,WAAOK,0BAA0B,CAAChB,OAAD,EAAU,EACzC,GAAGC,OADsC;AAEzCC,MAAAA;AAFyC,KAAV,CAAjC;AAID;;AAEDJ,EAAAA,GAAG,CAAE,iBAAgBG,OAAO,CAACU,IAAK,oBAA/B,CAAH;AAEA,SAAOM,mBAAmB,CAACjB,OAAD,EAAU,EAClC,GAAGC,OAD+B;AAElCC,IAAAA;AAFkC,GAAV,CAA1B;AAID;AAED;AACA;AACA;AACA;;AACA,MAAMe,mBAAmB,GAAG,OAAOjB,OAAP,EAAgBC,OAAhB,KAA4B;AACtD;AACAA,EAAAA,OAAO,CAACC,MAAR,CAAegB,KAAf,GAAuBjB,OAAO,CAACC,MAAR,CAAegB,KAAf,CAAqBC,MAArB,CAA6BC,IAAD,IAAU;AAC3D,WAAOA,IAAI,CAACC,IAAL,KAAcpB,OAAO,CAACU,IAA7B;AACD,GAFsB,CAAvB;AAIA,QAAMW,WAAW,GAAG,MAAM/B,KAAK,CAACgC,MAAN,CAAatB,OAAO,CAACC,MAArB,CAA1B;AACA,QAAMsB,MAAM,GAAG,MAAMxB,OAAO,CAACyB,OAAR,CAAgBC,SAAhB,CAA0BzB,OAAO,CAAC0B,OAAlC,CAArB;AACA,QAAMC,IAAI,GAAG,MAAMJ,MAAM,CAACK,MAAP,CAAcP,WAAd,CAAnB;AACA,QAAMnB,SAAS,GAAGX,GAAG,CAACsC,MAAJ,CAAW7B,OAAO,CAAC8B,UAAnB,EAA+BxC,KAAK,CAACyC,IAArC,EAA2CJ,IAA3C,CAAlB;AAEA,QAAM5B,OAAO,CAACO,IAAR,CAAaC,MAAb,CAAoByB,GAApB,CAAwB9B,SAAxB,EAAmCmB,WAAnC,CAAN;AAEAxB,EAAAA,GAAG,CAAE,6BAA4BK,SAAU,EAAxC,CAAH;AAEA,SAAO;AACL+B,IAAAA,IAAI,EAAEjC,OAAO,CAACC,MADT;AAELiC,IAAAA,GAAG,EAAEhC;AAFA,GAAP;AAID,CAnBD;AAqBA;AACA;AACA;AACA;;;AACA,MAAMa,0BAA0B,GAAG,OAAOhB,OAAP,EAAgBC,OAAhB,KAA4B;AAC7D,QAAM;AACJmC,IAAAA,UADI;AACQC,IAAAA;AADR,MAEF,MAAM1C,YAAY,CAACK,OAAD,EAAUC,OAAO,CAACU,IAAlB,EAAwBV,OAAO,CAACC,MAAhC,CAFtB;AAIA,QAAMkC,UAAU,CAACE,GAAX,CAAerC,OAAO,CAACU,IAAvB,CAAN;AAEA,QAAM;AACJuB,IAAAA;AADI,MAEF,MAAMK,WAAW,CAACvC,OAAD,EAAUqC,IAAV,EAAgBpC,OAAO,CAACU,IAAxB,EAA8BV,OAA9B,CAFrB;AAIA,SAAOL,mBAAmB,CAACI,OAAD,EAAUkC,IAAI,CAAChB,KAAf,EAAsBkB,UAAtB,EAAkCnC,OAAlC,CAA1B;AACD,CAZD;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMsC,WAAW,GAAG,OAAOvC,OAAP,EAAgBwC,SAAhB,EAA2B7B,IAA3B,EAAiCV,OAAjC,KAA6C;AAC/D,QAAMwC,IAAI,GAAGD,SAAS,CAACE,GAAV,EAAb;;AAEA,MAAI,CAACD,IAAL,EAAW;AACT,UAAM5C,OAAO,CAAC,IAAIQ,KAAJ,CAAU,uBAAV,CAAD,EAAqC,gBAArC,CAAb;AACD;;AAED,QAAM;AACJsC,IAAAA,MADI;AAEJC,IAAAA,MAFI;AAGJV,IAAAA;AAHI,MAIFO,IAJJ;;AAMA,MAAI,CAACP,IAAL,EAAW;AACT,UAAMrC,OAAO,CAAC,IAAIQ,KAAJ,CAAU,uBAAV,CAAD,EAAqC,gBAArC,CAAb;AACD;;AAED,QAAMe,IAAI,GAAGc,IAAI,CAAChB,KAAL,CACV2B,IADU,CACLzB,IAAI,IAAI,CAACA,IAAI,CAACC,IAAL,IAAa,EAAd,EAAkByB,SAAlB,CAA4B,CAA5B,EAA+B,CAA/B,MAAsCF,MADzC,CAAb;;AAGA,MAAI,CAACxB,IAAL,EAAW;AACT,UAAMvB,OAAO,CAAC,IAAIQ,KAAJ,CAAW,6BAA4BuC,MAAO,aAAYjC,IAAK,EAA/D,CAAD,EAAoE,eAApE,CAAb;AACD;;AAED,MAAIS,IAAI,CAACC,IAAL,KAAe,GAAEuB,MAAO,GAAEjC,IAAK,EAAnC,EAAsC;AACpCb,IAAAA,GAAG,CAAE,0BAAyBsB,IAAI,CAACC,IAAK,EAArC,CAAH;AAEA,UAAM0B,KAAK,GAAGb,IAAI,CAAChB,KAAL,CAAWC,MAAX,CAAmB6B,QAAD,IAAc;AAC5C,aAAOA,QAAQ,CAAC3B,IAAT,KAAkBD,IAAI,CAACC,IAA9B;AACD,KAFa,CAAd;AAIA,UAAMsB,MAAM,CAACL,GAAP,CAAW3B,IAAX,CAAN;AAEA,WAAOf,mBAAmB,CAACI,OAAD,EAAU+C,KAAV,EAAiBJ,MAAjB,EAAyB1C,OAAzB,CAA1B;AACD;;AAEDH,EAAAA,GAAG,CAAE,6BAA4BsB,IAAI,CAACC,IAAK,QAAOuB,MAAO,GAAEjC,IAAK,EAA7D,CAAH;AAEA,QAAMsC,MAAM,GAAG,MAAMV,WAAW,CAACvC,OAAD,EAAUwC,SAAV,EAAqB7B,IAArB,EAA2BV,OAA3B,CAAhC;AAEA,MAAIkC,GAAG,GAAGc,MAAM,CAACd,GAAjB;AACA,MAAIe,IAAI,GAAGD,MAAM,CAACC,IAAlB;AACA,MAAIC,OAAO,GAAGP,MAAd;;AAEA,MAAIK,MAAM,CAACf,IAAP,CAAYhB,KAAZ,CAAkBkC,MAAlB,KAA6B,CAAjC,EAAoC;AAClCtD,IAAAA,GAAG,CAAE,yBAAwB8C,MAAO,EAAjC,CAAH,CADkC,CAGlC;;AACA,UAAMxB,IAAI,GAAG6B,MAAM,CAACf,IAAP,CAAYhB,KAAZ,CAAkB,CAAlB,CAAb;AAEAiC,IAAAA,OAAO,GAAI,GAAEP,MAAO,GAAE,CAACxB,IAAI,CAACC,IAAL,IAAa,EAAd,EAAkByB,SAAlB,CAA4B,CAA5B,CAA+B,EAArD;AACAX,IAAAA,GAAG,GAAGf,IAAI,CAACiC,IAAX;AACAH,IAAAA,IAAI,GAAG9B,IAAI,CAACkC,KAAL,IAAc,CAArB;AACD;;AAEDxD,EAAAA,GAAG,CAAE,kBAAiB8C,MAAO,cAAaO,OAAQ,EAA/C,CAAH;AAEA,SAAOI,iBAAiB,CAACvD,OAAD,EAAU2C,MAAV,EAAkBT,IAAlB,EAAwBU,MAAxB,EAAgCO,OAAhC,EAAyCD,IAAzC,EAA+Cf,GAA/C,EAAoDlC,OAApD,CAAxB;AACD,CA1DD;AA4DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMsD,iBAAiB,GAAG,CAACvD,OAAD,EAAU2C,MAAV,EAAkBzC,MAAlB,EAA0BsD,OAA1B,EAAmCL,OAAnC,EAA4CD,IAA5C,EAAkDf,GAAlD,EAAuDlC,OAAvD,KAAmE;AAC3F;AACA,QAAMwD,WAAW,GAAGvD,MAAM,CAACgB,KAAP,CAAaC,MAAb,CAAqBC,IAAD,IAAU;AAChD,WAAOA,IAAI,CAACC,IAAL,KAAcmC,OAArB;AACD,GAFmB,CAApB;AAGAC,EAAAA,WAAW,CAACC,IAAZ,CAAiB;AACfrC,IAAAA,IAAI,EAAE8B,OADS;AAEfG,IAAAA,KAAK,EAAEJ,IAFQ;AAGfG,IAAAA,IAAI,EAAElB;AAHS,GAAjB;AAMA,SAAOvC,mBAAmB,CAACI,OAAD,EAAUyD,WAAV,EAAuBd,MAAvB,EAA+B1C,OAA/B,CAA1B;AACD,CAZD","sourcesContent":["\nimport * as dagPB from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport {\n  generatePath,\n  updateHamtDirectory\n} from './hamt-utils.js'\nimport errCode from 'err-code'\n\nconst log = logger('ipfs:mfs:core:utils:remove-link')\n\n/**\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} RemoveLinkOptions\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {CID} [parentCid]\n * @property {PBNode} [parent]\n *\n * @typedef {object} RemoveLinkOptionsInternal\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {PBNode} parent\n */\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptions} options\n */\nexport async function removeLink (context, options) {\n  let parent = options.parent\n\n  if (options.parentCid) {\n    const parentCid = CID.asCID(options.parentCid)\n    if (parentCid === null) {\n      throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID')\n    }\n\n    log(`Loading parent node ${parentCid}`)\n    const block = await context.repo.blocks.get(parentCid)\n    parent = dagPB.decode(block)\n  }\n\n  if (!parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT')\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME')\n  }\n\n  if (!parent.Data) {\n    throw errCode(new Error('Parent node had no data'), 'ERR_INVALID_NODE')\n  }\n\n  const meta = UnixFS.unmarshal(parent.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`)\n\n    return removeFromShardedDirectory(context, {\n      ...options,\n      parent\n    })\n  }\n\n  log(`Removing link ${options.name} regular directory`)\n\n  return removeFromDirectory(context, {\n    ...options,\n    parent\n  })\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromDirectory = async (context, options) => {\n  // Remove existing link if it exists\n  options.parent.Links = options.parent.Links.filter((link) => {\n    return link.Name !== options.name\n  })\n\n  const parentBlock = await dagPB.encode(options.parent)\n  const hasher = await context.hashers.getHasher(options.hashAlg)\n  const hash = await hasher.digest(parentBlock)\n  const parentCid = CID.create(options.cidVersion, dagPB.code, hash)\n\n  await context.repo.blocks.put(parentCid, parentBlock)\n\n  log(`Updated regular directory ${parentCid}`)\n\n  return {\n    node: options.parent,\n    cid: parentCid\n  }\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket, path\n  } = await generatePath(context, options.name, options.parent)\n\n  await rootBucket.del(options.name)\n\n  const {\n    node\n  } = await updateShard(context, path, options.name, options)\n\n  return updateHamtDirectory(context, node.Links, rootBucket, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {{ bucket: Bucket, prefix: string, node?: PBNode }[]} positions\n * @param {string} name\n * @param {RemoveLinkOptionsInternal} options\n * @returns {Promise<{ node: PBNode, cid: CID, size: number }>}\n */\nconst updateShard = async (context, positions, name, options) => {\n  const last = positions.pop()\n\n  if (!last) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT')\n  }\n\n  const {\n    bucket,\n    prefix,\n    node\n  } = last\n\n  if (!node) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT')\n  }\n\n  const link = node.Links\n    .find(link => (link.Name || '').substring(0, 2) === prefix)\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${name}`), 'ERR_NOT_FOUND')\n  }\n\n  if (link.Name === `${prefix}${name}`) {\n    log(`Removing existing link ${link.Name}`)\n\n    const links = node.Links.filter((nodeLink) => {\n      return nodeLink.Name !== link.Name\n    })\n\n    await bucket.del(name)\n\n    return updateHamtDirectory(context, links, bucket, options)\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${name}`)\n\n  const result = await updateShard(context, positions, name, options)\n\n  let cid = result.cid\n  let size = result.size\n  let newName = prefix\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`)\n\n    // convert shard back to normal dir\n    const link = result.node.Links[0]\n\n    newName = `${prefix}${(link.Name || '').substring(2)}`\n    cid = link.Hash\n    size = link.Tsize || 0\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`)\n\n  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {Bucket} bucket\n * @param {PBNode} parent\n * @param {string} oldName\n * @param {string} newName\n * @param {number} size\n * @param {CID} cid\n * @param {RemoveLinkOptionsInternal} options\n */\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  // Remove existing link if it exists\n  const parentLinks = parent.Links.filter((link) => {\n    return link.Name !== oldName\n  })\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  })\n\n  return updateHamtDirectory(context, parentLinks, bucket, options)\n}\n"]},"metadata":{},"sourceType":"module"}