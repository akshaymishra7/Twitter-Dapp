{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport * as lp from 'it-length-prefixed';\nimport { handshake } from 'it-handshake';\nimport { CircuitRelay } from '../pb/index.js';\nconst log = logger('libp2p:circuit:stream-handler');\nexport class StreamHandler {\n  constructor(options) {\n    const {\n      stream,\n      maxLength = 4096\n    } = options;\n    this.stream = stream;\n    this.shake = handshake(this.stream);\n    this.decoder = lp.decode.fromReader(this.shake.reader, {\n      maxDataLength: maxLength\n    });\n  }\n  /**\n   * Read and decode message\n   */\n\n\n  async read() {\n    // @ts-expect-error FIXME is a source, needs to be a generator\n    const msg = await this.decoder.next();\n\n    if (msg.value != null) {\n      const value = CircuitRelay.decode(msg.value);\n      log('read message type', value.type);\n      return value;\n    }\n\n    log('read received no value, closing stream'); // End the stream, we didn't get data\n\n    this.close();\n  }\n  /**\n   * Encode and write array of buffers\n   */\n\n\n  write(msg) {\n    log('write message type %s', msg.type);\n    this.shake.write(lp.encode.single(CircuitRelay.encode(msg)));\n  }\n  /**\n   * Return the handshake rest stream and invalidate handler\n   */\n\n\n  rest() {\n    this.shake.rest();\n    return this.shake.stream;\n  }\n  /**\n   * @param {CircuitRelay} msg - An unencoded CircuitRelay protobuf message\n   */\n\n\n  end(msg) {\n    this.write(msg);\n    this.close();\n  }\n  /**\n   * Close the stream\n   */\n\n\n  close() {\n    log('closing the stream');\n    void this.rest().sink([]).catch(err => {\n      log.error(err);\n    });\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,QAAuB,gBAAvB;AACA,OAAO,KAAKC,EAAZ,MAAoB,oBAApB;AACA,SAAoBC,SAApB,QAAqC,cAArC;AACA,SAASC,YAAT,QAA6B,gBAA7B;AAKA,MAAMC,GAAG,GAAGJ,MAAM,CAAC,+BAAD,CAAlB;AAcA,OAAM,MAAOK,aAAP,CAAoB;AAKxBC,cAAaC,OAAb,EAA0C;AACxC,UAAM;AAAEC,YAAF;AAAUC,eAAS,GAAG;AAAtB,QAA+BF,OAArC;AAEA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKE,KAAL,GAAaR,SAAS,CAAC,KAAKM,MAAN,CAAtB;AACA,SAAKG,OAAL,GAAeV,EAAE,CAACW,MAAH,CAAUC,UAAV,CAAqB,KAAKH,KAAL,CAAWI,MAAhC,EAAwC;AAAEC,mBAAa,EAAEN;AAAjB,KAAxC,CAAf;AACD;AAED;;;;;AAGU,QAAJO,IAAI;AACR;AACA,UAAMC,GAAG,GAAG,MAAM,KAAKN,OAAL,CAAaO,IAAb,EAAlB;;AAEA,QAAID,GAAG,CAACE,KAAJ,IAAa,IAAjB,EAAuB;AACrB,YAAMA,KAAK,GAAGhB,YAAY,CAACS,MAAb,CAAoBK,GAAG,CAACE,KAAxB,CAAd;AACAf,SAAG,CAAC,mBAAD,EAAsBe,KAAK,CAACC,IAA5B,CAAH;AACA,aAAOD,KAAP;AACD;;AAEDf,OAAG,CAAC,wCAAD,CAAH,CAVQ,CAWR;;AACA,SAAKiB,KAAL;AACD;AAED;;;;;AAGAC,OAAK,CAAEL,GAAF,EAAmB;AACtBb,OAAG,CAAC,uBAAD,EAA0Ba,GAAG,CAACG,IAA9B,CAAH;AACA,SAAKV,KAAL,CAAWY,KAAX,CAAiBrB,EAAE,CAACsB,MAAH,CAAUC,MAAV,CAAiBrB,YAAY,CAACoB,MAAb,CAAoBN,GAApB,CAAjB,CAAjB;AACD;AAED;;;;;AAGAQ,MAAI;AACF,SAAKf,KAAL,CAAWe,IAAX;AACA,WAAO,KAAKf,KAAL,CAAWF,MAAlB;AACD;AAED;;;;;AAGAkB,KAAG,CAAET,GAAF,EAAmB;AACpB,SAAKK,KAAL,CAAWL,GAAX;AACA,SAAKI,KAAL;AACD;AAED;;;;;AAGAA,OAAK;AACHjB,OAAG,CAAC,oBAAD,CAAH;AACA,SAAK,KAAKqB,IAAL,GAAYE,IAAZ,CAAiB,EAAjB,EAAqBC,KAArB,CAA2BC,GAAG,IAAG;AACpCzB,SAAG,CAAC0B,KAAJ,CAAUD,GAAV;AACD,KAFI,CAAL;AAGD;;AA/DuB","names":["logger","lp","handshake","CircuitRelay","log","StreamHandler","constructor","options","stream","maxLength","shake","decoder","decode","fromReader","reader","maxDataLength","read","msg","next","value","type","close","write","encode","single","rest","end","sink","catch","err","error"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\circuit\\circuit\\stream-handler.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport * as lp from 'it-length-prefixed'\nimport { Handshake, handshake } from 'it-handshake'\nimport { CircuitRelay } from '../pb/index.js'\nimport type { Stream } from '@libp2p/interface-connection'\nimport type { Source } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst log = logger('libp2p:circuit:stream-handler')\n\nexport interface StreamHandlerOptions {\n  /**\n   * A duplex iterable\n   */\n  stream: Stream\n\n  /**\n   * max bytes length of message\n   */\n  maxLength?: number\n}\n\nexport class StreamHandler {\n  private readonly stream: Stream\n  private readonly shake: Handshake<Uint8ArrayList | Uint8Array>\n  private readonly decoder: Source<Uint8ArrayList>\n\n  constructor (options: StreamHandlerOptions) {\n    const { stream, maxLength = 4096 } = options\n\n    this.stream = stream\n    this.shake = handshake(this.stream)\n    this.decoder = lp.decode.fromReader(this.shake.reader, { maxDataLength: maxLength })\n  }\n\n  /**\n   * Read and decode message\n   */\n  async read () {\n    // @ts-expect-error FIXME is a source, needs to be a generator\n    const msg = await this.decoder.next()\n\n    if (msg.value != null) {\n      const value = CircuitRelay.decode(msg.value)\n      log('read message type', value.type)\n      return value\n    }\n\n    log('read received no value, closing stream')\n    // End the stream, we didn't get data\n    this.close()\n  }\n\n  /**\n   * Encode and write array of buffers\n   */\n  write (msg: CircuitRelay) {\n    log('write message type %s', msg.type)\n    this.shake.write(lp.encode.single(CircuitRelay.encode(msg)))\n  }\n\n  /**\n   * Return the handshake rest stream and invalidate handler\n   */\n  rest () {\n    this.shake.rest()\n    return this.shake.stream\n  }\n\n  /**\n   * @param {CircuitRelay} msg - An unencoded CircuitRelay protobuf message\n   */\n  end (msg: CircuitRelay) {\n    this.write(msg)\n    this.close()\n  }\n\n  /**\n   * Close the stream\n   */\n  close () {\n    log('closing the stream')\n    void this.rest().sink([]).catch(err => {\n      log.error(err)\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}