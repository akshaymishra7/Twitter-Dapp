{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 5] */\nimport { logger } from '@libp2p/logger';\nimport sanitize from 'sanitize-filename';\nimport mergeOptions from 'merge-options';\nimport { Key } from 'interface-datastore/key';\nimport { CMS } from './cms.js';\nimport errCode from 'err-code';\nimport { codes } from '../errors.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { generateKeyPair, importKey, unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport { pbkdf2, randomBytes } from '@libp2p/crypto';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nconst log = logger('libp2p:keychain');\nconst keyPrefix = '/pkcs8/';\nconst infoPrefix = '/info/';\nconst privates = new WeakMap(); // NIST SP 800-132\n\nconst NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n};\nconst defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n};\n\nfunction validateKeyName(name) {\n  if (name == null) {\n    return false;\n  }\n\n  if (typeof name !== 'string') {\n    return false;\n  }\n\n  return name === sanitize(name.trim()) && name.length > 0;\n}\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n */\n\n\nasync function randomDelay() {\n  const min = 200;\n  const max = 1000;\n  const delay = Math.random() * (max - min) + min;\n  await new Promise(resolve => setTimeout(resolve, delay));\n}\n/**\n * Converts a key name into a datastore name\n */\n\n\nfunction DsName(name) {\n  return new Key(keyPrefix + name);\n}\n/**\n * Converts a key name into a datastore info name\n */\n\n\nfunction DsInfoName(name) {\n  return new Key(infoPrefix + name);\n}\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\n\n\nexport class KeyChain {\n  /**\n   * Creates a new instance of a key chain\n   */\n  constructor(components, init) {\n    this.components = components;\n    this.init = mergeOptions(defaultOptions, init); // Enforce NIST SP 800-132\n\n    if (this.init.pass != null && this.init.pass?.length < 20) {\n      throw new Error('pass must be least 20 characters');\n    }\n\n    if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);\n    }\n\n    if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);\n    }\n\n    if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);\n    }\n\n    const dek = this.init.pass != null && this.init.dek?.salt != null ? pbkdf2(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : '';\n    privates.set(this, {\n      dek\n    });\n    this.started = false;\n  }\n\n  isStarted() {\n    return this.started;\n  }\n\n  async start() {\n    const dsname = DsInfoName('self');\n\n    if (!(await this.components.datastore.has(dsname))) {\n      await this.importPeer('self', this.components.peerId);\n    }\n\n    this.started = true;\n  }\n\n  stop() {\n    this.started = false;\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content\n   */\n\n\n  get cms() {\n    const cached = privates.get(this);\n\n    if (cached == null) {\n      throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    const dek = cached.dek;\n    return new CMS(this, dek);\n  }\n  /**\n   * Generates the options for a keychain.  A random salt is produced.\n   *\n   * @returns {object}\n   */\n\n\n  static generateOptions() {\n    const options = Object.assign({}, defaultOptions);\n    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3; // no base64 padding\n\n    options.dek.salt = uint8ArrayToString(randomBytes(saltLength), 'base64');\n    return options;\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data.\n   * The default options for a keychain.\n   *\n   * @returns {object}\n   */\n\n\n  static get options() {\n    return defaultOptions;\n  }\n  /**\n   * Create a new key.\n   *\n   * @param {string} name - The local key name; cannot already exist.\n   * @param {string} type - One of the key types; 'rsa'.\n   * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only\n   */\n\n\n  async createKey(name, type) {\n    let size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2048;\n\n    if (!validateKeyName(name) || name === 'self') {\n      await randomDelay();\n      throw errCode(new Error('Invalid key name'), codes.ERR_INVALID_KEY_NAME);\n    }\n\n    if (typeof type !== 'string') {\n      await randomDelay();\n      throw errCode(new Error('Invalid key type'), codes.ERR_INVALID_KEY_TYPE);\n    }\n\n    const dsname = DsName(name);\n    const exists = await this.components.datastore.has(dsname);\n\n    if (exists) {\n      await randomDelay();\n      throw errCode(new Error('Key name already exists'), codes.ERR_KEY_ALREADY_EXISTS);\n    }\n\n    switch (type.toLowerCase()) {\n      case 'rsa':\n        if (!Number.isSafeInteger(size) || size < 2048) {\n          await randomDelay();\n          throw errCode(new Error('Invalid RSA key size'), codes.ERR_INVALID_KEY_SIZE);\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    let keyInfo;\n\n    try {\n      const keypair = await generateKeyPair(type, size);\n      const kid = await keypair.id();\n      const cached = privates.get(this);\n\n      if (cached == null) {\n        throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS);\n      }\n\n      const dek = cached.dek;\n      const pem = await keypair.export(dek);\n      keyInfo = {\n        name: name,\n        id: kid\n      };\n      const batch = this.components.datastore.batch();\n      batch.put(dsname, uint8ArrayFromString(pem));\n      batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n      await batch.commit();\n    } catch (err) {\n      await randomDelay();\n      throw err;\n    }\n\n    return keyInfo;\n  }\n  /**\n   * List all the keys.\n   *\n   * @returns {Promise<KeyInfo[]>}\n   */\n\n\n  async listKeys() {\n    const query = {\n      prefix: infoPrefix\n    };\n    const info = [];\n\n    for await (const value of this.components.datastore.query(query)) {\n      info.push(JSON.parse(uint8ArrayToString(value.value)));\n    }\n\n    return info;\n  }\n  /**\n   * Find a key by it's id\n   */\n\n\n  async findKeyById(id) {\n    try {\n      const keys = await this.listKeys();\n      return keys.find(k => k.id === id);\n    } catch (err) {\n      await randomDelay();\n      throw err;\n    }\n  }\n  /**\n   * Find a key by it's name.\n   *\n   * @param {string} name - The local key name.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  async findKeyByName(name) {\n    if (!validateKeyName(name)) {\n      await randomDelay();\n      throw errCode(new Error(`Invalid key name '${name}'`), codes.ERR_INVALID_KEY_NAME);\n    }\n\n    const dsname = DsInfoName(name);\n\n    try {\n      const res = await this.components.datastore.get(dsname);\n      return JSON.parse(uint8ArrayToString(res));\n    } catch (err) {\n      await randomDelay();\n      log.error(err);\n      throw errCode(new Error(`Key '${name}' does not exist.`), codes.ERR_KEY_NOT_FOUND);\n    }\n  }\n  /**\n   * Remove an existing key.\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  async removeKey(name) {\n    if (!validateKeyName(name) || name === 'self') {\n      await randomDelay();\n      throw errCode(new Error(`Invalid key name '${name}'`), codes.ERR_INVALID_KEY_NAME);\n    }\n\n    const dsname = DsName(name);\n    const keyInfo = await this.findKeyByName(name);\n    const batch = this.components.datastore.batch();\n    batch.delete(dsname);\n    batch.delete(DsInfoName(name));\n    await batch.commit();\n    return keyInfo;\n  }\n  /**\n   * Rename a key\n   *\n   * @param {string} oldName - The old local key name; must already exist.\n   * @param {string} newName - The new local key name; must not already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  async renameKey(oldName, newName) {\n    if (!validateKeyName(oldName) || oldName === 'self') {\n      await randomDelay();\n      throw errCode(new Error(`Invalid old key name '${oldName}'`), codes.ERR_OLD_KEY_NAME_INVALID);\n    }\n\n    if (!validateKeyName(newName) || newName === 'self') {\n      await randomDelay();\n      throw errCode(new Error(`Invalid new key name '${newName}'`), codes.ERR_NEW_KEY_NAME_INVALID);\n    }\n\n    const oldDsname = DsName(oldName);\n    const newDsname = DsName(newName);\n    const oldInfoName = DsInfoName(oldName);\n    const newInfoName = DsInfoName(newName);\n    const exists = await this.components.datastore.has(newDsname);\n\n    if (exists) {\n      await randomDelay();\n      throw errCode(new Error(`Key '${newName}' already exists`), codes.ERR_KEY_ALREADY_EXISTS);\n    }\n\n    try {\n      const pem = await this.components.datastore.get(oldDsname);\n      const res = await this.components.datastore.get(oldInfoName);\n      const keyInfo = JSON.parse(uint8ArrayToString(res));\n      keyInfo.name = newName;\n      const batch = this.components.datastore.batch();\n      batch.put(newDsname, pem);\n      batch.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)));\n      batch.delete(oldDsname);\n      batch.delete(oldInfoName);\n      await batch.commit();\n      return keyInfo;\n    } catch (err) {\n      await randomDelay();\n      throw err;\n    }\n  }\n  /**\n   * Export an existing key as a PEM encrypted PKCS #8 string\n   */\n\n\n  async exportKey(name, password) {\n    if (!validateKeyName(name)) {\n      await randomDelay();\n      throw errCode(new Error(`Invalid key name '${name}'`), codes.ERR_INVALID_KEY_NAME);\n    }\n\n    if (password == null) {\n      await randomDelay();\n      throw errCode(new Error('Password is required'), codes.ERR_PASSWORD_REQUIRED);\n    }\n\n    const dsname = DsName(name);\n\n    try {\n      const res = await this.components.datastore.get(dsname);\n      const pem = uint8ArrayToString(res);\n      const cached = privates.get(this);\n\n      if (cached == null) {\n        throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS);\n      }\n\n      const dek = cached.dek;\n      const privateKey = await importKey(pem, dek);\n      return await privateKey.export(password);\n    } catch (err) {\n      await randomDelay();\n      throw err;\n    }\n  }\n  /**\n   * Export an existing key as a PeerId\n   */\n\n\n  async exportPeerId(name) {\n    const password = 'temporary-password';\n    const pem = await this.exportKey(name, password);\n    const privateKey = await importKey(pem, password);\n    return await peerIdFromKeys(privateKey.public.bytes, privateKey.bytes);\n  }\n  /**\n   * Import a new key from a PEM encoded PKCS #8 string\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {string} pem - The PEM encoded PKCS #8 string\n   * @param {string} password - The password.\n   * @returns {Promise<KeyInfo>}\n   */\n\n\n  async importKey(name, pem, password) {\n    if (!validateKeyName(name) || name === 'self') {\n      await randomDelay();\n      throw errCode(new Error(`Invalid key name '${name}'`), codes.ERR_INVALID_KEY_NAME);\n    }\n\n    if (pem == null) {\n      await randomDelay();\n      throw errCode(new Error('PEM encoded key is required'), codes.ERR_PEM_REQUIRED);\n    }\n\n    const dsname = DsName(name);\n    const exists = await this.components.datastore.has(dsname);\n\n    if (exists) {\n      await randomDelay();\n      throw errCode(new Error(`Key '${name}' already exists`), codes.ERR_KEY_ALREADY_EXISTS);\n    }\n\n    let privateKey;\n\n    try {\n      privateKey = await importKey(pem, password);\n    } catch (err) {\n      await randomDelay();\n      throw errCode(new Error('Cannot read the key, most likely the password is wrong'), codes.ERR_CANNOT_READ_KEY);\n    }\n\n    let kid;\n\n    try {\n      kid = await privateKey.id();\n      const cached = privates.get(this);\n\n      if (cached == null) {\n        throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS);\n      }\n\n      const dek = cached.dek;\n      pem = await privateKey.export(dek);\n    } catch (err) {\n      await randomDelay();\n      throw err;\n    }\n\n    const keyInfo = {\n      name: name,\n      id: kid\n    };\n    const batch = this.components.datastore.batch();\n    batch.put(dsname, uint8ArrayFromString(pem));\n    batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n    await batch.commit();\n    return keyInfo;\n  }\n  /**\n   * Import a peer key\n   */\n\n\n  async importPeer(name, peer) {\n    try {\n      if (!validateKeyName(name)) {\n        throw errCode(new Error(`Invalid key name '${name}'`), codes.ERR_INVALID_KEY_NAME);\n      }\n\n      if (peer == null) {\n        throw errCode(new Error('PeerId is required'), codes.ERR_MISSING_PRIVATE_KEY);\n      }\n\n      if (peer.privateKey == null) {\n        throw errCode(new Error('PeerId.privKey is required'), codes.ERR_MISSING_PRIVATE_KEY);\n      }\n\n      const privateKey = await unmarshalPrivateKey(peer.privateKey);\n      const dsname = DsName(name);\n      const exists = await this.components.datastore.has(dsname);\n\n      if (exists) {\n        await randomDelay();\n        throw errCode(new Error(`Key '${name}' already exists`), codes.ERR_KEY_ALREADY_EXISTS);\n      }\n\n      const cached = privates.get(this);\n\n      if (cached == null) {\n        throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS);\n      }\n\n      const dek = cached.dek;\n      const pem = await privateKey.export(dek);\n      const keyInfo = {\n        name: name,\n        id: peer.toString()\n      };\n      const batch = this.components.datastore.batch();\n      batch.put(dsname, uint8ArrayFromString(pem));\n      batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n      await batch.commit();\n      return keyInfo;\n    } catch (err) {\n      await randomDelay();\n      throw err;\n    }\n  }\n  /**\n   * Gets the private key as PEM encoded PKCS #8 string\n   */\n\n\n  async getPrivateKey(name) {\n    if (!validateKeyName(name)) {\n      await randomDelay();\n      throw errCode(new Error(`Invalid key name '${name}'`), codes.ERR_INVALID_KEY_NAME);\n    }\n\n    try {\n      const dsname = DsName(name);\n      const res = await this.components.datastore.get(dsname);\n      return uint8ArrayToString(res);\n    } catch (err) {\n      await randomDelay();\n      log.error(err);\n      throw errCode(new Error(`Key '${name}' does not exist.`), codes.ERR_KEY_NOT_FOUND);\n    }\n  }\n  /**\n   * Rotate keychain password and re-encrypt all associated keys\n   */\n\n\n  async rotateKeychainPass(oldPass, newPass) {\n    if (typeof oldPass !== 'string') {\n      await randomDelay();\n      throw errCode(new Error(`Invalid old pass type '${typeof oldPass}'`), codes.ERR_INVALID_OLD_PASS_TYPE);\n    }\n\n    if (typeof newPass !== 'string') {\n      await randomDelay();\n      throw errCode(new Error(`Invalid new pass type '${typeof newPass}'`), codes.ERR_INVALID_NEW_PASS_TYPE);\n    }\n\n    if (newPass.length < 20) {\n      await randomDelay();\n      throw errCode(new Error(`Invalid pass length ${newPass.length}`), codes.ERR_INVALID_PASS_LENGTH);\n    }\n\n    log('recreating keychain');\n    const cached = privates.get(this);\n\n    if (cached == null) {\n      throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    const oldDek = cached.dek;\n    this.init.pass = newPass;\n    const newDek = newPass != null && this.init.dek?.salt != null ? pbkdf2(newPass, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : '';\n    privates.set(this, {\n      dek: newDek\n    });\n    const keys = await this.listKeys();\n\n    for (const key of keys) {\n      const res = await this.components.datastore.get(DsName(key.name));\n      const pem = uint8ArrayToString(res);\n      const privateKey = await importKey(pem, oldDek);\n      const password = newDek.toString();\n      const keyAsPEM = await privateKey.export(password); // Update stored key\n\n      const batch = this.components.datastore.batch();\n      const keyInfo = {\n        name: key.name,\n        id: key.id\n      };\n      batch.put(DsName(key.name), uint8ArrayFromString(keyAsPEM));\n      batch.put(DsInfoName(key.name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n      await batch.commit();\n    }\n\n    log('keychain reconstructed');\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","sanitize","mergeOptions","Key","CMS","errCode","codes","toString","uint8ArrayToString","fromString","uint8ArrayFromString","generateKeyPair","importKey","unmarshalPrivateKey","pbkdf2","randomBytes","peerIdFromKeys","log","keyPrefix","infoPrefix","privates","WeakMap","NIST","minKeyLength","minSaltLength","minIterationCount","defaultOptions","dek","keyLength","iterationCount","salt","hash","validateKeyName","name","trim","length","randomDelay","min","max","delay","Math","random","Promise","resolve","setTimeout","DsName","DsInfoName","KeyChain","constructor","components","init","pass","Error","set","started","isStarted","start","dsname","datastore","has","importPeer","peerId","stop","cms","cached","get","ERR_INVALID_PARAMETERS","generateOptions","options","Object","assign","saltLength","ceil","createKey","type","size","ERR_INVALID_KEY_NAME","ERR_INVALID_KEY_TYPE","exists","ERR_KEY_ALREADY_EXISTS","toLowerCase","Number","isSafeInteger","ERR_INVALID_KEY_SIZE","keyInfo","keypair","kid","id","pem","export","batch","put","JSON","stringify","commit","err","listKeys","query","prefix","info","value","push","parse","findKeyById","keys","find","k","findKeyByName","res","error","ERR_KEY_NOT_FOUND","removeKey","delete","renameKey","oldName","newName","ERR_OLD_KEY_NAME_INVALID","ERR_NEW_KEY_NAME_INVALID","oldDsname","newDsname","oldInfoName","newInfoName","exportKey","password","ERR_PASSWORD_REQUIRED","privateKey","exportPeerId","public","bytes","ERR_PEM_REQUIRED","ERR_CANNOT_READ_KEY","peer","ERR_MISSING_PRIVATE_KEY","getPrivateKey","rotateKeychainPass","oldPass","newPass","ERR_INVALID_OLD_PASS_TYPE","ERR_INVALID_NEW_PASS_TYPE","ERR_INVALID_PASS_LENGTH","oldDek","newDek","key","keyAsPEM"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\keychain\\index.ts"],"sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 5] */\n\nimport { logger } from '@libp2p/logger'\nimport sanitize from 'sanitize-filename'\nimport mergeOptions from 'merge-options'\nimport { Key } from 'interface-datastore/key'\nimport { CMS } from './cms.js'\nimport errCode from 'err-code'\nimport { codes } from '../errors.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { generateKeyPair, importKey, unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport { pbkdf2, randomBytes } from '@libp2p/crypto'\nimport type { Startable } from '@libp2p/interfaces/dist/src/startable'\nimport type { Datastore } from 'interface-datastore'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport type { KeyTypes } from '@libp2p/crypto/keys'\n\nconst log = logger('libp2p:keychain')\n\nexport interface DEKConfig {\n  hash: string\n  salt: string\n  iterationCount: number\n  keyLength: number\n}\n\nexport interface KeyChainInit {\n  pass?: string\n  dek?: DEKConfig\n}\n\n/**\n * Information about a key.\n */\nexport interface KeyInfo {\n  /**\n   * The universally unique key id\n   */\n  id: string\n\n  /**\n   * The local key name.\n   */\n  name: string\n}\n\nconst keyPrefix = '/pkcs8/'\nconst infoPrefix = '/info/'\nconst privates = new WeakMap<object, { dek: string }>()\n\n// NIST SP 800-132\nconst NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n}\n\nconst defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n}\n\nfunction validateKeyName (name: string) {\n  if (name == null) {\n    return false\n  }\n  if (typeof name !== 'string') {\n    return false\n  }\n  return name === sanitize(name.trim()) && name.length > 0\n}\n\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n */\nasync function randomDelay () {\n  const min = 200\n  const max = 1000\n  const delay = Math.random() * (max - min) + min\n\n  await new Promise(resolve => setTimeout(resolve, delay))\n}\n\n/**\n * Converts a key name into a datastore name\n */\nfunction DsName (name: string) {\n  return new Key(keyPrefix + name)\n}\n\n/**\n * Converts a key name into a datastore info name\n */\nfunction DsInfoName (name: string) {\n  return new Key(infoPrefix + name)\n}\n\nexport interface KeyChainComponents {\n  peerId: PeerId\n  datastore: Datastore\n}\n\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\nexport class KeyChain implements Startable {\n  private readonly components: KeyChainComponents\n  private readonly init: KeyChainInit\n  private started: boolean\n\n  /**\n   * Creates a new instance of a key chain\n   */\n  constructor (components: KeyChainComponents, init: KeyChainInit) {\n    this.components = components\n    this.init = mergeOptions(defaultOptions, init)\n\n    // Enforce NIST SP 800-132\n    if (this.init.pass != null && this.init.pass?.length < 20) {\n      throw new Error('pass must be least 20 characters')\n    }\n    if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`)\n    }\n    if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`)\n    }\n    if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`)\n    }\n\n    const dek = this.init.pass != null && this.init.dek?.salt != null\n      ? pbkdf2(\n        this.init.pass,\n        this.init.dek?.salt,\n        this.init.dek?.iterationCount,\n        this.init.dek?.keyLength,\n        this.init.dek?.hash)\n      : ''\n\n    privates.set(this, { dek })\n    this.started = false\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  async start () {\n    const dsname = DsInfoName('self')\n\n    if (!(await this.components.datastore.has(dsname))) {\n      await this.importPeer('self', this.components.peerId)\n    }\n\n    this.started = true\n  }\n\n  stop () {\n    this.started = false\n  }\n\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content\n   */\n  get cms () {\n    const cached = privates.get(this)\n\n    if (cached == null) {\n      throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    const dek = cached.dek\n\n    return new CMS(this, dek)\n  }\n\n  /**\n   * Generates the options for a keychain.  A random salt is produced.\n   *\n   * @returns {object}\n   */\n  static generateOptions (): KeyChainInit {\n    const options = Object.assign({}, defaultOptions)\n    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3 // no base64 padding\n    options.dek.salt = uint8ArrayToString(randomBytes(saltLength), 'base64')\n    return options\n  }\n\n  /**\n   * Gets an object that can encrypt/decrypt protected data.\n   * The default options for a keychain.\n   *\n   * @returns {object}\n   */\n  static get options () {\n    return defaultOptions\n  }\n\n  /**\n   * Create a new key.\n   *\n   * @param {string} name - The local key name; cannot already exist.\n   * @param {string} type - One of the key types; 'rsa'.\n   * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only\n   */\n  async createKey (name: string, type: KeyTypes, size = 2048): Promise<KeyInfo> {\n    if (!validateKeyName(name) || name === 'self') {\n      await randomDelay()\n      throw errCode(new Error('Invalid key name'), codes.ERR_INVALID_KEY_NAME)\n    }\n\n    if (typeof type !== 'string') {\n      await randomDelay()\n      throw errCode(new Error('Invalid key type'), codes.ERR_INVALID_KEY_TYPE)\n    }\n\n    const dsname = DsName(name)\n    const exists = await this.components.datastore.has(dsname)\n    if (exists) {\n      await randomDelay()\n      throw errCode(new Error('Key name already exists'), codes.ERR_KEY_ALREADY_EXISTS)\n    }\n\n    switch (type.toLowerCase()) {\n      case 'rsa':\n        if (!Number.isSafeInteger(size) || size < 2048) {\n          await randomDelay()\n          throw errCode(new Error('Invalid RSA key size'), codes.ERR_INVALID_KEY_SIZE)\n        }\n        break\n      default:\n        break\n    }\n\n    let keyInfo\n    try {\n      const keypair = await generateKeyPair(type, size)\n      const kid = await keypair.id()\n      const cached = privates.get(this)\n\n      if (cached == null) {\n        throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS)\n      }\n\n      const dek = cached.dek\n      const pem = await keypair.export(dek)\n      keyInfo = {\n        name: name,\n        id: kid\n      }\n      const batch = this.components.datastore.batch()\n      batch.put(dsname, uint8ArrayFromString(pem))\n      batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n\n      await batch.commit()\n    } catch (err: any) {\n      await randomDelay()\n      throw err\n    }\n\n    return keyInfo\n  }\n\n  /**\n   * List all the keys.\n   *\n   * @returns {Promise<KeyInfo[]>}\n   */\n  async listKeys () {\n    const query = {\n      prefix: infoPrefix\n    }\n\n    const info = []\n    for await (const value of this.components.datastore.query(query)) {\n      info.push(JSON.parse(uint8ArrayToString(value.value)))\n    }\n\n    return info\n  }\n\n  /**\n   * Find a key by it's id\n   */\n  async findKeyById (id: string): Promise<KeyInfo> {\n    try {\n      const keys = await this.listKeys()\n      return keys.find((k) => k.id === id)\n    } catch (err: any) {\n      await randomDelay()\n      throw err\n    }\n  }\n\n  /**\n   * Find a key by it's name.\n   *\n   * @param {string} name - The local key name.\n   * @returns {Promise<KeyInfo>}\n   */\n  async findKeyByName (name: string): Promise<KeyInfo> {\n    if (!validateKeyName(name)) {\n      await randomDelay()\n      throw errCode(new Error(`Invalid key name '${name}'`), codes.ERR_INVALID_KEY_NAME)\n    }\n\n    const dsname = DsInfoName(name)\n    try {\n      const res = await this.components.datastore.get(dsname)\n      return JSON.parse(uint8ArrayToString(res))\n    } catch (err: any) {\n      await randomDelay()\n      log.error(err)\n      throw errCode(new Error(`Key '${name}' does not exist.`), codes.ERR_KEY_NOT_FOUND)\n    }\n  }\n\n  /**\n   * Remove an existing key.\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n  async removeKey (name: string) {\n    if (!validateKeyName(name) || name === 'self') {\n      await randomDelay()\n      throw errCode(new Error(`Invalid key name '${name}'`), codes.ERR_INVALID_KEY_NAME)\n    }\n    const dsname = DsName(name)\n    const keyInfo = await this.findKeyByName(name)\n    const batch = this.components.datastore.batch()\n    batch.delete(dsname)\n    batch.delete(DsInfoName(name))\n    await batch.commit()\n    return keyInfo\n  }\n\n  /**\n   * Rename a key\n   *\n   * @param {string} oldName - The old local key name; must already exist.\n   * @param {string} newName - The new local key name; must not already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n  async renameKey (oldName: string, newName: string): Promise<KeyInfo> {\n    if (!validateKeyName(oldName) || oldName === 'self') {\n      await randomDelay()\n      throw errCode(new Error(`Invalid old key name '${oldName}'`), codes.ERR_OLD_KEY_NAME_INVALID)\n    }\n    if (!validateKeyName(newName) || newName === 'self') {\n      await randomDelay()\n      throw errCode(new Error(`Invalid new key name '${newName}'`), codes.ERR_NEW_KEY_NAME_INVALID)\n    }\n    const oldDsname = DsName(oldName)\n    const newDsname = DsName(newName)\n    const oldInfoName = DsInfoName(oldName)\n    const newInfoName = DsInfoName(newName)\n\n    const exists = await this.components.datastore.has(newDsname)\n    if (exists) {\n      await randomDelay()\n      throw errCode(new Error(`Key '${newName}' already exists`), codes.ERR_KEY_ALREADY_EXISTS)\n    }\n\n    try {\n      const pem = await this.components.datastore.get(oldDsname)\n      const res = await this.components.datastore.get(oldInfoName)\n\n      const keyInfo = JSON.parse(uint8ArrayToString(res))\n      keyInfo.name = newName\n      const batch = this.components.datastore.batch()\n      batch.put(newDsname, pem)\n      batch.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)))\n      batch.delete(oldDsname)\n      batch.delete(oldInfoName)\n      await batch.commit()\n      return keyInfo\n    } catch (err: any) {\n      await randomDelay()\n      throw err\n    }\n  }\n\n  /**\n   * Export an existing key as a PEM encrypted PKCS #8 string\n   */\n  async exportKey (name: string, password: string) {\n    if (!validateKeyName(name)) {\n      await randomDelay()\n      throw errCode(new Error(`Invalid key name '${name}'`), codes.ERR_INVALID_KEY_NAME)\n    }\n    if (password == null) {\n      await randomDelay()\n      throw errCode(new Error('Password is required'), codes.ERR_PASSWORD_REQUIRED)\n    }\n\n    const dsname = DsName(name)\n    try {\n      const res = await this.components.datastore.get(dsname)\n      const pem = uint8ArrayToString(res)\n      const cached = privates.get(this)\n\n      if (cached == null) {\n        throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS)\n      }\n\n      const dek = cached.dek\n      const privateKey = await importKey(pem, dek)\n      return await privateKey.export(password)\n    } catch (err: any) {\n      await randomDelay()\n      throw err\n    }\n  }\n\n  /**\n   * Export an existing key as a PeerId\n   */\n  async exportPeerId (name: string) {\n    const password = 'temporary-password'\n    const pem = await this.exportKey(name, password)\n    const privateKey = await importKey(pem, password)\n\n    return await peerIdFromKeys(privateKey.public.bytes, privateKey.bytes)\n  }\n\n  /**\n   * Import a new key from a PEM encoded PKCS #8 string\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {string} pem - The PEM encoded PKCS #8 string\n   * @param {string} password - The password.\n   * @returns {Promise<KeyInfo>}\n   */\n  async importKey (name: string, pem: string, password: string): Promise<KeyInfo> {\n    if (!validateKeyName(name) || name === 'self') {\n      await randomDelay()\n      throw errCode(new Error(`Invalid key name '${name}'`), codes.ERR_INVALID_KEY_NAME)\n    }\n    if (pem == null) {\n      await randomDelay()\n      throw errCode(new Error('PEM encoded key is required'), codes.ERR_PEM_REQUIRED)\n    }\n    const dsname = DsName(name)\n    const exists = await this.components.datastore.has(dsname)\n    if (exists) {\n      await randomDelay()\n      throw errCode(new Error(`Key '${name}' already exists`), codes.ERR_KEY_ALREADY_EXISTS)\n    }\n\n    let privateKey\n    try {\n      privateKey = await importKey(pem, password)\n    } catch (err: any) {\n      await randomDelay()\n      throw errCode(new Error('Cannot read the key, most likely the password is wrong'), codes.ERR_CANNOT_READ_KEY)\n    }\n\n    let kid\n    try {\n      kid = await privateKey.id()\n      const cached = privates.get(this)\n\n      if (cached == null) {\n        throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS)\n      }\n\n      const dek = cached.dek\n      pem = await privateKey.export(dek)\n    } catch (err: any) {\n      await randomDelay()\n      throw err\n    }\n\n    const keyInfo = {\n      name: name,\n      id: kid\n    }\n    const batch = this.components.datastore.batch()\n    batch.put(dsname, uint8ArrayFromString(pem))\n    batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n    await batch.commit()\n\n    return keyInfo\n  }\n\n  /**\n   * Import a peer key\n   */\n  async importPeer (name: string, peer: PeerId): Promise<KeyInfo> {\n    try {\n      if (!validateKeyName(name)) {\n        throw errCode(new Error(`Invalid key name '${name}'`), codes.ERR_INVALID_KEY_NAME)\n      }\n      if (peer == null) {\n        throw errCode(new Error('PeerId is required'), codes.ERR_MISSING_PRIVATE_KEY)\n      }\n      if (peer.privateKey == null) {\n        throw errCode(new Error('PeerId.privKey is required'), codes.ERR_MISSING_PRIVATE_KEY)\n      }\n\n      const privateKey = await unmarshalPrivateKey(peer.privateKey)\n\n      const dsname = DsName(name)\n      const exists = await this.components.datastore.has(dsname)\n      if (exists) {\n        await randomDelay()\n        throw errCode(new Error(`Key '${name}' already exists`), codes.ERR_KEY_ALREADY_EXISTS)\n      }\n\n      const cached = privates.get(this)\n\n      if (cached == null) {\n        throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS)\n      }\n\n      const dek = cached.dek\n      const pem = await privateKey.export(dek)\n      const keyInfo: KeyInfo = {\n        name: name,\n        id: peer.toString()\n      }\n      const batch = this.components.datastore.batch()\n      batch.put(dsname, uint8ArrayFromString(pem))\n      batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n      await batch.commit()\n      return keyInfo\n    } catch (err: any) {\n      await randomDelay()\n      throw err\n    }\n  }\n\n  /**\n   * Gets the private key as PEM encoded PKCS #8 string\n   */\n  async getPrivateKey (name: string): Promise<string> {\n    if (!validateKeyName(name)) {\n      await randomDelay()\n      throw errCode(new Error(`Invalid key name '${name}'`), codes.ERR_INVALID_KEY_NAME)\n    }\n\n    try {\n      const dsname = DsName(name)\n      const res = await this.components.datastore.get(dsname)\n      return uint8ArrayToString(res)\n    } catch (err: any) {\n      await randomDelay()\n      log.error(err)\n      throw errCode(new Error(`Key '${name}' does not exist.`), codes.ERR_KEY_NOT_FOUND)\n    }\n  }\n\n  /**\n   * Rotate keychain password and re-encrypt all associated keys\n   */\n  async rotateKeychainPass (oldPass: string, newPass: string) {\n    if (typeof oldPass !== 'string') {\n      await randomDelay()\n      throw errCode(new Error(`Invalid old pass type '${typeof oldPass}'`), codes.ERR_INVALID_OLD_PASS_TYPE)\n    }\n    if (typeof newPass !== 'string') {\n      await randomDelay()\n      throw errCode(new Error(`Invalid new pass type '${typeof newPass}'`), codes.ERR_INVALID_NEW_PASS_TYPE)\n    }\n    if (newPass.length < 20) {\n      await randomDelay()\n      throw errCode(new Error(`Invalid pass length ${newPass.length}`), codes.ERR_INVALID_PASS_LENGTH)\n    }\n    log('recreating keychain')\n    const cached = privates.get(this)\n\n    if (cached == null) {\n      throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    const oldDek = cached.dek\n    this.init.pass = newPass\n    const newDek = newPass != null && this.init.dek?.salt != null\n      ? pbkdf2(\n        newPass,\n        this.init.dek.salt,\n        this.init.dek?.iterationCount,\n        this.init.dek?.keyLength,\n        this.init.dek?.hash)\n      : ''\n    privates.set(this, { dek: newDek })\n    const keys = await this.listKeys()\n    for (const key of keys) {\n      const res = await this.components.datastore.get(DsName(key.name))\n      const pem = uint8ArrayToString(res)\n      const privateKey = await importKey(pem, oldDek)\n      const password = newDek.toString()\n      const keyAsPEM = await privateKey.export(password)\n\n      // Update stored key\n      const batch = this.components.datastore.batch()\n      const keyInfo = {\n        name: key.name,\n        id: key.id\n      }\n      batch.put(DsName(key.name), uint8ArrayFromString(keyAsPEM))\n      batch.put(DsInfoName(key.name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n      await batch.commit()\n    }\n    log('keychain reconstructed')\n  }\n}\n"]},"metadata":{},"sourceType":"module"}