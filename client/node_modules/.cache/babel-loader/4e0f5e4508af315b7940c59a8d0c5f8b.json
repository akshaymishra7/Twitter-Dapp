{"ast":null,"code":"/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport { FIFO } from './fifo.js';\nexport function pushable() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  const getNext = buffer => {\n    const next = buffer.shift();\n\n    if (next == null) {\n      return {\n        done: true\n      };\n    }\n\n    if (next.error != null) {\n      throw next.error;\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error\n      value: next.value\n    };\n  };\n\n  return _pushable(getNext, options);\n}\nexport function pushableV() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  const getNext = buffer => {\n    let next;\n    const values = [];\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift();\n\n      if (next == null) {\n        break;\n      }\n\n      if (next.error != null) {\n        throw next.error;\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error\n        values.push(next.value);\n      }\n    }\n\n    if (next == null) {\n      return {\n        done: true\n      };\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    };\n  };\n\n  return _pushable(getNext, options);\n}\n\nfunction _pushable(getNext, options) {\n  options = options ?? {};\n  let onEnd = options.onEnd;\n  let buffer = new FIFO();\n  let pushable;\n  let onNext;\n  let ended;\n\n  const waitNext = async () => {\n    if (!buffer.isEmpty()) {\n      return getNext(buffer);\n    }\n\n    if (ended) {\n      return {\n        done: true\n      };\n    }\n\n    return await new Promise((resolve, reject) => {\n      onNext = next => {\n        onNext = null;\n        buffer.push(next);\n\n        try {\n          resolve(getNext(buffer));\n        } catch (err) {\n          reject(err);\n        }\n\n        return pushable;\n      };\n    });\n  };\n\n  const bufferNext = next => {\n    if (onNext != null) {\n      return onNext(next);\n    }\n\n    buffer.push(next);\n    return pushable;\n  };\n\n  const bufferError = err => {\n    buffer = new FIFO();\n\n    if (onNext != null) {\n      return onNext({\n        error: err\n      });\n    }\n\n    buffer.push({\n      error: err\n    });\n    return pushable;\n  };\n\n  const push = value => {\n    if (ended) {\n      return pushable;\n    } // @ts-expect-error `byteLength` is not declared on PushType\n\n\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n    }\n\n    return bufferNext({\n      done: false,\n      value\n    });\n  };\n\n  const end = err => {\n    if (ended) return pushable;\n    ended = true;\n    return err != null ? bufferError(err) : bufferNext({\n      done: true\n    });\n  };\n\n  const _return = () => {\n    buffer = new FIFO();\n    end();\n    return {\n      done: true\n    };\n  };\n\n  const _throw = err => {\n    end(err);\n    return {\n      done: true\n    };\n  };\n\n  pushable = {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n\n    get readableLength() {\n      return buffer.size;\n    }\n\n  };\n\n  if (onEnd == null) {\n    return pushable;\n  }\n\n  const _pushable = pushable;\n  pushable = {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    next() {\n      return _pushable.next();\n    },\n\n    throw(err) {\n      _pushable.throw(err);\n\n      if (onEnd != null) {\n        onEnd(err);\n        onEnd = undefined;\n      }\n\n      return {\n        done: true\n      };\n    },\n\n    return() {\n      _pushable.return();\n\n      if (onEnd != null) {\n        onEnd();\n        onEnd = undefined;\n      }\n\n      return {\n        done: true\n      };\n    },\n\n    push,\n\n    end(err) {\n      _pushable.end(err);\n\n      if (onEnd != null) {\n        onEnd(err);\n        onEnd = undefined;\n      }\n\n      return pushable;\n    },\n\n    get readableLength() {\n      return _pushable.readableLength;\n    }\n\n  };\n  return pushable;\n}","map":{"version":3,"mappings":"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","names":["FIFO","pushable","options","getNext","buffer","next","shift","done","error","value","_pushable","pushableV","values","isEmpty","push","onEnd","onNext","ended","waitNext","Promise","resolve","reject","err","bufferNext","bufferError","objectMode","byteLength","Error","end","_return","_throw","Symbol","asyncIterator","return","throw","readableLength","size","undefined"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-pushable\\src\\index.ts"],"sourcesContent":["/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport { FIFO, Next } from './fifo.js'\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end: (err?: Error) => this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push: (value: T) => this\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?: (err?: Error) => void\n}\n\ntype NextResult<T> = { done: false, value: T } | { done: true }\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    if (!buffer.isEmpty()) {\n      return getNext(buffer)\n    }\n\n    if (ended) {\n      return { done: true }\n    }\n\n    return await new Promise((resolve, reject) => {\n      onNext = (next: Next<PushType>) => {\n        onNext = null\n        buffer.push(next)\n\n        try {\n          resolve(getNext(buffer))\n        } catch (err) {\n          reject(err)\n        }\n\n        return pushable\n      }\n    })\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): NextResult<ValueType> => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): NextResult<ValueType> => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength () {\n      return buffer.size\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    }\n  }\n\n  return pushable\n}\n"]},"metadata":{},"sourceType":"module"}