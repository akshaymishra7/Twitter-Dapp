{"ast":null,"code":"import { Uint8ArrayList } from 'uint8arraylist';\nimport { unsigned } from 'uint8-varint';\nimport { allocUnsafe } from 'uint8arrays/alloc';\nimport { isAsyncIterable } from './utils.js';\n\nconst defaultEncoder = length => {\n  const lengthLength = unsigned.encodingLength(length);\n  const lengthBuf = allocUnsafe(lengthLength);\n  unsigned.encode(length, lengthBuf);\n  defaultEncoder.bytes = lengthLength;\n  return lengthBuf;\n};\n\ndefaultEncoder.bytes = 0;\nexport function encode(source, options) {\n  options = options ?? {};\n  const encodeLength = options.lengthEncoder ?? defaultEncoder;\n\n  function* maybeYield(chunk) {\n    // length + data\n    const length = encodeLength(chunk.byteLength); // yield only Uint8Arrays\n\n    if (length instanceof Uint8Array) {\n      yield length;\n    } else {\n      yield* length;\n    } // yield only Uint8Arrays\n\n\n    if (chunk instanceof Uint8Array) {\n      yield chunk;\n    } else {\n      yield* chunk;\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return async function* () {\n      for await (const chunk of source) {\n        yield* maybeYield(chunk);\n      }\n    }();\n  }\n\n  return function* () {\n    for (const chunk of source) {\n      yield* maybeYield(chunk);\n    }\n  }();\n}\n\nencode.single = (chunk, options) => {\n  options = options ?? {};\n  const encodeLength = options.lengthEncoder ?? defaultEncoder;\n  return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);\n};","map":{"version":3,"mappings":"AAAA,SAASA,cAAT,QAA+B,gBAA/B;AACA,SAASC,QAAT,QAAyB,cAAzB;AAEA,SAASC,WAAT,QAA4B,mBAA5B;AACA,SAASC,eAAT,QAAgC,YAAhC;;AAOA,MAAMC,cAAc,GAA2BC,MAAD,IAAW;AACvD,QAAMC,YAAY,GAAGL,QAAQ,CAACM,cAAT,CAAwBF,MAAxB,CAArB;AACA,QAAMG,SAAS,GAAGN,WAAW,CAACI,YAAD,CAA7B;AAEAL,UAAQ,CAACQ,MAAT,CAAgBJ,MAAhB,EAAwBG,SAAxB;AAEAJ,gBAAc,CAACM,KAAf,GAAuBJ,YAAvB;AAEA,SAAOE,SAAP;AACD,CATD;;AAUAJ,cAAc,CAACM,KAAf,GAAuB,CAAvB;AAIA,OAAM,SAAUD,MAAV,CAAkBE,MAAlB,EAA+DC,OAA/D,EAAuF;AAC3FA,SAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,QAAMC,YAAY,GAAGD,OAAO,CAACE,aAAR,IAAyBV,cAA9C;;AAEA,YAAWW,UAAX,CAAuBC,KAAvB,EAAyD;AACvD;AACA,UAAMX,MAAM,GAAGQ,YAAY,CAACG,KAAK,CAACC,UAAP,CAA3B,CAFuD,CAIvD;;AACA,QAAIZ,MAAM,YAAYa,UAAtB,EAAkC;AAChC,YAAMb,MAAN;AACD,KAFD,MAEO;AACL,aAAQA,MAAR;AACD,KATsD,CAWvD;;;AACA,QAAIW,KAAK,YAAYE,UAArB,EAAiC;AAC/B,YAAMF,KAAN;AACD,KAFD,MAEO;AACL,aAAQA,KAAR;AACD;AACF;;AAED,MAAIb,eAAe,CAACQ,MAAD,CAAnB,EAA6B;AAC3B,WAAQ,mBAAgB;AACtB,iBAAW,MAAMK,KAAjB,IAA0BL,MAA1B,EAAkC;AAChC,eAAQI,UAAU,CAACC,KAAD,CAAlB;AACD;AACF,KAJM,EAAP;AAKD;;AAED,SAAQ,aAAU;AAChB,SAAK,MAAMA,KAAX,IAAoBL,MAApB,EAA4B;AAC1B,aAAQI,UAAU,CAACC,KAAD,CAAlB;AACD;AACF,GAJM,EAAP;AAKD;;AAEDP,MAAM,CAACU,MAAP,GAAgB,CAACH,KAAD,EAAqCJ,OAArC,KAAiE;AAC/EA,SAAO,GAAGA,OAAO,IAAI,EAArB;AACA,QAAMC,YAAY,GAAGD,OAAO,CAACE,aAAR,IAAyBV,cAA9C;AAEA,SAAO,IAAIJ,cAAJ,CACLa,YAAY,CAACG,KAAK,CAACC,UAAP,CADP,EAELD,KAFK,CAAP;AAID,CARD","names":["Uint8ArrayList","unsigned","allocUnsafe","isAsyncIterable","defaultEncoder","length","lengthLength","encodingLength","lengthBuf","encode","bytes","source","options","encodeLength","lengthEncoder","maybeYield","chunk","byteLength","Uint8Array","single"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\multistream-select\\node_modules\\it-length-prefixed\\src\\encode.ts"],"sourcesContent":["import { Uint8ArrayList } from 'uint8arraylist'\nimport { unsigned } from 'uint8-varint'\nimport type { LengthEncoderFunction } from './index.js'\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport { isAsyncIterable } from './utils.js'\nimport type { Source } from 'it-stream-types'\n\ninterface EncoderOptions {\n  lengthEncoder?: LengthEncoderFunction\n}\n\nconst defaultEncoder: LengthEncoderFunction = (length) => {\n  const lengthLength = unsigned.encodingLength(length)\n  const lengthBuf = allocUnsafe(lengthLength)\n\n  unsigned.encode(length, lengthBuf)\n\n  defaultEncoder.bytes = lengthLength\n\n  return lengthBuf\n}\ndefaultEncoder.bytes = 0\n\nexport function encode (source: Iterable<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): Generator<Uint8Array, void, undefined>\nexport function encode (source: Source<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): AsyncGenerator<Uint8Array, void, undefined>\nexport function encode (source: Source<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): Generator<Uint8Array, void, undefined> | AsyncGenerator<Uint8Array, void, undefined> {\n  options = options ?? {}\n\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n\n  function * maybeYield (chunk: Uint8Array | Uint8ArrayList): Generator<Uint8Array, void, undefined> {\n    // length + data\n    const length = encodeLength(chunk.byteLength)\n\n    // yield only Uint8Arrays\n    if (length instanceof Uint8Array) {\n      yield length\n    } else {\n      yield * length\n    }\n\n    // yield only Uint8Arrays\n    if (chunk instanceof Uint8Array) {\n      yield chunk\n    } else {\n      yield * chunk\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const chunk of source) {\n        yield * maybeYield(chunk)\n      }\n    })()\n  }\n\n  return (function * () {\n    for (const chunk of source) {\n      yield * maybeYield(chunk)\n    }\n  })()\n}\n\nencode.single = (chunk: Uint8ArrayList | Uint8Array, options?: EncoderOptions) => {\n  options = options ?? {}\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n\n  return new Uint8ArrayList(\n    encodeLength(chunk.byteLength),\n    chunk\n  )\n}\n"]},"metadata":{},"sourceType":"module"}