{"ast":null,"code":"import { nanoid } from 'nanoid';\nimport { WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK } from './constants.js';\nimport observer from 'observable-webworkers';\n\nconst handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {\n  return (worker, event) => {\n    if (event.data.type !== requestType) {\n      return;\n    }\n\n    const requestEvent = {\n      type: event.data.type,\n      name: event.data.name,\n      identifier: event.data.identifier\n    };\n    emitter.dispatchEvent(new MessageEvent(masterEvent, {\n      data: {\n        name: requestEvent.name,\n        handler: async () => {\n          // grant lock to worker\n          worker.postMessage({\n            type: grantType,\n            name: requestEvent.name,\n            identifier: requestEvent.identifier\n          }); // wait for worker to finish\n\n          return await new Promise(resolve => {\n            const releaseEventListener = event => {\n              if (event == null || event.data == null) {\n                return;\n              }\n\n              const releaseEvent = {\n                type: event.data.type,\n                name: event.data.name,\n                identifier: event.data.identifier\n              };\n\n              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n                worker.removeEventListener('message', releaseEventListener);\n                resolve();\n              }\n            };\n\n            worker.addEventListener('message', releaseEventListener);\n          });\n        }\n      }\n    }));\n  };\n};\n\nconst makeWorkerLockRequest = (name, requestType, grantType, releaseType) => {\n  return async () => {\n    const id = nanoid();\n    globalThis.postMessage({\n      type: requestType,\n      identifier: id,\n      name\n    });\n    return await new Promise(resolve => {\n      const listener = event => {\n        if (event == null || event.data == null) {\n          return;\n        }\n\n        const responseEvent = {\n          type: event.data.type,\n          identifier: event.data.identifier\n        };\n\n        if (responseEvent.type === grantType && responseEvent.identifier === id) {\n          globalThis.removeEventListener('message', listener); // grant lock\n\n          resolve(() => {\n            // release lock\n            globalThis.postMessage({\n              type: releaseType,\n              identifier: id,\n              name\n            });\n          });\n        }\n      };\n\n      globalThis.addEventListener('message', listener);\n    });\n  };\n};\n\nconst defaultOptions = {\n  singleProcess: false\n};\nexport default (options => {\n  options = Object.assign({}, defaultOptions, options);\n  const isPrimary = Boolean(globalThis.document) || options.singleProcess;\n\n  if (isPrimary) {\n    const emitter = new EventTarget();\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));\n    return emitter;\n  }\n\n  return {\n    isWorker: true,\n    readLock: name => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),\n    writeLock: name => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)\n  };\n});","map":{"version":3,"mappings":"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","names":["nanoid","WORKER_REQUEST_READ_LOCK","WORKER_RELEASE_READ_LOCK","MASTER_GRANT_READ_LOCK","WORKER_REQUEST_WRITE_LOCK","WORKER_RELEASE_WRITE_LOCK","MASTER_GRANT_WRITE_LOCK","observer","handleWorkerLockRequest","emitter","masterEvent","requestType","releaseType","grantType","worker","event","data","type","requestEvent","name","identifier","dispatchEvent","MessageEvent","handler","postMessage","Promise","resolve","releaseEventListener","releaseEvent","removeEventListener","addEventListener","makeWorkerLockRequest","id","globalThis","listener","responseEvent","defaultOptions","singleProcess","options","Object","assign","isPrimary","Boolean","document","EventTarget","isWorker","readLock","writeLock"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\mortice\\src\\browser.ts"],"sourcesContent":["import { nanoid } from 'nanoid'\nimport {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK\n} from './constants.js'\nimport observer from 'observable-webworkers'\nimport type { MorticeImplementation, MorticeOptions, Release } from './index.js'\n\nconst handleWorkerLockRequest = (emitter: EventTarget, masterEvent: string, requestType: string, releaseType: string, grantType: string) => {\n  return (worker: Worker, event: MessageEvent) => {\n    if (event.data.type !== requestType) {\n      return\n    }\n\n    const requestEvent = {\n      type: event.data.type,\n      name: event.data.name,\n      identifier: event.data.identifier\n    }\n\n    emitter.dispatchEvent(new MessageEvent(masterEvent, {\n      data: {\n        name: requestEvent.name,\n        handler: async (): Promise<void> => {\n          // grant lock to worker\n          worker.postMessage({\n            type: grantType,\n            name: requestEvent.name,\n            identifier: requestEvent.identifier\n          })\n\n          // wait for worker to finish\n          return await new Promise<void>((resolve) => {\n            const releaseEventListener = (event: MessageEvent) => {\n              if (event == null || event.data == null) {\n                return\n              }\n\n              const releaseEvent = {\n                type: event.data.type,\n                name: event.data.name,\n                identifier: event.data.identifier\n              }\n\n              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n                worker.removeEventListener('message', releaseEventListener)\n                resolve()\n              }\n            }\n\n            worker.addEventListener('message', releaseEventListener)\n          })\n        }\n      }\n    }))\n  }\n}\n\nconst makeWorkerLockRequest = (name: string, requestType: string, grantType: string, releaseType: string) => {\n  return async () => {\n    const id = nanoid()\n\n    globalThis.postMessage({\n      type: requestType,\n      identifier: id,\n      name\n    })\n\n    return await new Promise<Release>((resolve) => {\n      const listener = (event: MessageEvent) => {\n        if (event == null || event.data == null) {\n          return\n        }\n\n        const responseEvent = {\n          type: event.data.type,\n          identifier: event.data.identifier\n        }\n\n        if (responseEvent.type === grantType && responseEvent.identifier === id) {\n          globalThis.removeEventListener('message', listener)\n\n          // grant lock\n          resolve(() => {\n            // release lock\n            globalThis.postMessage({\n              type: releaseType,\n              identifier: id,\n              name\n            })\n          })\n        }\n      }\n\n      globalThis.addEventListener('message', listener)\n    })\n  }\n}\n\nconst defaultOptions = {\n  singleProcess: false\n}\n\nexport default (options: Required<MorticeOptions>): MorticeImplementation | EventTarget => {\n  options = Object.assign({}, defaultOptions, options)\n  const isPrimary = Boolean(globalThis.document) || options.singleProcess\n\n  if (isPrimary) {\n    const emitter = new EventTarget()\n\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK))\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK))\n\n    return emitter\n  }\n\n  return {\n    isWorker: true,\n    readLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),\n    writeLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}