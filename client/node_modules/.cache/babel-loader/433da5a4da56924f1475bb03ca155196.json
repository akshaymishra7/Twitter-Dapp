{"ast":null,"code":"import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist';\nimport { reader } from 'it-reader';\nexport function lteReader(source) {\n  const input = reader(source);\n  let overflow;\n  const lteReader = {\n    [Symbol.asyncIterator]: () => lteReader,\n\n    async next(bytes) {\n      if (overflow != null) {\n        let value;\n\n        if (bytes == null || overflow.length === bytes) {\n          value = overflow;\n          overflow = null;\n        } else if (overflow.length > bytes) {\n          value = overflow.sublist(0, bytes);\n          overflow = overflow.sublist(bytes);\n        } else if (overflow.length < bytes) {\n          const {\n            value: nextValue,\n            done\n          } = await input.next(bytes - overflow.length);\n\n          if (done === true ?? nextValue == null) {\n            throw Object.assign(new Error(`stream ended before ${bytes - overflow.length} bytes became available`), {\n              code: 'ERR_UNDER_READ'\n            });\n          }\n\n          value = new Uint8ArrayList(overflow, nextValue);\n          overflow = null;\n        }\n\n        if (value == null) {\n          const result = {\n            done: true,\n            value: undefined\n          };\n          return result;\n        }\n\n        const result = {\n          done: false,\n          value\n        };\n        return result;\n      }\n\n      return await input.next(bytes);\n    },\n\n    async nextLte(bytes) {\n      const {\n        done,\n        value\n      } = await lteReader.next();\n\n      if (done === true) {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n\n      if (value.length <= bytes) {\n        return {\n          done: false,\n          value\n        };\n      }\n\n      const list = isUint8ArrayList(value) ? value : new Uint8ArrayList(value);\n\n      if (overflow != null) {\n        overflow.append(list.sublist(bytes));\n      } else {\n        overflow = list.sublist(bytes);\n      }\n\n      return {\n        done: false,\n        value: list.sublist(0, bytes)\n      };\n    },\n\n    async return() {\n      return await input.return();\n    }\n\n  };\n  return lteReader;\n}","map":{"version":3,"mappings":"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","names":["isUint8ArrayList","Uint8ArrayList","reader","lteReader","source","input","overflow","Symbol","asyncIterator","next","bytes","value","length","sublist","nextValue","done","Object","assign","Error","code","result","undefined","nextLte","list","append","return"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-tar\\src\\lte-reader.ts"],"sourcesContent":["import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\nimport { reader } from 'it-reader'\nimport type { Source } from 'it-stream-types'\n\nexport interface LteReader extends AsyncIterator<Uint8ArrayList, void, number | undefined> {\n  nextLte: (bytes: number) => Promise<IteratorResult<Uint8ArrayList>>\n  return: () => Promise<IteratorResult<Uint8ArrayList>>\n}\n\nexport function lteReader (source: Source<Uint8Array>): LteReader {\n  const input = reader(source)\n  let overflow: Uint8ArrayList | null\n  const lteReader = {\n    [Symbol.asyncIterator]: () => lteReader,\n    async next (bytes?: number): Promise<IteratorResult<Uint8ArrayList>> {\n      if (overflow != null) {\n        let value\n        if (bytes == null || overflow.length === bytes) {\n          value = overflow\n          overflow = null\n        } else if (overflow.length > bytes) {\n          value = overflow.sublist(0, bytes)\n          overflow = overflow.sublist(bytes)\n        } else if (overflow.length < bytes) {\n          const { value: nextValue, done } = await input.next(bytes - overflow.length)\n          if (done === true ?? nextValue == null) {\n            throw Object.assign(\n              new Error(`stream ended before ${bytes - overflow.length} bytes became available`),\n              { code: 'ERR_UNDER_READ' }\n            )\n          }\n          value = new Uint8ArrayList(overflow, nextValue)\n          overflow = null\n        }\n\n        if (value == null) {\n          const result: IteratorResult<Uint8ArrayList> = { done: true, value: undefined }\n\n          return result\n        }\n\n        const result: IteratorResult<Uint8ArrayList> = { done: false, value }\n\n        return result\n      }\n\n      return await input.next(bytes)\n    },\n    async nextLte (bytes: number): Promise<IteratorResult<Uint8ArrayList>> {\n      const { done, value } = await lteReader.next()\n\n      if (done === true) {\n        return {\n          done: true,\n          value: undefined\n        }\n      }\n\n      if (value.length <= bytes) {\n        return { done: false, value }\n      }\n\n      const list = isUint8ArrayList(value) ? value : new Uint8ArrayList(value)\n\n      if (overflow != null) {\n        overflow.append(list.sublist(bytes))\n      } else {\n        overflow = list.sublist(bytes)\n      }\n\n      return { done: false, value: list.sublist(0, bytes) }\n    },\n    async return () {\n      return await input.return()\n    }\n  }\n\n  return lteReader\n}\n"]},"metadata":{},"sourceType":"module"}