{"ast":null,"code":"import { CodeError } from '@libp2p/interfaces/errors';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { base64urlToBuffer } from '../util.js';\nimport webcrypto from '../webcrypto.js';\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n};\nconst curveTypes = Object.keys(bits);\nconst names = curveTypes.join(' / ');\nexport async function generateEphmeralKeyPair(curve) {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE');\n  }\n\n  const pair = await webcrypto.get().subtle.generateKey({\n    name: 'ECDH',\n    namedCurve: curve\n  }, true, ['deriveBits']); // forcePrivate is used for testing only\n\n  const genSharedKey = async (theirPub, forcePrivate) => {\n    let privateKey;\n\n    if (forcePrivate != null) {\n      privateKey = await webcrypto.get().subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {\n        name: 'ECDH',\n        namedCurve: curve\n      }, false, ['deriveBits']);\n    } else {\n      privateKey = pair.privateKey;\n    }\n\n    const key = await webcrypto.get().subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {\n      name: 'ECDH',\n      namedCurve: curve\n    }, false, []);\n    const buffer = await webcrypto.get().subtle.deriveBits({\n      name: 'ECDH',\n      // @ts-expect-error namedCurve is missing from the types\n      namedCurve: curve,\n      public: key\n    }, privateKey, bits[curve]);\n    return new Uint8Array(buffer, 0, buffer.byteLength);\n  };\n\n  const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey);\n  const ecdhKey = {\n    key: marshalPublicKey(publicKey),\n    genSharedKey\n  };\n  return ecdhKey;\n}\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}; // Marshal converts a jwk encoded ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\n\nfunction marshalPublicKey(jwk) {\n  if (jwk.crv == null || jwk.x == null || jwk.y == null) {\n    throw new CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (jwk.crv !== 'P-256' && jwk.crv !== 'P-384' && jwk.crv !== 'P-521') {\n    throw new CodeError(`Unknown curve: ${jwk.crv}. Must be ${names}`, 'ERR_INVALID_CURVE');\n  }\n\n  const byteLen = curveLengths[jwk.crv];\n  return uint8ArrayConcat([Uint8Array.from([4]), base64urlToBuffer(jwk.x, byteLen), base64urlToBuffer(jwk.y, byteLen)], 1 + byteLen * 2);\n} // Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\n\n\nfunction unmarshalPublicKey(curve, key) {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE');\n  }\n\n  const byteLen = curveLengths[curve];\n\n  if (!uint8ArrayEquals(key.subarray(0, 1), Uint8Array.from([4]))) {\n    throw new CodeError('Cannot unmarshal public key - invalid key format', 'ERR_INVALID_KEY_FORMAT');\n  }\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: uint8ArrayToString(key.subarray(1, byteLen + 1), 'base64url'),\n    y: uint8ArrayToString(key.subarray(1 + byteLen), 'base64url'),\n    ext: true\n  };\n}\n\nconst unmarshalPrivateKey = (curve, key) => ({ ...unmarshalPublicKey(curve, key.public),\n  d: uint8ArrayToString(key.private, 'base64url')\n});","map":{"version":3,"mappings":"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","names":["CodeError","concat","uint8ArrayConcat","equals","uint8ArrayEquals","toString","uint8ArrayToString","base64urlToBuffer","webcrypto","bits","curveTypes","Object","keys","names","join","generateEphmeralKeyPair","curve","pair","get","subtle","generateKey","name","namedCurve","genSharedKey","theirPub","forcePrivate","privateKey","importKey","unmarshalPrivateKey","key","unmarshalPublicKey","buffer","deriveBits","public","Uint8Array","byteLength","publicKey","exportKey","ecdhKey","marshalPublicKey","curveLengths","jwk","crv","x","y","byteLen","from","subarray","kty","ext","d","private"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\crypto\\src\\keys\\ecdh-browser.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { base64urlToBuffer } from '../util.js'\nimport webcrypto from '../webcrypto.js'\nimport type { ECDHKey, ECDHKeyPair, JWKEncodedPrivateKey, JWKEncodedPublicKey } from './interface.js'\n\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n}\n\nconst curveTypes = Object.keys(bits)\nconst names = curveTypes.join(' / ')\n\nexport async function generateEphmeralKeyPair (curve: string): Promise<ECDHKey> {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE')\n  }\n\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: curve\n    },\n    true,\n    ['deriveBits']\n  )\n\n  // forcePrivate is used for testing only\n  const genSharedKey = async (theirPub: Uint8Array, forcePrivate?: ECDHKeyPair): Promise<Uint8Array> => {\n    let privateKey\n\n    if (forcePrivate != null) {\n      privateKey = await webcrypto.get().subtle.importKey(\n        'jwk',\n        unmarshalPrivateKey(curve, forcePrivate),\n        {\n          name: 'ECDH',\n          namedCurve: curve\n        },\n        false,\n        ['deriveBits']\n      )\n    } else {\n      privateKey = pair.privateKey\n    }\n\n    const key = await webcrypto.get().subtle.importKey(\n      'jwk',\n      unmarshalPublicKey(curve, theirPub),\n      {\n        name: 'ECDH',\n        namedCurve: curve\n      },\n      false,\n      []\n    )\n\n    const buffer = await webcrypto.get().subtle.deriveBits(\n      {\n        name: 'ECDH',\n        // @ts-expect-error namedCurve is missing from the types\n        namedCurve: curve,\n        public: key\n      },\n      privateKey,\n      bits[curve]\n    )\n\n    return new Uint8Array(buffer, 0, buffer.byteLength)\n  }\n\n  const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n\n  const ecdhKey: ECDHKey = {\n    key: marshalPublicKey(publicKey),\n    genSharedKey\n  }\n\n  return ecdhKey\n}\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}\n\n// Marshal converts a jwk encoded ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey (jwk: JsonWebKey): Uint8Array {\n  if (jwk.crv == null || jwk.x == null || jwk.y == null) {\n    throw new CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (jwk.crv !== 'P-256' && jwk.crv !== 'P-384' && jwk.crv !== 'P-521') {\n    throw new CodeError(`Unknown curve: ${jwk.crv}. Must be ${names}`, 'ERR_INVALID_CURVE')\n  }\n\n  const byteLen = curveLengths[jwk.crv]\n\n  return uint8ArrayConcat([\n    Uint8Array.from([4]), // uncompressed point\n    base64urlToBuffer(jwk.x, byteLen),\n    base64urlToBuffer(jwk.y, byteLen)\n  ], 1 + byteLen * 2)\n}\n\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\nfunction unmarshalPublicKey (curve: string, key: Uint8Array): JWKEncodedPublicKey {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE')\n  }\n\n  const byteLen = curveLengths[curve]\n\n  if (!uint8ArrayEquals(key.subarray(0, 1), Uint8Array.from([4]))) {\n    throw new CodeError('Cannot unmarshal public key - invalid key format', 'ERR_INVALID_KEY_FORMAT')\n  }\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: uint8ArrayToString(key.subarray(1, byteLen + 1), 'base64url'),\n    y: uint8ArrayToString(key.subarray(1 + byteLen), 'base64url'),\n    ext: true\n  }\n}\n\nconst unmarshalPrivateKey = (curve: string, key: ECDHKeyPair): JWKEncodedPrivateKey => ({\n  ...unmarshalPublicKey(curve, key.public),\n  d: uint8ArrayToString(key.private, 'base64url')\n})\n"]},"metadata":{},"sourceType":"module"}