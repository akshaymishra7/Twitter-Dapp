{"ast":null,"code":"import errCode from 'err-code';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { IpnsEntry } from './pb/ipns.js';\nimport { parseRFC3339, extractPublicKey, ipnsEntryDataForV2Sig, unmarshal, peerIdFromRoutingKey, parseCborData } from './utils.js';\nimport * as ERRORS from './errors.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('ipns:validator');\n/**\n * Validates the given ipns entry against the given public key\n */\n\nexport const validate = async (publicKey, entry) => {\n  const {\n    value,\n    validityType,\n    validity\n  } = entry;\n  let dataForSignature;\n  let signature; // Check v2 signature if it's available, otherwise use the v1 signature\n\n  if (entry.signatureV2 != null && entry.data != null) {\n    signature = entry.signatureV2;\n    dataForSignature = ipnsEntryDataForV2Sig(entry.data);\n    validateCborDataMatchesPbData(entry);\n  } else {\n    throw errCode(new Error('missing data or signatureV2'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  } // Validate Signature\n\n\n  let isValid;\n\n  try {\n    isValid = await publicKey.verify(dataForSignature, signature);\n  } catch (err) {\n    isValid = false;\n  }\n\n  if (!isValid) {\n    log.error('record signature verification failed');\n    throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  } // Validate according to the validity type\n\n\n  if (validity != null && validityType === IpnsEntry.ValidityType.EOL) {\n    let validityDate;\n\n    try {\n      validityDate = parseRFC3339(uint8ArrayToString(validity));\n    } catch (e) {\n      log.error('unrecognized validity format (not an rfc3339 format)');\n      throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT);\n    }\n\n    if (validityDate.getTime() < Date.now()) {\n      log.error('record has expired');\n      throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD);\n    }\n  } else if (validityType != null) {\n    log.error('unrecognized validity type');\n    throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n  }\n\n  log('ipns entry for %b is valid', value);\n};\n\nconst validateCborDataMatchesPbData = entry => {\n  if (entry.data == null) {\n    throw errCode(new Error('Record data is missing'), ERRORS.ERR_INVALID_RECORD_DATA);\n  }\n\n  const data = parseCborData(entry.data);\n\n  if (!uint8ArrayEquals(data.Value, entry.value)) {\n    throw errCode(new Error('Field \"value\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (!uint8ArrayEquals(data.Validity, entry.validity)) {\n    throw errCode(new Error('Field \"validity\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.ValidityType !== entry.validityType) {\n    throw errCode(new Error('Field \"validityType\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.Sequence !== entry.sequence) {\n    throw errCode(new Error('Field \"sequence\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.TTL !== entry.ttl) {\n    throw errCode(new Error('Field \"ttl\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n};\n\nexport const ipnsValidator = async (key, marshalledData) => {\n  const peerId = peerIdFromRoutingKey(key);\n  const receivedEntry = unmarshal(marshalledData); // extract public key\n\n  const pubKey = await extractPublicKey(peerId, receivedEntry); // Record validation\n\n  await validate(pubKey, receivedEntry);\n};","map":{"version":3,"mappings":"AAAA,OAAOA,OAAP,MAAoB,UAApB;AACA,SAASC,QAAQ,IAAIC,kBAArB,QAA+C,uBAA/C;AACA,SAASC,MAAM,IAAIC,gBAAnB,QAA2C,oBAA3C;AACA,SAASC,SAAT,QAA0B,cAA1B;AACA,SAASC,YAAT,EAAuBC,gBAAvB,EAAyCC,qBAAzC,EAAgEC,SAAhE,EAA2EC,oBAA3E,EAAiGC,aAAjG,QAAsH,YAAtH;AACA,OAAO,KAAKC,MAAZ,MAAwB,aAAxB;AAIA,SAASC,MAAT,QAAuB,gBAAvB;AAEA,MAAMC,GAAG,GAAGD,MAAM,CAAC,gBAAD,CAAlB;AAEA;;;;AAGA,OAAO,MAAME,QAAQ,GAAG,OAAOC,SAAP,EAA6BC,KAA7B,KAAgE;AACtF,QAAM;AAAEC,SAAF;AAASC,gBAAT;AAAuBC;AAAvB,MAAoCH,KAA1C;AAEA,MAAII,gBAAJ;AACA,MAAIC,SAAJ,CAJsF,CAMtF;;AACA,MAAKL,KAAK,CAACM,WAAN,IAAqB,IAAtB,IAAgCN,KAAK,CAACO,IAAN,IAAc,IAAlD,EAAyD;AACvDF,aAAS,GAAGL,KAAK,CAACM,WAAlB;AACAF,oBAAgB,GAAGb,qBAAqB,CAACS,KAAK,CAACO,IAAP,CAAxC;AAEAC,iCAA6B,CAACR,KAAD,CAA7B;AACD,GALD,MAKO;AACL,UAAMjB,OAAO,CAAC,IAAI0B,KAAJ,CAAU,6BAAV,CAAD,EAA2Cd,MAAM,CAACe,0BAAlD,CAAb;AACD,GAdqF,CAgBtF;;;AACA,MAAIC,OAAJ;;AACA,MAAI;AACFA,WAAO,GAAG,MAAMZ,SAAS,CAACa,MAAV,CAAiBR,gBAAjB,EAAmCC,SAAnC,CAAhB;AACD,GAFD,CAEE,OAAOQ,GAAP,EAAY;AACZF,WAAO,GAAG,KAAV;AACD;;AACD,MAAI,CAACA,OAAL,EAAc;AACZd,OAAG,CAACiB,KAAJ,CAAU,sCAAV;AACA,UAAM/B,OAAO,CAAC,IAAI0B,KAAJ,CAAU,sCAAV,CAAD,EAAoDd,MAAM,CAACe,0BAA3D,CAAb;AACD,GA1BqF,CA4BtF;;;AACA,MAAIP,QAAQ,IAAI,IAAZ,IAAoBD,YAAY,KAAKd,SAAS,CAAC2B,YAAV,CAAuBC,GAAhE,EAAqE;AACnE,QAAIC,YAAJ;;AAEA,QAAI;AACFA,kBAAY,GAAG5B,YAAY,CAACJ,kBAAkB,CAACkB,QAAD,CAAnB,CAA3B;AACD,KAFD,CAEE,OAAOe,CAAP,EAAU;AACVrB,SAAG,CAACiB,KAAJ,CAAU,sDAAV;AACA,YAAM/B,OAAO,CAAC,IAAI0B,KAAJ,CAAU,sDAAV,CAAD,EAAoEd,MAAM,CAACwB,uBAA3E,CAAb;AACD;;AAED,QAAIF,YAAY,CAACG,OAAb,KAAyBC,IAAI,CAACC,GAAL,EAA7B,EAAyC;AACvCzB,SAAG,CAACiB,KAAJ,CAAU,oBAAV;AACA,YAAM/B,OAAO,CAAC,IAAI0B,KAAJ,CAAU,oBAAV,CAAD,EAAkCd,MAAM,CAAC4B,uBAAzC,CAAb;AACD;AACF,GAdD,MAcO,IAAIrB,YAAY,IAAI,IAApB,EAA0B;AAC/BL,OAAG,CAACiB,KAAJ,CAAU,4BAAV;AACA,UAAM/B,OAAO,CAAC,IAAI0B,KAAJ,CAAU,4BAAV,CAAD,EAA0Cd,MAAM,CAAC6B,yBAAjD,CAAb;AACD;;AAED3B,KAAG,CAAC,4BAAD,EAA+BI,KAA/B,CAAH;AACD,CAjDM;;AAmDP,MAAMO,6BAA6B,GAAIR,KAAD,IAA2B;AAC/D,MAAIA,KAAK,CAACO,IAAN,IAAc,IAAlB,EAAwB;AACtB,UAAMxB,OAAO,CAAC,IAAI0B,KAAJ,CAAU,wBAAV,CAAD,EAAsCd,MAAM,CAAC8B,uBAA7C,CAAb;AACD;;AAED,QAAMlB,IAAI,GAAGb,aAAa,CAACM,KAAK,CAACO,IAAP,CAA1B;;AAEA,MAAI,CAACpB,gBAAgB,CAACoB,IAAI,CAACmB,KAAN,EAAa1B,KAAK,CAACC,KAAnB,CAArB,EAAgD;AAC9C,UAAMlB,OAAO,CAAC,IAAI0B,KAAJ,CAAU,uDAAV,CAAD,EAAqEd,MAAM,CAACe,0BAA5E,CAAb;AACD;;AAED,MAAI,CAACvB,gBAAgB,CAACoB,IAAI,CAACoB,QAAN,EAAgB3B,KAAK,CAACG,QAAtB,CAArB,EAAsD;AACpD,UAAMpB,OAAO,CAAC,IAAI0B,KAAJ,CAAU,0DAAV,CAAD,EAAwEd,MAAM,CAACe,0BAA/E,CAAb;AACD;;AAED,MAAIH,IAAI,CAACQ,YAAL,KAAsBf,KAAK,CAACE,YAAhC,EAA8C;AAC5C,UAAMnB,OAAO,CAAC,IAAI0B,KAAJ,CAAU,8DAAV,CAAD,EAA4Ed,MAAM,CAACe,0BAAnF,CAAb;AACD;;AAED,MAAIH,IAAI,CAACqB,QAAL,KAAkB5B,KAAK,CAAC6B,QAA5B,EAAsC;AACpC,UAAM9C,OAAO,CAAC,IAAI0B,KAAJ,CAAU,0DAAV,CAAD,EAAwEd,MAAM,CAACe,0BAA/E,CAAb;AACD;;AAED,MAAIH,IAAI,CAACuB,GAAL,KAAa9B,KAAK,CAAC+B,GAAvB,EAA4B;AAC1B,UAAMhD,OAAO,CAAC,IAAI0B,KAAJ,CAAU,qDAAV,CAAD,EAAmEd,MAAM,CAACe,0BAA1E,CAAb;AACD;AACF,CA1BD;;AA4BA,OAAO,MAAMsB,aAAa,GAAe,OAAOC,GAAP,EAAYC,cAAZ,KAA8B;AACrE,QAAMC,MAAM,GAAG1C,oBAAoB,CAACwC,GAAD,CAAnC;AACA,QAAMG,aAAa,GAAG5C,SAAS,CAAC0C,cAAD,CAA/B,CAFqE,CAIrE;;AACA,QAAMG,MAAM,GAAG,MAAM/C,gBAAgB,CAAC6C,MAAD,EAASC,aAAT,CAArC,CALqE,CAOrE;;AACA,QAAMtC,QAAQ,CAACuC,MAAD,EAASD,aAAT,CAAd;AACD,CATM","names":["errCode","toString","uint8ArrayToString","equals","uint8ArrayEquals","IpnsEntry","parseRFC3339","extractPublicKey","ipnsEntryDataForV2Sig","unmarshal","peerIdFromRoutingKey","parseCborData","ERRORS","logger","log","validate","publicKey","entry","value","validityType","validity","dataForSignature","signature","signatureV2","data","validateCborDataMatchesPbData","Error","ERR_SIGNATURE_VERIFICATION","isValid","verify","err","error","ValidityType","EOL","validityDate","e","ERR_UNRECOGNIZED_FORMAT","getTime","Date","now","ERR_IPNS_EXPIRED_RECORD","ERR_UNRECOGNIZED_VALIDITY","ERR_INVALID_RECORD_DATA","Value","Validity","Sequence","sequence","TTL","ttl","ipnsValidator","key","marshalledData","peerId","receivedEntry","pubKey"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\ipns\\src\\validator.ts"],"sourcesContent":["import errCode from 'err-code'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { IpnsEntry } from './pb/ipns.js'\nimport { parseRFC3339, extractPublicKey, ipnsEntryDataForV2Sig, unmarshal, peerIdFromRoutingKey, parseCborData } from './utils.js'\nimport * as ERRORS from './errors.js'\nimport type { IPNSEntry } from './index.js'\nimport type { PublicKey } from '@libp2p/interface-keys'\nimport type { ValidateFn } from '@libp2p/interface-dht'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('ipns:validator')\n\n/**\n * Validates the given ipns entry against the given public key\n */\nexport const validate = async (publicKey: PublicKey, entry: IPNSEntry): Promise<void> => {\n  const { value, validityType, validity } = entry\n\n  let dataForSignature: Uint8Array\n  let signature: Uint8Array\n\n  // Check v2 signature if it's available, otherwise use the v1 signature\n  if ((entry.signatureV2 != null) && (entry.data != null)) {\n    signature = entry.signatureV2\n    dataForSignature = ipnsEntryDataForV2Sig(entry.data)\n\n    validateCborDataMatchesPbData(entry)\n  } else {\n    throw errCode(new Error('missing data or signatureV2'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  // Validate Signature\n  let isValid\n  try {\n    isValid = await publicKey.verify(dataForSignature, signature)\n  } catch (err) {\n    isValid = false\n  }\n  if (!isValid) {\n    log.error('record signature verification failed')\n    throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  // Validate according to the validity type\n  if (validity != null && validityType === IpnsEntry.ValidityType.EOL) {\n    let validityDate\n\n    try {\n      validityDate = parseRFC3339(uint8ArrayToString(validity))\n    } catch (e) {\n      log.error('unrecognized validity format (not an rfc3339 format)')\n      throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT)\n    }\n\n    if (validityDate.getTime() < Date.now()) {\n      log.error('record has expired')\n      throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD)\n    }\n  } else if (validityType != null) {\n    log.error('unrecognized validity type')\n    throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n  }\n\n  log('ipns entry for %b is valid', value)\n}\n\nconst validateCborDataMatchesPbData = (entry: IPNSEntry): void => {\n  if (entry.data == null) {\n    throw errCode(new Error('Record data is missing'), ERRORS.ERR_INVALID_RECORD_DATA)\n  }\n\n  const data = parseCborData(entry.data)\n\n  if (!uint8ArrayEquals(data.Value, entry.value)) {\n    throw errCode(new Error('Field \"value\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (!uint8ArrayEquals(data.Validity, entry.validity)) {\n    throw errCode(new Error('Field \"validity\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (data.ValidityType !== entry.validityType) {\n    throw errCode(new Error('Field \"validityType\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (data.Sequence !== entry.sequence) {\n    throw errCode(new Error('Field \"sequence\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (data.TTL !== entry.ttl) {\n    throw errCode(new Error('Field \"ttl\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n}\n\nexport const ipnsValidator: ValidateFn = async (key, marshalledData) => {\n  const peerId = peerIdFromRoutingKey(key)\n  const receivedEntry = unmarshal(marshalledData)\n\n  // extract public key\n  const pubKey = await extractPublicKey(peerId, receivedEntry)\n\n  // Record validation\n  await validate(pubKey, receivedEntry)\n}\n"]},"metadata":{},"sourceType":"module"}