{"ast":null,"code":"'use strict';\n\nconst ModuleError = require('module-error');\n\nconst formats = new Set(['buffer', 'view', 'utf8']);\n/**\n * @template TIn, TFormat, TOut\n * @abstract\n */\n\nclass Encoding {\n  /**\n   * @param {IEncoding<TIn,TFormat,TOut>} options\n   */\n  constructor(options) {\n    /** @type {(data: TIn) => TFormat} */\n    this.encode = options.encode || this.encode;\n    /** @type {(data: TFormat) => TOut} */\n\n    this.decode = options.decode || this.decode;\n    /** @type {string} */\n\n    this.name = options.name || this.name;\n    /** @type {string} */\n\n    this.format = options.format || this.format;\n\n    if (typeof this.encode !== 'function') {\n      throw new TypeError(\"The 'encode' property must be a function\");\n    }\n\n    if (typeof this.decode !== 'function') {\n      throw new TypeError(\"The 'decode' property must be a function\");\n    }\n\n    this.encode = this.encode.bind(this);\n    this.decode = this.decode.bind(this);\n\n    if (typeof this.name !== 'string' || this.name === '') {\n      throw new TypeError(\"The 'name' property must be a string\");\n    }\n\n    if (typeof this.format !== 'string' || !formats.has(this.format)) {\n      throw new TypeError(\"The 'format' property must be one of 'buffer', 'view', 'utf8'\");\n    }\n\n    if (options.createViewTranscoder) {\n      this.createViewTranscoder = options.createViewTranscoder;\n    }\n\n    if (options.createBufferTranscoder) {\n      this.createBufferTranscoder = options.createBufferTranscoder;\n    }\n\n    if (options.createUTF8Transcoder) {\n      this.createUTF8Transcoder = options.createUTF8Transcoder;\n    }\n  }\n\n  get commonName() {\n    return (\n      /** @type {string} */\n      this.name.split('+')[0]\n    );\n  }\n  /** @return {BufferFormat<TIn,TOut>} */\n\n\n  createBufferTranscoder() {\n    throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {\n      code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n    });\n  }\n  /** @return {ViewFormat<TIn,TOut>} */\n\n\n  createViewTranscoder() {\n    throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'view'`, {\n      code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n    });\n  }\n  /** @return {UTF8Format<TIn,TOut>} */\n\n\n  createUTF8Transcoder() {\n    throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {\n      code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n    });\n  }\n\n}\n\nexports.Encoding = Encoding;\n/**\n * @typedef {import('./encoding').IEncoding<TIn,TFormat,TOut>} IEncoding\n * @template TIn, TFormat, TOut\n */\n\n/**\n * @typedef {import('./formats').BufferFormat<TIn,TOut>} BufferFormat\n * @template TIn, TOut\n */\n\n/**\n * @typedef {import('./formats').ViewFormat<TIn,TOut>} ViewFormat\n * @template TIn, TOut\n */\n\n/**\n * @typedef {import('./formats').UTF8Format<TIn,TOut>} UTF8Format\n * @template TIn, TOut\n */","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/level-transcoder/lib/encoding.js"],"names":["ModuleError","require","formats","Set","Encoding","constructor","options","encode","decode","name","format","TypeError","bind","has","createViewTranscoder","createBufferTranscoder","createUTF8Transcoder","commonName","split","code","exports"],"mappings":"AAAA;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,cAAD,CAA3B;;AACA,MAAMC,OAAO,GAAG,IAAIC,GAAJ,CAAQ,CAAC,QAAD,EAAW,MAAX,EAAmB,MAAnB,CAAR,CAAhB;AAEA;AACA;AACA;AACA;;AACA,MAAMC,QAAN,CAAe;AACb;AACF;AACA;AACEC,EAAAA,WAAW,CAAEC,OAAF,EAAW;AACpB;AACA,SAAKC,MAAL,GAAcD,OAAO,CAACC,MAAR,IAAkB,KAAKA,MAArC;AAEA;;AACA,SAAKC,MAAL,GAAcF,OAAO,CAACE,MAAR,IAAkB,KAAKA,MAArC;AAEA;;AACA,SAAKC,IAAL,GAAYH,OAAO,CAACG,IAAR,IAAgB,KAAKA,IAAjC;AAEA;;AACA,SAAKC,MAAL,GAAcJ,OAAO,CAACI,MAAR,IAAkB,KAAKA,MAArC;;AAEA,QAAI,OAAO,KAAKH,MAAZ,KAAuB,UAA3B,EAAuC;AACrC,YAAM,IAAII,SAAJ,CAAc,0CAAd,CAAN;AACD;;AAED,QAAI,OAAO,KAAKH,MAAZ,KAAuB,UAA3B,EAAuC;AACrC,YAAM,IAAIG,SAAJ,CAAc,0CAAd,CAAN;AACD;;AAED,SAAKJ,MAAL,GAAc,KAAKA,MAAL,CAAYK,IAAZ,CAAiB,IAAjB,CAAd;AACA,SAAKJ,MAAL,GAAc,KAAKA,MAAL,CAAYI,IAAZ,CAAiB,IAAjB,CAAd;;AAEA,QAAI,OAAO,KAAKH,IAAZ,KAAqB,QAArB,IAAiC,KAAKA,IAAL,KAAc,EAAnD,EAAuD;AACrD,YAAM,IAAIE,SAAJ,CAAc,sCAAd,CAAN;AACD;;AAED,QAAI,OAAO,KAAKD,MAAZ,KAAuB,QAAvB,IAAmC,CAACR,OAAO,CAACW,GAAR,CAAY,KAAKH,MAAjB,CAAxC,EAAkE;AAChE,YAAM,IAAIC,SAAJ,CAAc,+DAAd,CAAN;AACD;;AAED,QAAIL,OAAO,CAACQ,oBAAZ,EAAkC;AAChC,WAAKA,oBAAL,GAA4BR,OAAO,CAACQ,oBAApC;AACD;;AAED,QAAIR,OAAO,CAACS,sBAAZ,EAAoC;AAClC,WAAKA,sBAAL,GAA8BT,OAAO,CAACS,sBAAtC;AACD;;AAED,QAAIT,OAAO,CAACU,oBAAZ,EAAkC;AAChC,WAAKA,oBAAL,GAA4BV,OAAO,CAACU,oBAApC;AACD;AACF;;AAEa,MAAVC,UAAU,GAAI;AAChB;AAAO;AAAuB,WAAKR,IAAL,CAAUS,KAAV,CAAgB,GAAhB,EAAqB,CAArB;AAA9B;AACD;AAED;;;AACAH,EAAAA,sBAAsB,GAAI;AACxB,UAAM,IAAIf,WAAJ,CAAiB,aAAY,KAAKS,IAAK,oCAAvC,EAA4E;AAChFU,MAAAA,IAAI,EAAE;AAD0E,KAA5E,CAAN;AAGD;AAED;;;AACAL,EAAAA,oBAAoB,GAAI;AACtB,UAAM,IAAId,WAAJ,CAAiB,aAAY,KAAKS,IAAK,kCAAvC,EAA0E;AAC9EU,MAAAA,IAAI,EAAE;AADwE,KAA1E,CAAN;AAGD;AAED;;;AACAH,EAAAA,oBAAoB,GAAI;AACtB,UAAM,IAAIhB,WAAJ,CAAiB,aAAY,KAAKS,IAAK,kCAAvC,EAA0E;AAC9EU,MAAAA,IAAI,EAAE;AADwE,KAA1E,CAAN;AAGD;;AAxEY;;AA2EfC,OAAO,CAAChB,QAAR,GAAmBA,QAAnB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","sourcesContent":["'use strict'\n\nconst ModuleError = require('module-error')\nconst formats = new Set(['buffer', 'view', 'utf8'])\n\n/**\n * @template TIn, TFormat, TOut\n * @abstract\n */\nclass Encoding {\n  /**\n   * @param {IEncoding<TIn,TFormat,TOut>} options\n   */\n  constructor (options) {\n    /** @type {(data: TIn) => TFormat} */\n    this.encode = options.encode || this.encode\n\n    /** @type {(data: TFormat) => TOut} */\n    this.decode = options.decode || this.decode\n\n    /** @type {string} */\n    this.name = options.name || this.name\n\n    /** @type {string} */\n    this.format = options.format || this.format\n\n    if (typeof this.encode !== 'function') {\n      throw new TypeError(\"The 'encode' property must be a function\")\n    }\n\n    if (typeof this.decode !== 'function') {\n      throw new TypeError(\"The 'decode' property must be a function\")\n    }\n\n    this.encode = this.encode.bind(this)\n    this.decode = this.decode.bind(this)\n\n    if (typeof this.name !== 'string' || this.name === '') {\n      throw new TypeError(\"The 'name' property must be a string\")\n    }\n\n    if (typeof this.format !== 'string' || !formats.has(this.format)) {\n      throw new TypeError(\"The 'format' property must be one of 'buffer', 'view', 'utf8'\")\n    }\n\n    if (options.createViewTranscoder) {\n      this.createViewTranscoder = options.createViewTranscoder\n    }\n\n    if (options.createBufferTranscoder) {\n      this.createBufferTranscoder = options.createBufferTranscoder\n    }\n\n    if (options.createUTF8Transcoder) {\n      this.createUTF8Transcoder = options.createUTF8Transcoder\n    }\n  }\n\n  get commonName () {\n    return /** @type {string} */ (this.name.split('+')[0])\n  }\n\n  /** @return {BufferFormat<TIn,TOut>} */\n  createBufferTranscoder () {\n    throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {\n      code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n    })\n  }\n\n  /** @return {ViewFormat<TIn,TOut>} */\n  createViewTranscoder () {\n    throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'view'`, {\n      code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n    })\n  }\n\n  /** @return {UTF8Format<TIn,TOut>} */\n  createUTF8Transcoder () {\n    throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {\n      code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n    })\n  }\n}\n\nexports.Encoding = Encoding\n\n/**\n * @typedef {import('./encoding').IEncoding<TIn,TFormat,TOut>} IEncoding\n * @template TIn, TFormat, TOut\n */\n\n/**\n * @typedef {import('./formats').BufferFormat<TIn,TOut>} BufferFormat\n * @template TIn, TOut\n */\n\n/**\n * @typedef {import('./formats').ViewFormat<TIn,TOut>} ViewFormat\n * @template TIn, TOut\n */\n\n/**\n * @typedef {import('./formats').UTF8Format<TIn,TOut>} UTF8Format\n * @template TIn, TOut\n */\n"]},"metadata":{},"sourceType":"script"}