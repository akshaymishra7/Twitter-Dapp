{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport mergeOptions from 'merge-options'; // @ts-expect-error retimer does not have types\n\nimport retimer from 'retimer';\nimport all from 'it-all';\nimport { pipe } from 'it-pipe';\nimport filter from 'it-filter';\nimport sort from 'it-sort';\nconst log = logger('libp2p:connection-manager:auto-dialler');\nconst defaultOptions = {\n  enabled: true,\n  minConnections: 0,\n  autoDialInterval: 10000\n};\nexport class AutoDialler {\n  /**\n   * Proactively tries to connect to known peers stored in the PeerStore.\n   * It will keep the number of connections below the upper limit and sort\n   * the peers to connect based on wether we know their keys and protocols.\n   */\n  constructor(components, init) {\n    this.components = components;\n    this.options = mergeOptions.call({\n      ignoreUndefined: true\n    }, defaultOptions, init);\n    this.running = false;\n    this._autoDial = this._autoDial.bind(this);\n    log('options: %j', this.options);\n  }\n\n  isStarted() {\n    return this.running;\n  }\n  /**\n   * Starts the auto dialer\n   */\n\n\n  async start() {\n    if (!this.options.enabled) {\n      log('not enabled');\n      return;\n    }\n\n    this.running = true;\n    void this._autoDial().catch(err => {\n      log.error('could start autodial', err);\n    });\n    log('started');\n  }\n  /**\n   * Stops the auto dialler\n   */\n\n\n  async stop() {\n    if (!this.options.enabled) {\n      log('not enabled');\n      return;\n    }\n\n    this.running = false;\n\n    if (this.autoDialTimeout != null) {\n      this.autoDialTimeout.clear();\n    }\n\n    log('stopped');\n  }\n\n  async _autoDial() {\n    if (this.autoDialTimeout != null) {\n      this.autoDialTimeout.clear();\n    }\n\n    const minConnections = this.options.minConnections; // Already has enough connections\n\n    if (this.components.connectionManager.getConnections().length >= minConnections) {\n      this.autoDialTimeout = retimer(this._autoDial, this.options.autoDialInterval);\n      return;\n    } // Sort peers on whether we know protocols or public keys for them\n\n\n    const allPeers = await this.components.peerStore.all();\n    const peers = await pipe( // shuffle the peers\n    allPeers.sort(() => Math.random() > 0.5 ? 1 : -1), source => filter(source, peer => !peer.id.equals(this.components.peerId)), source => sort(source, (a, b) => {\n      if (b.protocols.length > a.protocols.length) {\n        return 1;\n      } else if (b.id.publicKey != null && a.id.publicKey == null) {\n        return 1;\n      }\n\n      return -1;\n    }), async source => await all(source));\n\n    for (let i = 0; this.running && i < peers.length && this.components.connectionManager.getConnections().length < minConnections; i++) {\n      // Connection Manager was stopped during async dial\n      if (!this.running) {\n        return;\n      }\n\n      const peer = peers[i];\n\n      if (this.components.connectionManager.getConnections(peer.id).length === 0) {\n        log('connecting to a peerStore stored peer %p', peer.id);\n\n        try {\n          await this.components.connectionManager.openConnection(peer.id);\n        } catch (err) {\n          log.error('could not connect to peerStore stored peer', err);\n        }\n      }\n    } // Connection Manager was stopped\n\n\n    if (!this.running) {\n      return;\n    }\n\n    this.autoDialTimeout = retimer(this._autoDial, this.options.autoDialInterval);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","mergeOptions","retimer","all","pipe","filter","sort","log","defaultOptions","enabled","minConnections","autoDialInterval","AutoDialler","constructor","components","init","options","call","ignoreUndefined","running","_autoDial","bind","isStarted","start","catch","err","error","stop","autoDialTimeout","clear","connectionManager","getConnections","length","allPeers","peerStore","peers","Math","random","source","peer","id","equals","peerId","a","b","protocols","publicKey","i","openConnection"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\connection-manager\\auto-dialler.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport mergeOptions from 'merge-options'\n// @ts-expect-error retimer does not have types\nimport retimer from 'retimer'\nimport all from 'it-all'\nimport { pipe } from 'it-pipe'\nimport filter from 'it-filter'\nimport sort from 'it-sort'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\nimport type { PeerStore } from '@libp2p/interface-peer-store'\n\nconst log = logger('libp2p:connection-manager:auto-dialler')\n\nexport interface AutoDiallerInit {\n  /**\n   * Should preemptively guarantee connections are above the low watermark\n   */\n  enabled?: boolean\n\n  /**\n   * The minimum number of connections to avoid pruning\n   */\n  minConnections?: number\n\n  /**\n   * How often, in milliseconds, it should preemptively guarantee connections are above the low watermark\n   */\n  autoDialInterval?: number\n}\n\nexport interface AutoDiallerComponents {\n  peerId: PeerId\n  connectionManager: ConnectionManager\n  peerStore: PeerStore\n}\n\nconst defaultOptions: Partial<AutoDiallerInit> = {\n  enabled: true,\n  minConnections: 0,\n  autoDialInterval: 10000\n}\n\nexport class AutoDialler implements Startable {\n  private readonly components: AutoDiallerComponents\n  private readonly options: Required<AutoDiallerInit>\n  private running: boolean\n  private autoDialTimeout?: ReturnType<retimer>\n\n  /**\n   * Proactively tries to connect to known peers stored in the PeerStore.\n   * It will keep the number of connections below the upper limit and sort\n   * the peers to connect based on wether we know their keys and protocols.\n   */\n  constructor (components: AutoDiallerComponents, init: AutoDiallerInit) {\n    this.components = components\n    this.options = mergeOptions.call({ ignoreUndefined: true }, defaultOptions, init)\n    this.running = false\n    this._autoDial = this._autoDial.bind(this)\n\n    log('options: %j', this.options)\n  }\n\n  isStarted () {\n    return this.running\n  }\n\n  /**\n   * Starts the auto dialer\n   */\n  async start () {\n    if (!this.options.enabled) {\n      log('not enabled')\n      return\n    }\n\n    this.running = true\n\n    void this._autoDial().catch(err => {\n      log.error('could start autodial', err)\n    })\n\n    log('started')\n  }\n\n  /**\n   * Stops the auto dialler\n   */\n  async stop () {\n    if (!this.options.enabled) {\n      log('not enabled')\n      return\n    }\n\n    this.running = false\n\n    if (this.autoDialTimeout != null) {\n      this.autoDialTimeout.clear()\n    }\n\n    log('stopped')\n  }\n\n  async _autoDial () {\n    if (this.autoDialTimeout != null) {\n      this.autoDialTimeout.clear()\n    }\n\n    const minConnections = this.options.minConnections\n\n    // Already has enough connections\n    if (this.components.connectionManager.getConnections().length >= minConnections) {\n      this.autoDialTimeout = retimer(this._autoDial, this.options.autoDialInterval)\n\n      return\n    }\n\n    // Sort peers on whether we know protocols or public keys for them\n    const allPeers = await this.components.peerStore.all()\n\n    const peers = await pipe(\n      // shuffle the peers\n      allPeers.sort(() => Math.random() > 0.5 ? 1 : -1),\n      (source) => filter(source, (peer) => !peer.id.equals(this.components.peerId)),\n      (source) => sort(source, (a, b) => {\n        if (b.protocols.length > a.protocols.length) {\n          return 1\n        } else if (b.id.publicKey != null && a.id.publicKey == null) {\n          return 1\n        }\n        return -1\n      }),\n      async (source) => await all(source)\n    )\n\n    for (let i = 0; this.running && i < peers.length && this.components.connectionManager.getConnections().length < minConnections; i++) {\n      // Connection Manager was stopped during async dial\n      if (!this.running) {\n        return\n      }\n\n      const peer = peers[i]\n\n      if (this.components.connectionManager.getConnections(peer.id).length === 0) {\n        log('connecting to a peerStore stored peer %p', peer.id)\n        try {\n          await this.components.connectionManager.openConnection(peer.id)\n        } catch (err: any) {\n          log.error('could not connect to peerStore stored peer', err)\n        }\n      }\n    }\n\n    // Connection Manager was stopped\n    if (!this.running) {\n      return\n    }\n\n    this.autoDialTimeout = retimer(this._autoDial, this.options.autoDialInterval)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}