{"ast":null,"code":"import debug from 'debug';\nimport Receptacle from 'receptacle';\nimport * as utils from './utils.js';\nconst log = Object.assign(debug('dns-over-http-resolver'), {\n  error: debug('dns-over-http-resolver:error')\n});\n/**\n * DNS over HTTP resolver.\n * Uses a list of servers to resolve DNS records with HTTP requests.\n */\n\nclass Resolver {\n  /**\n   * @class\n   * @param {object} [options]\n   * @param {number} [options.maxCache = 100] - maximum number of cached dns records\n   * @param {Request} [options.request] - function to return DNSJSON\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._cache = new Receptacle({\n      max: options?.maxCache ?? 100\n    });\n    this._TXTcache = new Receptacle({\n      max: options?.maxCache ?? 100\n    });\n    this._servers = ['https://cloudflare-dns.com/dns-query', 'https://dns.google/resolve'];\n    this._request = options.request ?? utils.request;\n    this._abortControllers = [];\n  }\n  /**\n   * Cancel all outstanding DNS queries made by this resolver. Any outstanding\n   * requests will be aborted and promises rejected.\n   */\n\n\n  cancel() {\n    this._abortControllers.forEach(controller => controller.abort());\n  }\n  /**\n   * Get an array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   */\n\n\n  getServers() {\n    return this._servers;\n  }\n  /**\n   * Get a shuffled array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   */\n\n\n  _getShuffledServers() {\n    const newServers = [...this._servers];\n\n    for (let i = newServers.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * i);\n      const temp = newServers[i];\n      newServers[i] = newServers[j];\n      newServers[j] = temp;\n    }\n\n    return newServers;\n  }\n  /**\n   * Sets the IP address and port of servers to be used when performing DNS resolution.\n   *\n   * @param {string[]} servers - array of RFC 5952 formatted addresses.\n   */\n\n\n  setServers(servers) {\n    this._servers = servers;\n  }\n  /**\n   * Uses the DNS protocol to resolve the given host name into the appropriate DNS record\n   *\n   * @param {string} hostname - host name to resolve\n   * @param {string} [rrType = 'A'] - resource record type\n   */\n\n\n  async resolve(hostname) {\n    let rrType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'A';\n\n    switch (rrType) {\n      case 'A':\n        return await this.resolve4(hostname);\n\n      case 'AAAA':\n        return await this.resolve6(hostname);\n\n      case 'TXT':\n        return await this.resolveTxt(hostname);\n\n      default:\n        throw new Error(`${rrType} is not supported`);\n    }\n  }\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv4 addresses\n   *\n   * @param {string} hostname - host name to resolve\n   */\n\n\n  async resolve4(hostname) {\n    const recordType = 'A';\n\n    const cached = this._cache.get(utils.getCacheKey(hostname, recordType));\n\n    if (cached != null) {\n      return cached;\n    }\n\n    let aborted = false;\n\n    for (const server of this._getShuffledServers()) {\n      const controller = new AbortController();\n\n      this._abortControllers.push(controller);\n\n      try {\n        const response = await this._request(utils.buildResource(server, hostname, recordType), controller.signal);\n        const data = response.Answer.map(a => a.data);\n        const ttl = Math.min(...response.Answer.map(a => a.TTL));\n\n        this._cache.set(utils.getCacheKey(hostname, recordType), data, {\n          ttl\n        });\n\n        return data;\n      } catch (err) {\n        if (controller.signal.aborted) {\n          aborted = true;\n        }\n\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`);\n      } finally {\n        this._abortControllers = this._abortControllers.filter(c => c !== controller);\n      }\n    }\n\n    if (aborted) {\n      throw Object.assign(new Error('queryA ECANCELLED'), {\n        code: 'ECANCELLED'\n      });\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`);\n  }\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv6 addresses\n   *\n   * @param {string} hostname - host name to resolve\n   */\n\n\n  async resolve6(hostname) {\n    const recordType = 'AAAA';\n\n    const cached = this._cache.get(utils.getCacheKey(hostname, recordType));\n\n    if (cached != null) {\n      return cached;\n    }\n\n    let aborted = false;\n\n    for (const server of this._getShuffledServers()) {\n      const controller = new AbortController();\n\n      this._abortControllers.push(controller);\n\n      try {\n        const response = await this._request(utils.buildResource(server, hostname, recordType), controller.signal);\n        const data = response.Answer.map(a => a.data);\n        const ttl = Math.min(...response.Answer.map(a => a.TTL));\n\n        this._cache.set(utils.getCacheKey(hostname, recordType), data, {\n          ttl\n        });\n\n        return data;\n      } catch (err) {\n        if (controller.signal.aborted) {\n          aborted = true;\n        }\n\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`);\n      } finally {\n        this._abortControllers = this._abortControllers.filter(c => c !== controller);\n      }\n    }\n\n    if (aborted) {\n      throw Object.assign(new Error('queryAaaa ECANCELLED'), {\n        code: 'ECANCELLED'\n      });\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`);\n  }\n  /**\n   * Uses the DNS protocol to resolve the given host name into a Text record\n   *\n   * @param {string} hostname - host name to resolve\n   */\n\n\n  async resolveTxt(hostname) {\n    const recordType = 'TXT';\n\n    const cached = this._TXTcache.get(utils.getCacheKey(hostname, recordType));\n\n    if (cached != null) {\n      return cached;\n    }\n\n    let aborted = false;\n\n    for (const server of this._getShuffledServers()) {\n      const controller = new AbortController();\n\n      this._abortControllers.push(controller);\n\n      try {\n        const response = await this._request(utils.buildResource(server, hostname, recordType), controller.signal);\n        const data = response.Answer.map(a => [a.data.replace(/['\"]+/g, '')]);\n        const ttl = Math.min(...response.Answer.map(a => a.TTL));\n\n        this._TXTcache.set(utils.getCacheKey(hostname, recordType), data, {\n          ttl\n        });\n\n        return data;\n      } catch (err) {\n        if (controller.signal.aborted) {\n          aborted = true;\n        }\n\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`);\n      } finally {\n        this._abortControllers = this._abortControllers.filter(c => c !== controller);\n      }\n    }\n\n    if (aborted) {\n      throw Object.assign(new Error('queryTxt ECANCELLED'), {\n        code: 'ECANCELLED'\n      });\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`);\n  }\n\n  clearCache() {\n    this._cache.clear();\n\n    this._TXTcache.clear();\n  }\n\n}\n\nexport default Resolver;","map":{"version":3,"mappings":"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","names":["debug","Receptacle","utils","log","Object","assign","error","Resolver","constructor","options","_cache","max","maxCache","_TXTcache","_servers","_request","request","_abortControllers","cancel","forEach","controller","abort","getServers","_getShuffledServers","newServers","i","length","j","Math","floor","random","temp","setServers","servers","resolve","hostname","rrType","resolve4","resolve6","resolveTxt","Error","recordType","cached","get","getCacheKey","aborted","server","AbortController","push","response","buildResource","signal","data","Answer","map","a","ttl","min","TTL","set","err","filter","c","code","replace","clearCache","clear"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\dns-over-http-resolver\\src\\index.ts"],"sourcesContent":["import debug from 'debug'\nimport Receptacle from 'receptacle'\nimport * as utils from './utils.js'\nimport type { DNSJSON } from './utils'\n\nconst log = Object.assign(debug('dns-over-http-resolver'), {\n  error: debug('dns-over-http-resolver:error')\n})\n\nexport interface Request { (resource: string, signal: AbortSignal): Promise<DNSJSON> }\n\ninterface ResolverOptions {\n  maxCache?: number\n  request?: Request\n}\n\n/**\n * DNS over HTTP resolver.\n * Uses a list of servers to resolve DNS records with HTTP requests.\n */\nclass Resolver {\n  private readonly _cache: Receptacle<string[]>\n  private readonly _TXTcache: Receptacle<string[][]>\n  private _servers: string[]\n  private readonly _request: Request\n  private _abortControllers: AbortController[]\n\n  /**\n   * @class\n   * @param {object} [options]\n   * @param {number} [options.maxCache = 100] - maximum number of cached dns records\n   * @param {Request} [options.request] - function to return DNSJSON\n   */\n  constructor (options: ResolverOptions = {}) {\n    this._cache = new Receptacle({ max: options?.maxCache ?? 100 })\n    this._TXTcache = new Receptacle({ max: options?.maxCache ?? 100 })\n    this._servers = [\n      'https://cloudflare-dns.com/dns-query',\n      'https://dns.google/resolve'\n    ]\n    this._request = options.request ?? utils.request\n    this._abortControllers = []\n  }\n\n  /**\n   * Cancel all outstanding DNS queries made by this resolver. Any outstanding\n   * requests will be aborted and promises rejected.\n   */\n  cancel () {\n    this._abortControllers.forEach(controller => controller.abort())\n  }\n\n  /**\n   * Get an array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   */\n  getServers () {\n    return this._servers\n  }\n\n  /**\n   * Get a shuffled array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   */\n  _getShuffledServers () {\n    const newServers = [...this._servers]\n\n    for (let i = newServers.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * i)\n      const temp = newServers[i]\n      newServers[i] = newServers[j]\n      newServers[j] = temp\n    }\n\n    return newServers\n  }\n\n  /**\n   * Sets the IP address and port of servers to be used when performing DNS resolution.\n   *\n   * @param {string[]} servers - array of RFC 5952 formatted addresses.\n   */\n  setServers (servers: string[]) {\n    this._servers = servers\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into the appropriate DNS record\n   *\n   * @param {string} hostname - host name to resolve\n   * @param {string} [rrType = 'A'] - resource record type\n   */\n  async resolve (hostname: string, rrType = 'A') {\n    switch (rrType) {\n      case 'A':\n        return await this.resolve4(hostname)\n      case 'AAAA':\n        return await this.resolve6(hostname)\n      case 'TXT':\n        return await this.resolveTxt(hostname)\n      default:\n        throw new Error(`${rrType} is not supported`)\n    }\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv4 addresses\n   *\n   * @param {string} hostname - host name to resolve\n   */\n  async resolve4 (hostname: string) {\n    const recordType = 'A'\n    const cached = this._cache.get(utils.getCacheKey(hostname, recordType))\n    if (cached != null) {\n      return cached\n    }\n    let aborted = false\n\n    for (const server of this._getShuffledServers()) {\n      const controller = new AbortController()\n      this._abortControllers.push(controller)\n\n      try {\n        const response = await this._request(utils.buildResource(\n          server,\n          hostname,\n          recordType\n        ), controller.signal)\n\n        const data = response.Answer.map(a => a.data)\n        const ttl = Math.min(...response.Answer.map(a => a.TTL))\n\n        this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl })\n\n        return data\n      } catch (err) {\n        if (controller.signal.aborted) {\n          aborted = true\n        }\n\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`)\n      } finally {\n        this._abortControllers = this._abortControllers.filter(c => c !== controller)\n      }\n    }\n\n    if (aborted) {\n      throw Object.assign(new Error('queryA ECANCELLED'), {\n        code: 'ECANCELLED'\n      })\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`)\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv6 addresses\n   *\n   * @param {string} hostname - host name to resolve\n   */\n  async resolve6 (hostname: string) {\n    const recordType = 'AAAA'\n    const cached = this._cache.get(utils.getCacheKey(hostname, recordType))\n    if (cached != null) {\n      return cached\n    }\n    let aborted = false\n\n    for (const server of this._getShuffledServers()) {\n      const controller = new AbortController()\n      this._abortControllers.push(controller)\n\n      try {\n        const response = await this._request(utils.buildResource(\n          server,\n          hostname,\n          recordType\n        ), controller.signal)\n\n        const data = response.Answer.map(a => a.data)\n        const ttl = Math.min(...response.Answer.map(a => a.TTL))\n\n        this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl })\n\n        return data\n      } catch (err) {\n        if (controller.signal.aborted) {\n          aborted = true\n        }\n\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`)\n      } finally {\n        this._abortControllers = this._abortControllers.filter(c => c !== controller)\n      }\n    }\n\n    if (aborted) {\n      throw Object.assign(new Error('queryAaaa ECANCELLED'), {\n        code: 'ECANCELLED'\n      })\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`)\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into a Text record\n   *\n   * @param {string} hostname - host name to resolve\n   */\n  async resolveTxt (hostname: string) {\n    const recordType = 'TXT'\n    const cached = this._TXTcache.get(utils.getCacheKey(hostname, recordType))\n    if (cached != null) {\n      return cached\n    }\n    let aborted = false\n\n    for (const server of this._getShuffledServers()) {\n      const controller = new AbortController()\n      this._abortControllers.push(controller)\n\n      try {\n        const response = await this._request(utils.buildResource(\n          server,\n          hostname,\n          recordType\n        ), controller.signal)\n\n        const data = response.Answer.map(a => [a.data.replace(/['\"]+/g, '')])\n        const ttl = Math.min(...response.Answer.map(a => a.TTL))\n\n        this._TXTcache.set(utils.getCacheKey(hostname, recordType), data, { ttl })\n\n        return data\n      } catch (err) {\n        if (controller.signal.aborted) {\n          aborted = true\n        }\n\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`)\n      } finally {\n        this._abortControllers = this._abortControllers.filter(c => c !== controller)\n      }\n    }\n\n    if (aborted) {\n      throw Object.assign(new Error('queryTxt ECANCELLED'), {\n        code: 'ECANCELLED'\n      })\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`)\n  }\n\n  clearCache () {\n    this._cache.clear()\n    this._TXTcache.clear()\n  }\n}\n\nexport default Resolver\n"]},"metadata":{},"sourceType":"module"}