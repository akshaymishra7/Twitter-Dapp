{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { CID } from 'multiformats/cid';\nimport PQueue from 'p-queue';\nimport defer from 'p-defer';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport anySignal from 'any-signal';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nconst log = logger('libp2p:delegated-peer-routing');\nconst DEFAULT_TIMEOUT = 30e3; // 30 second default\n\nconst CONCURRENT_HTTP_REQUESTS = 4;\nexport var EventTypes;\n\n(function (EventTypes) {\n  EventTypes[EventTypes[\"SENDING_QUERY\"] = 0] = \"SENDING_QUERY\";\n  EventTypes[EventTypes[\"PEER_RESPONSE\"] = 1] = \"PEER_RESPONSE\";\n  EventTypes[EventTypes[\"FINAL_PEER\"] = 2] = \"FINAL_PEER\";\n  EventTypes[EventTypes[\"QUERY_ERROR\"] = 3] = \"QUERY_ERROR\";\n  EventTypes[EventTypes[\"PROVIDER\"] = 4] = \"PROVIDER\";\n  EventTypes[EventTypes[\"VALUE\"] = 5] = \"VALUE\";\n  EventTypes[EventTypes[\"ADDING_PEER\"] = 6] = \"ADDING_PEER\";\n  EventTypes[EventTypes[\"DIALING_PEER\"] = 7] = \"DIALING_PEER\";\n})(EventTypes || (EventTypes = {}));\n/**\n * The types of messages set/received during DHT queries\n */\n\n\nexport var MessageType;\n\n(function (MessageType) {\n  MessageType[MessageType[\"PUT_VALUE\"] = 0] = \"PUT_VALUE\";\n  MessageType[MessageType[\"GET_VALUE\"] = 1] = \"GET_VALUE\";\n  MessageType[MessageType[\"ADD_PROVIDER\"] = 2] = \"ADD_PROVIDER\";\n  MessageType[MessageType[\"GET_PROVIDERS\"] = 3] = \"GET_PROVIDERS\";\n  MessageType[MessageType[\"FIND_NODE\"] = 4] = \"FIND_NODE\";\n  MessageType[MessageType[\"PING\"] = 5] = \"PING\";\n})(MessageType || (MessageType = {}));\n\nclass DelegatedPeerRouting {\n  /**\n   * Create a new DelegatedPeerRouting instance\n   */\n  constructor(client) {\n    if (client == null) {\n      throw new Error('missing ipfs http client');\n    }\n\n    this.client = client;\n    this.started = false;\n    this.abortController = new AbortController(); // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n\n    this.httpQueue = new PQueue({\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    });\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig();\n    log(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`);\n  }\n\n  isStarted() {\n    return this.started;\n  }\n\n  start() {\n    this.started = true;\n  }\n\n  stop() {\n    this.httpQueue.clear();\n    this.abortController.abort();\n    this.abortController = new AbortController();\n    this.started = false;\n  }\n  /**\n   * Attempts to find the given peer\n   */\n\n\n  async findPeer(id) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    log('findPeer starts: %p', id);\n    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;\n    options.signal = anySignal([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));\n    const onStart = defer();\n    const onFinish = defer();\n    void this.httpQueue.add(async () => {\n      onStart.resolve();\n      return await onFinish.promise;\n    });\n\n    try {\n      await onStart.promise;\n\n      for await (const event of this.client.dht.findPeer(id, options)) {\n        if (event.name === 'FINAL_PEER') {\n          const peerInfo = {\n            id: event.peer.id,\n            multiaddrs: event.peer.multiaddrs,\n            protocols: []\n          };\n          return peerInfo;\n        }\n      }\n    } catch (err) {\n      log.error('findPeer errored: %o', err);\n      throw err;\n    } finally {\n      onFinish.resolve();\n      log('findPeer finished: %p', id);\n    }\n\n    throw new CodeError('Not found', 'ERR_NOT_FOUND');\n  }\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   */\n\n\n  async *getClosestPeers(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let cidOrPeerId;\n    const cid = CID.asCID(key);\n\n    if (cid != null) {\n      cidOrPeerId = cid;\n    } else {\n      cidOrPeerId = peerIdFromBytes(key);\n    }\n\n    log('getClosestPeers starts: %s', cidOrPeerId);\n    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;\n    options.signal = anySignal([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));\n    const onStart = defer();\n    const onFinish = defer();\n    void this.httpQueue.add(async () => {\n      onStart.resolve();\n      return await onFinish.promise;\n    });\n\n    try {\n      await onStart.promise;\n\n      for await (const event of this.client.dht.query(cidOrPeerId, options)) {\n        if (event.name === 'PEER_RESPONSE') {\n          yield* event.closer.map(closer => ({\n            id: closer.id,\n            multiaddrs: closer.multiaddrs,\n            protocols: []\n          }));\n        }\n      }\n    } catch (err) {\n      log.error('getClosestPeers errored:', err);\n      throw err;\n    } finally {\n      onFinish.resolve();\n      log('getClosestPeers finished: %b', key);\n    }\n  }\n\n}\n\nexport function delegatedPeerRouting(client) {\n  return () => new DelegatedPeerRouting(client);\n}","map":{"version":3,"mappings":"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","names":["logger","CID","PQueue","defer","CodeError","anySignal","peerIdFromBytes","log","DEFAULT_TIMEOUT","CONCURRENT_HTTP_REQUESTS","EventTypes","MessageType","DelegatedPeerRouting","constructor","client","Error","started","abortController","AbortController","httpQueue","concurrency","protocol","host","port","getEndpointConfig","isStarted","start","stop","clear","abort","findPeer","id","options","timeout","signal","concat","onStart","onFinish","add","resolve","promise","event","dht","name","peerInfo","peer","multiaddrs","protocols","err","error","getClosestPeers","key","cidOrPeerId","cid","asCID","query","closer","map","delegatedPeerRouting"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\delegated-peer-routing\\src\\index.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { CID } from 'multiformats/cid'\nimport PQueue from 'p-queue'\nimport defer from 'p-defer'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport anySignal from 'any-signal'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { AbortOptions } from 'ipfs-core-types/src/utils'\nimport type { PeerRouting } from '@libp2p/interface-peer-routing'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\n\nconst log = logger('libp2p:delegated-peer-routing')\n\nconst DEFAULT_TIMEOUT = 30e3 // 30 second default\nconst CONCURRENT_HTTP_REQUESTS = 4\n\nexport interface HTTPClientExtraOptions {\n  headers?: Record<string, string>\n  searchParams?: URLSearchParams\n}\n\nexport enum EventTypes {\n  SENDING_QUERY = 0,\n  PEER_RESPONSE,\n  FINAL_PEER,\n  QUERY_ERROR,\n  PROVIDER,\n  VALUE,\n  ADDING_PEER,\n  DIALING_PEER\n}\n\n/**\n * The types of messages set/received during DHT queries\n */\nexport enum MessageType {\n  PUT_VALUE = 0,\n  GET_VALUE,\n  ADD_PROVIDER,\n  GET_PROVIDERS,\n  FIND_NODE,\n  PING\n}\n\nexport type MessageName = keyof typeof MessageType\n\nexport interface DHTRecord {\n  key: Uint8Array\n  value: Uint8Array\n  timeReceived?: Date\n}\n\nexport interface SendingQueryEvent {\n  type: EventTypes.SENDING_QUERY\n  name: 'SENDING_QUERY'\n}\n\nexport interface PeerResponseEvent {\n  from: PeerId\n  type: EventTypes.PEER_RESPONSE\n  name: 'PEER_RESPONSE'\n  messageType: MessageType\n  messageName: MessageName\n  providers: PeerInfo[]\n  closer: PeerInfo[]\n  record?: DHTRecord\n}\n\nexport interface FinalPeerEvent {\n  peer: PeerInfo\n  type: EventTypes.FINAL_PEER\n  name: 'FINAL_PEER'\n}\n\nexport interface QueryErrorEvent {\n  type: EventTypes.QUERY_ERROR\n  name: 'QUERY_ERROR'\n  error: Error\n}\n\nexport interface ProviderEvent {\n  type: EventTypes.PROVIDER\n  name: 'PROVIDER'\n  providers: PeerInfo[]\n}\n\nexport interface ValueEvent {\n  type: EventTypes.VALUE\n  name: 'VALUE'\n  value: Uint8Array\n}\n\nexport interface AddingPeerEvent {\n  type: EventTypes.ADDING_PEER\n  name: 'ADDING_PEER'\n  peer: PeerId\n}\n\nexport interface DialingPeerEvent {\n  peer: PeerId\n  type: EventTypes.DIALING_PEER\n  name: 'DIALING_PEER'\n}\n\nexport type QueryEvent = SendingQueryEvent | PeerResponseEvent | FinalPeerEvent | QueryErrorEvent | ProviderEvent | ValueEvent | AddingPeerEvent | DialingPeerEvent\n\nexport interface Delegate {\n  getEndpointConfig: () => { protocol: string, host: string, port: string }\n\n  dht: {\n    findPeer: (peerId: PeerId, options?: AbortOptions) => AsyncIterable<QueryEvent>\n    query: (peerId: PeerId | CID, options?: AbortOptions) => AsyncIterable<QueryEvent>\n  }\n}\n\nclass DelegatedPeerRouting implements PeerRouting, Startable {\n  private readonly client: Delegate\n  private readonly httpQueue: PQueue\n  private started: boolean\n  private abortController: AbortController\n\n  /**\n   * Create a new DelegatedPeerRouting instance\n   */\n  constructor (client: Delegate) {\n    if (client == null) {\n      throw new Error('missing ipfs http client')\n    }\n\n    this.client = client\n    this.started = false\n    this.abortController = new AbortController()\n\n    // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n    this.httpQueue = new PQueue({\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    })\n\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig()\n\n    log(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`)\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  stop (): void {\n    this.httpQueue.clear()\n    this.abortController.abort()\n    this.abortController = new AbortController()\n    this.started = false\n  }\n\n  /**\n   * Attempts to find the given peer\n   */\n  async findPeer (id: PeerId, options: HTTPClientExtraOptions & AbortOptions = {}): Promise<PeerInfo> {\n    log('findPeer starts: %p', id)\n    options.timeout = options.timeout ?? DEFAULT_TIMEOUT\n    options.signal = anySignal([this.abortController.signal].concat((options.signal != null) ? [options.signal] : []))\n\n    const onStart = defer()\n    const onFinish = defer()\n\n    void this.httpQueue.add(async () => {\n      onStart.resolve()\n      return await onFinish.promise\n    })\n\n    try {\n      await onStart.promise\n\n      for await (const event of this.client.dht.findPeer(id, options)) {\n        if (event.name === 'FINAL_PEER') {\n          const peerInfo: PeerInfo = {\n            id: event.peer.id,\n            multiaddrs: event.peer.multiaddrs,\n            protocols: []\n          }\n\n          return peerInfo\n        }\n      }\n    } catch (err: any) {\n      log.error('findPeer errored: %o', err)\n\n      throw err\n    } finally {\n      onFinish.resolve()\n      log('findPeer finished: %p', id)\n    }\n\n    throw new CodeError('Not found', 'ERR_NOT_FOUND')\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   */\n  async * getClosestPeers (key: Uint8Array, options: HTTPClientExtraOptions & AbortOptions = {}): AsyncGenerator<PeerInfo, void, undefined> {\n    let cidOrPeerId: CID | PeerId\n    const cid = CID.asCID(key)\n\n    if (cid != null) {\n      cidOrPeerId = cid\n    } else {\n      cidOrPeerId = peerIdFromBytes(key)\n    }\n\n    log('getClosestPeers starts: %s', cidOrPeerId)\n    options.timeout = options.timeout ?? DEFAULT_TIMEOUT\n    options.signal = anySignal([this.abortController.signal].concat((options.signal != null) ? [options.signal] : []))\n\n    const onStart = defer()\n    const onFinish = defer()\n\n    void this.httpQueue.add(async () => {\n      onStart.resolve()\n      return await onFinish.promise\n    })\n\n    try {\n      await onStart.promise\n\n      for await (const event of this.client.dht.query(cidOrPeerId, options)) {\n        if (event.name === 'PEER_RESPONSE') {\n          yield * event.closer.map(closer => ({\n            id: closer.id,\n            multiaddrs: closer.multiaddrs,\n            protocols: []\n          }))\n        }\n      }\n    } catch (err) {\n      log.error('getClosestPeers errored:', err)\n      throw err\n    } finally {\n      onFinish.resolve()\n      log('getClosestPeers finished: %b', key)\n    }\n  }\n}\n\nexport function delegatedPeerRouting (client: Delegate): (components?: any) => PeerRouting {\n  return () => new DelegatedPeerRouting(client)\n}\n"]},"metadata":{},"sourceType":"module"}