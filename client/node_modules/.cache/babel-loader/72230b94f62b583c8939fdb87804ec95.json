{"ast":null,"code":"import { Uint8ArrayList } from 'uint8arraylist';\n/**\n * Returns an `AsyncGenerator` that allows reading a set number of bytes from the passed source.\n *\n * @example\n *\n * ```javascript\n * import { reader } from 'it-reader'\n *\n * const stream = reader(source)\n *\n * // read 10 bytes from the stream\n * const { done, value } = await stream.next(10)\n *\n * if (done === true) {\n *   // stream finished\n * }\n *\n * if (value != null) {\n *   // do something with value\n * }\n * ```\n */\n\nexport function reader(source) {\n  const reader = async function* () {\n    // @ts-expect-error first yield in stream is ignored\n    let bytes = yield; // Allows us to receive 8 when reader.next(8) is called\n\n    let bl = new Uint8ArrayList();\n\n    for await (const chunk of source) {\n      if (bytes == null) {\n        bl.append(chunk);\n        bytes = yield bl;\n        bl = new Uint8ArrayList();\n        continue;\n      }\n\n      bl.append(chunk);\n\n      while (bl.length >= bytes) {\n        const data = bl.sublist(0, bytes);\n        bl.consume(bytes);\n        bytes = yield data; // If we no longer want a specific byte length, we yield the rest now\n\n        if (bytes == null) {\n          if (bl.length > 0) {\n            bytes = yield bl;\n            bl = new Uint8ArrayList();\n          }\n\n          break; // bytes is null and/or no more buffer to yield\n        }\n      }\n    } // Consumer wants more bytes but the source has ended and our buffer\n    // is not big enough to satisfy.\n\n\n    if (bytes != null) {\n      throw Object.assign(new Error(`stream ended before ${bytes} bytes became available`), {\n        code: 'ERR_UNDER_READ',\n        buffer: bl\n      });\n    }\n  }();\n\n  void reader.next();\n  return reader;\n}","map":{"version":3,"mappings":"AAAA,SAASA,cAAT,QAA+B,gBAA/B;AAWA;;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAM,SAAUC,MAAV,CAAkBC,MAAlB,EAA6D;AACjE,QAAMD,MAAM,GAAY,mBAAgB;AACtC;AACA,QAAIE,KAAK,GAAuB,KAAhC,CAFsC,CAEA;;AACtC,QAAIC,EAAE,GAAG,IAAIJ,cAAJ,EAAT;;AAEA,eAAW,MAAMK,KAAjB,IAA0BH,MAA1B,EAAkC;AAChC,UAAIC,KAAK,IAAI,IAAb,EAAmB;AACjBC,UAAE,CAACE,MAAH,CAAUD,KAAV;AACAF,aAAK,GAAG,MAAMC,EAAd;AACAA,UAAE,GAAG,IAAIJ,cAAJ,EAAL;AACA;AACD;;AAEDI,QAAE,CAACE,MAAH,CAAUD,KAAV;;AAEA,aAAOD,EAAE,CAACG,MAAH,IAAaJ,KAApB,EAA2B;AACzB,cAAMK,IAAI,GAAGJ,EAAE,CAACK,OAAH,CAAW,CAAX,EAAcN,KAAd,CAAb;AACAC,UAAE,CAACM,OAAH,CAAWP,KAAX;AACAA,aAAK,GAAG,MAAMK,IAAd,CAHyB,CAKzB;;AACA,YAAIL,KAAK,IAAI,IAAb,EAAmB;AACjB,cAAIC,EAAE,CAACG,MAAH,GAAY,CAAhB,EAAmB;AACjBJ,iBAAK,GAAG,MAAMC,EAAd;AACAA,cAAE,GAAG,IAAIJ,cAAJ,EAAL;AACD;;AACD,gBALiB,CAKX;AACP;AACF;AACF,KA7BqC,CA+BtC;AACA;;;AACA,QAAIG,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAMQ,MAAM,CAACC,MAAP,CACJ,IAAIC,KAAJ,CAAU,uBAAuBV,KAAK,yBAAtC,CADI,EAEJ;AAAEW,YAAI,EAAE,gBAAR;AAA0BC,cAAM,EAAEX;AAAlC,OAFI,CAAN;AAID;AACF,GAvCsB,EAAvB;;AAyCA,OAAKH,MAAM,CAACe,IAAP,EAAL;AACA,SAAOf,MAAP;AACD","names":["Uint8ArrayList","reader","source","bytes","bl","chunk","append","length","data","sublist","consume","Object","assign","Error","code","buffer","next"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-reader\\src\\index.ts"],"sourcesContent":["import { Uint8ArrayList } from 'uint8arraylist'\nimport type { Source } from 'it-stream-types'\n\n/**\n * A specialized `AsyncGenerator` that lets you pass a number to the `.next` method which\n * will attempt to return only that many bytes.\n */\nexport interface Reader extends AsyncGenerator<Uint8ArrayList, void, any> {\n  next: (...args: [] | [number | undefined]) => Promise<IteratorResult<Uint8ArrayList, void>>\n}\n\n/**\n * Returns an `AsyncGenerator` that allows reading a set number of bytes from the passed source.\n *\n * @example\n *\n * ```javascript\n * import { reader } from 'it-reader'\n *\n * const stream = reader(source)\n *\n * // read 10 bytes from the stream\n * const { done, value } = await stream.next(10)\n *\n * if (done === true) {\n *   // stream finished\n * }\n *\n * if (value != null) {\n *   // do something with value\n * }\n * ```\n */\nexport function reader (source: Source<Uint8Array | Uint8ArrayList>): Reader {\n  const reader: Reader = (async function * (): AsyncGenerator<Uint8ArrayList, void, any> {\n    // @ts-expect-error first yield in stream is ignored\n    let bytes: number | undefined = yield // Allows us to receive 8 when reader.next(8) is called\n    let bl = new Uint8ArrayList()\n\n    for await (const chunk of source) {\n      if (bytes == null) {\n        bl.append(chunk)\n        bytes = yield bl\n        bl = new Uint8ArrayList()\n        continue\n      }\n\n      bl.append(chunk)\n\n      while (bl.length >= bytes) {\n        const data = bl.sublist(0, bytes)\n        bl.consume(bytes)\n        bytes = yield data\n\n        // If we no longer want a specific byte length, we yield the rest now\n        if (bytes == null) {\n          if (bl.length > 0) {\n            bytes = yield bl\n            bl = new Uint8ArrayList()\n          }\n          break // bytes is null and/or no more buffer to yield\n        }\n      }\n    }\n\n    // Consumer wants more bytes but the source has ended and our buffer\n    // is not big enough to satisfy.\n    if (bytes != null) {\n      throw Object.assign(\n        new Error(`stream ended before ${bytes} bytes became available`),\n        { code: 'ERR_UNDER_READ', buffer: bl }\n      )\n    }\n  })()\n\n  void reader.next()\n  return reader\n}\n"]},"metadata":{},"sourceType":"module"}