{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { codes } from './errors.js';\nimport { isTopology } from '@libp2p/interface-registrar';\nimport merge from 'merge-options';\nconst log = logger('libp2p:registrar');\nexport const DEFAULT_MAX_INBOUND_STREAMS = 32;\nexport const DEFAULT_MAX_OUTBOUND_STREAMS = 64;\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\n\nexport class DefaultRegistrar {\n  constructor(components) {\n    this.topologies = new Map();\n    this.handlers = new Map();\n    this.components = components;\n    this._onDisconnect = this._onDisconnect.bind(this);\n    this._onProtocolChange = this._onProtocolChange.bind(this);\n    this._onConnect = this._onConnect.bind(this);\n    this.components.connectionManager.addEventListener('peer:disconnect', this._onDisconnect);\n    this.components.connectionManager.addEventListener('peer:connect', this._onConnect); // happens after identify\n\n    this.components.peerStore.addEventListener('change:protocols', this._onProtocolChange);\n  }\n\n  getProtocols() {\n    return Array.from(new Set([...this.topologies.keys(), ...this.handlers.keys()])).sort();\n  }\n\n  getHandler(protocol) {\n    const handler = this.handlers.get(protocol);\n\n    if (handler == null) {\n      throw errCode(new Error(`No handler registered for protocol ${protocol}`), codes.ERR_NO_HANDLER_FOR_PROTOCOL);\n    }\n\n    return handler;\n  }\n\n  getTopologies(protocol) {\n    const topologies = this.topologies.get(protocol);\n\n    if (topologies == null) {\n      return [];\n    }\n\n    return [...topologies.values()];\n  }\n  /**\n   * Registers the `handler` for each protocol\n   */\n\n\n  async handle(protocol, handler, opts) {\n    if (this.handlers.has(protocol)) {\n      throw errCode(new Error(`Handler already registered for protocol ${protocol}`), codes.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);\n    }\n\n    const options = merge.bind({\n      ignoreUndefined: true\n    })({\n      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,\n      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS\n    }, opts);\n    this.handlers.set(protocol, {\n      handler,\n      options\n    }); // Add new protocols to self protocols in the Protobook\n\n    await this.components.peerStore.protoBook.add(this.components.peerId, [protocol]);\n  }\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   */\n\n\n  async unhandle(protocols) {\n    const protocolList = Array.isArray(protocols) ? protocols : [protocols];\n    protocolList.forEach(protocol => {\n      this.handlers.delete(protocol);\n    }); // Remove protocols from self protocols in the Protobook\n\n    await this.components.peerStore.protoBook.remove(this.components.peerId, protocolList);\n  }\n  /**\n   * Register handlers for a set of multicodecs given\n   */\n\n\n  async register(protocol, topology) {\n    if (!isTopology(topology)) {\n      log.error('topology must be an instance of interfaces/topology');\n      throw errCode(new Error('topology must be an instance of interfaces/topology'), codes.ERR_INVALID_PARAMETERS);\n    } // Create topology\n\n\n    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;\n    let topologies = this.topologies.get(protocol);\n\n    if (topologies == null) {\n      topologies = new Map();\n      this.topologies.set(protocol, topologies);\n    }\n\n    topologies.set(id, topology); // Set registrar\n\n    await topology.setRegistrar(this);\n    return id;\n  }\n  /**\n   * Unregister topology\n   */\n\n\n  unregister(id) {\n    for (const [protocol, topologies] of this.topologies.entries()) {\n      if (topologies.has(id)) {\n        topologies.delete(id);\n\n        if (topologies.size === 0) {\n          this.topologies.delete(protocol);\n        }\n      }\n    }\n  }\n  /**\n   * Remove a disconnected peer from the record\n   */\n\n\n  _onDisconnect(evt) {\n    const connection = evt.detail;\n    void this.components.peerStore.protoBook.get(connection.remotePeer).then(peerProtocols => {\n      for (const protocol of peerProtocols) {\n        const topologies = this.topologies.get(protocol);\n\n        if (topologies == null) {\n          // no topologies are interested in this protocol\n          continue;\n        }\n\n        for (const topology of topologies.values()) {\n          topology.onDisconnect(connection.remotePeer);\n        }\n      }\n    }).catch(err => {\n      log.error(err);\n    });\n  }\n  /**\n   * On peer connected if we already have their protocols. Usually used for reconnects\n   * as change:protocols event won't be emitted due to identical protocols.\n   */\n\n\n  _onConnect(evt) {\n    const connection = evt.detail;\n    void this.components.peerStore.protoBook.get(connection.remotePeer).then(peerProtocols => {\n      for (const protocol of peerProtocols) {\n        const topologies = this.topologies.get(protocol);\n\n        if (topologies == null) {\n          // no topologies are interested in this protocol\n          continue;\n        }\n\n        for (const topology of topologies.values()) {\n          topology.onConnect(connection.remotePeer, connection);\n        }\n      }\n    }).catch(err => {\n      log.error(err);\n    });\n  }\n  /**\n   * Check if a new peer support the multicodecs for this topology\n   */\n\n\n  _onProtocolChange(evt) {\n    const {\n      peerId,\n      protocols,\n      oldProtocols\n    } = evt.detail;\n    const removed = oldProtocols.filter(protocol => !protocols.includes(protocol));\n    const added = protocols.filter(protocol => !oldProtocols.includes(protocol));\n\n    for (const protocol of removed) {\n      const topologies = this.topologies.get(protocol);\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue;\n      }\n\n      for (const topology of topologies.values()) {\n        topology.onDisconnect(peerId);\n      }\n    }\n\n    for (const protocol of added) {\n      const topologies = this.topologies.get(protocol);\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue;\n      }\n\n      for (const topology of topologies.values()) {\n        const connection = this.components.connectionManager.getConnections(peerId)[0];\n\n        if (connection == null) {\n          continue;\n        }\n\n        topology.onConnect(peerId, connection);\n      }\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","errCode","codes","isTopology","merge","log","DEFAULT_MAX_INBOUND_STREAMS","DEFAULT_MAX_OUTBOUND_STREAMS","DefaultRegistrar","constructor","components","topologies","Map","handlers","_onDisconnect","bind","_onProtocolChange","_onConnect","connectionManager","addEventListener","peerStore","getProtocols","Array","from","Set","keys","sort","getHandler","protocol","handler","get","Error","ERR_NO_HANDLER_FOR_PROTOCOL","getTopologies","values","handle","opts","has","ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED","options","ignoreUndefined","maxInboundStreams","maxOutboundStreams","set","protoBook","add","peerId","unhandle","protocols","protocolList","isArray","forEach","delete","remove","register","topology","error","ERR_INVALID_PARAMETERS","id","Math","random","toString","Date","now","setRegistrar","unregister","entries","size","evt","connection","detail","remotePeer","then","peerProtocols","onDisconnect","catch","err","onConnect","oldProtocols","removed","filter","includes","added","getConnections"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\registrar.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { codes } from './errors.js'\nimport { isTopology, StreamHandlerOptions, StreamHandlerRecord } from '@libp2p/interface-registrar'\nimport merge from 'merge-options'\nimport type { Registrar, StreamHandler, Topology } from '@libp2p/interface-registrar'\nimport type { PeerProtocolsChangeData, PeerStore } from '@libp2p/interface-peer-store'\nimport type { Connection } from '@libp2p/interface-connection'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\nimport type { PeerId } from '@libp2p/interface-peer-id'\n\nconst log = logger('libp2p:registrar')\n\nexport const DEFAULT_MAX_INBOUND_STREAMS = 32\nexport const DEFAULT_MAX_OUTBOUND_STREAMS = 64\n\nexport interface RegistrarComponents {\n  peerId: PeerId\n  connectionManager: ConnectionManager\n  peerStore: PeerStore\n}\n\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\nexport class DefaultRegistrar implements Registrar {\n  private readonly topologies: Map<string, Map<string, Topology>>\n  private readonly handlers: Map<string, StreamHandlerRecord>\n  private readonly components: RegistrarComponents\n\n  constructor (components: RegistrarComponents) {\n    this.topologies = new Map()\n    this.handlers = new Map()\n    this.components = components\n\n    this._onDisconnect = this._onDisconnect.bind(this)\n    this._onProtocolChange = this._onProtocolChange.bind(this)\n    this._onConnect = this._onConnect.bind(this)\n\n    this.components.connectionManager.addEventListener('peer:disconnect', this._onDisconnect)\n    this.components.connectionManager.addEventListener('peer:connect', this._onConnect)\n\n    // happens after identify\n    this.components.peerStore.addEventListener('change:protocols', this._onProtocolChange)\n  }\n\n  getProtocols () {\n    return Array.from(new Set<string>([\n      ...this.topologies.keys(),\n      ...this.handlers.keys()\n    ])).sort()\n  }\n\n  getHandler (protocol: string) {\n    const handler = this.handlers.get(protocol)\n\n    if (handler == null) {\n      throw errCode(new Error(`No handler registered for protocol ${protocol}`), codes.ERR_NO_HANDLER_FOR_PROTOCOL)\n    }\n\n    return handler\n  }\n\n  getTopologies (protocol: string) {\n    const topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      return []\n    }\n\n    return [\n      ...topologies.values()\n    ]\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   */\n  async handle (protocol: string, handler: StreamHandler, opts?: StreamHandlerOptions): Promise<void> {\n    if (this.handlers.has(protocol)) {\n      throw errCode(new Error(`Handler already registered for protocol ${protocol}`), codes.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED)\n    }\n\n    const options = merge.bind({ ignoreUndefined: true })({\n      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,\n      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS\n    }, opts)\n\n    this.handlers.set(protocol, {\n      handler,\n      options\n    })\n\n    // Add new protocols to self protocols in the Protobook\n    await this.components.peerStore.protoBook.add(this.components.peerId, [protocol])\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   */\n  async unhandle (protocols: string | string[]) {\n    const protocolList = Array.isArray(protocols) ? protocols : [protocols]\n\n    protocolList.forEach(protocol => {\n      this.handlers.delete(protocol)\n    })\n\n    // Remove protocols from self protocols in the Protobook\n    await this.components.peerStore.protoBook.remove(this.components.peerId, protocolList)\n  }\n\n  /**\n   * Register handlers for a set of multicodecs given\n   */\n  async register (protocol: string, topology: Topology): Promise<string> {\n    if (!isTopology(topology)) {\n      log.error('topology must be an instance of interfaces/topology')\n      throw errCode(new Error('topology must be an instance of interfaces/topology'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    // Create topology\n    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`\n\n    let topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      topologies = new Map<string, Topology>()\n      this.topologies.set(protocol, topologies)\n    }\n\n    topologies.set(id, topology)\n\n    // Set registrar\n    await topology.setRegistrar(this)\n\n    return id\n  }\n\n  /**\n   * Unregister topology\n   */\n  unregister (id: string) {\n    for (const [protocol, topologies] of this.topologies.entries()) {\n      if (topologies.has(id)) {\n        topologies.delete(id)\n\n        if (topologies.size === 0) {\n          this.topologies.delete(protocol)\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove a disconnected peer from the record\n   */\n  _onDisconnect (evt: CustomEvent<Connection>) {\n    const connection = evt.detail\n\n    void this.components.peerStore.protoBook.get(connection.remotePeer)\n      .then(peerProtocols => {\n        for (const protocol of peerProtocols) {\n          const topologies = this.topologies.get(protocol)\n\n          if (topologies == null) {\n            // no topologies are interested in this protocol\n            continue\n          }\n\n          for (const topology of topologies.values()) {\n            topology.onDisconnect(connection.remotePeer)\n          }\n        }\n      })\n      .catch(err => {\n        log.error(err)\n      })\n  }\n\n  /**\n   * On peer connected if we already have their protocols. Usually used for reconnects\n   * as change:protocols event won't be emitted due to identical protocols.\n   */\n  _onConnect (evt: CustomEvent<Connection>) {\n    const connection = evt.detail\n\n    void this.components.peerStore.protoBook.get(connection.remotePeer)\n      .then(peerProtocols => {\n        for (const protocol of peerProtocols) {\n          const topologies = this.topologies.get(protocol)\n\n          if (topologies == null) {\n            // no topologies are interested in this protocol\n            continue\n          }\n\n          for (const topology of topologies.values()) {\n            topology.onConnect(connection.remotePeer, connection)\n          }\n        }\n      })\n      .catch(err => {\n        log.error(err)\n      })\n  }\n\n  /**\n   * Check if a new peer support the multicodecs for this topology\n   */\n  _onProtocolChange (evt: CustomEvent<PeerProtocolsChangeData>) {\n    const { peerId, protocols, oldProtocols } = evt.detail\n    const removed = oldProtocols.filter(protocol => !protocols.includes(protocol))\n    const added = protocols.filter(protocol => !oldProtocols.includes(protocol))\n\n    for (const protocol of removed) {\n      const topologies = this.topologies.get(protocol)\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue\n      }\n\n      for (const topology of topologies.values()) {\n        topology.onDisconnect(peerId)\n      }\n    }\n\n    for (const protocol of added) {\n      const topologies = this.topologies.get(protocol)\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue\n      }\n\n      for (const topology of topologies.values()) {\n        const connection = this.components.connectionManager.getConnections(peerId)[0]\n\n        if (connection == null) {\n          continue\n        }\n        topology.onConnect(peerId, connection)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}