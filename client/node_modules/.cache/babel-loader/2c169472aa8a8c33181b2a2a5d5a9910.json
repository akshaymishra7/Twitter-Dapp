{"ast":null,"code":"/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\nclass Node {\n  value;\n  next;\n\n  constructor(value) {\n    this.value = value;\n  }\n\n}\n\nexport default class Queue {\n  #head;\n  #tail;\n  #size;\n\n  constructor() {\n    this.clear();\n  }\n\n  enqueue(value) {\n    const node = new Node(value);\n\n    if (this.#head) {\n      this.#tail.next = node;\n      this.#tail = node;\n    } else {\n      this.#head = node;\n      this.#tail = node;\n    }\n\n    this.#size++;\n  }\n\n  dequeue() {\n    const current = this.#head;\n\n    if (!current) {\n      return;\n    }\n\n    this.#head = this.#head.next;\n    this.#size--;\n    return current.value;\n  }\n\n  clear() {\n    this.#head = undefined;\n    this.#tail = undefined;\n    this.#size = 0;\n  }\n\n  get size() {\n    return this.#size;\n  }\n\n  *[Symbol.iterator]() {\n    let current = this.#head;\n\n    while (current) {\n      yield current.value;\n      current = current.next;\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/yocto-queue/index.js"],"names":["Node","value","next","constructor","Queue","head","tail","size","clear","enqueue","node","dequeue","current","undefined","Symbol","iterator"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,MAAMA,IAAN,CAAW;AACVC,EAAAA,KAAK;AACLC,EAAAA,IAAI;;AAEJC,EAAAA,WAAW,CAACF,KAAD,EAAQ;AAClB,SAAKA,KAAL,GAAaA,KAAb;AACA;;AANS;;AASX,eAAe,MAAMG,KAAN,CAAY;AAC1B,GAACC,IAAD;AACA,GAACC,IAAD;AACA,GAACC,IAAD;;AAEAJ,EAAAA,WAAW,GAAG;AACb,SAAKK,KAAL;AACA;;AAEDC,EAAAA,OAAO,CAACR,KAAD,EAAQ;AACd,UAAMS,IAAI,GAAG,IAAIV,IAAJ,CAASC,KAAT,CAAb;;AAEA,QAAI,KAAK,CAACI,IAAV,EAAgB;AACf,WAAK,CAACC,IAAN,CAAWJ,IAAX,GAAkBQ,IAAlB;AACA,WAAK,CAACJ,IAAN,GAAaI,IAAb;AACA,KAHD,MAGO;AACN,WAAK,CAACL,IAAN,GAAaK,IAAb;AACA,WAAK,CAACJ,IAAN,GAAaI,IAAb;AACA;;AAED,SAAK,CAACH,IAAN;AACA;;AAEDI,EAAAA,OAAO,GAAG;AACT,UAAMC,OAAO,GAAG,KAAK,CAACP,IAAtB;;AACA,QAAI,CAACO,OAAL,EAAc;AACb;AACA;;AAED,SAAK,CAACP,IAAN,GAAa,KAAK,CAACA,IAAN,CAAWH,IAAxB;AACA,SAAK,CAACK,IAAN;AACA,WAAOK,OAAO,CAACX,KAAf;AACA;;AAEDO,EAAAA,KAAK,GAAG;AACP,SAAK,CAACH,IAAN,GAAaQ,SAAb;AACA,SAAK,CAACP,IAAN,GAAaO,SAAb;AACA,SAAK,CAACN,IAAN,GAAa,CAAb;AACA;;AAEO,MAAJA,IAAI,GAAG;AACV,WAAO,KAAK,CAACA,IAAb;AACA;;AAEiB,IAAfO,MAAM,CAACC,QAAQ,IAAI;AACrB,QAAIH,OAAO,GAAG,KAAK,CAACP,IAApB;;AAEA,WAAOO,OAAP,EAAgB;AACf,YAAMA,OAAO,CAACX,KAAd;AACAW,MAAAA,OAAO,GAAGA,OAAO,CAACV,IAAlB;AACA;AACD;;AAnDyB","sourcesContent":["/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n\tvalue;\n\tnext;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n}\n\nexport default class Queue {\n\t#head;\n\t#tail;\n\t#size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this.#head) {\n\t\t\tthis.#tail.next = node;\n\t\t\tthis.#tail = node;\n\t\t} else {\n\t\t\tthis.#head = node;\n\t\t\tthis.#tail = node;\n\t\t}\n\n\t\tthis.#size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this.#head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#head = this.#head.next;\n\t\tthis.#size--;\n\t\treturn current.value;\n\t}\n\n\tclear() {\n\t\tthis.#head = undefined;\n\t\tthis.#tail = undefined;\n\t\tthis.#size = 0;\n\t}\n\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this.#head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}