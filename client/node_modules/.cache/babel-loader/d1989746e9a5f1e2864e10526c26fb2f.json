{"ast":null,"code":"import { TAG_LENGTH } from '@stablelib/chacha20poly1305';\nimport { NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG } from '../constants.js';\nimport { uint16BEEncode } from '../encoder.js'; // Returns generator that encrypts payload from the user\n\nexport function encryptStream(handshake, metrics) {\n  return async function* (source) {\n    for await (const chunk of source) {\n      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n\n        if (end > chunk.length) {\n          end = chunk.length;\n        }\n\n        const data = handshake.encrypt(chunk.subarray(i, end), handshake.session);\n        metrics?.encryptedPackets.increment();\n        yield uint16BEEncode(data.byteLength);\n        yield data;\n      }\n    }\n  };\n} // Decrypt received payload to the user\n\nexport function decryptStream(handshake, metrics) {\n  return async function* (source) {\n    for await (const chunk of source) {\n      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES;\n\n        if (end > chunk.length) {\n          end = chunk.length;\n        }\n\n        if (end - TAG_LENGTH < i) {\n          throw new Error('Invalid chunk');\n        }\n\n        const encrypted = chunk.subarray(i, end); // memory allocation is not cheap so reuse the encrypted Uint8Array\n        // see https://github.com/ChainSafe/js-libp2p-noise/pull/242#issue-1422126164\n        // this is ok because chacha20 reads bytes one by one and don't reread after that\n        // it's also tested in https://github.com/ChainSafe/as-chacha20poly1305/pull/1/files#diff-25252846b58979dcaf4e41d47b3eadd7e4f335e7fb98da6c049b1f9cd011f381R48\n\n        const dst = chunk.subarray(i, end - TAG_LENGTH);\n        const {\n          plaintext: decrypted,\n          valid\n        } = handshake.decrypt(encrypted, handshake.session, dst);\n\n        if (!valid) {\n          metrics?.decryptErrors.increment();\n          throw new Error('Failed to validate decrypted chunk');\n        }\n\n        metrics?.decryptedPackets.increment();\n        yield decrypted;\n      }\n    }\n  };\n}","map":{"version":3,"mappings":"AAAA,SAASA,UAAT,QAA2B,6BAA3B;AAKA,SAASC,0BAAT,EAAqCC,sCAArC,QAAmF,iBAAnF;AACA,SAASC,cAAT,QAA+B,eAA/B,C,CAEA;;AACA,OAAM,SAAUC,aAAV,CAAyBC,SAAzB,EAAgDC,OAAhD,EAAyE;AAC7E,SAAO,iBAAkBC,MAAlB,EAAwB;AAC7B,eAAW,MAAMC,KAAjB,IAA0BD,MAA1B,EAAkC;AAChC,WAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,IAAIP,sCAAvC,EAA+E;AAC7E,YAAIS,GAAG,GAAGF,CAAC,GAAGP,sCAAd;;AACA,YAAIS,GAAG,GAAGH,KAAK,CAACE,MAAhB,EAAwB;AACtBC,aAAG,GAAGH,KAAK,CAACE,MAAZ;AACD;;AAED,cAAME,IAAI,GAAGP,SAAS,CAACQ,OAAV,CAAkBL,KAAK,CAACM,QAAN,CAAeL,CAAf,EAAkBE,GAAlB,CAAlB,EAA0CN,SAAS,CAACU,OAApD,CAAb;AACAT,eAAO,EAAEU,gBAAT,CAA0BC,SAA1B;AAEA,cAAMd,cAAc,CAACS,IAAI,CAACM,UAAN,CAApB;AACA,cAAMN,IAAN;AACD;AACF;AACF,GAfD;AAgBD,C,CAED;;AACA,OAAM,SAAUO,aAAV,CAAyBd,SAAzB,EAAgDC,OAAhD,EAAyE;AAC7E,SAAO,iBAAkBC,MAAlB,EAAwB;AAC7B,eAAW,MAAMC,KAAjB,IAA0BD,MAA1B,EAAkC;AAChC,WAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,IAAIR,0BAAvC,EAAmE;AACjE,YAAIU,GAAG,GAAGF,CAAC,GAAGR,0BAAd;;AACA,YAAIU,GAAG,GAAGH,KAAK,CAACE,MAAhB,EAAwB;AACtBC,aAAG,GAAGH,KAAK,CAACE,MAAZ;AACD;;AAED,YAAIC,GAAG,GAAGX,UAAN,GAAmBS,CAAvB,EAA0B;AACxB,gBAAM,IAAIW,KAAJ,CAAU,eAAV,CAAN;AACD;;AACD,cAAMC,SAAS,GAAGb,KAAK,CAACM,QAAN,CAAeL,CAAf,EAAkBE,GAAlB,CAAlB,CATiE,CAUjE;AACA;AACA;AACA;;AACA,cAAMW,GAAG,GAAGd,KAAK,CAACM,QAAN,CAAeL,CAAf,EAAkBE,GAAG,GAAGX,UAAxB,CAAZ;AACA,cAAM;AAAEuB,mBAAS,EAAEC,SAAb;AAAwBC;AAAxB,YAAkCpB,SAAS,CAACqB,OAAV,CAAkBL,SAAlB,EAA6BhB,SAAS,CAACU,OAAvC,EAAgDO,GAAhD,CAAxC;;AACA,YAAI,CAACG,KAAL,EAAY;AACVnB,iBAAO,EAAEqB,aAAT,CAAuBV,SAAvB;AACA,gBAAM,IAAIG,KAAJ,CAAU,oCAAV,CAAN;AACD;;AACDd,eAAO,EAAEsB,gBAAT,CAA0BX,SAA1B;AACA,cAAMO,SAAN;AACD;AACF;AACF,GA1BD;AA2BD","names":["TAG_LENGTH","NOISE_MSG_MAX_LENGTH_BYTES","NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG","uint16BEEncode","encryptStream","handshake","metrics","source","chunk","i","length","end","data","encrypt","subarray","session","encryptedPackets","increment","byteLength","decryptStream","Error","encrypted","dst","plaintext","decrypted","valid","decrypt","decryptErrors","decryptedPackets"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-noise\\src\\crypto\\streaming.ts"],"sourcesContent":["import { TAG_LENGTH } from '@stablelib/chacha20poly1305'\nimport type { Transform } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { IHandshake } from '../@types/handshake-interface.js'\nimport type { MetricsRegistry } from '../metrics.js'\nimport { NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG } from '../constants.js'\nimport { uint16BEEncode } from '../encoder.js'\n\n// Returns generator that encrypts payload from the user\nexport function encryptStream (handshake: IHandshake, metrics?: MetricsRegistry): Transform<Uint8Array> {\n  return async function * (source) {\n    for await (const chunk of source) {\n      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG\n        if (end > chunk.length) {\n          end = chunk.length\n        }\n\n        const data = handshake.encrypt(chunk.subarray(i, end), handshake.session)\n        metrics?.encryptedPackets.increment()\n\n        yield uint16BEEncode(data.byteLength)\n        yield data\n      }\n    }\n  }\n}\n\n// Decrypt received payload to the user\nexport function decryptStream (handshake: IHandshake, metrics?: MetricsRegistry): Transform<Uint8ArrayList, Uint8Array> {\n  return async function * (source) {\n    for await (const chunk of source) {\n      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES\n        if (end > chunk.length) {\n          end = chunk.length\n        }\n\n        if (end - TAG_LENGTH < i) {\n          throw new Error('Invalid chunk')\n        }\n        const encrypted = chunk.subarray(i, end)\n        // memory allocation is not cheap so reuse the encrypted Uint8Array\n        // see https://github.com/ChainSafe/js-libp2p-noise/pull/242#issue-1422126164\n        // this is ok because chacha20 reads bytes one by one and don't reread after that\n        // it's also tested in https://github.com/ChainSafe/as-chacha20poly1305/pull/1/files#diff-25252846b58979dcaf4e41d47b3eadd7e4f335e7fb98da6c049b1f9cd011f381R48\n        const dst = chunk.subarray(i, end - TAG_LENGTH)\n        const { plaintext: decrypted, valid } = handshake.decrypt(encrypted, handshake.session, dst)\n        if (!valid) {\n          metrics?.decryptErrors.increment()\n          throw new Error('Failed to validate decrypted chunk')\n        }\n        metrics?.decryptedPackets.increment()\n        yield decrypted\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}