{"ast":null,"code":"import { unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport { StrictSign, StrictNoSign } from '@libp2p/interface-pubsub';\nimport { PublishConfigType } from '../types.js';\n/**\n * Prepare a PublishConfig object from a PeerId.\n */\n\nexport async function getPublishConfigFromPeerId(signaturePolicy, peerId) {\n  switch (signaturePolicy) {\n    case StrictSign:\n      {\n        if (!peerId) {\n          throw Error('Must provide PeerId');\n        }\n\n        if (peerId.privateKey == null) {\n          throw Error('Cannot sign message, no private key present');\n        }\n\n        if (peerId.publicKey == null) {\n          throw Error('Cannot sign message, no public key present');\n        } // Transform privateKey once at initialization time instead of once per message\n\n\n        const privateKey = await unmarshalPrivateKey(peerId.privateKey);\n        return {\n          type: PublishConfigType.Signing,\n          author: peerId,\n          key: peerId.publicKey,\n          privateKey\n        };\n      }\n\n    case StrictNoSign:\n      return {\n        type: PublishConfigType.Anonymous\n      };\n\n    default:\n      throw new Error(`Unknown signature policy \"${signaturePolicy}\"`);\n  }\n}","map":{"version":3,"mappings":"AAAA,SAASA,mBAAT,QAAoC,qBAApC;AACA,SAASC,UAAT,EAAqBC,YAArB,QAAyC,0BAAzC;AAEA,SAAwBC,iBAAxB,QAAiD,aAAjD;AAEA;;;;AAGA,OAAO,eAAeC,0BAAf,CACLC,eADK,EAELC,MAFK,EAEU;AAEf,UAAQD,eAAR;AACE,SAAKJ,UAAL;AAAiB;AACf,YAAI,CAACK,MAAL,EAAa;AACX,gBAAMC,KAAK,CAAC,qBAAD,CAAX;AACD;;AAED,YAAID,MAAM,CAACE,UAAP,IAAqB,IAAzB,EAA+B;AAC7B,gBAAMD,KAAK,CAAC,6CAAD,CAAX;AACD;;AAED,YAAID,MAAM,CAACG,SAAP,IAAoB,IAAxB,EAA8B;AAC5B,gBAAMF,KAAK,CAAC,4CAAD,CAAX;AACD,SAXc,CAaf;;;AACA,cAAMC,UAAU,GAAG,MAAMR,mBAAmB,CAACM,MAAM,CAACE,UAAR,CAA5C;AAEA,eAAO;AACLE,cAAI,EAAEP,iBAAiB,CAACQ,OADnB;AAELC,gBAAM,EAAEN,MAFH;AAGLO,aAAG,EAAEP,MAAM,CAACG,SAHP;AAILD;AAJK,SAAP;AAMD;;AAED,SAAKN,YAAL;AACE,aAAO;AACLQ,YAAI,EAAEP,iBAAiB,CAACW;AADnB,OAAP;;AAIF;AACE,YAAM,IAAIP,KAAJ,CAAU,6BAA6BF,eAAe,GAAtD,CAAN;AA/BJ;AAiCD","names":["unmarshalPrivateKey","StrictSign","StrictNoSign","PublishConfigType","getPublishConfigFromPeerId","signaturePolicy","peerId","Error","privateKey","publicKey","type","Signing","author","key","Anonymous"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\utils\\publishConfig.ts"],"sourcesContent":["import { unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport { StrictSign, StrictNoSign } from '@libp2p/interface-pubsub'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport { PublishConfig, PublishConfigType } from '../types.js'\n\n/**\n * Prepare a PublishConfig object from a PeerId.\n */\nexport async function getPublishConfigFromPeerId(\n  signaturePolicy: typeof StrictSign | typeof StrictNoSign,\n  peerId?: PeerId\n): Promise<PublishConfig> {\n  switch (signaturePolicy) {\n    case StrictSign: {\n      if (!peerId) {\n        throw Error('Must provide PeerId')\n      }\n\n      if (peerId.privateKey == null) {\n        throw Error('Cannot sign message, no private key present')\n      }\n\n      if (peerId.publicKey == null) {\n        throw Error('Cannot sign message, no public key present')\n      }\n\n      // Transform privateKey once at initialization time instead of once per message\n      const privateKey = await unmarshalPrivateKey(peerId.privateKey)\n\n      return {\n        type: PublishConfigType.Signing,\n        author: peerId,\n        key: peerId.publicKey,\n        privateKey\n      }\n    }\n\n    case StrictNoSign:\n      return {\n        type: PublishConfigType.Anonymous\n      }\n\n    default:\n      throw new Error(`Unknown signature policy \"${signaturePolicy}\"`)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}