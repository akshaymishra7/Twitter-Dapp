{"ast":null,"code":"import errCode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { exporter } from 'ipfs-unixfs-exporter';\nimport { createNode } from './utils/create-node.js';\nimport { toPathComponents } from './utils/to-path-components.js';\nimport { updateMfsRoot } from './utils/update-mfs-root.js';\nimport { updateTree } from './utils/update-tree.js';\nimport { addLink } from './utils/add-link.js';\nimport { loadMfsRoot } from './utils/with-mfs-root.js';\nimport mergeOpts from 'merge-options';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nconst log = logger('ipfs:mfs:mkdir');\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} flush\n * @property {number} [mode]\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true\n};\n/**\n * @param {MfsContext} context\n */\n\nexport function createMkdir(context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"mkdir\"]}\n   */\n  async function mfsMkdir(path) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options);\n\n    if (!path) {\n      throw new Error('no path given to Mkdir');\n    }\n\n    path = path.trim();\n\n    if (path === '/') {\n      if (opts.parents) {\n        return;\n      }\n\n      throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH');\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n    }\n\n    log(`Creating ${path}`);\n    const pathComponents = toPathComponents(path);\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH');\n    }\n\n    const root = await loadMfsRoot(context, opts);\n    let parent;\n    const trail = [];\n    const emptyDir = await createNode(context, 'directory', opts); // make sure the containing folder exists, creating it if necessary\n\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i);\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`;\n\n      try {\n        parent = await exporter(subPath, context.repo.blocks);\n\n        if (parent.type !== 'file' && parent.type !== 'directory') {\n          throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n        }\n\n        if (i === pathComponents.length) {\n          if (opts.parents) {\n            return;\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        });\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !opts.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND');\n          } // add the intermediate directory\n\n\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);\n        } else {\n          throw err;\n        }\n      }\n    } // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n    // update the tree from the leaf to the root\n\n\n    const newRootCid = await updateTree(context, trail, opts); // Update the MFS record with the new CID for the root of the tree\n\n    await updateMfsRoot(context, newRootCid, opts);\n  }\n\n  return withTimeoutOption(mfsMkdir);\n}\n/**\n * @param {MfsContext} context\n * @param {string} childName\n * @param {{ cid: CID, node?: PBNode }} emptyDir\n * @param {{ cid?: CID, node?: PBNode }} parent\n * @param {{ name: string, cid: CID }[]} trail\n * @param {DefaultOptions} options\n */\n\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`);\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    // TODO vmx 2021-03-09: Remove the usage of size completely\n    size: 0,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  });\n  trail[trail.length - 1].cid = result.cid;\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  });\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/files/mkdir.js"],"names":["errCode","logger","exporter","createNode","toPathComponents","updateMfsRoot","updateTree","addLink","loadMfsRoot","mergeOpts","withTimeoutOption","mergeOptions","bind","ignoreUndefined","log","defaultOptions","parents","hashAlg","cidVersion","shardSplitThreshold","flush","createMkdir","context","mfsMkdir","path","options","opts","Error","trim","substring","pathComponents","root","parent","trail","emptyDir","i","length","subPathComponents","slice","subPath","join","repo","blocks","type","push","name","cid","err","code","addEmptyDir","newRootCid","childName","result","node","parentCid","size"],"mappings":"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","sourcesContent":["import errCode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { createNode } from './utils/create-node.js'\nimport { toPathComponents } from './utils/to-path-components.js'\nimport { updateMfsRoot } from './utils/update-mfs-root.js'\nimport { updateTree } from './utils/update-tree.js'\nimport { addLink } from './utils/add-link.js'\nimport { loadMfsRoot } from './utils/with-mfs-root.js'\nimport mergeOpts from 'merge-options'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('ipfs:mfs:mkdir')\n\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} flush\n * @property {number} [mode]\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createMkdir (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"mkdir\"]}\n   */\n  async function mfsMkdir (path, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options)\n\n    if (!path) {\n      throw new Error('no path given to Mkdir')\n    }\n\n    path = path.trim()\n\n    if (path === '/') {\n      if (opts.parents) {\n        return\n      }\n\n      throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n    }\n\n    log(`Creating ${path}`)\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH')\n    }\n\n    const root = await loadMfsRoot(context, opts)\n    let parent\n    const trail = []\n    const emptyDir = await createNode(context, 'directory', opts)\n\n    // make sure the containing folder exists, creating it if necessary\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i)\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`\n\n      try {\n        parent = await exporter(subPath, context.repo.blocks)\n\n        if (parent.type !== 'file' && parent.type !== 'directory') {\n          throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n        }\n\n        if (i === pathComponents.length) {\n          if (opts.parents) {\n            return\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS')\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        })\n      } catch (/** @type {any} */ err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !opts.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND')\n          }\n\n          // add the intermediate directory\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts)\n        } else {\n          throw err\n        }\n      }\n    }\n\n    // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n\n    // update the tree from the leaf to the root\n    const newRootCid = await updateTree(context, trail, opts)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts)\n  }\n\n  return withTimeoutOption(mfsMkdir)\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} childName\n * @param {{ cid: CID, node?: PBNode }} emptyDir\n * @param {{ cid?: CID, node?: PBNode }} parent\n * @param {{ name: string, cid: CID }[]} trail\n * @param {DefaultOptions} options\n */\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`)\n\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    // TODO vmx 2021-03-09: Remove the usage of size completely\n    size: 0,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  })\n\n  trail[trail.length - 1].cid = result.cid\n\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  })\n}\n"]},"metadata":{},"sourceType":"module"}