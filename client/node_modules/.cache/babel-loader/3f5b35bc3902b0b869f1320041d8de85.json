{"ast":null,"code":"import { Uint8ArrayList } from 'uint8arraylist';\nimport { unsigned } from 'uint8-varint';\nimport { allocUnsafe } from './alloc.js';\n\nconst defaultEncoder = length => {\n  const lengthLength = unsigned.encodingLength(length);\n  const lengthBuf = allocUnsafe(lengthLength);\n  unsigned.encode(length, lengthBuf);\n  defaultEncoder.bytes = lengthLength;\n  return lengthBuf;\n};\n\ndefaultEncoder.bytes = 0;\nexport function encode(options) {\n  options = options ?? {};\n  const encodeLength = options.lengthEncoder ?? defaultEncoder;\n\n  const encoder = async function* (source) {\n    for await (const chunk of source) {\n      // length + data\n      const length = encodeLength(chunk.byteLength); // yield only Uint8Arrays\n\n      if (length instanceof Uint8Array) {\n        yield length;\n      } else {\n        yield* length;\n      } // yield only Uint8Arrays\n\n\n      if (chunk instanceof Uint8Array) {\n        yield chunk;\n      } else {\n        yield* chunk;\n      }\n    }\n  };\n\n  return encoder;\n}\n\nencode.single = (chunk, options) => {\n  options = options ?? {};\n  const encodeLength = options.lengthEncoder ?? defaultEncoder;\n  return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);\n};","map":{"version":3,"mappings":"AAAA,SAASA,cAAT,QAA+B,gBAA/B;AACA,SAASC,QAAT,QAAyB,cAAzB;AAGA,SAASC,WAAT,QAA4B,YAA5B;;AAMA,MAAMC,cAAc,GAA2BC,MAAD,IAAW;AACvD,QAAMC,YAAY,GAAGJ,QAAQ,CAACK,cAAT,CAAwBF,MAAxB,CAArB;AACA,QAAMG,SAAS,GAAGL,WAAW,CAACG,YAAD,CAA7B;AAEAJ,UAAQ,CAACO,MAAT,CAAgBJ,MAAhB,EAAwBG,SAAxB;AAEAJ,gBAAc,CAACM,KAAf,GAAuBJ,YAAvB;AAEA,SAAOE,SAAP;AACD,CATD;;AAUAJ,cAAc,CAACM,KAAf,GAAuB,CAAvB;AAEA,OAAM,SAAUD,MAAV,CAAkBE,OAAlB,EAA0C;AAC9CA,SAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,QAAMC,YAAY,GAAGD,OAAO,CAACE,aAAR,IAAyBT,cAA9C;;AAEA,QAAMU,OAAO,GAAG,iBAAkBC,MAAlB,EAA6D;AAC3E,eAAW,MAAMC,KAAjB,IAA0BD,MAA1B,EAAkC;AAChC;AACA,YAAMV,MAAM,GAAGO,YAAY,CAACI,KAAK,CAACC,UAAP,CAA3B,CAFgC,CAIhC;;AACA,UAAIZ,MAAM,YAAYa,UAAtB,EAAkC;AAChC,cAAMb,MAAN;AACD,OAFD,MAEO;AACL,eAAQA,MAAR;AACD,OAT+B,CAWhC;;;AACA,UAAIW,KAAK,YAAYE,UAArB,EAAiC;AAC/B,cAAMF,KAAN;AACD,OAFD,MAEO;AACL,eAAQA,KAAR;AACD;AACF;AACF,GAnBD;;AAqBA,SAAOF,OAAP;AACD;;AAEDL,MAAM,CAACU,MAAP,GAAgB,CAACH,KAAD,EAAqCL,OAArC,KAAiE;AAC/EA,SAAO,GAAGA,OAAO,IAAI,EAArB;AACA,QAAMC,YAAY,GAAGD,OAAO,CAACE,aAAR,IAAyBT,cAA9C;AAEA,SAAO,IAAIH,cAAJ,CACLW,YAAY,CAACI,KAAK,CAACC,UAAP,CADP,EAELD,KAFK,CAAP;AAID,CARD","names":["Uint8ArrayList","unsigned","allocUnsafe","defaultEncoder","length","lengthLength","encodingLength","lengthBuf","encode","bytes","options","encodeLength","lengthEncoder","encoder","source","chunk","byteLength","Uint8Array","single"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-length-prefixed\\src\\encode.ts"],"sourcesContent":["import { Uint8ArrayList } from 'uint8arraylist'\nimport { unsigned } from 'uint8-varint'\nimport type { LengthEncoderFunction } from './index.js'\nimport type { Source, Transform } from 'it-stream-types'\nimport { allocUnsafe } from './alloc.js'\n\ninterface EncoderOptions {\n  lengthEncoder?: LengthEncoderFunction\n}\n\nconst defaultEncoder: LengthEncoderFunction = (length) => {\n  const lengthLength = unsigned.encodingLength(length)\n  const lengthBuf = allocUnsafe(lengthLength)\n\n  unsigned.encode(length, lengthBuf)\n\n  defaultEncoder.bytes = lengthLength\n\n  return lengthBuf\n}\ndefaultEncoder.bytes = 0\n\nexport function encode (options?: EncoderOptions): Transform<Uint8ArrayList | Uint8Array, Uint8Array> {\n  options = options ?? {}\n\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n\n  const encoder = async function * (source: Source<Uint8ArrayList | Uint8Array>): Source<Uint8Array> {\n    for await (const chunk of source) {\n      // length + data\n      const length = encodeLength(chunk.byteLength)\n\n      // yield only Uint8Arrays\n      if (length instanceof Uint8Array) {\n        yield length\n      } else {\n        yield * length\n      }\n\n      // yield only Uint8Arrays\n      if (chunk instanceof Uint8Array) {\n        yield chunk\n      } else {\n        yield * chunk\n      }\n    }\n  }\n\n  return encoder\n}\n\nencode.single = (chunk: Uint8ArrayList | Uint8Array, options?: EncoderOptions) => {\n  options = options ?? {}\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n\n  return new Uint8ArrayList(\n    encodeLength(chunk.byteLength),\n    chunk\n  )\n}\n"]},"metadata":{},"sourceType":"module"}