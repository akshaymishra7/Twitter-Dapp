{"ast":null,"code":"/* eslint-disable import/export */\n\n/* eslint-disable complexity */\n\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var NoiseExtensions;\n\n(function (NoiseExtensions) {\n  let _codec;\n\n  NoiseExtensions.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.webtransportCerthashes != null) {\n          for (const value of obj.webtransportCerthashes) {\n            w.uint32(10);\n            w.bytes(value);\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {\n          webtransportCerthashes: []\n        };\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.webtransportCerthashes.push(reader.bytes());\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  NoiseExtensions.encode = obj => {\n    return encodeMessage(obj, NoiseExtensions.codec());\n  };\n\n  NoiseExtensions.decode = buf => {\n    return decodeMessage(buf, NoiseExtensions.codec());\n  };\n})(NoiseExtensions || (NoiseExtensions = {}));\n\nexport var NoiseHandshakePayload;\n\n(function (NoiseHandshakePayload) {\n  let _codec;\n\n  NoiseHandshakePayload.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (opts.writeDefaults === true || obj.identityKey != null && obj.identityKey.byteLength > 0) {\n          w.uint32(10);\n          w.bytes(obj.identityKey ?? new Uint8Array(0));\n        }\n\n        if (opts.writeDefaults === true || obj.identitySig != null && obj.identitySig.byteLength > 0) {\n          w.uint32(18);\n          w.bytes(obj.identitySig ?? new Uint8Array(0));\n        }\n\n        if (obj.extensions != null) {\n          w.uint32(34);\n          NoiseExtensions.codec().encode(obj.extensions, w, {\n            writeDefaults: false\n          });\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {\n          identityKey: new Uint8Array(0),\n          identitySig: new Uint8Array(0)\n        };\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.identityKey = reader.bytes();\n              break;\n\n            case 2:\n              obj.identitySig = reader.bytes();\n              break;\n\n            case 4:\n              obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32());\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  NoiseHandshakePayload.encode = obj => {\n    return encodeMessage(obj, NoiseHandshakePayload.codec());\n  };\n\n  NoiseHandshakePayload.decode = buf => {\n    return decodeMessage(buf, NoiseHandshakePayload.codec());\n  };\n})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));","map":{"version":3,"mappings":"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","names":["encodeMessage","decodeMessage","message","NoiseExtensions","_codec","obj","w","opts","lengthDelimited","fork","webtransportCerthashes","value","uint32","bytes","ldelim","reader","length","end","len","pos","tag","push","skipType","codec","buf","NoiseHandshakePayload","writeDefaults","identityKey","byteLength","Uint8Array","identitySig","extensions","encode","decode"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-noise\\src\\proto\\payload.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface NoiseExtensions {\n  webtransportCerthashes: Uint8Array[]\n}\n\nexport namespace NoiseExtensions {\n  let _codec: Codec<NoiseExtensions>\n\n  export const codec = (): Codec<NoiseExtensions> => {\n    if (_codec == null) {\n      _codec = message<NoiseExtensions>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.webtransportCerthashes != null) {\n          for (const value of obj.webtransportCerthashes) {\n            w.uint32(10)\n            w.bytes(value)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          webtransportCerthashes: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.webtransportCerthashes.push(reader.bytes())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<NoiseExtensions>): Uint8Array => {\n    return encodeMessage(obj, NoiseExtensions.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): NoiseExtensions => {\n    return decodeMessage(buf, NoiseExtensions.codec())\n  }\n}\n\nexport interface NoiseHandshakePayload {\n  identityKey: Uint8Array\n  identitySig: Uint8Array\n  extensions?: NoiseExtensions\n}\n\nexport namespace NoiseHandshakePayload {\n  let _codec: Codec<NoiseHandshakePayload>\n\n  export const codec = (): Codec<NoiseHandshakePayload> => {\n    if (_codec == null) {\n      _codec = message<NoiseHandshakePayload>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (opts.writeDefaults === true || (obj.identityKey != null && obj.identityKey.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.identityKey ?? new Uint8Array(0))\n        }\n\n        if (opts.writeDefaults === true || (obj.identitySig != null && obj.identitySig.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.identitySig ?? new Uint8Array(0))\n        }\n\n        if (obj.extensions != null) {\n          w.uint32(34)\n          NoiseExtensions.codec().encode(obj.extensions, w, {\n            writeDefaults: false\n          })\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          identityKey: new Uint8Array(0),\n          identitySig: new Uint8Array(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.identityKey = reader.bytes()\n              break\n            case 2:\n              obj.identitySig = reader.bytes()\n              break\n            case 4:\n              obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<NoiseHandshakePayload>): Uint8Array => {\n    return encodeMessage(obj, NoiseHandshakePayload.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): NoiseHandshakePayload => {\n    return decodeMessage(buf, NoiseHandshakePayload.codec())\n  }\n}\n"]},"metadata":{},"sourceType":"module"}