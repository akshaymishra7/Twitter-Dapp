{"ast":null,"code":"'use strict';\n\nconst {\n  supports\n} = require('level-supports');\n\nconst {\n  Transcoder\n} = require('level-transcoder');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst {\n  fromCallback\n} = require('catering');\n\nconst ModuleError = require('module-error');\n\nconst {\n  AbstractIterator\n} = require('./abstract-iterator');\n\nconst {\n  DefaultKeyIterator,\n  DefaultValueIterator\n} = require('./lib/default-kv-iterator');\n\nconst {\n  DeferredIterator,\n  DeferredKeyIterator,\n  DeferredValueIterator\n} = require('./lib/deferred-iterator');\n\nconst {\n  DefaultChainedBatch\n} = require('./lib/default-chained-batch');\n\nconst {\n  getCallback,\n  getOptions\n} = require('./lib/common');\n\nconst rangeOptions = require('./lib/range-options');\n\nconst kPromise = Symbol('promise');\nconst kLanded = Symbol('landed');\nconst kResources = Symbol('resources');\nconst kCloseResources = Symbol('closeResources');\nconst kOperations = Symbol('operations');\nconst kUndefer = Symbol('undefer');\nconst kDeferOpen = Symbol('deferOpen');\nconst kOptions = Symbol('options');\nconst kStatus = Symbol('status');\nconst kDefaultOptions = Symbol('defaultOptions');\nconst kTranscoder = Symbol('transcoder');\nconst kKeyEncoding = Symbol('keyEncoding');\nconst kValueEncoding = Symbol('valueEncoding');\n\nconst noop = () => {};\n\nclass AbstractLevel extends EventEmitter {\n  constructor(manifest, options) {\n    super();\n\n    if (typeof manifest !== 'object' || manifest === null) {\n      throw new TypeError(\"The first argument 'manifest' must be an object\");\n    }\n\n    options = getOptions(options);\n    const {\n      keyEncoding,\n      valueEncoding,\n      passive,\n      ...forward\n    } = options;\n    this[kResources] = new Set();\n    this[kOperations] = [];\n    this[kDeferOpen] = true;\n    this[kOptions] = forward;\n    this[kStatus] = 'opening';\n    this.supports = supports(manifest, {\n      status: true,\n      promises: true,\n      clear: true,\n      getMany: true,\n      deferredOpen: true,\n      // TODO (next major): add seek\n      snapshots: manifest.snapshots !== false,\n      permanence: manifest.permanence !== false,\n      // TODO: remove from level-supports because it's always supported\n      keyIterator: true,\n      valueIterator: true,\n      iteratorNextv: true,\n      iteratorAll: true,\n      encodings: manifest.encodings || {},\n      events: Object.assign({}, manifest.events, {\n        opening: true,\n        open: true,\n        closing: true,\n        closed: true,\n        put: true,\n        del: true,\n        batch: true,\n        clear: true\n      })\n    });\n    this[kTranscoder] = new Transcoder(formats(this));\n    this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || 'utf8');\n    this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || 'utf8'); // Add custom and transcoder encodings to manifest\n\n    for (const encoding of this[kTranscoder].encodings()) {\n      if (!this.supports.encodings[encoding.commonName]) {\n        this.supports.encodings[encoding.commonName] = true;\n      }\n    }\n\n    this[kDefaultOptions] = {\n      empty: Object.freeze({}),\n      entry: Object.freeze({\n        keyEncoding: this[kKeyEncoding].commonName,\n        valueEncoding: this[kValueEncoding].commonName\n      }),\n      key: Object.freeze({\n        keyEncoding: this[kKeyEncoding].commonName\n      })\n    }; // Let subclass finish its constructor\n\n    this.nextTick(() => {\n      if (this[kDeferOpen]) {\n        this.open({\n          passive: false\n        }, noop);\n      }\n    });\n  }\n\n  get status() {\n    return this[kStatus];\n  }\n\n  keyEncoding(encoding) {\n    return this[kTranscoder].encoding(encoding != null ? encoding : this[kKeyEncoding]);\n  }\n\n  valueEncoding(encoding) {\n    return this[kTranscoder].encoding(encoding != null ? encoding : this[kValueEncoding]);\n  }\n\n  open(options, callback) {\n    callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = { ...this[kOptions],\n      ...getOptions(options)\n    };\n    options.createIfMissing = options.createIfMissing !== false;\n    options.errorIfExists = !!options.errorIfExists;\n\n    const maybeOpened = err => {\n      if (this[kStatus] === 'closing' || this[kStatus] === 'opening') {\n        // Wait until pending state changes are done\n        this.once(kLanded, err ? () => maybeOpened(err) : maybeOpened);\n      } else if (this[kStatus] !== 'open') {\n        callback(new ModuleError('Database is not open', {\n          code: 'LEVEL_DATABASE_NOT_OPEN',\n          cause: err\n        }));\n      } else {\n        callback();\n      }\n    };\n\n    if (options.passive) {\n      if (this[kStatus] === 'opening') {\n        this.once(kLanded, maybeOpened);\n      } else {\n        this.nextTick(maybeOpened);\n      }\n    } else if (this[kStatus] === 'closed' || this[kDeferOpen]) {\n      this[kDeferOpen] = false;\n      this[kStatus] = 'opening';\n      this.emit('opening');\n\n      this._open(options, err => {\n        if (err) {\n          this[kStatus] = 'closed'; // Resources must be safe to close in any db state\n\n          this[kCloseResources](() => {\n            this.emit(kLanded);\n            maybeOpened(err);\n          });\n          this[kUndefer]();\n          return;\n        }\n\n        this[kStatus] = 'open';\n        this[kUndefer]();\n        this.emit(kLanded); // Only emit public event if pending state changes are done\n\n        if (this[kStatus] === 'open') this.emit('open'); // TODO (next major): remove this alias\n\n        if (this[kStatus] === 'open') this.emit('ready');\n        maybeOpened();\n      });\n    } else if (this[kStatus] === 'open') {\n      this.nextTick(maybeOpened);\n    } else {\n      this.once(kLanded, () => this.open(options, callback));\n    }\n\n    return callback[kPromise];\n  }\n\n  _open(options, callback) {\n    this.nextTick(callback);\n  }\n\n  close(callback) {\n    callback = fromCallback(callback, kPromise);\n\n    const maybeClosed = err => {\n      if (this[kStatus] === 'opening' || this[kStatus] === 'closing') {\n        // Wait until pending state changes are done\n        this.once(kLanded, err ? maybeClosed(err) : maybeClosed);\n      } else if (this[kStatus] !== 'closed') {\n        callback(new ModuleError('Database is not closed', {\n          code: 'LEVEL_DATABASE_NOT_CLOSED',\n          cause: err\n        }));\n      } else {\n        callback();\n      }\n    };\n\n    if (this[kStatus] === 'open') {\n      this[kStatus] = 'closing';\n      this.emit('closing');\n\n      const cancel = err => {\n        this[kStatus] = 'open';\n        this[kUndefer]();\n        this.emit(kLanded);\n        maybeClosed(err);\n      };\n\n      this[kCloseResources](() => {\n        this._close(err => {\n          if (err) return cancel(err);\n          this[kStatus] = 'closed';\n          this[kUndefer]();\n          this.emit(kLanded); // Only emit public event if pending state changes are done\n\n          if (this[kStatus] === 'closed') this.emit('closed');\n          maybeClosed();\n        });\n      });\n    } else if (this[kStatus] === 'closed') {\n      this.nextTick(maybeClosed);\n    } else {\n      this.once(kLanded, () => this.close(callback));\n    }\n\n    return callback[kPromise];\n  }\n\n  [kCloseResources](callback) {\n    if (this[kResources].size === 0) {\n      return this.nextTick(callback);\n    }\n\n    let pending = this[kResources].size;\n    let sync = true;\n\n    const next = () => {\n      if (--pending === 0) {\n        // We don't have tests for generic resources, so dezalgo\n        if (sync) this.nextTick(callback);else callback();\n      }\n    }; // In parallel so that all resources know they are closed\n\n\n    for (const resource of this[kResources]) {\n      resource.close(next);\n    }\n\n    sync = false;\n    this[kResources].clear();\n  }\n\n  _close(callback) {\n    this.nextTick(callback);\n  }\n\n  get(key, options, callback) {\n    callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = getOptions(options, this[kDefaultOptions].entry);\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.get(key, options, callback));\n      return callback[kPromise];\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise];\n    }\n\n    const err = this._checkKey(key);\n\n    if (err) {\n      this.nextTick(callback, err);\n      return callback[kPromise];\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding);\n    const valueEncoding = this.valueEncoding(options.valueEncoding);\n    const keyFormat = keyEncoding.format;\n    const valueFormat = valueEncoding.format; // Forward encoding options to the underlying store\n\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      // Avoid spread operator because of https://bugs.chromium.org/p/chromium/issues/detail?id=1204540\n      options = Object.assign({}, options, {\n        keyEncoding: keyFormat,\n        valueEncoding: valueFormat\n      });\n    }\n\n    this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err, value) => {\n      if (err) {\n        // Normalize not found error for backwards compatibility with abstract-leveldown and level(up)\n        if (err.code === 'LEVEL_NOT_FOUND' || err.notFound || /NotFound/i.test(err)) {\n          if (!err.code) err.code = 'LEVEL_NOT_FOUND'; // Preferred way going forward\n\n          if (!err.notFound) err.notFound = true; // Same as level-errors\n\n          if (!err.status) err.status = 404; // Same as level-errors\n        }\n\n        return callback(err);\n      }\n\n      try {\n        value = valueEncoding.decode(value);\n      } catch (err) {\n        return callback(new ModuleError('Could not decode value', {\n          code: 'LEVEL_DECODE_ERROR',\n          cause: err\n        }));\n      }\n\n      callback(null, value);\n    });\n\n    return callback[kPromise];\n  }\n\n  _get(key, options, callback) {\n    this.nextTick(callback, new Error('NotFound'));\n  }\n\n  getMany(keys, options, callback) {\n    callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = getOptions(options, this[kDefaultOptions].entry);\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.getMany(keys, options, callback));\n      return callback[kPromise];\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise];\n    }\n\n    if (!Array.isArray(keys)) {\n      this.nextTick(callback, new TypeError(\"The first argument 'keys' must be an array\"));\n      return callback[kPromise];\n    }\n\n    if (keys.length === 0) {\n      this.nextTick(callback, null, []);\n      return callback[kPromise];\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding);\n    const valueEncoding = this.valueEncoding(options.valueEncoding);\n    const keyFormat = keyEncoding.format;\n    const valueFormat = valueEncoding.format; // Forward encoding options\n\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      options = Object.assign({}, options, {\n        keyEncoding: keyFormat,\n        valueEncoding: valueFormat\n      });\n    }\n\n    const mappedKeys = new Array(keys.length);\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n\n      const err = this._checkKey(key);\n\n      if (err) {\n        this.nextTick(callback, err);\n        return callback[kPromise];\n      }\n\n      mappedKeys[i] = this.prefixKey(keyEncoding.encode(key), keyFormat);\n    }\n\n    this._getMany(mappedKeys, options, (err, values) => {\n      if (err) return callback(err);\n\n      try {\n        for (let i = 0; i < values.length; i++) {\n          if (values[i] !== undefined) {\n            values[i] = valueEncoding.decode(values[i]);\n          }\n        }\n      } catch (err) {\n        return callback(new ModuleError(`Could not decode one or more of ${values.length} value(s)`, {\n          code: 'LEVEL_DECODE_ERROR',\n          cause: err\n        }));\n      }\n\n      callback(null, values);\n    });\n\n    return callback[kPromise];\n  }\n\n  _getMany(keys, options, callback) {\n    this.nextTick(callback, null, new Array(keys.length).fill(undefined));\n  }\n\n  put(key, value, options, callback) {\n    callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = getOptions(options, this[kDefaultOptions].entry);\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.put(key, value, options, callback));\n      return callback[kPromise];\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise];\n    }\n\n    const err = this._checkKey(key) || this._checkValue(value);\n\n    if (err) {\n      this.nextTick(callback, err);\n      return callback[kPromise];\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding);\n    const valueEncoding = this.valueEncoding(options.valueEncoding);\n    const keyFormat = keyEncoding.format;\n    const valueFormat = valueEncoding.format; // Forward encoding options\n\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      options = Object.assign({}, options, {\n        keyEncoding: keyFormat,\n        valueEncoding: valueFormat\n      });\n    }\n\n    const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat);\n    const mappedValue = valueEncoding.encode(value);\n\n    this._put(mappedKey, mappedValue, options, err => {\n      if (err) return callback(err);\n      this.emit('put', key, value);\n      callback();\n    });\n\n    return callback[kPromise];\n  }\n\n  _put(key, value, options, callback) {\n    this.nextTick(callback);\n  }\n\n  del(key, options, callback) {\n    callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = getOptions(options, this[kDefaultOptions].key);\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.del(key, options, callback));\n      return callback[kPromise];\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise];\n    }\n\n    const err = this._checkKey(key);\n\n    if (err) {\n      this.nextTick(callback, err);\n      return callback[kPromise];\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding);\n    const keyFormat = keyEncoding.format; // Forward encoding options\n\n    if (options.keyEncoding !== keyFormat) {\n      options = Object.assign({}, options, {\n        keyEncoding: keyFormat\n      });\n    }\n\n    this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, err => {\n      if (err) return callback(err);\n      this.emit('del', key);\n      callback();\n    });\n\n    return callback[kPromise];\n  }\n\n  _del(key, options, callback) {\n    this.nextTick(callback);\n  }\n\n  batch(operations, options, callback) {\n    if (!arguments.length) {\n      if (this[kStatus] === 'opening') return new DefaultChainedBatch(this);\n\n      if (this[kStatus] !== 'open') {\n        throw new ModuleError('Database is not open', {\n          code: 'LEVEL_DATABASE_NOT_OPEN'\n        });\n      }\n\n      return this._chainedBatch();\n    }\n\n    if (typeof operations === 'function') callback = operations;else callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = getOptions(options, this[kDefaultOptions].empty);\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.batch(operations, options, callback));\n      return callback[kPromise];\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise];\n    }\n\n    if (!Array.isArray(operations)) {\n      this.nextTick(callback, new TypeError(\"The first argument 'operations' must be an array\"));\n      return callback[kPromise];\n    }\n\n    if (operations.length === 0) {\n      this.nextTick(callback);\n      return callback[kPromise];\n    }\n\n    const mapped = new Array(operations.length);\n    const {\n      keyEncoding: ke,\n      valueEncoding: ve,\n      ...forward\n    } = options;\n\n    for (let i = 0; i < operations.length; i++) {\n      if (typeof operations[i] !== 'object' || operations[i] === null) {\n        this.nextTick(callback, new TypeError('A batch operation must be an object'));\n        return callback[kPromise];\n      }\n\n      const op = Object.assign({}, operations[i]);\n\n      if (op.type !== 'put' && op.type !== 'del') {\n        this.nextTick(callback, new TypeError(\"A batch operation must have a type property that is 'put' or 'del'\"));\n        return callback[kPromise];\n      }\n\n      const err = this._checkKey(op.key);\n\n      if (err) {\n        this.nextTick(callback, err);\n        return callback[kPromise];\n      }\n\n      const db = op.sublevel != null ? op.sublevel : this;\n      const keyEncoding = db.keyEncoding(op.keyEncoding || ke);\n      const keyFormat = keyEncoding.format;\n      op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat);\n      op.keyEncoding = keyFormat;\n\n      if (op.type === 'put') {\n        const valueErr = this._checkValue(op.value);\n\n        if (valueErr) {\n          this.nextTick(callback, valueErr);\n          return callback[kPromise];\n        }\n\n        const valueEncoding = db.valueEncoding(op.valueEncoding || ve);\n        op.value = valueEncoding.encode(op.value);\n        op.valueEncoding = valueEncoding.format;\n      } // Prevent double prefixing\n\n\n      if (db !== this) {\n        op.sublevel = null;\n      }\n\n      mapped[i] = op;\n    }\n\n    this._batch(mapped, forward, err => {\n      if (err) return callback(err);\n      this.emit('batch', operations);\n      callback();\n    });\n\n    return callback[kPromise];\n  }\n\n  _batch(operations, options, callback) {\n    this.nextTick(callback);\n  }\n\n  sublevel(name, options) {\n    return this._sublevel(name, AbstractSublevel.defaults(options));\n  }\n\n  _sublevel(name, options) {\n    return new AbstractSublevel(this, name, options);\n  }\n\n  prefixKey(key, keyFormat) {\n    return key;\n  }\n\n  clear(options, callback) {\n    callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = getOptions(options, this[kDefaultOptions].empty);\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.clear(options, callback));\n      return callback[kPromise];\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise];\n    }\n\n    const original = options;\n    const keyEncoding = this.keyEncoding(options.keyEncoding);\n    options = rangeOptions(options, keyEncoding);\n    options.keyEncoding = keyEncoding.format;\n\n    if (options.limit === 0) {\n      this.nextTick(callback);\n    } else {\n      this._clear(options, err => {\n        if (err) return callback(err);\n        this.emit('clear', original);\n        callback();\n      });\n    }\n\n    return callback[kPromise];\n  }\n\n  _clear(options, callback) {\n    this.nextTick(callback);\n  }\n\n  iterator(options) {\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding);\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding);\n    options = rangeOptions(options, keyEncoding);\n    options.keys = options.keys !== false;\n    options.values = options.values !== false; // We need the original encoding options in AbstractIterator in order to decode data\n\n    options[AbstractIterator.keyEncoding] = keyEncoding;\n    options[AbstractIterator.valueEncoding] = valueEncoding; // Forward encoding options to private API\n\n    options.keyEncoding = keyEncoding.format;\n    options.valueEncoding = valueEncoding.format;\n\n    if (this[kStatus] === 'opening') {\n      return new DeferredIterator(this, options);\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      });\n    }\n\n    return this._iterator(options);\n  }\n\n  _iterator(options) {\n    return new AbstractIterator(this, options);\n  }\n\n  keys(options) {\n    // Also include valueEncoding (though unused) because we may fallback to _iterator()\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding);\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding);\n    options = rangeOptions(options, keyEncoding); // We need the original encoding options in AbstractKeyIterator in order to decode data\n\n    options[AbstractIterator.keyEncoding] = keyEncoding;\n    options[AbstractIterator.valueEncoding] = valueEncoding; // Forward encoding options to private API\n\n    options.keyEncoding = keyEncoding.format;\n    options.valueEncoding = valueEncoding.format;\n\n    if (this[kStatus] === 'opening') {\n      return new DeferredKeyIterator(this, options);\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      });\n    }\n\n    return this._keys(options);\n  }\n\n  _keys(options) {\n    return new DefaultKeyIterator(this, options);\n  }\n\n  values(options) {\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding);\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding);\n    options = rangeOptions(options, keyEncoding); // We need the original encoding options in AbstractValueIterator in order to decode data\n\n    options[AbstractIterator.keyEncoding] = keyEncoding;\n    options[AbstractIterator.valueEncoding] = valueEncoding; // Forward encoding options to private API\n\n    options.keyEncoding = keyEncoding.format;\n    options.valueEncoding = valueEncoding.format;\n\n    if (this[kStatus] === 'opening') {\n      return new DeferredValueIterator(this, options);\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      });\n    }\n\n    return this._values(options);\n  }\n\n  _values(options) {\n    return new DefaultValueIterator(this, options);\n  }\n\n  defer(fn) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('The first argument must be a function');\n    }\n\n    this[kOperations].push(fn);\n  }\n\n  [kUndefer]() {\n    if (this[kOperations].length === 0) {\n      return;\n    }\n\n    const operations = this[kOperations];\n    this[kOperations] = [];\n\n    for (const op of operations) {\n      op();\n    }\n  } // TODO: docs and types\n\n\n  attachResource(resource) {\n    if (typeof resource !== 'object' || resource === null || typeof resource.close !== 'function') {\n      throw new TypeError('The first argument must be a resource object');\n    }\n\n    this[kResources].add(resource);\n  } // TODO: docs and types\n\n\n  detachResource(resource) {\n    this[kResources].delete(resource);\n  }\n\n  _chainedBatch() {\n    return new DefaultChainedBatch(this);\n  }\n\n  _checkKey(key) {\n    if (key === null || key === undefined) {\n      return new ModuleError('Key cannot be null or undefined', {\n        code: 'LEVEL_INVALID_KEY'\n      });\n    }\n  }\n\n  _checkValue(value) {\n    if (value === null || value === undefined) {\n      return new ModuleError('Value cannot be null or undefined', {\n        code: 'LEVEL_INVALID_VALUE'\n      });\n    }\n  }\n\n} // Expose browser-compatible nextTick for dependents\n// TODO: after we drop node 10, also use queueMicrotask in node\n\n\nAbstractLevel.prototype.nextTick = require('./lib/next-tick');\n\nconst {\n  AbstractSublevel\n} = require('./lib/abstract-sublevel')({\n  AbstractLevel\n});\n\nexports.AbstractLevel = AbstractLevel;\nexports.AbstractSublevel = AbstractSublevel;\n\nconst maybeError = function (db, callback) {\n  if (db[kStatus] !== 'open') {\n    db.nextTick(callback, new ModuleError('Database is not open', {\n      code: 'LEVEL_DATABASE_NOT_OPEN'\n    }));\n    return true;\n  }\n\n  return false;\n};\n\nconst formats = function (db) {\n  return Object.keys(db.supports.encodings).filter(k => !!db.supports.encodings[k]);\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/abstract-level/abstract-level.js"],"names":["supports","require","Transcoder","EventEmitter","fromCallback","ModuleError","AbstractIterator","DefaultKeyIterator","DefaultValueIterator","DeferredIterator","DeferredKeyIterator","DeferredValueIterator","DefaultChainedBatch","getCallback","getOptions","rangeOptions","kPromise","Symbol","kLanded","kResources","kCloseResources","kOperations","kUndefer","kDeferOpen","kOptions","kStatus","kDefaultOptions","kTranscoder","kKeyEncoding","kValueEncoding","noop","AbstractLevel","constructor","manifest","options","TypeError","keyEncoding","valueEncoding","passive","forward","Set","status","promises","clear","getMany","deferredOpen","snapshots","permanence","keyIterator","valueIterator","iteratorNextv","iteratorAll","encodings","events","Object","assign","opening","open","closing","closed","put","del","batch","formats","encoding","commonName","empty","freeze","entry","key","nextTick","callback","createIfMissing","errorIfExists","maybeOpened","err","once","code","cause","emit","_open","close","maybeClosed","cancel","_close","size","pending","sync","next","resource","get","defer","maybeError","_checkKey","keyFormat","format","valueFormat","_get","prefixKey","encode","value","notFound","test","decode","Error","keys","Array","isArray","length","mappedKeys","i","_getMany","values","undefined","fill","_checkValue","mappedKey","mappedValue","_put","_del","operations","arguments","_chainedBatch","mapped","ke","ve","op","type","db","sublevel","valueErr","_batch","name","_sublevel","AbstractSublevel","defaults","original","limit","_clear","iterator","_iterator","_keys","_values","fn","push","attachResource","add","detachResource","delete","prototype","exports","filter","k"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAeC,OAAO,CAAC,gBAAD,CAA5B;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAiBD,OAAO,CAAC,kBAAD,CAA9B;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAmBF,OAAO,CAAC,QAAD,CAAhC;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAmBH,OAAO,CAAC,UAAD,CAAhC;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,cAAD,CAA3B;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAuBL,OAAO,CAAC,qBAAD,CAApC;;AACA,MAAM;AAAEM,EAAAA,kBAAF;AAAsBC,EAAAA;AAAtB,IAA+CP,OAAO,CAAC,2BAAD,CAA5D;;AACA,MAAM;AAAEQ,EAAAA,gBAAF;AAAoBC,EAAAA,mBAApB;AAAyCC,EAAAA;AAAzC,IAAmEV,OAAO,CAAC,yBAAD,CAAhF;;AACA,MAAM;AAAEW,EAAAA;AAAF,IAA0BX,OAAO,CAAC,6BAAD,CAAvC;;AACA,MAAM;AAAEY,EAAAA,WAAF;AAAeC,EAAAA;AAAf,IAA8Bb,OAAO,CAAC,cAAD,CAA3C;;AACA,MAAMc,YAAY,GAAGd,OAAO,CAAC,qBAAD,CAA5B;;AAEA,MAAMe,QAAQ,GAAGC,MAAM,CAAC,SAAD,CAAvB;AACA,MAAMC,OAAO,GAAGD,MAAM,CAAC,QAAD,CAAtB;AACA,MAAME,UAAU,GAAGF,MAAM,CAAC,WAAD,CAAzB;AACA,MAAMG,eAAe,GAAGH,MAAM,CAAC,gBAAD,CAA9B;AACA,MAAMI,WAAW,GAAGJ,MAAM,CAAC,YAAD,CAA1B;AACA,MAAMK,QAAQ,GAAGL,MAAM,CAAC,SAAD,CAAvB;AACA,MAAMM,UAAU,GAAGN,MAAM,CAAC,WAAD,CAAzB;AACA,MAAMO,QAAQ,GAAGP,MAAM,CAAC,SAAD,CAAvB;AACA,MAAMQ,OAAO,GAAGR,MAAM,CAAC,QAAD,CAAtB;AACA,MAAMS,eAAe,GAAGT,MAAM,CAAC,gBAAD,CAA9B;AACA,MAAMU,WAAW,GAAGV,MAAM,CAAC,YAAD,CAA1B;AACA,MAAMW,YAAY,GAAGX,MAAM,CAAC,aAAD,CAA3B;AACA,MAAMY,cAAc,GAAGZ,MAAM,CAAC,eAAD,CAA7B;;AACA,MAAMa,IAAI,GAAG,MAAM,CAAE,CAArB;;AAEA,MAAMC,aAAN,SAA4B5B,YAA5B,CAAyC;AACvC6B,EAAAA,WAAW,CAAEC,QAAF,EAAYC,OAAZ,EAAqB;AAC9B;;AAEA,QAAI,OAAOD,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAAjD,EAAuD;AACrD,YAAM,IAAIE,SAAJ,CAAc,iDAAd,CAAN;AACD;;AAEDD,IAAAA,OAAO,GAAGpB,UAAU,CAACoB,OAAD,CAApB;AACA,UAAM;AAAEE,MAAAA,WAAF;AAAeC,MAAAA,aAAf;AAA8BC,MAAAA,OAA9B;AAAuC,SAAGC;AAA1C,QAAsDL,OAA5D;AAEA,SAAKf,UAAL,IAAmB,IAAIqB,GAAJ,EAAnB;AACA,SAAKnB,WAAL,IAAoB,EAApB;AACA,SAAKE,UAAL,IAAmB,IAAnB;AACA,SAAKC,QAAL,IAAiBe,OAAjB;AACA,SAAKd,OAAL,IAAgB,SAAhB;AAEA,SAAKzB,QAAL,GAAgBA,QAAQ,CAACiC,QAAD,EAAW;AACjCQ,MAAAA,MAAM,EAAE,IADyB;AAEjCC,MAAAA,QAAQ,EAAE,IAFuB;AAGjCC,MAAAA,KAAK,EAAE,IAH0B;AAIjCC,MAAAA,OAAO,EAAE,IAJwB;AAKjCC,MAAAA,YAAY,EAAE,IALmB;AAOjC;AACAC,MAAAA,SAAS,EAAEb,QAAQ,CAACa,SAAT,KAAuB,KARD;AASjCC,MAAAA,UAAU,EAAEd,QAAQ,CAACc,UAAT,KAAwB,KATH;AAWjC;AACAC,MAAAA,WAAW,EAAE,IAZoB;AAajCC,MAAAA,aAAa,EAAE,IAbkB;AAcjCC,MAAAA,aAAa,EAAE,IAdkB;AAejCC,MAAAA,WAAW,EAAE,IAfoB;AAiBjCC,MAAAA,SAAS,EAAEnB,QAAQ,CAACmB,SAAT,IAAsB,EAjBA;AAkBjCC,MAAAA,MAAM,EAAEC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBtB,QAAQ,CAACoB,MAA3B,EAAmC;AACzCG,QAAAA,OAAO,EAAE,IADgC;AAEzCC,QAAAA,IAAI,EAAE,IAFmC;AAGzCC,QAAAA,OAAO,EAAE,IAHgC;AAIzCC,QAAAA,MAAM,EAAE,IAJiC;AAKzCC,QAAAA,GAAG,EAAE,IALoC;AAMzCC,QAAAA,GAAG,EAAE,IANoC;AAOzCC,QAAAA,KAAK,EAAE,IAPkC;AAQzCnB,QAAAA,KAAK,EAAE;AARkC,OAAnC;AAlByB,KAAX,CAAxB;AA8BA,SAAKhB,WAAL,IAAoB,IAAIzB,UAAJ,CAAe6D,OAAO,CAAC,IAAD,CAAtB,CAApB;AACA,SAAKnC,YAAL,IAAqB,KAAKD,WAAL,EAAkBqC,QAAlB,CAA2B5B,WAAW,IAAI,MAA1C,CAArB;AACA,SAAKP,cAAL,IAAuB,KAAKF,WAAL,EAAkBqC,QAAlB,CAA2B3B,aAAa,IAAI,MAA5C,CAAvB,CAhD8B,CAkD9B;;AACA,SAAK,MAAM2B,QAAX,IAAuB,KAAKrC,WAAL,EAAkByB,SAAlB,EAAvB,EAAsD;AACpD,UAAI,CAAC,KAAKpD,QAAL,CAAcoD,SAAd,CAAwBY,QAAQ,CAACC,UAAjC,CAAL,EAAmD;AACjD,aAAKjE,QAAL,CAAcoD,SAAd,CAAwBY,QAAQ,CAACC,UAAjC,IAA+C,IAA/C;AACD;AACF;;AAED,SAAKvC,eAAL,IAAwB;AACtBwC,MAAAA,KAAK,EAAEZ,MAAM,CAACa,MAAP,CAAc,EAAd,CADe;AAEtBC,MAAAA,KAAK,EAAEd,MAAM,CAACa,MAAP,CAAc;AACnB/B,QAAAA,WAAW,EAAE,KAAKR,YAAL,EAAmBqC,UADb;AAEnB5B,QAAAA,aAAa,EAAE,KAAKR,cAAL,EAAqBoC;AAFjB,OAAd,CAFe;AAMtBI,MAAAA,GAAG,EAAEf,MAAM,CAACa,MAAP,CAAc;AACjB/B,QAAAA,WAAW,EAAE,KAAKR,YAAL,EAAmBqC;AADf,OAAd;AANiB,KAAxB,CAzD8B,CAoE9B;;AACA,SAAKK,QAAL,CAAc,MAAM;AAClB,UAAI,KAAK/C,UAAL,CAAJ,EAAsB;AACpB,aAAKkC,IAAL,CAAU;AAAEnB,UAAAA,OAAO,EAAE;AAAX,SAAV,EAA8BR,IAA9B;AACD;AACF,KAJD;AAKD;;AAES,MAANW,MAAM,GAAI;AACZ,WAAO,KAAKhB,OAAL,CAAP;AACD;;AAEDW,EAAAA,WAAW,CAAE4B,QAAF,EAAY;AACrB,WAAO,KAAKrC,WAAL,EAAkBqC,QAAlB,CAA2BA,QAAQ,IAAI,IAAZ,GAAmBA,QAAnB,GAA8B,KAAKpC,YAAL,CAAzD,CAAP;AACD;;AAEDS,EAAAA,aAAa,CAAE2B,QAAF,EAAY;AACvB,WAAO,KAAKrC,WAAL,EAAkBqC,QAAlB,CAA2BA,QAAQ,IAAI,IAAZ,GAAmBA,QAAnB,GAA8B,KAAKnC,cAAL,CAAzD,CAAP;AACD;;AAED4B,EAAAA,IAAI,CAAEvB,OAAF,EAAWqC,QAAX,EAAqB;AACvBA,IAAAA,QAAQ,GAAG1D,WAAW,CAACqB,OAAD,EAAUqC,QAAV,CAAtB;AACAA,IAAAA,QAAQ,GAAGnE,YAAY,CAACmE,QAAD,EAAWvD,QAAX,CAAvB;AAEAkB,IAAAA,OAAO,GAAG,EAAE,GAAG,KAAKV,QAAL,CAAL;AAAqB,SAAGV,UAAU,CAACoB,OAAD;AAAlC,KAAV;AAEAA,IAAAA,OAAO,CAACsC,eAAR,GAA0BtC,OAAO,CAACsC,eAAR,KAA4B,KAAtD;AACAtC,IAAAA,OAAO,CAACuC,aAAR,GAAwB,CAAC,CAACvC,OAAO,CAACuC,aAAlC;;AAEA,UAAMC,WAAW,GAAIC,GAAD,IAAS;AAC3B,UAAI,KAAKlD,OAAL,MAAkB,SAAlB,IAA+B,KAAKA,OAAL,MAAkB,SAArD,EAAgE;AAC9D;AACA,aAAKmD,IAAL,CAAU1D,OAAV,EAAmByD,GAAG,GAAG,MAAMD,WAAW,CAACC,GAAD,CAApB,GAA4BD,WAAlD;AACD,OAHD,MAGO,IAAI,KAAKjD,OAAL,MAAkB,MAAtB,EAA8B;AACnC8C,QAAAA,QAAQ,CAAC,IAAIlE,WAAJ,CAAgB,sBAAhB,EAAwC;AAC/CwE,UAAAA,IAAI,EAAE,yBADyC;AAE/CC,UAAAA,KAAK,EAAEH;AAFwC,SAAxC,CAAD,CAAR;AAID,OALM,MAKA;AACLJ,QAAAA,QAAQ;AACT;AACF,KAZD;;AAcA,QAAIrC,OAAO,CAACI,OAAZ,EAAqB;AACnB,UAAI,KAAKb,OAAL,MAAkB,SAAtB,EAAiC;AAC/B,aAAKmD,IAAL,CAAU1D,OAAV,EAAmBwD,WAAnB;AACD,OAFD,MAEO;AACL,aAAKJ,QAAL,CAAcI,WAAd;AACD;AACF,KAND,MAMO,IAAI,KAAKjD,OAAL,MAAkB,QAAlB,IAA8B,KAAKF,UAAL,CAAlC,EAAoD;AACzD,WAAKA,UAAL,IAAmB,KAAnB;AACA,WAAKE,OAAL,IAAgB,SAAhB;AACA,WAAKsD,IAAL,CAAU,SAAV;;AAEA,WAAKC,KAAL,CAAW9C,OAAX,EAAqByC,GAAD,IAAS;AAC3B,YAAIA,GAAJ,EAAS;AACP,eAAKlD,OAAL,IAAgB,QAAhB,CADO,CAGP;;AACA,eAAKL,eAAL,EAAsB,MAAM;AAC1B,iBAAK2D,IAAL,CAAU7D,OAAV;AACAwD,YAAAA,WAAW,CAACC,GAAD,CAAX;AACD,WAHD;AAKA,eAAKrD,QAAL;AACA;AACD;;AAED,aAAKG,OAAL,IAAgB,MAAhB;AACA,aAAKH,QAAL;AACA,aAAKyD,IAAL,CAAU7D,OAAV,EAhB2B,CAkB3B;;AACA,YAAI,KAAKO,OAAL,MAAkB,MAAtB,EAA8B,KAAKsD,IAAL,CAAU,MAAV,EAnBH,CAqB3B;;AACA,YAAI,KAAKtD,OAAL,MAAkB,MAAtB,EAA8B,KAAKsD,IAAL,CAAU,OAAV;AAE9BL,QAAAA,WAAW;AACZ,OAzBD;AA0BD,KA/BM,MA+BA,IAAI,KAAKjD,OAAL,MAAkB,MAAtB,EAA8B;AACnC,WAAK6C,QAAL,CAAcI,WAAd;AACD,KAFM,MAEA;AACL,WAAKE,IAAL,CAAU1D,OAAV,EAAmB,MAAM,KAAKuC,IAAL,CAAUvB,OAAV,EAAmBqC,QAAnB,CAAzB;AACD;;AAED,WAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAEDgE,EAAAA,KAAK,CAAE9C,OAAF,EAAWqC,QAAX,EAAqB;AACxB,SAAKD,QAAL,CAAcC,QAAd;AACD;;AAEDU,EAAAA,KAAK,CAAEV,QAAF,EAAY;AACfA,IAAAA,QAAQ,GAAGnE,YAAY,CAACmE,QAAD,EAAWvD,QAAX,CAAvB;;AAEA,UAAMkE,WAAW,GAAIP,GAAD,IAAS;AAC3B,UAAI,KAAKlD,OAAL,MAAkB,SAAlB,IAA+B,KAAKA,OAAL,MAAkB,SAArD,EAAgE;AAC9D;AACA,aAAKmD,IAAL,CAAU1D,OAAV,EAAmByD,GAAG,GAAGO,WAAW,CAACP,GAAD,CAAd,GAAsBO,WAA5C;AACD,OAHD,MAGO,IAAI,KAAKzD,OAAL,MAAkB,QAAtB,EAAgC;AACrC8C,QAAAA,QAAQ,CAAC,IAAIlE,WAAJ,CAAgB,wBAAhB,EAA0C;AACjDwE,UAAAA,IAAI,EAAE,2BAD2C;AAEjDC,UAAAA,KAAK,EAAEH;AAF0C,SAA1C,CAAD,CAAR;AAID,OALM,MAKA;AACLJ,QAAAA,QAAQ;AACT;AACF,KAZD;;AAcA,QAAI,KAAK9C,OAAL,MAAkB,MAAtB,EAA8B;AAC5B,WAAKA,OAAL,IAAgB,SAAhB;AACA,WAAKsD,IAAL,CAAU,SAAV;;AAEA,YAAMI,MAAM,GAAIR,GAAD,IAAS;AACtB,aAAKlD,OAAL,IAAgB,MAAhB;AACA,aAAKH,QAAL;AACA,aAAKyD,IAAL,CAAU7D,OAAV;AACAgE,QAAAA,WAAW,CAACP,GAAD,CAAX;AACD,OALD;;AAOA,WAAKvD,eAAL,EAAsB,MAAM;AAC1B,aAAKgE,MAAL,CAAaT,GAAD,IAAS;AACnB,cAAIA,GAAJ,EAAS,OAAOQ,MAAM,CAACR,GAAD,CAAb;AAET,eAAKlD,OAAL,IAAgB,QAAhB;AACA,eAAKH,QAAL;AACA,eAAKyD,IAAL,CAAU7D,OAAV,EALmB,CAOnB;;AACA,cAAI,KAAKO,OAAL,MAAkB,QAAtB,EAAgC,KAAKsD,IAAL,CAAU,QAAV;AAEhCG,UAAAA,WAAW;AACZ,SAXD;AAYD,OAbD;AAcD,KAzBD,MAyBO,IAAI,KAAKzD,OAAL,MAAkB,QAAtB,EAAgC;AACrC,WAAK6C,QAAL,CAAcY,WAAd;AACD,KAFM,MAEA;AACL,WAAKN,IAAL,CAAU1D,OAAV,EAAmB,MAAM,KAAK+D,KAAL,CAAWV,QAAX,CAAzB;AACD;;AAED,WAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAEe,GAAfI,eAAe,EAAGmD,QAAH,EAAa;AAC3B,QAAI,KAAKpD,UAAL,EAAiBkE,IAAjB,KAA0B,CAA9B,EAAiC;AAC/B,aAAO,KAAKf,QAAL,CAAcC,QAAd,CAAP;AACD;;AAED,QAAIe,OAAO,GAAG,KAAKnE,UAAL,EAAiBkE,IAA/B;AACA,QAAIE,IAAI,GAAG,IAAX;;AAEA,UAAMC,IAAI,GAAG,MAAM;AACjB,UAAI,EAAEF,OAAF,KAAc,CAAlB,EAAqB;AACnB;AACA,YAAIC,IAAJ,EAAU,KAAKjB,QAAL,CAAcC,QAAd,EAAV,KACKA,QAAQ;AACd;AACF,KAND,CAR2B,CAgB3B;;;AACA,SAAK,MAAMkB,QAAX,IAAuB,KAAKtE,UAAL,CAAvB,EAAyC;AACvCsE,MAAAA,QAAQ,CAACR,KAAT,CAAeO,IAAf;AACD;;AAEDD,IAAAA,IAAI,GAAG,KAAP;AACA,SAAKpE,UAAL,EAAiBwB,KAAjB;AACD;;AAEDyC,EAAAA,MAAM,CAAEb,QAAF,EAAY;AAChB,SAAKD,QAAL,CAAcC,QAAd;AACD;;AAEDmB,EAAAA,GAAG,CAAErB,GAAF,EAAOnC,OAAP,EAAgBqC,QAAhB,EAA0B;AAC3BA,IAAAA,QAAQ,GAAG1D,WAAW,CAACqB,OAAD,EAAUqC,QAAV,CAAtB;AACAA,IAAAA,QAAQ,GAAGnE,YAAY,CAACmE,QAAD,EAAWvD,QAAX,CAAvB;AACAkB,IAAAA,OAAO,GAAGpB,UAAU,CAACoB,OAAD,EAAU,KAAKR,eAAL,EAAsB0C,KAAhC,CAApB;;AAEA,QAAI,KAAK3C,OAAL,MAAkB,SAAtB,EAAiC;AAC/B,WAAKkE,KAAL,CAAW,MAAM,KAAKD,GAAL,CAASrB,GAAT,EAAcnC,OAAd,EAAuBqC,QAAvB,CAAjB;AACA,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,QAAI4E,UAAU,CAAC,IAAD,EAAOrB,QAAP,CAAd,EAAgC;AAC9B,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,UAAM2D,GAAG,GAAG,KAAKkB,SAAL,CAAexB,GAAf,CAAZ;;AAEA,QAAIM,GAAJ,EAAS;AACP,WAAKL,QAAL,CAAcC,QAAd,EAAwBI,GAAxB;AACA,aAAOJ,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,UAAMoB,WAAW,GAAG,KAAKA,WAAL,CAAiBF,OAAO,CAACE,WAAzB,CAApB;AACA,UAAMC,aAAa,GAAG,KAAKA,aAAL,CAAmBH,OAAO,CAACG,aAA3B,CAAtB;AACA,UAAMyD,SAAS,GAAG1D,WAAW,CAAC2D,MAA9B;AACA,UAAMC,WAAW,GAAG3D,aAAa,CAAC0D,MAAlC,CAxB2B,CA0B3B;;AACA,QAAI7D,OAAO,CAACE,WAAR,KAAwB0D,SAAxB,IAAqC5D,OAAO,CAACG,aAAR,KAA0B2D,WAAnE,EAAgF;AAC9E;AACA9D,MAAAA,OAAO,GAAGoB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBrB,OAAlB,EAA2B;AAAEE,QAAAA,WAAW,EAAE0D,SAAf;AAA0BzD,QAAAA,aAAa,EAAE2D;AAAzC,OAA3B,CAAV;AACD;;AAED,SAAKC,IAAL,CAAU,KAAKC,SAAL,CAAe9D,WAAW,CAAC+D,MAAZ,CAAmB9B,GAAnB,CAAf,EAAwCyB,SAAxC,CAAV,EAA8D5D,OAA9D,EAAuE,CAACyC,GAAD,EAAMyB,KAAN,KAAgB;AACrF,UAAIzB,GAAJ,EAAS;AACP;AACA,YAAIA,GAAG,CAACE,IAAJ,KAAa,iBAAb,IAAkCF,GAAG,CAAC0B,QAAtC,IAAkD,YAAYC,IAAZ,CAAiB3B,GAAjB,CAAtD,EAA6E;AAC3E,cAAI,CAACA,GAAG,CAACE,IAAT,EAAeF,GAAG,CAACE,IAAJ,GAAW,iBAAX,CAD4D,CAC/B;;AAC5C,cAAI,CAACF,GAAG,CAAC0B,QAAT,EAAmB1B,GAAG,CAAC0B,QAAJ,GAAe,IAAf,CAFwD,CAEpC;;AACvC,cAAI,CAAC1B,GAAG,CAAClC,MAAT,EAAiBkC,GAAG,CAAClC,MAAJ,GAAa,GAAb,CAH0D,CAGzC;AACnC;;AAED,eAAO8B,QAAQ,CAACI,GAAD,CAAf;AACD;;AAED,UAAI;AACFyB,QAAAA,KAAK,GAAG/D,aAAa,CAACkE,MAAd,CAAqBH,KAArB,CAAR;AACD,OAFD,CAEE,OAAOzB,GAAP,EAAY;AACZ,eAAOJ,QAAQ,CAAC,IAAIlE,WAAJ,CAAgB,wBAAhB,EAA0C;AACxDwE,UAAAA,IAAI,EAAE,oBADkD;AAExDC,UAAAA,KAAK,EAAEH;AAFiD,SAA1C,CAAD,CAAf;AAID;;AAEDJ,MAAAA,QAAQ,CAAC,IAAD,EAAO6B,KAAP,CAAR;AACD,KAtBD;;AAwBA,WAAO7B,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAEDiF,EAAAA,IAAI,CAAE5B,GAAF,EAAOnC,OAAP,EAAgBqC,QAAhB,EAA0B;AAC5B,SAAKD,QAAL,CAAcC,QAAd,EAAwB,IAAIiC,KAAJ,CAAU,UAAV,CAAxB;AACD;;AAED5D,EAAAA,OAAO,CAAE6D,IAAF,EAAQvE,OAAR,EAAiBqC,QAAjB,EAA2B;AAChCA,IAAAA,QAAQ,GAAG1D,WAAW,CAACqB,OAAD,EAAUqC,QAAV,CAAtB;AACAA,IAAAA,QAAQ,GAAGnE,YAAY,CAACmE,QAAD,EAAWvD,QAAX,CAAvB;AACAkB,IAAAA,OAAO,GAAGpB,UAAU,CAACoB,OAAD,EAAU,KAAKR,eAAL,EAAsB0C,KAAhC,CAApB;;AAEA,QAAI,KAAK3C,OAAL,MAAkB,SAAtB,EAAiC;AAC/B,WAAKkE,KAAL,CAAW,MAAM,KAAK/C,OAAL,CAAa6D,IAAb,EAAmBvE,OAAnB,EAA4BqC,QAA5B,CAAjB;AACA,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,QAAI4E,UAAU,CAAC,IAAD,EAAOrB,QAAP,CAAd,EAAgC;AAC9B,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,QAAI,CAAC0F,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAL,EAA0B;AACxB,WAAKnC,QAAL,CAAcC,QAAd,EAAwB,IAAIpC,SAAJ,CAAc,4CAAd,CAAxB;AACA,aAAOoC,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,QAAIyF,IAAI,CAACG,MAAL,KAAgB,CAApB,EAAuB;AACrB,WAAKtC,QAAL,CAAcC,QAAd,EAAwB,IAAxB,EAA8B,EAA9B;AACA,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,UAAMoB,WAAW,GAAG,KAAKA,WAAL,CAAiBF,OAAO,CAACE,WAAzB,CAApB;AACA,UAAMC,aAAa,GAAG,KAAKA,aAAL,CAAmBH,OAAO,CAACG,aAA3B,CAAtB;AACA,UAAMyD,SAAS,GAAG1D,WAAW,CAAC2D,MAA9B;AACA,UAAMC,WAAW,GAAG3D,aAAa,CAAC0D,MAAlC,CA3BgC,CA6BhC;;AACA,QAAI7D,OAAO,CAACE,WAAR,KAAwB0D,SAAxB,IAAqC5D,OAAO,CAACG,aAAR,KAA0B2D,WAAnE,EAAgF;AAC9E9D,MAAAA,OAAO,GAAGoB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBrB,OAAlB,EAA2B;AAAEE,QAAAA,WAAW,EAAE0D,SAAf;AAA0BzD,QAAAA,aAAa,EAAE2D;AAAzC,OAA3B,CAAV;AACD;;AAED,UAAMa,UAAU,GAAG,IAAIH,KAAJ,CAAUD,IAAI,CAACG,MAAf,CAAnB;;AAEA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,IAAI,CAACG,MAAzB,EAAiCE,CAAC,EAAlC,EAAsC;AACpC,YAAMzC,GAAG,GAAGoC,IAAI,CAACK,CAAD,CAAhB;;AACA,YAAMnC,GAAG,GAAG,KAAKkB,SAAL,CAAexB,GAAf,CAAZ;;AAEA,UAAIM,GAAJ,EAAS;AACP,aAAKL,QAAL,CAAcC,QAAd,EAAwBI,GAAxB;AACA,eAAOJ,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED6F,MAAAA,UAAU,CAACC,CAAD,CAAV,GAAgB,KAAKZ,SAAL,CAAe9D,WAAW,CAAC+D,MAAZ,CAAmB9B,GAAnB,CAAf,EAAwCyB,SAAxC,CAAhB;AACD;;AAED,SAAKiB,QAAL,CAAcF,UAAd,EAA0B3E,OAA1B,EAAmC,CAACyC,GAAD,EAAMqC,MAAN,KAAiB;AAClD,UAAIrC,GAAJ,EAAS,OAAOJ,QAAQ,CAACI,GAAD,CAAf;;AAET,UAAI;AACF,aAAK,IAAImC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGE,MAAM,CAACJ,MAA3B,EAAmCE,CAAC,EAApC,EAAwC;AACtC,cAAIE,MAAM,CAACF,CAAD,CAAN,KAAcG,SAAlB,EAA6B;AAC3BD,YAAAA,MAAM,CAACF,CAAD,CAAN,GAAYzE,aAAa,CAACkE,MAAd,CAAqBS,MAAM,CAACF,CAAD,CAA3B,CAAZ;AACD;AACF;AACF,OAND,CAME,OAAOnC,GAAP,EAAY;AACZ,eAAOJ,QAAQ,CAAC,IAAIlE,WAAJ,CAAiB,mCAAkC2G,MAAM,CAACJ,MAAO,WAAjE,EAA6E;AAC3F/B,UAAAA,IAAI,EAAE,oBADqF;AAE3FC,UAAAA,KAAK,EAAEH;AAFoF,SAA7E,CAAD,CAAf;AAID;;AAEDJ,MAAAA,QAAQ,CAAC,IAAD,EAAOyC,MAAP,CAAR;AACD,KAjBD;;AAmBA,WAAOzC,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED+F,EAAAA,QAAQ,CAAEN,IAAF,EAAQvE,OAAR,EAAiBqC,QAAjB,EAA2B;AACjC,SAAKD,QAAL,CAAcC,QAAd,EAAwB,IAAxB,EAA8B,IAAImC,KAAJ,CAAUD,IAAI,CAACG,MAAf,EAAuBM,IAAvB,CAA4BD,SAA5B,CAA9B;AACD;;AAEDrD,EAAAA,GAAG,CAAES,GAAF,EAAO+B,KAAP,EAAclE,OAAd,EAAuBqC,QAAvB,EAAiC;AAClCA,IAAAA,QAAQ,GAAG1D,WAAW,CAACqB,OAAD,EAAUqC,QAAV,CAAtB;AACAA,IAAAA,QAAQ,GAAGnE,YAAY,CAACmE,QAAD,EAAWvD,QAAX,CAAvB;AACAkB,IAAAA,OAAO,GAAGpB,UAAU,CAACoB,OAAD,EAAU,KAAKR,eAAL,EAAsB0C,KAAhC,CAApB;;AAEA,QAAI,KAAK3C,OAAL,MAAkB,SAAtB,EAAiC;AAC/B,WAAKkE,KAAL,CAAW,MAAM,KAAK/B,GAAL,CAASS,GAAT,EAAc+B,KAAd,EAAqBlE,OAArB,EAA8BqC,QAA9B,CAAjB;AACA,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,QAAI4E,UAAU,CAAC,IAAD,EAAOrB,QAAP,CAAd,EAAgC;AAC9B,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,UAAM2D,GAAG,GAAG,KAAKkB,SAAL,CAAexB,GAAf,KAAuB,KAAK8C,WAAL,CAAiBf,KAAjB,CAAnC;;AAEA,QAAIzB,GAAJ,EAAS;AACP,WAAKL,QAAL,CAAcC,QAAd,EAAwBI,GAAxB;AACA,aAAOJ,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,UAAMoB,WAAW,GAAG,KAAKA,WAAL,CAAiBF,OAAO,CAACE,WAAzB,CAApB;AACA,UAAMC,aAAa,GAAG,KAAKA,aAAL,CAAmBH,OAAO,CAACG,aAA3B,CAAtB;AACA,UAAMyD,SAAS,GAAG1D,WAAW,CAAC2D,MAA9B;AACA,UAAMC,WAAW,GAAG3D,aAAa,CAAC0D,MAAlC,CAxBkC,CA0BlC;;AACA,QAAI7D,OAAO,CAACE,WAAR,KAAwB0D,SAAxB,IAAqC5D,OAAO,CAACG,aAAR,KAA0B2D,WAAnE,EAAgF;AAC9E9D,MAAAA,OAAO,GAAGoB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBrB,OAAlB,EAA2B;AAAEE,QAAAA,WAAW,EAAE0D,SAAf;AAA0BzD,QAAAA,aAAa,EAAE2D;AAAzC,OAA3B,CAAV;AACD;;AAED,UAAMoB,SAAS,GAAG,KAAKlB,SAAL,CAAe9D,WAAW,CAAC+D,MAAZ,CAAmB9B,GAAnB,CAAf,EAAwCyB,SAAxC,CAAlB;AACA,UAAMuB,WAAW,GAAGhF,aAAa,CAAC8D,MAAd,CAAqBC,KAArB,CAApB;;AAEA,SAAKkB,IAAL,CAAUF,SAAV,EAAqBC,WAArB,EAAkCnF,OAAlC,EAA4CyC,GAAD,IAAS;AAClD,UAAIA,GAAJ,EAAS,OAAOJ,QAAQ,CAACI,GAAD,CAAf;AACT,WAAKI,IAAL,CAAU,KAAV,EAAiBV,GAAjB,EAAsB+B,KAAtB;AACA7B,MAAAA,QAAQ;AACT,KAJD;;AAMA,WAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAEDsG,EAAAA,IAAI,CAAEjD,GAAF,EAAO+B,KAAP,EAAclE,OAAd,EAAuBqC,QAAvB,EAAiC;AACnC,SAAKD,QAAL,CAAcC,QAAd;AACD;;AAEDV,EAAAA,GAAG,CAAEQ,GAAF,EAAOnC,OAAP,EAAgBqC,QAAhB,EAA0B;AAC3BA,IAAAA,QAAQ,GAAG1D,WAAW,CAACqB,OAAD,EAAUqC,QAAV,CAAtB;AACAA,IAAAA,QAAQ,GAAGnE,YAAY,CAACmE,QAAD,EAAWvD,QAAX,CAAvB;AACAkB,IAAAA,OAAO,GAAGpB,UAAU,CAACoB,OAAD,EAAU,KAAKR,eAAL,EAAsB2C,GAAhC,CAApB;;AAEA,QAAI,KAAK5C,OAAL,MAAkB,SAAtB,EAAiC;AAC/B,WAAKkE,KAAL,CAAW,MAAM,KAAK9B,GAAL,CAASQ,GAAT,EAAcnC,OAAd,EAAuBqC,QAAvB,CAAjB;AACA,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,QAAI4E,UAAU,CAAC,IAAD,EAAOrB,QAAP,CAAd,EAAgC;AAC9B,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,UAAM2D,GAAG,GAAG,KAAKkB,SAAL,CAAexB,GAAf,CAAZ;;AAEA,QAAIM,GAAJ,EAAS;AACP,WAAKL,QAAL,CAAcC,QAAd,EAAwBI,GAAxB;AACA,aAAOJ,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,UAAMoB,WAAW,GAAG,KAAKA,WAAL,CAAiBF,OAAO,CAACE,WAAzB,CAApB;AACA,UAAM0D,SAAS,GAAG1D,WAAW,CAAC2D,MAA9B,CAtB2B,CAwB3B;;AACA,QAAI7D,OAAO,CAACE,WAAR,KAAwB0D,SAA5B,EAAuC;AACrC5D,MAAAA,OAAO,GAAGoB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBrB,OAAlB,EAA2B;AAAEE,QAAAA,WAAW,EAAE0D;AAAf,OAA3B,CAAV;AACD;;AAED,SAAKyB,IAAL,CAAU,KAAKrB,SAAL,CAAe9D,WAAW,CAAC+D,MAAZ,CAAmB9B,GAAnB,CAAf,EAAwCyB,SAAxC,CAAV,EAA8D5D,OAA9D,EAAwEyC,GAAD,IAAS;AAC9E,UAAIA,GAAJ,EAAS,OAAOJ,QAAQ,CAACI,GAAD,CAAf;AACT,WAAKI,IAAL,CAAU,KAAV,EAAiBV,GAAjB;AACAE,MAAAA,QAAQ;AACT,KAJD;;AAMA,WAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAEDuG,EAAAA,IAAI,CAAElD,GAAF,EAAOnC,OAAP,EAAgBqC,QAAhB,EAA0B;AAC5B,SAAKD,QAAL,CAAcC,QAAd;AACD;;AAEDT,EAAAA,KAAK,CAAE0D,UAAF,EAActF,OAAd,EAAuBqC,QAAvB,EAAiC;AACpC,QAAI,CAACkD,SAAS,CAACb,MAAf,EAAuB;AACrB,UAAI,KAAKnF,OAAL,MAAkB,SAAtB,EAAiC,OAAO,IAAIb,mBAAJ,CAAwB,IAAxB,CAAP;;AACjC,UAAI,KAAKa,OAAL,MAAkB,MAAtB,EAA8B;AAC5B,cAAM,IAAIpB,WAAJ,CAAgB,sBAAhB,EAAwC;AAC5CwE,UAAAA,IAAI,EAAE;AADsC,SAAxC,CAAN;AAGD;;AACD,aAAO,KAAK6C,aAAL,EAAP;AACD;;AAED,QAAI,OAAOF,UAAP,KAAsB,UAA1B,EAAsCjD,QAAQ,GAAGiD,UAAX,CAAtC,KACKjD,QAAQ,GAAG1D,WAAW,CAACqB,OAAD,EAAUqC,QAAV,CAAtB;AAELA,IAAAA,QAAQ,GAAGnE,YAAY,CAACmE,QAAD,EAAWvD,QAAX,CAAvB;AACAkB,IAAAA,OAAO,GAAGpB,UAAU,CAACoB,OAAD,EAAU,KAAKR,eAAL,EAAsBwC,KAAhC,CAApB;;AAEA,QAAI,KAAKzC,OAAL,MAAkB,SAAtB,EAAiC;AAC/B,WAAKkE,KAAL,CAAW,MAAM,KAAK7B,KAAL,CAAW0D,UAAX,EAAuBtF,OAAvB,EAAgCqC,QAAhC,CAAjB;AACA,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,QAAI4E,UAAU,CAAC,IAAD,EAAOrB,QAAP,CAAd,EAAgC;AAC9B,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,QAAI,CAAC0F,KAAK,CAACC,OAAN,CAAca,UAAd,CAAL,EAAgC;AAC9B,WAAKlD,QAAL,CAAcC,QAAd,EAAwB,IAAIpC,SAAJ,CAAc,kDAAd,CAAxB;AACA,aAAOoC,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,QAAIwG,UAAU,CAACZ,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,WAAKtC,QAAL,CAAcC,QAAd;AACA,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,UAAM2G,MAAM,GAAG,IAAIjB,KAAJ,CAAUc,UAAU,CAACZ,MAArB,CAAf;AACA,UAAM;AAAExE,MAAAA,WAAW,EAAEwF,EAAf;AAAmBvF,MAAAA,aAAa,EAAEwF,EAAlC;AAAsC,SAAGtF;AAAzC,QAAqDL,OAA3D;;AAEA,SAAK,IAAI4E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,UAAU,CAACZ,MAA/B,EAAuCE,CAAC,EAAxC,EAA4C;AAC1C,UAAI,OAAOU,UAAU,CAACV,CAAD,CAAjB,KAAyB,QAAzB,IAAqCU,UAAU,CAACV,CAAD,CAAV,KAAkB,IAA3D,EAAiE;AAC/D,aAAKxC,QAAL,CAAcC,QAAd,EAAwB,IAAIpC,SAAJ,CAAc,qCAAd,CAAxB;AACA,eAAOoC,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,YAAM8G,EAAE,GAAGxE,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBiE,UAAU,CAACV,CAAD,CAA5B,CAAX;;AAEA,UAAIgB,EAAE,CAACC,IAAH,KAAY,KAAZ,IAAqBD,EAAE,CAACC,IAAH,KAAY,KAArC,EAA4C;AAC1C,aAAKzD,QAAL,CAAcC,QAAd,EAAwB,IAAIpC,SAAJ,CAAc,oEAAd,CAAxB;AACA,eAAOoC,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,YAAM2D,GAAG,GAAG,KAAKkB,SAAL,CAAeiC,EAAE,CAACzD,GAAlB,CAAZ;;AAEA,UAAIM,GAAJ,EAAS;AACP,aAAKL,QAAL,CAAcC,QAAd,EAAwBI,GAAxB;AACA,eAAOJ,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,YAAMgH,EAAE,GAAGF,EAAE,CAACG,QAAH,IAAe,IAAf,GAAsBH,EAAE,CAACG,QAAzB,GAAoC,IAA/C;AACA,YAAM7F,WAAW,GAAG4F,EAAE,CAAC5F,WAAH,CAAe0F,EAAE,CAAC1F,WAAH,IAAkBwF,EAAjC,CAApB;AACA,YAAM9B,SAAS,GAAG1D,WAAW,CAAC2D,MAA9B;AAEA+B,MAAAA,EAAE,CAACzD,GAAH,GAAS2D,EAAE,CAAC9B,SAAH,CAAa9D,WAAW,CAAC+D,MAAZ,CAAmB2B,EAAE,CAACzD,GAAtB,CAAb,EAAyCyB,SAAzC,CAAT;AACAgC,MAAAA,EAAE,CAAC1F,WAAH,GAAiB0D,SAAjB;;AAEA,UAAIgC,EAAE,CAACC,IAAH,KAAY,KAAhB,EAAuB;AACrB,cAAMG,QAAQ,GAAG,KAAKf,WAAL,CAAiBW,EAAE,CAAC1B,KAApB,CAAjB;;AAEA,YAAI8B,QAAJ,EAAc;AACZ,eAAK5D,QAAL,CAAcC,QAAd,EAAwB2D,QAAxB;AACA,iBAAO3D,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,cAAMqB,aAAa,GAAG2F,EAAE,CAAC3F,aAAH,CAAiByF,EAAE,CAACzF,aAAH,IAAoBwF,EAArC,CAAtB;AAEAC,QAAAA,EAAE,CAAC1B,KAAH,GAAW/D,aAAa,CAAC8D,MAAd,CAAqB2B,EAAE,CAAC1B,KAAxB,CAAX;AACA0B,QAAAA,EAAE,CAACzF,aAAH,GAAmBA,aAAa,CAAC0D,MAAjC;AACD,OAvCyC,CAyC1C;;;AACA,UAAIiC,EAAE,KAAK,IAAX,EAAiB;AACfF,QAAAA,EAAE,CAACG,QAAH,GAAc,IAAd;AACD;;AAEDN,MAAAA,MAAM,CAACb,CAAD,CAAN,GAAYgB,EAAZ;AACD;;AAED,SAAKK,MAAL,CAAYR,MAAZ,EAAoBpF,OAApB,EAA8BoC,GAAD,IAAS;AACpC,UAAIA,GAAJ,EAAS,OAAOJ,QAAQ,CAACI,GAAD,CAAf;AACT,WAAKI,IAAL,CAAU,OAAV,EAAmByC,UAAnB;AACAjD,MAAAA,QAAQ;AACT,KAJD;;AAMA,WAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAEDmH,EAAAA,MAAM,CAAEX,UAAF,EAActF,OAAd,EAAuBqC,QAAvB,EAAiC;AACrC,SAAKD,QAAL,CAAcC,QAAd;AACD;;AAED0D,EAAAA,QAAQ,CAAEG,IAAF,EAAQlG,OAAR,EAAiB;AACvB,WAAO,KAAKmG,SAAL,CAAeD,IAAf,EAAqBE,gBAAgB,CAACC,QAAjB,CAA0BrG,OAA1B,CAArB,CAAP;AACD;;AAEDmG,EAAAA,SAAS,CAAED,IAAF,EAAQlG,OAAR,EAAiB;AACxB,WAAO,IAAIoG,gBAAJ,CAAqB,IAArB,EAA2BF,IAA3B,EAAiClG,OAAjC,CAAP;AACD;;AAEDgE,EAAAA,SAAS,CAAE7B,GAAF,EAAOyB,SAAP,EAAkB;AACzB,WAAOzB,GAAP;AACD;;AAED1B,EAAAA,KAAK,CAAET,OAAF,EAAWqC,QAAX,EAAqB;AACxBA,IAAAA,QAAQ,GAAG1D,WAAW,CAACqB,OAAD,EAAUqC,QAAV,CAAtB;AACAA,IAAAA,QAAQ,GAAGnE,YAAY,CAACmE,QAAD,EAAWvD,QAAX,CAAvB;AACAkB,IAAAA,OAAO,GAAGpB,UAAU,CAACoB,OAAD,EAAU,KAAKR,eAAL,EAAsBwC,KAAhC,CAApB;;AAEA,QAAI,KAAKzC,OAAL,MAAkB,SAAtB,EAAiC;AAC/B,WAAKkE,KAAL,CAAW,MAAM,KAAKhD,KAAL,CAAWT,OAAX,EAAoBqC,QAApB,CAAjB;AACA,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,QAAI4E,UAAU,CAAC,IAAD,EAAOrB,QAAP,CAAd,EAAgC;AAC9B,aAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED,UAAMwH,QAAQ,GAAGtG,OAAjB;AACA,UAAME,WAAW,GAAG,KAAKA,WAAL,CAAiBF,OAAO,CAACE,WAAzB,CAApB;AAEAF,IAAAA,OAAO,GAAGnB,YAAY,CAACmB,OAAD,EAAUE,WAAV,CAAtB;AACAF,IAAAA,OAAO,CAACE,WAAR,GAAsBA,WAAW,CAAC2D,MAAlC;;AAEA,QAAI7D,OAAO,CAACuG,KAAR,KAAkB,CAAtB,EAAyB;AACvB,WAAKnE,QAAL,CAAcC,QAAd;AACD,KAFD,MAEO;AACL,WAAKmE,MAAL,CAAYxG,OAAZ,EAAsByC,GAAD,IAAS;AAC5B,YAAIA,GAAJ,EAAS,OAAOJ,QAAQ,CAACI,GAAD,CAAf;AACT,aAAKI,IAAL,CAAU,OAAV,EAAmByD,QAAnB;AACAjE,QAAAA,QAAQ;AACT,OAJD;AAKD;;AAED,WAAOA,QAAQ,CAACvD,QAAD,CAAf;AACD;;AAED0H,EAAAA,MAAM,CAAExG,OAAF,EAAWqC,QAAX,EAAqB;AACzB,SAAKD,QAAL,CAAcC,QAAd;AACD;;AAEDoE,EAAAA,QAAQ,CAAEzG,OAAF,EAAW;AACjB,UAAME,WAAW,GAAG,KAAKA,WAAL,CAAiBF,OAAO,IAAIA,OAAO,CAACE,WAApC,CAApB;AACA,UAAMC,aAAa,GAAG,KAAKA,aAAL,CAAmBH,OAAO,IAAIA,OAAO,CAACG,aAAtC,CAAtB;AAEAH,IAAAA,OAAO,GAAGnB,YAAY,CAACmB,OAAD,EAAUE,WAAV,CAAtB;AACAF,IAAAA,OAAO,CAACuE,IAAR,GAAevE,OAAO,CAACuE,IAAR,KAAiB,KAAhC;AACAvE,IAAAA,OAAO,CAAC8E,MAAR,GAAiB9E,OAAO,CAAC8E,MAAR,KAAmB,KAApC,CANiB,CAQjB;;AACA9E,IAAAA,OAAO,CAAC5B,gBAAgB,CAAC8B,WAAlB,CAAP,GAAwCA,WAAxC;AACAF,IAAAA,OAAO,CAAC5B,gBAAgB,CAAC+B,aAAlB,CAAP,GAA0CA,aAA1C,CAViB,CAYjB;;AACAH,IAAAA,OAAO,CAACE,WAAR,GAAsBA,WAAW,CAAC2D,MAAlC;AACA7D,IAAAA,OAAO,CAACG,aAAR,GAAwBA,aAAa,CAAC0D,MAAtC;;AAEA,QAAI,KAAKtE,OAAL,MAAkB,SAAtB,EAAiC;AAC/B,aAAO,IAAIhB,gBAAJ,CAAqB,IAArB,EAA2ByB,OAA3B,CAAP;AACD,KAFD,MAEO,IAAI,KAAKT,OAAL,MAAkB,MAAtB,EAA8B;AACnC,YAAM,IAAIpB,WAAJ,CAAgB,sBAAhB,EAAwC;AAC5CwE,QAAAA,IAAI,EAAE;AADsC,OAAxC,CAAN;AAGD;;AAED,WAAO,KAAK+D,SAAL,CAAe1G,OAAf,CAAP;AACD;;AAED0G,EAAAA,SAAS,CAAE1G,OAAF,EAAW;AAClB,WAAO,IAAI5B,gBAAJ,CAAqB,IAArB,EAA2B4B,OAA3B,CAAP;AACD;;AAEDuE,EAAAA,IAAI,CAAEvE,OAAF,EAAW;AACb;AACA,UAAME,WAAW,GAAG,KAAKA,WAAL,CAAiBF,OAAO,IAAIA,OAAO,CAACE,WAApC,CAApB;AACA,UAAMC,aAAa,GAAG,KAAKA,aAAL,CAAmBH,OAAO,IAAIA,OAAO,CAACG,aAAtC,CAAtB;AAEAH,IAAAA,OAAO,GAAGnB,YAAY,CAACmB,OAAD,EAAUE,WAAV,CAAtB,CALa,CAOb;;AACAF,IAAAA,OAAO,CAAC5B,gBAAgB,CAAC8B,WAAlB,CAAP,GAAwCA,WAAxC;AACAF,IAAAA,OAAO,CAAC5B,gBAAgB,CAAC+B,aAAlB,CAAP,GAA0CA,aAA1C,CATa,CAWb;;AACAH,IAAAA,OAAO,CAACE,WAAR,GAAsBA,WAAW,CAAC2D,MAAlC;AACA7D,IAAAA,OAAO,CAACG,aAAR,GAAwBA,aAAa,CAAC0D,MAAtC;;AAEA,QAAI,KAAKtE,OAAL,MAAkB,SAAtB,EAAiC;AAC/B,aAAO,IAAIf,mBAAJ,CAAwB,IAAxB,EAA8BwB,OAA9B,CAAP;AACD,KAFD,MAEO,IAAI,KAAKT,OAAL,MAAkB,MAAtB,EAA8B;AACnC,YAAM,IAAIpB,WAAJ,CAAgB,sBAAhB,EAAwC;AAC5CwE,QAAAA,IAAI,EAAE;AADsC,OAAxC,CAAN;AAGD;;AAED,WAAO,KAAKgE,KAAL,CAAW3G,OAAX,CAAP;AACD;;AAED2G,EAAAA,KAAK,CAAE3G,OAAF,EAAW;AACd,WAAO,IAAI3B,kBAAJ,CAAuB,IAAvB,EAA6B2B,OAA7B,CAAP;AACD;;AAED8E,EAAAA,MAAM,CAAE9E,OAAF,EAAW;AACf,UAAME,WAAW,GAAG,KAAKA,WAAL,CAAiBF,OAAO,IAAIA,OAAO,CAACE,WAApC,CAApB;AACA,UAAMC,aAAa,GAAG,KAAKA,aAAL,CAAmBH,OAAO,IAAIA,OAAO,CAACG,aAAtC,CAAtB;AAEAH,IAAAA,OAAO,GAAGnB,YAAY,CAACmB,OAAD,EAAUE,WAAV,CAAtB,CAJe,CAMf;;AACAF,IAAAA,OAAO,CAAC5B,gBAAgB,CAAC8B,WAAlB,CAAP,GAAwCA,WAAxC;AACAF,IAAAA,OAAO,CAAC5B,gBAAgB,CAAC+B,aAAlB,CAAP,GAA0CA,aAA1C,CARe,CAUf;;AACAH,IAAAA,OAAO,CAACE,WAAR,GAAsBA,WAAW,CAAC2D,MAAlC;AACA7D,IAAAA,OAAO,CAACG,aAAR,GAAwBA,aAAa,CAAC0D,MAAtC;;AAEA,QAAI,KAAKtE,OAAL,MAAkB,SAAtB,EAAiC;AAC/B,aAAO,IAAId,qBAAJ,CAA0B,IAA1B,EAAgCuB,OAAhC,CAAP;AACD,KAFD,MAEO,IAAI,KAAKT,OAAL,MAAkB,MAAtB,EAA8B;AACnC,YAAM,IAAIpB,WAAJ,CAAgB,sBAAhB,EAAwC;AAC5CwE,QAAAA,IAAI,EAAE;AADsC,OAAxC,CAAN;AAGD;;AAED,WAAO,KAAKiE,OAAL,CAAa5G,OAAb,CAAP;AACD;;AAED4G,EAAAA,OAAO,CAAE5G,OAAF,EAAW;AAChB,WAAO,IAAI1B,oBAAJ,CAAyB,IAAzB,EAA+B0B,OAA/B,CAAP;AACD;;AAEDyD,EAAAA,KAAK,CAAEoD,EAAF,EAAM;AACT,QAAI,OAAOA,EAAP,KAAc,UAAlB,EAA8B;AAC5B,YAAM,IAAI5G,SAAJ,CAAc,uCAAd,CAAN;AACD;;AAED,SAAKd,WAAL,EAAkB2H,IAAlB,CAAuBD,EAAvB;AACD;;AAEQ,GAARzH,QAAQ,IAAK;AACZ,QAAI,KAAKD,WAAL,EAAkBuF,MAAlB,KAA6B,CAAjC,EAAoC;AAClC;AACD;;AAED,UAAMY,UAAU,GAAG,KAAKnG,WAAL,CAAnB;AACA,SAAKA,WAAL,IAAoB,EAApB;;AAEA,SAAK,MAAMyG,EAAX,IAAiBN,UAAjB,EAA6B;AAC3BM,MAAAA,EAAE;AACH;AACF,GAvtBsC,CAytBvC;;;AACAmB,EAAAA,cAAc,CAAExD,QAAF,EAAY;AACxB,QAAI,OAAOA,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAA7C,IACF,OAAOA,QAAQ,CAACR,KAAhB,KAA0B,UAD5B,EACwC;AACtC,YAAM,IAAI9C,SAAJ,CAAc,8CAAd,CAAN;AACD;;AAED,SAAKhB,UAAL,EAAiB+H,GAAjB,CAAqBzD,QAArB;AACD,GAjuBsC,CAmuBvC;;;AACA0D,EAAAA,cAAc,CAAE1D,QAAF,EAAY;AACxB,SAAKtE,UAAL,EAAiBiI,MAAjB,CAAwB3D,QAAxB;AACD;;AAEDiC,EAAAA,aAAa,GAAI;AACf,WAAO,IAAI9G,mBAAJ,CAAwB,IAAxB,CAAP;AACD;;AAEDiF,EAAAA,SAAS,CAAExB,GAAF,EAAO;AACd,QAAIA,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAK4C,SAA5B,EAAuC;AACrC,aAAO,IAAI5G,WAAJ,CAAgB,iCAAhB,EAAmD;AACxDwE,QAAAA,IAAI,EAAE;AADkD,OAAnD,CAAP;AAGD;AACF;;AAEDsC,EAAAA,WAAW,CAAEf,KAAF,EAAS;AAClB,QAAIA,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKa,SAAhC,EAA2C;AACzC,aAAO,IAAI5G,WAAJ,CAAgB,mCAAhB,EAAqD;AAC1DwE,QAAAA,IAAI,EAAE;AADoD,OAArD,CAAP;AAGD;AACF;;AA1vBsC,C,CA6vBzC;AACA;;;AACA9C,aAAa,CAACsH,SAAd,CAAwB/E,QAAxB,GAAmCrE,OAAO,CAAC,iBAAD,CAA1C;;AAEA,MAAM;AAAEqI,EAAAA;AAAF,IAAuBrI,OAAO,CAAC,yBAAD,CAAP,CAAmC;AAAE8B,EAAAA;AAAF,CAAnC,CAA7B;;AAEAuH,OAAO,CAACvH,aAAR,GAAwBA,aAAxB;AACAuH,OAAO,CAAChB,gBAAR,GAA2BA,gBAA3B;;AAEA,MAAM1C,UAAU,GAAG,UAAUoC,EAAV,EAAczD,QAAd,EAAwB;AACzC,MAAIyD,EAAE,CAACvG,OAAD,CAAF,KAAgB,MAApB,EAA4B;AAC1BuG,IAAAA,EAAE,CAAC1D,QAAH,CAAYC,QAAZ,EAAsB,IAAIlE,WAAJ,CAAgB,sBAAhB,EAAwC;AAC5DwE,MAAAA,IAAI,EAAE;AADsD,KAAxC,CAAtB;AAGA,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD,CATD;;AAWA,MAAMd,OAAO,GAAG,UAAUiE,EAAV,EAAc;AAC5B,SAAO1E,MAAM,CAACmD,IAAP,CAAYuB,EAAE,CAAChI,QAAH,CAAYoD,SAAxB,EACJmG,MADI,CACGC,CAAC,IAAI,CAAC,CAACxB,EAAE,CAAChI,QAAH,CAAYoD,SAAZ,CAAsBoG,CAAtB,CADV,CAAP;AAED,CAHD","sourcesContent":["'use strict'\n\nconst { supports } = require('level-supports')\nconst { Transcoder } = require('level-transcoder')\nconst { EventEmitter } = require('events')\nconst { fromCallback } = require('catering')\nconst ModuleError = require('module-error')\nconst { AbstractIterator } = require('./abstract-iterator')\nconst { DefaultKeyIterator, DefaultValueIterator } = require('./lib/default-kv-iterator')\nconst { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = require('./lib/deferred-iterator')\nconst { DefaultChainedBatch } = require('./lib/default-chained-batch')\nconst { getCallback, getOptions } = require('./lib/common')\nconst rangeOptions = require('./lib/range-options')\n\nconst kPromise = Symbol('promise')\nconst kLanded = Symbol('landed')\nconst kResources = Symbol('resources')\nconst kCloseResources = Symbol('closeResources')\nconst kOperations = Symbol('operations')\nconst kUndefer = Symbol('undefer')\nconst kDeferOpen = Symbol('deferOpen')\nconst kOptions = Symbol('options')\nconst kStatus = Symbol('status')\nconst kDefaultOptions = Symbol('defaultOptions')\nconst kTranscoder = Symbol('transcoder')\nconst kKeyEncoding = Symbol('keyEncoding')\nconst kValueEncoding = Symbol('valueEncoding')\nconst noop = () => {}\n\nclass AbstractLevel extends EventEmitter {\n  constructor (manifest, options) {\n    super()\n\n    if (typeof manifest !== 'object' || manifest === null) {\n      throw new TypeError(\"The first argument 'manifest' must be an object\")\n    }\n\n    options = getOptions(options)\n    const { keyEncoding, valueEncoding, passive, ...forward } = options\n\n    this[kResources] = new Set()\n    this[kOperations] = []\n    this[kDeferOpen] = true\n    this[kOptions] = forward\n    this[kStatus] = 'opening'\n\n    this.supports = supports(manifest, {\n      status: true,\n      promises: true,\n      clear: true,\n      getMany: true,\n      deferredOpen: true,\n\n      // TODO (next major): add seek\n      snapshots: manifest.snapshots !== false,\n      permanence: manifest.permanence !== false,\n\n      // TODO: remove from level-supports because it's always supported\n      keyIterator: true,\n      valueIterator: true,\n      iteratorNextv: true,\n      iteratorAll: true,\n\n      encodings: manifest.encodings || {},\n      events: Object.assign({}, manifest.events, {\n        opening: true,\n        open: true,\n        closing: true,\n        closed: true,\n        put: true,\n        del: true,\n        batch: true,\n        clear: true\n      })\n    })\n\n    this[kTranscoder] = new Transcoder(formats(this))\n    this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || 'utf8')\n    this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || 'utf8')\n\n    // Add custom and transcoder encodings to manifest\n    for (const encoding of this[kTranscoder].encodings()) {\n      if (!this.supports.encodings[encoding.commonName]) {\n        this.supports.encodings[encoding.commonName] = true\n      }\n    }\n\n    this[kDefaultOptions] = {\n      empty: Object.freeze({}),\n      entry: Object.freeze({\n        keyEncoding: this[kKeyEncoding].commonName,\n        valueEncoding: this[kValueEncoding].commonName\n      }),\n      key: Object.freeze({\n        keyEncoding: this[kKeyEncoding].commonName\n      })\n    }\n\n    // Let subclass finish its constructor\n    this.nextTick(() => {\n      if (this[kDeferOpen]) {\n        this.open({ passive: false }, noop)\n      }\n    })\n  }\n\n  get status () {\n    return this[kStatus]\n  }\n\n  keyEncoding (encoding) {\n    return this[kTranscoder].encoding(encoding != null ? encoding : this[kKeyEncoding])\n  }\n\n  valueEncoding (encoding) {\n    return this[kTranscoder].encoding(encoding != null ? encoding : this[kValueEncoding])\n  }\n\n  open (options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n\n    options = { ...this[kOptions], ...getOptions(options) }\n\n    options.createIfMissing = options.createIfMissing !== false\n    options.errorIfExists = !!options.errorIfExists\n\n    const maybeOpened = (err) => {\n      if (this[kStatus] === 'closing' || this[kStatus] === 'opening') {\n        // Wait until pending state changes are done\n        this.once(kLanded, err ? () => maybeOpened(err) : maybeOpened)\n      } else if (this[kStatus] !== 'open') {\n        callback(new ModuleError('Database is not open', {\n          code: 'LEVEL_DATABASE_NOT_OPEN',\n          cause: err\n        }))\n      } else {\n        callback()\n      }\n    }\n\n    if (options.passive) {\n      if (this[kStatus] === 'opening') {\n        this.once(kLanded, maybeOpened)\n      } else {\n        this.nextTick(maybeOpened)\n      }\n    } else if (this[kStatus] === 'closed' || this[kDeferOpen]) {\n      this[kDeferOpen] = false\n      this[kStatus] = 'opening'\n      this.emit('opening')\n\n      this._open(options, (err) => {\n        if (err) {\n          this[kStatus] = 'closed'\n\n          // Resources must be safe to close in any db state\n          this[kCloseResources](() => {\n            this.emit(kLanded)\n            maybeOpened(err)\n          })\n\n          this[kUndefer]()\n          return\n        }\n\n        this[kStatus] = 'open'\n        this[kUndefer]()\n        this.emit(kLanded)\n\n        // Only emit public event if pending state changes are done\n        if (this[kStatus] === 'open') this.emit('open')\n\n        // TODO (next major): remove this alias\n        if (this[kStatus] === 'open') this.emit('ready')\n\n        maybeOpened()\n      })\n    } else if (this[kStatus] === 'open') {\n      this.nextTick(maybeOpened)\n    } else {\n      this.once(kLanded, () => this.open(options, callback))\n    }\n\n    return callback[kPromise]\n  }\n\n  _open (options, callback) {\n    this.nextTick(callback)\n  }\n\n  close (callback) {\n    callback = fromCallback(callback, kPromise)\n\n    const maybeClosed = (err) => {\n      if (this[kStatus] === 'opening' || this[kStatus] === 'closing') {\n        // Wait until pending state changes are done\n        this.once(kLanded, err ? maybeClosed(err) : maybeClosed)\n      } else if (this[kStatus] !== 'closed') {\n        callback(new ModuleError('Database is not closed', {\n          code: 'LEVEL_DATABASE_NOT_CLOSED',\n          cause: err\n        }))\n      } else {\n        callback()\n      }\n    }\n\n    if (this[kStatus] === 'open') {\n      this[kStatus] = 'closing'\n      this.emit('closing')\n\n      const cancel = (err) => {\n        this[kStatus] = 'open'\n        this[kUndefer]()\n        this.emit(kLanded)\n        maybeClosed(err)\n      }\n\n      this[kCloseResources](() => {\n        this._close((err) => {\n          if (err) return cancel(err)\n\n          this[kStatus] = 'closed'\n          this[kUndefer]()\n          this.emit(kLanded)\n\n          // Only emit public event if pending state changes are done\n          if (this[kStatus] === 'closed') this.emit('closed')\n\n          maybeClosed()\n        })\n      })\n    } else if (this[kStatus] === 'closed') {\n      this.nextTick(maybeClosed)\n    } else {\n      this.once(kLanded, () => this.close(callback))\n    }\n\n    return callback[kPromise]\n  }\n\n  [kCloseResources] (callback) {\n    if (this[kResources].size === 0) {\n      return this.nextTick(callback)\n    }\n\n    let pending = this[kResources].size\n    let sync = true\n\n    const next = () => {\n      if (--pending === 0) {\n        // We don't have tests for generic resources, so dezalgo\n        if (sync) this.nextTick(callback)\n        else callback()\n      }\n    }\n\n    // In parallel so that all resources know they are closed\n    for (const resource of this[kResources]) {\n      resource.close(next)\n    }\n\n    sync = false\n    this[kResources].clear()\n  }\n\n  _close (callback) {\n    this.nextTick(callback)\n  }\n\n  get (key, options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].entry)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.get(key, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    const err = this._checkKey(key)\n\n    if (err) {\n      this.nextTick(callback, err)\n      return callback[kPromise]\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options.valueEncoding)\n    const keyFormat = keyEncoding.format\n    const valueFormat = valueEncoding.format\n\n    // Forward encoding options to the underlying store\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      // Avoid spread operator because of https://bugs.chromium.org/p/chromium/issues/detail?id=1204540\n      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat })\n    }\n\n    this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err, value) => {\n      if (err) {\n        // Normalize not found error for backwards compatibility with abstract-leveldown and level(up)\n        if (err.code === 'LEVEL_NOT_FOUND' || err.notFound || /NotFound/i.test(err)) {\n          if (!err.code) err.code = 'LEVEL_NOT_FOUND' // Preferred way going forward\n          if (!err.notFound) err.notFound = true // Same as level-errors\n          if (!err.status) err.status = 404 // Same as level-errors\n        }\n\n        return callback(err)\n      }\n\n      try {\n        value = valueEncoding.decode(value)\n      } catch (err) {\n        return callback(new ModuleError('Could not decode value', {\n          code: 'LEVEL_DECODE_ERROR',\n          cause: err\n        }))\n      }\n\n      callback(null, value)\n    })\n\n    return callback[kPromise]\n  }\n\n  _get (key, options, callback) {\n    this.nextTick(callback, new Error('NotFound'))\n  }\n\n  getMany (keys, options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].entry)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.getMany(keys, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    if (!Array.isArray(keys)) {\n      this.nextTick(callback, new TypeError(\"The first argument 'keys' must be an array\"))\n      return callback[kPromise]\n    }\n\n    if (keys.length === 0) {\n      this.nextTick(callback, null, [])\n      return callback[kPromise]\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options.valueEncoding)\n    const keyFormat = keyEncoding.format\n    const valueFormat = valueEncoding.format\n\n    // Forward encoding options\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat })\n    }\n\n    const mappedKeys = new Array(keys.length)\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n      const err = this._checkKey(key)\n\n      if (err) {\n        this.nextTick(callback, err)\n        return callback[kPromise]\n      }\n\n      mappedKeys[i] = this.prefixKey(keyEncoding.encode(key), keyFormat)\n    }\n\n    this._getMany(mappedKeys, options, (err, values) => {\n      if (err) return callback(err)\n\n      try {\n        for (let i = 0; i < values.length; i++) {\n          if (values[i] !== undefined) {\n            values[i] = valueEncoding.decode(values[i])\n          }\n        }\n      } catch (err) {\n        return callback(new ModuleError(`Could not decode one or more of ${values.length} value(s)`, {\n          code: 'LEVEL_DECODE_ERROR',\n          cause: err\n        }))\n      }\n\n      callback(null, values)\n    })\n\n    return callback[kPromise]\n  }\n\n  _getMany (keys, options, callback) {\n    this.nextTick(callback, null, new Array(keys.length).fill(undefined))\n  }\n\n  put (key, value, options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].entry)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.put(key, value, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    const err = this._checkKey(key) || this._checkValue(value)\n\n    if (err) {\n      this.nextTick(callback, err)\n      return callback[kPromise]\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options.valueEncoding)\n    const keyFormat = keyEncoding.format\n    const valueFormat = valueEncoding.format\n\n    // Forward encoding options\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat })\n    }\n\n    const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat)\n    const mappedValue = valueEncoding.encode(value)\n\n    this._put(mappedKey, mappedValue, options, (err) => {\n      if (err) return callback(err)\n      this.emit('put', key, value)\n      callback()\n    })\n\n    return callback[kPromise]\n  }\n\n  _put (key, value, options, callback) {\n    this.nextTick(callback)\n  }\n\n  del (key, options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].key)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.del(key, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    const err = this._checkKey(key)\n\n    if (err) {\n      this.nextTick(callback, err)\n      return callback[kPromise]\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n    const keyFormat = keyEncoding.format\n\n    // Forward encoding options\n    if (options.keyEncoding !== keyFormat) {\n      options = Object.assign({}, options, { keyEncoding: keyFormat })\n    }\n\n    this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err) => {\n      if (err) return callback(err)\n      this.emit('del', key)\n      callback()\n    })\n\n    return callback[kPromise]\n  }\n\n  _del (key, options, callback) {\n    this.nextTick(callback)\n  }\n\n  batch (operations, options, callback) {\n    if (!arguments.length) {\n      if (this[kStatus] === 'opening') return new DefaultChainedBatch(this)\n      if (this[kStatus] !== 'open') {\n        throw new ModuleError('Database is not open', {\n          code: 'LEVEL_DATABASE_NOT_OPEN'\n        })\n      }\n      return this._chainedBatch()\n    }\n\n    if (typeof operations === 'function') callback = operations\n    else callback = getCallback(options, callback)\n\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].empty)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.batch(operations, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    if (!Array.isArray(operations)) {\n      this.nextTick(callback, new TypeError(\"The first argument 'operations' must be an array\"))\n      return callback[kPromise]\n    }\n\n    if (operations.length === 0) {\n      this.nextTick(callback)\n      return callback[kPromise]\n    }\n\n    const mapped = new Array(operations.length)\n    const { keyEncoding: ke, valueEncoding: ve, ...forward } = options\n\n    for (let i = 0; i < operations.length; i++) {\n      if (typeof operations[i] !== 'object' || operations[i] === null) {\n        this.nextTick(callback, new TypeError('A batch operation must be an object'))\n        return callback[kPromise]\n      }\n\n      const op = Object.assign({}, operations[i])\n\n      if (op.type !== 'put' && op.type !== 'del') {\n        this.nextTick(callback, new TypeError(\"A batch operation must have a type property that is 'put' or 'del'\"))\n        return callback[kPromise]\n      }\n\n      const err = this._checkKey(op.key)\n\n      if (err) {\n        this.nextTick(callback, err)\n        return callback[kPromise]\n      }\n\n      const db = op.sublevel != null ? op.sublevel : this\n      const keyEncoding = db.keyEncoding(op.keyEncoding || ke)\n      const keyFormat = keyEncoding.format\n\n      op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat)\n      op.keyEncoding = keyFormat\n\n      if (op.type === 'put') {\n        const valueErr = this._checkValue(op.value)\n\n        if (valueErr) {\n          this.nextTick(callback, valueErr)\n          return callback[kPromise]\n        }\n\n        const valueEncoding = db.valueEncoding(op.valueEncoding || ve)\n\n        op.value = valueEncoding.encode(op.value)\n        op.valueEncoding = valueEncoding.format\n      }\n\n      // Prevent double prefixing\n      if (db !== this) {\n        op.sublevel = null\n      }\n\n      mapped[i] = op\n    }\n\n    this._batch(mapped, forward, (err) => {\n      if (err) return callback(err)\n      this.emit('batch', operations)\n      callback()\n    })\n\n    return callback[kPromise]\n  }\n\n  _batch (operations, options, callback) {\n    this.nextTick(callback)\n  }\n\n  sublevel (name, options) {\n    return this._sublevel(name, AbstractSublevel.defaults(options))\n  }\n\n  _sublevel (name, options) {\n    return new AbstractSublevel(this, name, options)\n  }\n\n  prefixKey (key, keyFormat) {\n    return key\n  }\n\n  clear (options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].empty)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.clear(options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    const original = options\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n\n    options = rangeOptions(options, keyEncoding)\n    options.keyEncoding = keyEncoding.format\n\n    if (options.limit === 0) {\n      this.nextTick(callback)\n    } else {\n      this._clear(options, (err) => {\n        if (err) return callback(err)\n        this.emit('clear', original)\n        callback()\n      })\n    }\n\n    return callback[kPromise]\n  }\n\n  _clear (options, callback) {\n    this.nextTick(callback)\n  }\n\n  iterator (options) {\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding)\n\n    options = rangeOptions(options, keyEncoding)\n    options.keys = options.keys !== false\n    options.values = options.values !== false\n\n    // We need the original encoding options in AbstractIterator in order to decode data\n    options[AbstractIterator.keyEncoding] = keyEncoding\n    options[AbstractIterator.valueEncoding] = valueEncoding\n\n    // Forward encoding options to private API\n    options.keyEncoding = keyEncoding.format\n    options.valueEncoding = valueEncoding.format\n\n    if (this[kStatus] === 'opening') {\n      return new DeferredIterator(this, options)\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      })\n    }\n\n    return this._iterator(options)\n  }\n\n  _iterator (options) {\n    return new AbstractIterator(this, options)\n  }\n\n  keys (options) {\n    // Also include valueEncoding (though unused) because we may fallback to _iterator()\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding)\n\n    options = rangeOptions(options, keyEncoding)\n\n    // We need the original encoding options in AbstractKeyIterator in order to decode data\n    options[AbstractIterator.keyEncoding] = keyEncoding\n    options[AbstractIterator.valueEncoding] = valueEncoding\n\n    // Forward encoding options to private API\n    options.keyEncoding = keyEncoding.format\n    options.valueEncoding = valueEncoding.format\n\n    if (this[kStatus] === 'opening') {\n      return new DeferredKeyIterator(this, options)\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      })\n    }\n\n    return this._keys(options)\n  }\n\n  _keys (options) {\n    return new DefaultKeyIterator(this, options)\n  }\n\n  values (options) {\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding)\n\n    options = rangeOptions(options, keyEncoding)\n\n    // We need the original encoding options in AbstractValueIterator in order to decode data\n    options[AbstractIterator.keyEncoding] = keyEncoding\n    options[AbstractIterator.valueEncoding] = valueEncoding\n\n    // Forward encoding options to private API\n    options.keyEncoding = keyEncoding.format\n    options.valueEncoding = valueEncoding.format\n\n    if (this[kStatus] === 'opening') {\n      return new DeferredValueIterator(this, options)\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      })\n    }\n\n    return this._values(options)\n  }\n\n  _values (options) {\n    return new DefaultValueIterator(this, options)\n  }\n\n  defer (fn) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('The first argument must be a function')\n    }\n\n    this[kOperations].push(fn)\n  }\n\n  [kUndefer] () {\n    if (this[kOperations].length === 0) {\n      return\n    }\n\n    const operations = this[kOperations]\n    this[kOperations] = []\n\n    for (const op of operations) {\n      op()\n    }\n  }\n\n  // TODO: docs and types\n  attachResource (resource) {\n    if (typeof resource !== 'object' || resource === null ||\n      typeof resource.close !== 'function') {\n      throw new TypeError('The first argument must be a resource object')\n    }\n\n    this[kResources].add(resource)\n  }\n\n  // TODO: docs and types\n  detachResource (resource) {\n    this[kResources].delete(resource)\n  }\n\n  _chainedBatch () {\n    return new DefaultChainedBatch(this)\n  }\n\n  _checkKey (key) {\n    if (key === null || key === undefined) {\n      return new ModuleError('Key cannot be null or undefined', {\n        code: 'LEVEL_INVALID_KEY'\n      })\n    }\n  }\n\n  _checkValue (value) {\n    if (value === null || value === undefined) {\n      return new ModuleError('Value cannot be null or undefined', {\n        code: 'LEVEL_INVALID_VALUE'\n      })\n    }\n  }\n}\n\n// Expose browser-compatible nextTick for dependents\n// TODO: after we drop node 10, also use queueMicrotask in node\nAbstractLevel.prototype.nextTick = require('./lib/next-tick')\n\nconst { AbstractSublevel } = require('./lib/abstract-sublevel')({ AbstractLevel })\n\nexports.AbstractLevel = AbstractLevel\nexports.AbstractSublevel = AbstractSublevel\n\nconst maybeError = function (db, callback) {\n  if (db[kStatus] !== 'open') {\n    db.nextTick(callback, new ModuleError('Database is not open', {\n      code: 'LEVEL_DATABASE_NOT_OPEN'\n    }))\n    return true\n  }\n\n  return false\n}\n\nconst formats = function (db) {\n  return Object.keys(db.supports.encodings)\n    .filter(k => !!db.supports.encodings[k])\n}\n"]},"metadata":{},"sourceType":"script"}