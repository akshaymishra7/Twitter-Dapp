{"ast":null,"code":"import { abortableSource } from 'abortable-iterator';\nimport { CLOSE_TIMEOUT } from './constants.js';\nimport pTimeout from 'p-timeout';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:websockets:socket'); // Convert a stream into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\n\nexport function socketToMaConn(stream, remoteAddr, options) {\n  options = options ?? {};\n  const maConn = {\n    async sink(source) {\n      if (options?.signal != null) {\n        source = abortableSource(source, options.signal);\n      }\n\n      try {\n        await stream.sink(source);\n      } catch (err) {\n        if (err.type !== 'aborted') {\n          log.error(err);\n        }\n      }\n    },\n\n    source: options.signal != null ? abortableSource(stream.source, options.signal) : stream.source,\n    remoteAddr,\n    timeline: {\n      open: Date.now()\n    },\n\n    async close() {\n      const start = Date.now();\n\n      try {\n        await pTimeout(stream.close(), {\n          milliseconds: CLOSE_TIMEOUT\n        });\n      } catch (err) {\n        const {\n          host,\n          port\n        } = maConn.remoteAddr.toOptions();\n        log('timeout closing stream to %s:%s after %dms, destroying it manually', host, port, Date.now() - start);\n        stream.destroy();\n      } finally {\n        maConn.timeline.close = Date.now();\n      }\n    }\n\n  };\n  stream.socket.addEventListener('close', () => {\n    // In instances where `close` was not explicitly called,\n    // such as an iterable stream ending, ensure we have set the close\n    // timeline\n    if (maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now();\n    }\n  }, {\n    once: true\n  });\n  return maConn;\n}","map":{"version":3,"mappings":"AAAA,SAASA,eAAT,QAAgC,oBAAhC;AACA,SAASC,aAAT,QAA8B,gBAA9B;AACA,OAAOC,QAAP,MAAqB,WAArB;AACA,SAASC,MAAT,QAAuB,gBAAvB;AAMA,MAAMC,GAAG,GAAGD,MAAM,CAAC,0BAAD,CAAlB,C,CAMA;AACA;;AACA,OAAM,SAAUE,cAAV,CAA0BC,MAA1B,EAAmDC,UAAnD,EAA0EC,OAA1E,EAAuG;AAC3GA,SAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,QAAMC,MAAM,GAAwB;AAClC,UAAMC,IAAN,CAAYC,MAAZ,EAAkB;AAChB,UAAKH,OAAO,EAAEI,MAAV,IAAqB,IAAzB,EAA+B;AAC7BD,cAAM,GAAGX,eAAe,CAACW,MAAD,EAASH,OAAO,CAACI,MAAjB,CAAxB;AACD;;AAED,UAAI;AACF,cAAMN,MAAM,CAACI,IAAP,CAAYC,MAAZ,CAAN;AACD,OAFD,CAEE,OAAOE,GAAP,EAAiB;AACjB,YAAIA,GAAG,CAACC,IAAJ,KAAa,SAAjB,EAA4B;AAC1BV,aAAG,CAACW,KAAJ,CAAUF,GAAV;AACD;AACF;AACF,KAbiC;;AAelCF,UAAM,EAAGH,OAAO,CAACI,MAAR,IAAkB,IAAnB,GAA2BZ,eAAe,CAACM,MAAM,CAACK,MAAR,EAAgBH,OAAO,CAACI,MAAxB,CAA1C,GAA4EN,MAAM,CAACK,MAfzD;AAiBlCJ,cAjBkC;AAmBlCS,YAAQ,EAAE;AAAEC,UAAI,EAAEC,IAAI,CAACC,GAAL;AAAR,KAnBwB;;AAqBlC,UAAMC,KAAN,GAAW;AACT,YAAMC,KAAK,GAAGH,IAAI,CAACC,GAAL,EAAd;;AAEA,UAAI;AACF,cAAMjB,QAAQ,CAACI,MAAM,CAACc,KAAP,EAAD,EAAiB;AAC7BE,sBAAY,EAAErB;AADe,SAAjB,CAAd;AAGD,OAJD,CAIE,OAAOY,GAAP,EAAY;AACZ,cAAM;AAAEU,cAAF;AAAQC;AAAR,YAAiBf,MAAM,CAACF,UAAP,CAAkBkB,SAAlB,EAAvB;AACArB,WAAG,CAAC,oEAAD,EACDmB,IADC,EACKC,IADL,EACWN,IAAI,CAACC,GAAL,KAAaE,KADxB,CAAH;AAGAf,cAAM,CAACoB,OAAP;AACD,OAVD,SAUU;AACRjB,cAAM,CAACO,QAAP,CAAgBI,KAAhB,GAAwBF,IAAI,CAACC,GAAL,EAAxB;AACD;AACF;;AArCiC,GAApC;AAwCAb,QAAM,CAACqB,MAAP,CAAcC,gBAAd,CAA+B,OAA/B,EAAwC,MAAK;AAC3C;AACA;AACA;AACA,QAAInB,MAAM,CAACO,QAAP,CAAgBI,KAAhB,IAAyB,IAA7B,EAAmC;AACjCX,YAAM,CAACO,QAAP,CAAgBI,KAAhB,GAAwBF,IAAI,CAACC,GAAL,EAAxB;AACD;AACF,GAPD,EAOG;AAAEU,QAAI,EAAE;AAAR,GAPH;AASA,SAAOpB,MAAP;AACD","names":["abortableSource","CLOSE_TIMEOUT","pTimeout","logger","log","socketToMaConn","stream","remoteAddr","options","maConn","sink","source","signal","err","type","error","timeline","open","Date","now","close","start","milliseconds","host","port","toOptions","destroy","socket","addEventListener","once"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\websockets\\src\\socket-to-conn.ts"],"sourcesContent":["import { abortableSource } from 'abortable-iterator'\nimport { CLOSE_TIMEOUT } from './constants.js'\nimport pTimeout from 'p-timeout'\nimport { logger } from '@libp2p/logger'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { DuplexWebSocket } from 'it-ws/duplex'\n\nconst log = logger('libp2p:websockets:socket')\n\nexport interface SocketToConnOptions extends AbortOptions {\n  localAddr?: Multiaddr\n}\n\n// Convert a stream into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\nexport function socketToMaConn (stream: DuplexWebSocket, remoteAddr: Multiaddr, options?: SocketToConnOptions): MultiaddrConnection {\n  options = options ?? {}\n\n  const maConn: MultiaddrConnection = {\n    async sink (source) {\n      if ((options?.signal) != null) {\n        source = abortableSource(source, options.signal)\n      }\n\n      try {\n        await stream.sink(source)\n      } catch (err: any) {\n        if (err.type !== 'aborted') {\n          log.error(err)\n        }\n      }\n    },\n\n    source: (options.signal != null) ? abortableSource(stream.source, options.signal) : stream.source,\n\n    remoteAddr,\n\n    timeline: { open: Date.now() },\n\n    async close () {\n      const start = Date.now()\n\n      try {\n        await pTimeout(stream.close(), {\n          milliseconds: CLOSE_TIMEOUT\n        })\n      } catch (err) {\n        const { host, port } = maConn.remoteAddr.toOptions()\n        log('timeout closing stream to %s:%s after %dms, destroying it manually',\n          host, port, Date.now() - start)\n\n        stream.destroy()\n      } finally {\n        maConn.timeline.close = Date.now()\n      }\n    }\n  }\n\n  stream.socket.addEventListener('close', () => {\n    // In instances where `close` was not explicitly called,\n    // such as an iterable stream ending, ensure we have set the close\n    // timeline\n    if (maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now()\n    }\n  }, { once: true })\n\n  return maConn\n}\n"]},"metadata":{},"sourceType":"module"}