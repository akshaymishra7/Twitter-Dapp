{"ast":null,"code":"/**\n * @packageDocumentation\n *\n * @example\n *\n * ```js\n *\n * import { pipe } from 'it-pipe'\n * import { duplexPair } from 'it-pair/duplex'\n * import { handshake } from 'it-handshake'\n *\n * // Create connected duplex streams\n * const [client, server] = duplexPair()\n * const clientShake = handshake(client)\n * const serverShake = handshake(server)\n *\n * clientShake.write('hello')\n * console.log('client: %s', await serverShake.read())\n * // > client: hello\n * serverShake.write('hi')\n * serverShake.rest() // the server has finished the handshake\n * console.log('server: %s', await clientShake.read())\n * // > server: hi\n * clientShake.rest() // the client has finished the handshake\n *\n * // Make the server echo responses\n * pipe(\n *   serverShake.stream,\n *   async function * (source) {\n *     for await (const message of source) {\n *       yield message\n *     }\n *   },\n *   serverShake.stream\n * )\n *\n * // Send and receive an echo through the handshake stream\n * pipe(\n *   ['echo'],\n *   clientShake.stream,\n *   async function * (source) {\n *     for await (const bufferList of source) {\n *       console.log('Echo response: %s', bufferList.slice())\n *       // > Echo response: echo\n *     }\n *   }\n * )\n * ```\n */\nimport { reader } from 'it-reader';\nimport { pushable } from 'it-pushable';\nimport defer from 'p-defer'; // Convert a duplex stream into a reader and writer and rest stream\n\nexport function handshake(stream) {\n  const writer = pushable(); // Write bytes on demand to the sink\n\n  const source = reader(stream.source); // Read bytes on demand from the source\n  // Waits for a source to be passed to the rest stream's sink\n\n  const sourcePromise = defer();\n  let sinkErr;\n  const sinkPromise = stream.sink(async function* () {\n    yield* writer;\n    const source = await sourcePromise.promise;\n    yield* source;\n  }());\n  sinkPromise.catch(err => {\n    sinkErr = err;\n  });\n  const rest = {\n    sink: async source => {\n      if (sinkErr != null) {\n        await Promise.reject(sinkErr);\n        return;\n      }\n\n      sourcePromise.resolve(source);\n      await sinkPromise;\n    },\n    source\n  };\n  return {\n    reader: source,\n    writer,\n    stream: rest,\n    rest: () => writer.end(),\n    write: writer.push,\n    read: async () => {\n      const res = await source.next();\n\n      if (res.value != null) {\n        return res.value;\n      }\n    }\n  };\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA,SAAiBA,MAAjB,QAA+B,WAA/B;AACA,SAASC,QAAT,QAAyB,aAAzB;AACA,OAAOC,KAAP,MAAkB,SAAlB,C,CAcA;;AACA,OAAM,SAAUC,SAAV,CAAiFC,MAAjF,EAAyK;AAC7K,QAAMC,MAAM,GAAGJ,QAAQ,EAAvB,CAD6K,CAC5I;;AACjC,QAAMK,MAAM,GAAGN,MAAM,CAACI,MAAM,CAACE,MAAR,CAArB,CAF6K,CAExI;AAErC;;AACA,QAAMC,aAAa,GAAGL,KAAK,EAA3B;AACA,MAAIM,OAAJ;AAEA,QAAMC,WAAW,GAAGL,MAAM,CAACM,IAAP,CAAa,mBAAgB;AAC/C,WAAQL,MAAR;AACA,UAAMC,MAAM,GAAG,MAAMC,aAAa,CAACI,OAAnC;AACA,WAAQL,MAAR;AACD,GAJ+B,EAAZ,CAApB;AAMAG,aAAW,CAACG,KAAZ,CAAkBC,GAAG,IAAG;AACtBL,WAAO,GAAGK,GAAV;AACD,GAFD;AAIA,QAAMC,IAAI,GAAyE;AACjFJ,QAAI,EAAE,MAAMJ,MAAN,IAAe;AACnB,UAAIE,OAAO,IAAI,IAAf,EAAqB;AACnB,cAAMO,OAAO,CAACC,MAAR,CAAeR,OAAf,CAAN;AAA+B;AAChC;;AAEDD,mBAAa,CAACU,OAAd,CAAsBX,MAAtB;AACA,YAAMG,WAAN;AACD,KARgF;AASjFH;AATiF,GAAnF;AAYA,SAAO;AACLN,UAAM,EAAEM,MADH;AAELD,UAFK;AAGLD,UAAM,EAAEU,IAHH;AAILA,QAAI,EAAE,MAAMT,MAAM,CAACa,GAAP,EAJP;AAKLC,SAAK,EAAEd,MAAM,CAACe,IALT;AAMLC,QAAI,EAAE,YAAW;AACf,YAAMC,GAAG,GAAG,MAAMhB,MAAM,CAACiB,IAAP,EAAlB;;AAEA,UAAID,GAAG,CAACE,KAAJ,IAAa,IAAjB,EAAuB;AACrB,eAAOF,GAAG,CAACE,KAAX;AACD;AACF;AAZI,GAAP;AAcD","names":["reader","pushable","defer","handshake","stream","writer","source","sourcePromise","sinkErr","sinkPromise","sink","promise","catch","err","rest","Promise","reject","resolve","end","write","push","read","res","next","value"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-handshake\\src\\index.ts"],"sourcesContent":["/**\n * @packageDocumentation\n *\n * @example\n *\n * ```js\n *\n * import { pipe } from 'it-pipe'\n * import { duplexPair } from 'it-pair/duplex'\n * import { handshake } from 'it-handshake'\n *\n * // Create connected duplex streams\n * const [client, server] = duplexPair()\n * const clientShake = handshake(client)\n * const serverShake = handshake(server)\n *\n * clientShake.write('hello')\n * console.log('client: %s', await serverShake.read())\n * // > client: hello\n * serverShake.write('hi')\n * serverShake.rest() // the server has finished the handshake\n * console.log('server: %s', await clientShake.read())\n * // > server: hi\n * clientShake.rest() // the client has finished the handshake\n *\n * // Make the server echo responses\n * pipe(\n *   serverShake.stream,\n *   async function * (source) {\n *     for await (const message of source) {\n *       yield message\n *     }\n *   },\n *   serverShake.stream\n * )\n *\n * // Send and receive an echo through the handshake stream\n * pipe(\n *   ['echo'],\n *   clientShake.stream,\n *   async function * (source) {\n *     for await (const bufferList of source) {\n *       console.log('Echo response: %s', bufferList.slice())\n *       // > Echo response: echo\n *     }\n *   }\n * )\n * ```\n */\n\nimport { Reader, reader } from 'it-reader'\nimport { pushable } from 'it-pushable'\nimport defer from 'p-defer'\nimport type { Duplex, Source } from 'it-stream-types'\nimport type { Pushable } from 'it-pushable'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Handshake<TSink = Uint8Array | Uint8ArrayList> {\n  reader: Reader\n  writer: Pushable<TSink>\n  stream: Duplex<AsyncGenerator<Uint8ArrayList | Uint8Array>, Source<TSink>, Promise<void>>\n  rest: () => Source<TSink>\n  write: (data: TSink) => void\n  read: () => Promise<Uint8ArrayList | undefined>\n}\n\n// Convert a duplex stream into a reader and writer and rest stream\nexport function handshake<TSink extends Uint8ArrayList | Uint8Array = Uint8ArrayList> (stream: Duplex<AsyncIterable<Uint8ArrayList | Uint8Array>, Source<TSink>, Promise<void>>): Handshake<TSink> {\n  const writer = pushable<TSink>() // Write bytes on demand to the sink\n  const source = reader(stream.source) // Read bytes on demand from the source\n\n  // Waits for a source to be passed to the rest stream's sink\n  const sourcePromise = defer<Source<TSink>>()\n  let sinkErr: Error\n\n  const sinkPromise = stream.sink((async function * () {\n    yield * writer\n    const source = await sourcePromise.promise\n    yield * source\n  })())\n\n  sinkPromise.catch(err => {\n    sinkErr = err\n  })\n\n  const rest: Duplex<AsyncGenerator<Uint8ArrayList>, Source<TSink>, Promise<void>> = {\n    sink: async source => {\n      if (sinkErr != null) {\n        await Promise.reject(sinkErr); return\n      }\n\n      sourcePromise.resolve(source)\n      await sinkPromise\n    },\n    source\n  }\n\n  return {\n    reader: source,\n    writer,\n    stream: rest,\n    rest: () => writer.end(),\n    write: writer.push,\n    read: async () => {\n      const res = await source.next()\n\n      if (res.value != null) {\n        return res.value\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}