{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Package hmac implements HMAC algorithm.\n */\n\nvar hash_1 = require(\"@stablelib/hash\");\n\nvar constant_time_1 = require(\"@stablelib/constant-time\");\n\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */\n\n\nvar HMAC =\n/** @class */\nfunction () {\n  /**\n   * Constructs a new HMAC with the given Hash and secret key.\n   */\n  function HMAC(hash, key) {\n    this._finished = false; // true if HMAC was finalized\n    // Initialize inner and outer hashes.\n\n    this._inner = new hash();\n    this._outer = new hash(); // Set block and digest sizes for this HMAC\n    // instance to values from the hash.\n\n    this.blockSize = this._outer.blockSize;\n    this.digestLength = this._outer.digestLength; // Pad temporary stores a key (or its hash) padded with zeroes.\n\n    var pad = new Uint8Array(this.blockSize);\n\n    if (key.length > this.blockSize) {\n      // If key is bigger than hash block size, it must be\n      // hashed and this hash is used as a key instead.\n      this._inner.update(key).finish(pad).clean();\n    } else {\n      // Otherwise, copy the key into pad.\n      pad.set(key);\n    } // Now two different keys are derived from padded key\n    // by xoring a different byte value to each.\n    // To make inner hash key, xor byte 0x36 into pad.\n\n\n    for (var i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36;\n    } // Update inner hash with the result.\n\n\n    this._inner.update(pad); // To make outer hash key, xor byte 0x5c into pad.\n    // But since we already xored 0x36 there, we must\n    // first undo this by xoring it again.\n\n\n    for (var i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36 ^ 0x5c;\n    } // Update outer hash with the result.\n\n\n    this._outer.update(pad); // Save states of both hashes, so that we can quickly restore\n    // them later in reset() without the need to remember the actual\n    // key and perform this initialization again.\n\n\n    if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {\n      this._innerKeyedState = this._inner.saveState();\n      this._outerKeyedState = this._outer.saveState();\n    } // Clean pad.\n\n\n    wipe_1.wipe(pad);\n  }\n  /**\n   * Returns HMAC state to the state initialized with key\n   * to make it possible to run HMAC over the other data with the same\n   * key without creating a new instance.\n   */\n\n\n  HMAC.prototype.reset = function () {\n    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n      throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n    } // Restore keyed states of inner and outer hashes.\n\n\n    this._inner.restoreState(this._innerKeyedState);\n\n    this._outer.restoreState(this._outerKeyedState);\n\n    this._finished = false;\n    return this;\n  };\n  /**\n   * Cleans HMAC state.\n   */\n\n\n  HMAC.prototype.clean = function () {\n    if (hash_1.isSerializableHash(this._inner)) {\n      this._inner.cleanSavedState(this._innerKeyedState);\n    }\n\n    if (hash_1.isSerializableHash(this._outer)) {\n      this._outer.cleanSavedState(this._outerKeyedState);\n    }\n\n    this._inner.clean();\n\n    this._outer.clean();\n  };\n  /**\n   * Updates state with provided data.\n   */\n\n\n  HMAC.prototype.update = function (data) {\n    this._inner.update(data);\n\n    return this;\n  };\n  /**\n   * Finalizes HMAC and puts the result in out.\n   */\n\n\n  HMAC.prototype.finish = function (out) {\n    if (this._finished) {\n      // If HMAC was finalized, outer hash is also finalized,\n      // so it produces the same digest it produced when it\n      // was finalized.\n      this._outer.finish(out);\n\n      return this;\n    } // Finalize inner hash and store the result temporarily.\n\n\n    this._inner.finish(out); // Update outer hash with digest of inner hash and and finalize it.\n\n\n    this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n\n    this._finished = true;\n    return this;\n  };\n  /**\n   * Returns the computed message authentication code.\n   */\n\n\n  HMAC.prototype.digest = function () {\n    var out = new Uint8Array(this.digestLength);\n    this.finish(out);\n    return out;\n  };\n  /**\n   * Saves HMAC state.\n   * This function is needed for PBKDF2 optimization.\n   */\n\n\n  HMAC.prototype.saveState = function () {\n    if (!hash_1.isSerializableHash(this._inner)) {\n      throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n    }\n\n    return this._inner.saveState();\n  };\n\n  HMAC.prototype.restoreState = function (savedState) {\n    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n      throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n    }\n\n    this._inner.restoreState(savedState);\n\n    this._outer.restoreState(this._outerKeyedState);\n\n    this._finished = false;\n    return this;\n  };\n\n  HMAC.prototype.cleanSavedState = function (savedState) {\n    if (!hash_1.isSerializableHash(this._inner)) {\n      throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n    }\n\n    this._inner.cleanSavedState(savedState);\n  };\n\n  return HMAC;\n}();\n\nexports.HMAC = HMAC;\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */\n\nfunction hmac(hash, key, data) {\n  var h = new HMAC(hash, key);\n  h.update(data);\n  var digest = h.digest();\n  h.clean();\n  return digest;\n}\n\nexports.hmac = hmac;\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */\n\nexports.equal = constant_time_1.equal;","map":{"version":3,"mappings":"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","names":["hash","key","_inner","_outer","blockSize","digestLength","pad","Uint8Array","length","update","finish","clean","set","i","hash_1","_innerKeyedState","saveState","_outerKeyedState","wipe_1","HMAC","Error","restoreState","_finished","cleanSavedState","data","out","subarray","savedState","exports","hmac","h","digest","constant_time_1"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@stablelib\\hmac\\hmac.ts"],"sourcesContent":["// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package hmac implements HMAC algorithm.\n */\n\nimport { Hash, SerializableHash, isSerializableHash } from \"@stablelib/hash\";\nimport { equal as constantTimeEqual } from \"@stablelib/constant-time\";\nimport { wipe } from \"@stablelib/wipe\";\n\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */\nexport class HMAC implements SerializableHash {\n    readonly blockSize: number;\n    readonly digestLength: number;\n\n    private _inner: Hash; // inner hash\n    private _outer: Hash; // outer hash\n\n    private _finished = false; // true if HMAC was finalized\n\n    // Copies of hash states after keying.\n    // Need for quick reset without hashing the key again.\n    private _innerKeyedState: any | undefined;\n    private _outerKeyedState: any | undefined;\n\n    /**\n     * Constructs a new HMAC with the given Hash and secret key.\n     */\n    constructor(hash: new () => Hash | SerializableHash, key: Uint8Array) {\n        // Initialize inner and outer hashes.\n        this._inner = new hash();\n        this._outer = new hash();\n\n        // Set block and digest sizes for this HMAC\n        // instance to values from the hash.\n        this.blockSize = this._outer.blockSize;\n        this.digestLength = this._outer.digestLength;\n\n        // Pad temporary stores a key (or its hash) padded with zeroes.\n        const pad = new Uint8Array(this.blockSize);\n\n        if (key.length > this.blockSize) {\n            // If key is bigger than hash block size, it must be\n            // hashed and this hash is used as a key instead.\n            this._inner.update(key).finish(pad).clean();\n        } else {\n            // Otherwise, copy the key into pad.\n            pad.set(key);\n        }\n\n        // Now two different keys are derived from padded key\n        // by xoring a different byte value to each.\n\n        // To make inner hash key, xor byte 0x36 into pad.\n        for (let i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        // Update inner hash with the result.\n        this._inner.update(pad);\n\n        // To make outer hash key, xor byte 0x5c into pad.\n        // But since we already xored 0x36 there, we must\n        // first undo this by xoring it again.\n        for (let i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        // Update outer hash with the result.\n        this._outer.update(pad);\n\n        // Save states of both hashes, so that we can quickly restore\n        // them later in reset() without the need to remember the actual\n        // key and perform this initialization again.\n        if (isSerializableHash(this._inner) && isSerializableHash(this._outer)) {\n            this._innerKeyedState = this._inner.saveState();\n            this._outerKeyedState = this._outer.saveState();\n        }\n\n        // Clean pad.\n        wipe(pad);\n    }\n\n    /**\n     * Returns HMAC state to the state initialized with key\n     * to make it possible to run HMAC over the other data with the same\n     * key without creating a new instance.\n     */\n    reset(): this {\n        if (!isSerializableHash(this._inner) || !isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n        }\n        // Restore keyed states of inner and outer hashes.\n        this._inner.restoreState(this._innerKeyedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    }\n\n    /**\n     * Cleans HMAC state.\n     */\n    clean() {\n        if (isSerializableHash(this._inner)) {\n            this._inner.cleanSavedState(this._innerKeyedState);\n        }\n        if (isSerializableHash(this._outer)) {\n            this._outer.cleanSavedState(this._outerKeyedState);\n        }\n        this._inner.clean();\n        this._outer.clean();\n    }\n\n    /**\n     * Updates state with provided data.\n     */\n    update(data: Uint8Array): this {\n        this._inner.update(data);\n        return this;\n    }\n\n    /**\n     * Finalizes HMAC and puts the result in out.\n     */\n    finish(out: Uint8Array): this {\n        if (this._finished) {\n            // If HMAC was finalized, outer hash is also finalized,\n            // so it produces the same digest it produced when it\n            // was finalized.\n            this._outer.finish(out);\n            return this;\n        }\n\n        // Finalize inner hash and store the result temporarily.\n        this._inner.finish(out);\n\n        // Update outer hash with digest of inner hash and and finalize it.\n        this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n        this._finished = true;\n\n        return this;\n    }\n\n    /**\n     * Returns the computed message authentication code.\n     */\n    digest(): Uint8Array {\n        const out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    }\n\n    /**\n     * Saves HMAC state.\n     * This function is needed for PBKDF2 optimization.\n     */\n    saveState(): any {\n        if (!isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n        }\n        return this._inner.saveState();\n    }\n\n    restoreState(savedState: any): this {\n        if (!isSerializableHash(this._inner) || !isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n        }\n        this._inner.restoreState(savedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    }\n\n    cleanSavedState(savedState: any) {\n        if (!isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n        }\n        this._inner.cleanSavedState(savedState);\n    }\n}\n\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */\nexport function hmac(hash: new () => Hash, key: Uint8Array, data: Uint8Array): Uint8Array {\n    const h = new HMAC(hash, key);\n    h.update(data);\n    const digest = h.digest();\n    h.clean();\n    return digest;\n}\n\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */\nexport const equal = constantTimeEqual;\n"]},"metadata":{},"sourceType":"script"}