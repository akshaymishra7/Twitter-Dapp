{"ast":null,"code":"'use strict';\n\nconst ModuleError = require('module-error');\n\nconst {\n  Buffer\n} = require('buffer') || {};\n\nconst {\n  AbstractSublevelIterator,\n  AbstractSublevelKeyIterator,\n  AbstractSublevelValueIterator\n} = require('./abstract-sublevel-iterator');\n\nconst kPrefix = Symbol('prefix');\nconst kUpperBound = Symbol('upperBound');\nconst kPrefixRange = Symbol('prefixRange');\nconst kParent = Symbol('parent');\nconst kUnfix = Symbol('unfix');\nconst textEncoder = new TextEncoder();\nconst defaults = {\n  separator: '!'\n}; // Wrapped to avoid circular dependency\n\nmodule.exports = function (_ref) {\n  let {\n    AbstractLevel\n  } = _ref;\n\n  class AbstractSublevel extends AbstractLevel {\n    static defaults(options) {\n      // To help migrating from subleveldown to abstract-level\n      if (typeof options === 'string') {\n        throw new ModuleError('The subleveldown string shorthand for { separator } has been removed', {\n          code: 'LEVEL_LEGACY'\n        });\n      } else if (options && options.open) {\n        throw new ModuleError('The subleveldown open option has been removed', {\n          code: 'LEVEL_LEGACY'\n        });\n      }\n\n      if (options == null) {\n        return defaults;\n      } else if (!options.separator) {\n        return { ...options,\n          separator: '!'\n        };\n      } else {\n        return options;\n      }\n    } // TODO: add autoClose option, which if true, does parent.attachResource(this)\n\n\n    constructor(db, name, options) {\n      // Don't forward AbstractSublevel options to AbstractLevel\n      const {\n        separator,\n        manifest,\n        ...forward\n      } = AbstractSublevel.defaults(options);\n      name = trim(name, separator); // Reserve one character between separator and name to give us an upper bound\n\n      const reserved = separator.charCodeAt(0) + 1;\n      const parent = db[kParent] || db; // Keys should sort like ['!a!', '!a!!a!', '!a\"', '!aa!', '!b!'].\n      // Use ASCII for consistent length between string, Buffer and Uint8Array\n\n      if (!textEncoder.encode(name).every(x => x > reserved && x < 127)) {\n        throw new ModuleError(`Prefix must use bytes > ${reserved} < ${127}`, {\n          code: 'LEVEL_INVALID_PREFIX'\n        });\n      }\n\n      super(mergeManifests(parent, manifest), forward);\n      const prefix = (db.prefix || '') + separator + name + separator;\n      const upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved);\n      this[kParent] = parent;\n      this[kPrefix] = new MultiFormat(prefix);\n      this[kUpperBound] = new MultiFormat(upperBound);\n      this[kUnfix] = new Unfixer();\n      this.nextTick = parent.nextTick;\n    }\n\n    prefixKey(key, keyFormat) {\n      if (keyFormat === 'utf8') {\n        return this[kPrefix].utf8 + key;\n      } else if (key.byteLength === 0) {\n        // Fast path for empty key (no copy)\n        return this[kPrefix][keyFormat];\n      } else if (keyFormat === 'view') {\n        const view = this[kPrefix].view;\n        const result = new Uint8Array(view.byteLength + key.byteLength);\n        result.set(view, 0);\n        result.set(key, view.byteLength);\n        return result;\n      } else {\n        const buffer = this[kPrefix].buffer;\n        return Buffer.concat([buffer, key], buffer.byteLength + key.byteLength);\n      }\n    } // Not exposed for now.\n\n\n    [kPrefixRange](range, keyFormat) {\n      if (range.gte !== undefined) {\n        range.gte = this.prefixKey(range.gte, keyFormat);\n      } else if (range.gt !== undefined) {\n        range.gt = this.prefixKey(range.gt, keyFormat);\n      } else {\n        range.gte = this[kPrefix][keyFormat];\n      }\n\n      if (range.lte !== undefined) {\n        range.lte = this.prefixKey(range.lte, keyFormat);\n      } else if (range.lt !== undefined) {\n        range.lt = this.prefixKey(range.lt, keyFormat);\n      } else {\n        range.lte = this[kUpperBound][keyFormat];\n      }\n    }\n\n    get prefix() {\n      return this[kPrefix].utf8;\n    }\n\n    get db() {\n      return this[kParent];\n    }\n\n    _open(options, callback) {\n      // The parent db must open itself or be (re)opened by the user because\n      // a sublevel should not initiate state changes on the rest of the db.\n      this[kParent].open({\n        passive: true\n      }, callback);\n    }\n\n    _put(key, value, options, callback) {\n      this[kParent].put(key, value, options, callback);\n    }\n\n    _get(key, options, callback) {\n      this[kParent].get(key, options, callback);\n    }\n\n    _getMany(keys, options, callback) {\n      this[kParent].getMany(keys, options, callback);\n    }\n\n    _del(key, options, callback) {\n      this[kParent].del(key, options, callback);\n    }\n\n    _batch(operations, options, callback) {\n      this[kParent].batch(operations, options, callback);\n    }\n\n    _clear(options, callback) {\n      // TODO (refactor): move to AbstractLevel\n      this[kPrefixRange](options, options.keyEncoding);\n      this[kParent].clear(options, callback);\n    }\n\n    _iterator(options) {\n      // TODO (refactor): move to AbstractLevel\n      this[kPrefixRange](options, options.keyEncoding);\n      const iterator = this[kParent].iterator(options);\n      const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);\n      return new AbstractSublevelIterator(this, options, iterator, unfix);\n    }\n\n    _keys(options) {\n      this[kPrefixRange](options, options.keyEncoding);\n      const iterator = this[kParent].keys(options);\n      const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);\n      return new AbstractSublevelKeyIterator(this, options, iterator, unfix);\n    }\n\n    _values(options) {\n      this[kPrefixRange](options, options.keyEncoding);\n      const iterator = this[kParent].values(options);\n      return new AbstractSublevelValueIterator(this, options, iterator);\n    }\n\n  }\n\n  return {\n    AbstractSublevel\n  };\n};\n\nconst mergeManifests = function (parent, manifest) {\n  return { // Inherit manifest of parent db\n    ...parent.supports,\n    // Disable unsupported features\n    createIfMissing: false,\n    errorIfExists: false,\n    // Unset additional events because we're not forwarding them\n    events: {},\n    // Unset additional methods (like approximateSize) which we can't support here unless\n    // the AbstractSublevel class is overridden by an implementation of `abstract-level`.\n    additionalMethods: {},\n    // Inherit manifest of custom AbstractSublevel subclass. Such a class is not\n    // allowed to override encodings.\n    ...manifest,\n    encodings: {\n      utf8: supportsEncoding(parent, 'utf8'),\n      buffer: supportsEncoding(parent, 'buffer'),\n      view: supportsEncoding(parent, 'view')\n    }\n  };\n};\n\nconst supportsEncoding = function (parent, encoding) {\n  // Prefer a non-transcoded encoding for optimal performance\n  return parent.supports.encodings[encoding] ? parent.keyEncoding(encoding).name === encoding : false;\n};\n\nclass MultiFormat {\n  constructor(key) {\n    this.utf8 = key;\n    this.view = textEncoder.encode(key);\n    this.buffer = Buffer ? Buffer.from(this.view.buffer, 0, this.view.byteLength) : {};\n  }\n\n}\n\nclass Unfixer {\n  constructor() {\n    this.cache = new Map();\n  }\n\n  get(prefixLength, keyFormat) {\n    let unfix = this.cache.get(keyFormat);\n\n    if (unfix === undefined) {\n      if (keyFormat === 'view') {\n        unfix = function (prefixLength, key) {\n          // Avoid Uint8Array#slice() because it copies\n          return key.subarray(prefixLength);\n        }.bind(null, prefixLength);\n      } else {\n        unfix = function (prefixLength, key) {\n          // Avoid Buffer#subarray() because it's slow\n          return key.slice(prefixLength);\n        }.bind(null, prefixLength);\n      }\n\n      this.cache.set(keyFormat, unfix);\n    }\n\n    return unfix;\n  }\n\n}\n\nconst trim = function (str, char) {\n  let start = 0;\n  let end = str.length;\n\n  while (start < end && str[start] === char) start++;\n\n  while (end > start && str[end - 1] === char) end--;\n\n  return str.slice(start, end);\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/abstract-level/lib/abstract-sublevel.js"],"names":["ModuleError","require","Buffer","AbstractSublevelIterator","AbstractSublevelKeyIterator","AbstractSublevelValueIterator","kPrefix","Symbol","kUpperBound","kPrefixRange","kParent","kUnfix","textEncoder","TextEncoder","defaults","separator","module","exports","AbstractLevel","AbstractSublevel","options","code","open","constructor","db","name","manifest","forward","trim","reserved","charCodeAt","parent","encode","every","x","mergeManifests","prefix","upperBound","slice","String","fromCharCode","MultiFormat","Unfixer","nextTick","prefixKey","key","keyFormat","utf8","byteLength","view","result","Uint8Array","set","buffer","concat","range","gte","undefined","gt","lte","lt","_open","callback","passive","_put","value","put","_get","get","_getMany","keys","getMany","_del","del","_batch","operations","batch","_clear","keyEncoding","clear","_iterator","iterator","unfix","length","_keys","_values","values","supports","createIfMissing","errorIfExists","events","additionalMethods","encodings","supportsEncoding","encoding","from","cache","Map","prefixLength","subarray","bind","str","char","start","end"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ModuleError = require('module-error')\nconst { Buffer } = require('buffer') || {}\nconst {\n  AbstractSublevelIterator,\n  AbstractSublevelKeyIterator,\n  AbstractSublevelValueIterator\n} = require('./abstract-sublevel-iterator')\n\nconst kPrefix = Symbol('prefix')\nconst kUpperBound = Symbol('upperBound')\nconst kPrefixRange = Symbol('prefixRange')\nconst kParent = Symbol('parent')\nconst kUnfix = Symbol('unfix')\n\nconst textEncoder = new TextEncoder()\nconst defaults = { separator: '!' }\n\n// Wrapped to avoid circular dependency\nmodule.exports = function ({ AbstractLevel }) {\n  class AbstractSublevel extends AbstractLevel {\n    static defaults (options) {\n      // To help migrating from subleveldown to abstract-level\n      if (typeof options === 'string') {\n        throw new ModuleError('The subleveldown string shorthand for { separator } has been removed', {\n          code: 'LEVEL_LEGACY'\n        })\n      } else if (options && options.open) {\n        throw new ModuleError('The subleveldown open option has been removed', {\n          code: 'LEVEL_LEGACY'\n        })\n      }\n\n      if (options == null) {\n        return defaults\n      } else if (!options.separator) {\n        return { ...options, separator: '!' }\n      } else {\n        return options\n      }\n    }\n\n    // TODO: add autoClose option, which if true, does parent.attachResource(this)\n    constructor (db, name, options) {\n      // Don't forward AbstractSublevel options to AbstractLevel\n      const { separator, manifest, ...forward } = AbstractSublevel.defaults(options)\n      name = trim(name, separator)\n\n      // Reserve one character between separator and name to give us an upper bound\n      const reserved = separator.charCodeAt(0) + 1\n      const parent = db[kParent] || db\n\n      // Keys should sort like ['!a!', '!a!!a!', '!a\"', '!aa!', '!b!'].\n      // Use ASCII for consistent length between string, Buffer and Uint8Array\n      if (!textEncoder.encode(name).every(x => x > reserved && x < 127)) {\n        throw new ModuleError(`Prefix must use bytes > ${reserved} < ${127}`, {\n          code: 'LEVEL_INVALID_PREFIX'\n        })\n      }\n\n      super(mergeManifests(parent, manifest), forward)\n\n      const prefix = (db.prefix || '') + separator + name + separator\n      const upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved)\n\n      this[kParent] = parent\n      this[kPrefix] = new MultiFormat(prefix)\n      this[kUpperBound] = new MultiFormat(upperBound)\n      this[kUnfix] = new Unfixer()\n\n      this.nextTick = parent.nextTick\n    }\n\n    prefixKey (key, keyFormat) {\n      if (keyFormat === 'utf8') {\n        return this[kPrefix].utf8 + key\n      } else if (key.byteLength === 0) {\n        // Fast path for empty key (no copy)\n        return this[kPrefix][keyFormat]\n      } else if (keyFormat === 'view') {\n        const view = this[kPrefix].view\n        const result = new Uint8Array(view.byteLength + key.byteLength)\n\n        result.set(view, 0)\n        result.set(key, view.byteLength)\n\n        return result\n      } else {\n        const buffer = this[kPrefix].buffer\n        return Buffer.concat([buffer, key], buffer.byteLength + key.byteLength)\n      }\n    }\n\n    // Not exposed for now.\n    [kPrefixRange] (range, keyFormat) {\n      if (range.gte !== undefined) {\n        range.gte = this.prefixKey(range.gte, keyFormat)\n      } else if (range.gt !== undefined) {\n        range.gt = this.prefixKey(range.gt, keyFormat)\n      } else {\n        range.gte = this[kPrefix][keyFormat]\n      }\n\n      if (range.lte !== undefined) {\n        range.lte = this.prefixKey(range.lte, keyFormat)\n      } else if (range.lt !== undefined) {\n        range.lt = this.prefixKey(range.lt, keyFormat)\n      } else {\n        range.lte = this[kUpperBound][keyFormat]\n      }\n    }\n\n    get prefix () {\n      return this[kPrefix].utf8\n    }\n\n    get db () {\n      return this[kParent]\n    }\n\n    _open (options, callback) {\n      // The parent db must open itself or be (re)opened by the user because\n      // a sublevel should not initiate state changes on the rest of the db.\n      this[kParent].open({ passive: true }, callback)\n    }\n\n    _put (key, value, options, callback) {\n      this[kParent].put(key, value, options, callback)\n    }\n\n    _get (key, options, callback) {\n      this[kParent].get(key, options, callback)\n    }\n\n    _getMany (keys, options, callback) {\n      this[kParent].getMany(keys, options, callback)\n    }\n\n    _del (key, options, callback) {\n      this[kParent].del(key, options, callback)\n    }\n\n    _batch (operations, options, callback) {\n      this[kParent].batch(operations, options, callback)\n    }\n\n    _clear (options, callback) {\n      // TODO (refactor): move to AbstractLevel\n      this[kPrefixRange](options, options.keyEncoding)\n      this[kParent].clear(options, callback)\n    }\n\n    _iterator (options) {\n      // TODO (refactor): move to AbstractLevel\n      this[kPrefixRange](options, options.keyEncoding)\n      const iterator = this[kParent].iterator(options)\n      const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding)\n      return new AbstractSublevelIterator(this, options, iterator, unfix)\n    }\n\n    _keys (options) {\n      this[kPrefixRange](options, options.keyEncoding)\n      const iterator = this[kParent].keys(options)\n      const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding)\n      return new AbstractSublevelKeyIterator(this, options, iterator, unfix)\n    }\n\n    _values (options) {\n      this[kPrefixRange](options, options.keyEncoding)\n      const iterator = this[kParent].values(options)\n      return new AbstractSublevelValueIterator(this, options, iterator)\n    }\n  }\n\n  return { AbstractSublevel }\n}\n\nconst mergeManifests = function (parent, manifest) {\n  return {\n    // Inherit manifest of parent db\n    ...parent.supports,\n\n    // Disable unsupported features\n    createIfMissing: false,\n    errorIfExists: false,\n\n    // Unset additional events because we're not forwarding them\n    events: {},\n\n    // Unset additional methods (like approximateSize) which we can't support here unless\n    // the AbstractSublevel class is overridden by an implementation of `abstract-level`.\n    additionalMethods: {},\n\n    // Inherit manifest of custom AbstractSublevel subclass. Such a class is not\n    // allowed to override encodings.\n    ...manifest,\n\n    encodings: {\n      utf8: supportsEncoding(parent, 'utf8'),\n      buffer: supportsEncoding(parent, 'buffer'),\n      view: supportsEncoding(parent, 'view')\n    }\n  }\n}\n\nconst supportsEncoding = function (parent, encoding) {\n  // Prefer a non-transcoded encoding for optimal performance\n  return parent.supports.encodings[encoding]\n    ? parent.keyEncoding(encoding).name === encoding\n    : false\n}\n\nclass MultiFormat {\n  constructor (key) {\n    this.utf8 = key\n    this.view = textEncoder.encode(key)\n    this.buffer = Buffer ? Buffer.from(this.view.buffer, 0, this.view.byteLength) : {}\n  }\n}\n\nclass Unfixer {\n  constructor () {\n    this.cache = new Map()\n  }\n\n  get (prefixLength, keyFormat) {\n    let unfix = this.cache.get(keyFormat)\n\n    if (unfix === undefined) {\n      if (keyFormat === 'view') {\n        unfix = function (prefixLength, key) {\n          // Avoid Uint8Array#slice() because it copies\n          return key.subarray(prefixLength)\n        }.bind(null, prefixLength)\n      } else {\n        unfix = function (prefixLength, key) {\n          // Avoid Buffer#subarray() because it's slow\n          return key.slice(prefixLength)\n        }.bind(null, prefixLength)\n      }\n\n      this.cache.set(keyFormat, unfix)\n    }\n\n    return unfix\n  }\n}\n\nconst trim = function (str, char) {\n  let start = 0\n  let end = str.length\n\n  while (start < end && str[start] === char) start++\n  while (end > start && str[end - 1] === char) end--\n\n  return str.slice(start, end)\n}\n"]},"metadata":{},"sourceType":"script"}