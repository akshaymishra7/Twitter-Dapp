{"ast":null,"code":"import { CodeError } from '@libp2p/interfaces/errors';\nimport * as secp from '@noble/secp256k1';\nimport { sha256 } from 'multiformats/hashes/sha2';\nconst PRIVATE_KEY_BYTE_LENGTH = 32;\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength };\nexport function generateKey() {\n  return secp.utils.randomPrivateKey();\n}\n/**\n * Hash and sign message with private key\n */\n\nexport async function hashAndSign(key, msg) {\n  const {\n    digest\n  } = await sha256.digest(msg);\n\n  try {\n    return await secp.sign(digest, key);\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_INPUT');\n  }\n}\n/**\n * Hash message and verify signature with public key\n */\n\nexport async function hashAndVerify(key, sig, msg) {\n  try {\n    const {\n      digest\n    } = await sha256.digest(msg);\n    return secp.verify(sig, digest, key);\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_INPUT');\n  }\n}\nexport function compressPublicKey(key) {\n  const point = secp.Point.fromHex(key).toRawBytes(true);\n  return point;\n}\nexport function decompressPublicKey(key) {\n  const point = secp.Point.fromHex(key).toRawBytes(false);\n  return point;\n}\nexport function validatePrivateKey(key) {\n  try {\n    secp.getPublicKey(key, true);\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY');\n  }\n}\nexport function validatePublicKey(key) {\n  try {\n    secp.Point.fromHex(key);\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PUBLIC_KEY');\n  }\n}\nexport function computePublicKey(privateKey) {\n  try {\n    return secp.getPublicKey(privateKey, true);\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY');\n  }\n}","map":{"version":3,"mappings":"AAAA,SAASA,SAAT,QAA0B,2BAA1B;AACA,OAAO,KAAKC,IAAZ,MAAsB,kBAAtB;AACA,SAASC,MAAT,QAAuB,0BAAvB;AAEA,MAAMC,uBAAuB,GAAG,EAAhC;AAEA,SAASA,uBAAuB,IAAIC,gBAApC;AAEA,OAAM,SAAUC,WAAV,GAAqB;AACzB,SAAOJ,IAAI,CAACK,KAAL,CAAWC,gBAAX,EAAP;AACD;AAED;;;;AAGA,OAAO,eAAeC,WAAf,CAA4BC,GAA5B,EAA6CC,GAA7C,EAA4D;AACjE,QAAM;AAAEC;AAAF,MAAa,MAAMT,MAAM,CAACS,MAAP,CAAcD,GAAd,CAAzB;;AACA,MAAI;AACF,WAAO,MAAMT,IAAI,CAACW,IAAL,CAAUD,MAAV,EAAkBF,GAAlB,CAAb;AACD,GAFD,CAEE,OAAOI,GAAP,EAAY;AACZ,UAAM,IAAIb,SAAJ,CAAcc,MAAM,CAACD,GAAD,CAApB,EAA2B,mBAA3B,CAAN;AACD;AACF;AAED;;;;AAGA,OAAO,eAAeE,aAAf,CAA8BN,GAA9B,EAA+CO,GAA/C,EAAgEN,GAAhE,EAA+E;AACpF,MAAI;AACF,UAAM;AAAEC;AAAF,QAAa,MAAMT,MAAM,CAACS,MAAP,CAAcD,GAAd,CAAzB;AACA,WAAOT,IAAI,CAACgB,MAAL,CAAYD,GAAZ,EAAiBL,MAAjB,EAAyBF,GAAzB,CAAP;AACD,GAHD,CAGE,OAAOI,GAAP,EAAY;AACZ,UAAM,IAAIb,SAAJ,CAAcc,MAAM,CAACD,GAAD,CAApB,EAA2B,mBAA3B,CAAN;AACD;AACF;AAED,OAAM,SAAUK,iBAAV,CAA6BT,GAA7B,EAA4C;AAChD,QAAMU,KAAK,GAAGlB,IAAI,CAACmB,KAAL,CAAWC,OAAX,CAAmBZ,GAAnB,EAAwBa,UAAxB,CAAmC,IAAnC,CAAd;AACA,SAAOH,KAAP;AACD;AAED,OAAM,SAAUI,mBAAV,CAA+Bd,GAA/B,EAA8C;AAClD,QAAMU,KAAK,GAAGlB,IAAI,CAACmB,KAAL,CAAWC,OAAX,CAAmBZ,GAAnB,EAAwBa,UAAxB,CAAmC,KAAnC,CAAd;AACA,SAAOH,KAAP;AACD;AAED,OAAM,SAAUK,kBAAV,CAA8Bf,GAA9B,EAA6C;AACjD,MAAI;AACFR,QAAI,CAACwB,YAAL,CAAkBhB,GAAlB,EAAuB,IAAvB;AACD,GAFD,CAEE,OAAOI,GAAP,EAAY;AACZ,UAAM,IAAIb,SAAJ,CAAcc,MAAM,CAACD,GAAD,CAApB,EAA2B,yBAA3B,CAAN;AACD;AACF;AAED,OAAM,SAAUa,iBAAV,CAA6BjB,GAA7B,EAA4C;AAChD,MAAI;AACFR,QAAI,CAACmB,KAAL,CAAWC,OAAX,CAAmBZ,GAAnB;AACD,GAFD,CAEE,OAAOI,GAAP,EAAY;AACZ,UAAM,IAAIb,SAAJ,CAAcc,MAAM,CAACD,GAAD,CAApB,EAA2B,wBAA3B,CAAN;AACD;AACF;AAED,OAAM,SAAUc,gBAAV,CAA4BC,UAA5B,EAAkD;AACtD,MAAI;AACF,WAAO3B,IAAI,CAACwB,YAAL,CAAkBG,UAAlB,EAA8B,IAA9B,CAAP;AACD,GAFD,CAEE,OAAOf,GAAP,EAAY;AACZ,UAAM,IAAIb,SAAJ,CAAcc,MAAM,CAACD,GAAD,CAApB,EAA2B,yBAA3B,CAAN;AACD;AACF","names":["CodeError","secp","sha256","PRIVATE_KEY_BYTE_LENGTH","privateKeyLength","generateKey","utils","randomPrivateKey","hashAndSign","key","msg","digest","sign","err","String","hashAndVerify","sig","verify","compressPublicKey","point","Point","fromHex","toRawBytes","decompressPublicKey","validatePrivateKey","getPublicKey","validatePublicKey","computePublicKey","privateKey"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\crypto\\src\\keys\\secp256k1.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport * as secp from '@noble/secp256k1'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\nconst PRIVATE_KEY_BYTE_LENGTH = 32\n\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\nexport function generateKey (): Uint8Array {\n  return secp.utils.randomPrivateKey()\n}\n\n/**\n * Hash and sign message with private key\n */\nexport async function hashAndSign (key: Uint8Array, msg: Uint8Array): Promise<Uint8Array> {\n  const { digest } = await sha256.digest(msg)\n  try {\n    return await secp.sign(digest, key)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_INPUT')\n  }\n}\n\n/**\n * Hash message and verify signature with public key\n */\nexport async function hashAndVerify (key: Uint8Array, sig: Uint8Array, msg: Uint8Array): Promise<boolean> {\n  try {\n    const { digest } = await sha256.digest(msg)\n    return secp.verify(sig, digest, key)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_INPUT')\n  }\n}\n\nexport function compressPublicKey (key: Uint8Array): Uint8Array {\n  const point = secp.Point.fromHex(key).toRawBytes(true)\n  return point\n}\n\nexport function decompressPublicKey (key: Uint8Array): Uint8Array {\n  const point = secp.Point.fromHex(key).toRawBytes(false)\n  return point\n}\n\nexport function validatePrivateKey (key: Uint8Array): void {\n  try {\n    secp.getPublicKey(key, true)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY')\n  }\n}\n\nexport function validatePublicKey (key: Uint8Array): void {\n  try {\n    secp.Point.fromHex(key)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PUBLIC_KEY')\n  }\n}\n\nexport function computePublicKey (privateKey: Uint8Array): Uint8Array {\n  try {\n    return secp.getPublicKey(privateKey, true)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY')\n  }\n}\n"]},"metadata":{},"sourceType":"module"}