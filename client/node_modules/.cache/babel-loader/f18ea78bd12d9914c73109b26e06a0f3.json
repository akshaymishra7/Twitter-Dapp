{"ast":null,"code":"import { abortableSource } from 'abortable-iterator';\nimport { pushable } from 'it-pushable';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { MAX_MSG_SIZE } from './decode.js';\nimport { anySignal } from 'any-signal';\nimport { InitiatorMessageTypes, ReceiverMessageTypes } from './message-types.js';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:mplex:stream');\nconst ERR_STREAM_RESET = 'ERR_STREAM_RESET';\nconst ERR_STREAM_ABORT = 'ERR_STREAM_ABORT';\nconst ERR_SINK_ENDED = 'ERR_SINK_ENDED';\nconst ERR_DOUBLE_SINK = 'ERR_DOUBLE_SINK';\nexport function createStream(options) {\n  const {\n    id,\n    name,\n    send,\n    onEnd,\n    type = 'initiator',\n    maxMsgSize = MAX_MSG_SIZE\n  } = options;\n  const abortController = new AbortController();\n  const resetController = new AbortController();\n  const closeController = new AbortController();\n  const Types = type === 'initiator' ? InitiatorMessageTypes : ReceiverMessageTypes;\n  const externalId = type === 'initiator' ? `i${id}` : `r${id}`;\n  const streamName = `${name == null ? id : name}`;\n  let sourceEnded = false;\n  let sinkEnded = false;\n  let sinkSunk = false;\n  let endErr;\n  const timeline = {\n    open: Date.now()\n  };\n\n  const onSourceEnd = err => {\n    if (sourceEnded) {\n      return;\n    }\n\n    sourceEnded = true;\n    log.trace('%s stream %s source end - err: %o', type, streamName, err);\n\n    if (err != null && endErr == null) {\n      endErr = err;\n    }\n\n    if (sinkEnded) {\n      stream.stat.timeline.close = Date.now();\n\n      if (onEnd != null) {\n        onEnd(endErr);\n      }\n    }\n  };\n\n  const onSinkEnd = err => {\n    if (sinkEnded) {\n      return;\n    }\n\n    sinkEnded = true;\n    log.trace('%s stream %s sink end - err: %o', type, streamName, err);\n\n    if (err != null && endErr == null) {\n      endErr = err;\n    }\n\n    if (sourceEnded) {\n      timeline.close = Date.now();\n\n      if (onEnd != null) {\n        onEnd(endErr);\n      }\n    }\n  };\n\n  const streamSource = pushable({\n    onEnd: onSourceEnd\n  });\n  const stream = {\n    // Close for both Reading and Writing\n    close: () => {\n      log.trace('%s stream %s close', type, streamName);\n      stream.closeRead();\n      stream.closeWrite();\n    },\n    // Close for reading\n    closeRead: () => {\n      log.trace('%s stream %s closeRead', type, streamName);\n\n      if (sourceEnded) {\n        return;\n      }\n\n      streamSource.end();\n    },\n    // Close for writing\n    closeWrite: () => {\n      log.trace('%s stream %s closeWrite', type, streamName);\n\n      if (sinkEnded) {\n        return;\n      }\n\n      closeController.abort();\n\n      try {\n        send({\n          id,\n          type: Types.CLOSE\n        });\n      } catch (err) {\n        log.trace('%s stream %s error sending close', type, name, err);\n      }\n\n      onSinkEnd();\n    },\n    // Close for reading and writing (local error)\n    abort: err => {\n      log.trace('%s stream %s abort', type, streamName, err); // End the source with the passed error\n\n      streamSource.end(err);\n      abortController.abort();\n      onSinkEnd(err);\n    },\n    // Close immediately for reading and writing (remote error)\n    reset: () => {\n      const err = new CodeError('stream reset', ERR_STREAM_RESET);\n      resetController.abort();\n      streamSource.end(err);\n      onSinkEnd(err);\n    },\n    sink: async source => {\n      if (sinkSunk) {\n        throw new CodeError('sink already called on stream', ERR_DOUBLE_SINK);\n      }\n\n      sinkSunk = true;\n\n      if (sinkEnded) {\n        throw new CodeError('stream closed for writing', ERR_SINK_ENDED);\n      }\n\n      const signal = anySignal([abortController.signal, resetController.signal, closeController.signal]);\n\n      try {\n        source = abortableSource(source, signal);\n\n        if (type === 'initiator') {\n          // If initiator, open a new stream\n          send({\n            id,\n            type: InitiatorMessageTypes.NEW_STREAM,\n            data: new Uint8ArrayList(uint8ArrayFromString(streamName))\n          });\n        }\n\n        for await (let data of source) {\n          while (data.length > 0) {\n            if (data.length <= maxMsgSize) {\n              send({\n                id,\n                type: Types.MESSAGE,\n                data: data instanceof Uint8Array ? new Uint8ArrayList(data) : data\n              });\n              break;\n            }\n\n            data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;\n            send({\n              id,\n              type: Types.MESSAGE,\n              data: data.sublist(0, maxMsgSize)\n            });\n            data.consume(maxMsgSize);\n          }\n        }\n      } catch (err) {\n        if (err.type === 'aborted' && err.message === 'The operation was aborted') {\n          if (closeController.signal.aborted) {\n            return;\n          }\n\n          if (resetController.signal.aborted) {\n            err.message = 'stream reset';\n            err.code = ERR_STREAM_RESET;\n          }\n\n          if (abortController.signal.aborted) {\n            err.message = 'stream aborted';\n            err.code = ERR_STREAM_ABORT;\n          }\n        } // Send no more data if this stream was remotely reset\n\n\n        if (err.code === ERR_STREAM_RESET) {\n          log.trace('%s stream %s reset', type, name);\n        } else {\n          log.trace('%s stream %s error', type, name, err);\n\n          try {\n            send({\n              id,\n              type: Types.RESET\n            });\n          } catch (err) {\n            log.trace('%s stream %s error sending reset', type, name, err);\n          }\n        }\n\n        streamSource.end(err);\n        onSinkEnd(err);\n        return;\n      } finally {\n        signal.clear();\n      }\n\n      try {\n        send({\n          id,\n          type: Types.CLOSE\n        });\n      } catch (err) {\n        log.trace('%s stream %s error sending close', type, name, err);\n      }\n\n      onSinkEnd();\n    },\n    source: streamSource,\n    sourcePush: data => {\n      streamSource.push(data);\n    },\n\n    sourceReadableLength() {\n      return streamSource.readableLength;\n    },\n\n    stat: {\n      direction: type === 'initiator' ? 'outbound' : 'inbound',\n      timeline\n    },\n    metadata: {},\n    id: externalId\n  };\n  return stream;\n}","map":{"version":3,"mappings":"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","names":["abortableSource","pushable","CodeError","MAX_MSG_SIZE","anySignal","InitiatorMessageTypes","ReceiverMessageTypes","fromString","uint8ArrayFromString","Uint8ArrayList","logger","log","ERR_STREAM_RESET","ERR_STREAM_ABORT","ERR_SINK_ENDED","ERR_DOUBLE_SINK","createStream","options","id","name","send","onEnd","type","maxMsgSize","abortController","AbortController","resetController","closeController","Types","externalId","streamName","sourceEnded","sinkEnded","sinkSunk","endErr","timeline","open","Date","now","onSourceEnd","err","trace","stream","stat","close","onSinkEnd","streamSource","closeRead","closeWrite","end","abort","CLOSE","reset","sink","source","signal","NEW_STREAM","data","length","MESSAGE","Uint8Array","sublist","consume","message","aborted","code","RESET","clear","sourcePush","push","sourceReadableLength","readableLength","direction","metadata"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\mplex\\src\\stream.ts"],"sourcesContent":["import { abortableSource } from 'abortable-iterator'\nimport { pushable } from 'it-pushable'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { MAX_MSG_SIZE } from './decode.js'\nimport { anySignal } from 'any-signal'\nimport { InitiatorMessageTypes, ReceiverMessageTypes } from './message-types.js'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { logger } from '@libp2p/logger'\nimport type { Message } from './message-types.js'\nimport type { StreamTimeline } from '@libp2p/interface-connection'\nimport type { Source } from 'it-stream-types'\nimport type { MplexStream } from './mplex.js'\n\nconst log = logger('libp2p:mplex:stream')\n\nconst ERR_STREAM_RESET = 'ERR_STREAM_RESET'\nconst ERR_STREAM_ABORT = 'ERR_STREAM_ABORT'\nconst ERR_SINK_ENDED = 'ERR_SINK_ENDED'\nconst ERR_DOUBLE_SINK = 'ERR_DOUBLE_SINK'\n\nexport interface Options {\n  id: number\n  send: (msg: Message) => void\n  name?: string\n  onEnd?: (err?: Error) => void\n  type?: 'initiator' | 'receiver'\n  maxMsgSize?: number\n}\n\nexport function createStream (options: Options): MplexStream {\n  const { id, name, send, onEnd, type = 'initiator', maxMsgSize = MAX_MSG_SIZE } = options\n\n  const abortController = new AbortController()\n  const resetController = new AbortController()\n  const closeController = new AbortController()\n  const Types = type === 'initiator' ? InitiatorMessageTypes : ReceiverMessageTypes\n  const externalId = type === 'initiator' ? (`i${id}`) : `r${id}`\n  const streamName = `${name == null ? id : name}`\n\n  let sourceEnded = false\n  let sinkEnded = false\n  let sinkSunk = false\n  let endErr: Error | undefined\n\n  const timeline: StreamTimeline = {\n    open: Date.now()\n  }\n\n  const onSourceEnd = (err?: Error): void => {\n    if (sourceEnded) {\n      return\n    }\n\n    sourceEnded = true\n    log.trace('%s stream %s source end - err: %o', type, streamName, err)\n\n    if (err != null && endErr == null) {\n      endErr = err\n    }\n\n    if (sinkEnded) {\n      stream.stat.timeline.close = Date.now()\n\n      if (onEnd != null) {\n        onEnd(endErr)\n      }\n    }\n  }\n\n  const onSinkEnd = (err?: Error): void => {\n    if (sinkEnded) {\n      return\n    }\n\n    sinkEnded = true\n    log.trace('%s stream %s sink end - err: %o', type, streamName, err)\n\n    if (err != null && endErr == null) {\n      endErr = err\n    }\n\n    if (sourceEnded) {\n      timeline.close = Date.now()\n\n      if (onEnd != null) {\n        onEnd(endErr)\n      }\n    }\n  }\n\n  const streamSource = pushable<Uint8ArrayList>({\n    onEnd: onSourceEnd\n  })\n\n  const stream: MplexStream = {\n    // Close for both Reading and Writing\n    close: () => {\n      log.trace('%s stream %s close', type, streamName)\n\n      stream.closeRead()\n      stream.closeWrite()\n    },\n\n    // Close for reading\n    closeRead: () => {\n      log.trace('%s stream %s closeRead', type, streamName)\n\n      if (sourceEnded) {\n        return\n      }\n\n      streamSource.end()\n    },\n\n    // Close for writing\n    closeWrite: () => {\n      log.trace('%s stream %s closeWrite', type, streamName)\n\n      if (sinkEnded) {\n        return\n      }\n\n      closeController.abort()\n\n      try {\n        send({ id, type: Types.CLOSE })\n      } catch (err) {\n        log.trace('%s stream %s error sending close', type, name, err)\n      }\n\n      onSinkEnd()\n    },\n\n    // Close for reading and writing (local error)\n    abort: (err: Error) => {\n      log.trace('%s stream %s abort', type, streamName, err)\n      // End the source with the passed error\n      streamSource.end(err)\n      abortController.abort()\n      onSinkEnd(err)\n    },\n\n    // Close immediately for reading and writing (remote error)\n    reset: () => {\n      const err = new CodeError('stream reset', ERR_STREAM_RESET)\n      resetController.abort()\n      streamSource.end(err)\n      onSinkEnd(err)\n    },\n\n    sink: async (source: Source<Uint8ArrayList | Uint8Array>) => {\n      if (sinkSunk) {\n        throw new CodeError('sink already called on stream', ERR_DOUBLE_SINK)\n      }\n\n      sinkSunk = true\n\n      if (sinkEnded) {\n        throw new CodeError('stream closed for writing', ERR_SINK_ENDED)\n      }\n\n      const signal = anySignal([\n        abortController.signal,\n        resetController.signal,\n        closeController.signal\n      ])\n\n      try {\n        source = abortableSource(source, signal)\n\n        if (type === 'initiator') { // If initiator, open a new stream\n          send({ id, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(uint8ArrayFromString(streamName)) })\n        }\n\n        for await (let data of source) {\n          while (data.length > 0) {\n            if (data.length <= maxMsgSize) {\n              send({ id, type: Types.MESSAGE, data: data instanceof Uint8Array ? new Uint8ArrayList(data) : data })\n              break\n            }\n            data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data\n            send({ id, type: Types.MESSAGE, data: data.sublist(0, maxMsgSize) })\n            data.consume(maxMsgSize)\n          }\n        }\n      } catch (err: any) {\n        if (err.type === 'aborted' && err.message === 'The operation was aborted') {\n          if (closeController.signal.aborted) {\n            return\n          }\n\n          if (resetController.signal.aborted) {\n            err.message = 'stream reset'\n            err.code = ERR_STREAM_RESET\n          }\n\n          if (abortController.signal.aborted) {\n            err.message = 'stream aborted'\n            err.code = ERR_STREAM_ABORT\n          }\n        }\n\n        // Send no more data if this stream was remotely reset\n        if (err.code === ERR_STREAM_RESET) {\n          log.trace('%s stream %s reset', type, name)\n        } else {\n          log.trace('%s stream %s error', type, name, err)\n          try {\n            send({ id, type: Types.RESET })\n          } catch (err) {\n            log.trace('%s stream %s error sending reset', type, name, err)\n          }\n        }\n\n        streamSource.end(err)\n        onSinkEnd(err)\n        return\n      } finally {\n        signal.clear()\n      }\n\n      try {\n        send({ id, type: Types.CLOSE })\n      } catch (err) {\n        log.trace('%s stream %s error sending close', type, name, err)\n      }\n\n      onSinkEnd()\n    },\n\n    source: streamSource,\n\n    sourcePush: (data: Uint8ArrayList) => {\n      streamSource.push(data)\n    },\n\n    sourceReadableLength () {\n      return streamSource.readableLength\n    },\n\n    stat: {\n      direction: type === 'initiator' ? 'outbound' : 'inbound',\n      timeline\n    },\n\n    metadata: {},\n\n    id: externalId\n  }\n\n  return stream\n}\n"]},"metadata":{},"sourceType":"module"}