{"ast":null,"code":"'use strict';\n\nconst ModuleError = require('module-error');\n\nconst encodings = require('./lib/encodings');\n\nconst {\n  Encoding\n} = require('./lib/encoding');\n\nconst {\n  BufferFormat,\n  ViewFormat,\n  UTF8Format\n} = require('./lib/formats');\n\nconst kFormats = Symbol('formats');\nconst kEncodings = Symbol('encodings');\nconst validFormats = new Set(['buffer', 'view', 'utf8']);\n/** @template T */\n\nclass Transcoder {\n  /**\n   * @param {Array<'buffer'|'view'|'utf8'>} formats\n   */\n  constructor(formats) {\n    if (!Array.isArray(formats)) {\n      throw new TypeError(\"The first argument 'formats' must be an array\");\n    } else if (!formats.every(f => validFormats.has(f))) {\n      // Note: we only only support aliases in key- and valueEncoding options (where we already did)\n      throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\");\n    }\n    /** @type {Map<string|MixedEncoding<any, any, any>, Encoding<any, any, any>>} */\n\n\n    this[kEncodings] = new Map();\n    this[kFormats] = new Set(formats); // Register encodings (done early in order to populate encodings())\n\n    for (const k in encodings) {\n      try {\n        this.encoding(k);\n      } catch (err) {\n        /* istanbul ignore if: assertion */\n        if (err.code !== 'LEVEL_ENCODING_NOT_SUPPORTED') throw err;\n      }\n    }\n  }\n  /**\n   * @returns {Array<Encoding<any,T,any>>}\n   */\n\n\n  encodings() {\n    return Array.from(new Set(this[kEncodings].values()));\n  }\n  /**\n   * @param {string|MixedEncoding<any, any, any>} encoding\n   * @returns {Encoding<any, T, any>}\n   */\n\n\n  encoding(encoding) {\n    let resolved = this[kEncodings].get(encoding);\n\n    if (resolved === undefined) {\n      if (typeof encoding === 'string' && encoding !== '') {\n        resolved = lookup[encoding];\n\n        if (!resolved) {\n          throw new ModuleError(`Encoding '${encoding}' is not found`, {\n            code: 'LEVEL_ENCODING_NOT_FOUND'\n          });\n        }\n      } else if (typeof encoding !== 'object' || encoding === null) {\n        throw new TypeError(\"First argument 'encoding' must be a string or object\");\n      } else {\n        resolved = from(encoding);\n      }\n\n      const {\n        name,\n        format\n      } = resolved;\n\n      if (!this[kFormats].has(format)) {\n        if (this[kFormats].has('view')) {\n          resolved = resolved.createViewTranscoder();\n        } else if (this[kFormats].has('buffer')) {\n          resolved = resolved.createBufferTranscoder();\n        } else if (this[kFormats].has('utf8')) {\n          resolved = resolved.createUTF8Transcoder();\n        } else {\n          throw new ModuleError(`Encoding '${name}' cannot be transcoded`, {\n            code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n          });\n        }\n      }\n\n      for (const k of [encoding, name, resolved.name, resolved.commonName]) {\n        this[kEncodings].set(k, resolved);\n      }\n    }\n\n    return resolved;\n  }\n\n}\n\nexports.Transcoder = Transcoder;\n/**\n * @param {MixedEncoding<any, any, any>} options\n * @returns {Encoding<any, any, any>}\n */\n\nfunction from(options) {\n  if (options instanceof Encoding) {\n    return options;\n  } // Loosely typed for ecosystem compatibility\n\n\n  const maybeType = 'type' in options && typeof options.type === 'string' ? options.type : undefined;\n  const name = options.name || maybeType || `anonymous-${anonymousCount++}`;\n\n  switch (detectFormat(options)) {\n    case 'view':\n      return new ViewFormat({ ...options,\n        name\n      });\n\n    case 'utf8':\n      return new UTF8Format({ ...options,\n        name\n      });\n\n    case 'buffer':\n      return new BufferFormat({ ...options,\n        name\n      });\n\n    default:\n      {\n        throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\");\n      }\n  }\n}\n/**\n * If format is not provided, fallback to detecting `level-codec`\n * or `multiformats` encodings, else assume a format of buffer.\n * @param {MixedEncoding<any, any, any>} options\n * @returns {string}\n */\n\n\nfunction detectFormat(options) {\n  if ('format' in options && options.format !== undefined) {\n    return options.format;\n  } else if ('buffer' in options && typeof options.buffer === 'boolean') {\n    return options.buffer ? 'buffer' : 'utf8'; // level-codec\n  } else if ('code' in options && Number.isInteger(options.code)) {\n    return 'view'; // multiformats\n  } else {\n    return 'buffer';\n  }\n}\n/**\n * @typedef {import('./lib/encoding').MixedEncoding<TIn,TFormat,TOut>} MixedEncoding\n * @template TIn, TFormat, TOut\n */\n\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\n\n\nconst aliases = {\n  binary: encodings.buffer,\n  'utf-8': encodings.utf8\n};\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\n\nconst lookup = { ...encodings,\n  ...aliases\n};\nlet anonymousCount = 0;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/level-transcoder/index.js"],"names":["ModuleError","require","encodings","Encoding","BufferFormat","ViewFormat","UTF8Format","kFormats","Symbol","kEncodings","validFormats","Set","Transcoder","constructor","formats","Array","isArray","TypeError","every","f","has","Map","k","encoding","err","code","from","values","resolved","get","undefined","lookup","name","format","createViewTranscoder","createBufferTranscoder","createUTF8Transcoder","commonName","set","exports","options","maybeType","type","anonymousCount","detectFormat","buffer","Number","isInteger","aliases","binary","utf8"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ModuleError = require('module-error')\nconst encodings = require('./lib/encodings')\nconst { Encoding } = require('./lib/encoding')\nconst { BufferFormat, ViewFormat, UTF8Format } = require('./lib/formats')\n\nconst kFormats = Symbol('formats')\nconst kEncodings = Symbol('encodings')\nconst validFormats = new Set(['buffer', 'view', 'utf8'])\n\n/** @template T */\nclass Transcoder {\n  /**\n   * @param {Array<'buffer'|'view'|'utf8'>} formats\n   */\n  constructor (formats) {\n    if (!Array.isArray(formats)) {\n      throw new TypeError(\"The first argument 'formats' must be an array\")\n    } else if (!formats.every(f => validFormats.has(f))) {\n      // Note: we only only support aliases in key- and valueEncoding options (where we already did)\n      throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\")\n    }\n\n    /** @type {Map<string|MixedEncoding<any, any, any>, Encoding<any, any, any>>} */\n    this[kEncodings] = new Map()\n    this[kFormats] = new Set(formats)\n\n    // Register encodings (done early in order to populate encodings())\n    for (const k in encodings) {\n      try {\n        this.encoding(k)\n      } catch (err) {\n        /* istanbul ignore if: assertion */\n        if (err.code !== 'LEVEL_ENCODING_NOT_SUPPORTED') throw err\n      }\n    }\n  }\n\n  /**\n   * @returns {Array<Encoding<any,T,any>>}\n   */\n  encodings () {\n    return Array.from(new Set(this[kEncodings].values()))\n  }\n\n  /**\n   * @param {string|MixedEncoding<any, any, any>} encoding\n   * @returns {Encoding<any, T, any>}\n   */\n  encoding (encoding) {\n    let resolved = this[kEncodings].get(encoding)\n\n    if (resolved === undefined) {\n      if (typeof encoding === 'string' && encoding !== '') {\n        resolved = lookup[encoding]\n\n        if (!resolved) {\n          throw new ModuleError(`Encoding '${encoding}' is not found`, {\n            code: 'LEVEL_ENCODING_NOT_FOUND'\n          })\n        }\n      } else if (typeof encoding !== 'object' || encoding === null) {\n        throw new TypeError(\"First argument 'encoding' must be a string or object\")\n      } else {\n        resolved = from(encoding)\n      }\n\n      const { name, format } = resolved\n\n      if (!this[kFormats].has(format)) {\n        if (this[kFormats].has('view')) {\n          resolved = resolved.createViewTranscoder()\n        } else if (this[kFormats].has('buffer')) {\n          resolved = resolved.createBufferTranscoder()\n        } else if (this[kFormats].has('utf8')) {\n          resolved = resolved.createUTF8Transcoder()\n        } else {\n          throw new ModuleError(`Encoding '${name}' cannot be transcoded`, {\n            code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n          })\n        }\n      }\n\n      for (const k of [encoding, name, resolved.name, resolved.commonName]) {\n        this[kEncodings].set(k, resolved)\n      }\n    }\n\n    return resolved\n  }\n}\n\nexports.Transcoder = Transcoder\n\n/**\n * @param {MixedEncoding<any, any, any>} options\n * @returns {Encoding<any, any, any>}\n */\nfunction from (options) {\n  if (options instanceof Encoding) {\n    return options\n  }\n\n  // Loosely typed for ecosystem compatibility\n  const maybeType = 'type' in options && typeof options.type === 'string' ? options.type : undefined\n  const name = options.name || maybeType || `anonymous-${anonymousCount++}`\n\n  switch (detectFormat(options)) {\n    case 'view': return new ViewFormat({ ...options, name })\n    case 'utf8': return new UTF8Format({ ...options, name })\n    case 'buffer': return new BufferFormat({ ...options, name })\n    default: {\n      throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\")\n    }\n  }\n}\n\n/**\n * If format is not provided, fallback to detecting `level-codec`\n * or `multiformats` encodings, else assume a format of buffer.\n * @param {MixedEncoding<any, any, any>} options\n * @returns {string}\n */\nfunction detectFormat (options) {\n  if ('format' in options && options.format !== undefined) {\n    return options.format\n  } else if ('buffer' in options && typeof options.buffer === 'boolean') {\n    return options.buffer ? 'buffer' : 'utf8' // level-codec\n  } else if ('code' in options && Number.isInteger(options.code)) {\n    return 'view' // multiformats\n  } else {\n    return 'buffer'\n  }\n}\n\n/**\n * @typedef {import('./lib/encoding').MixedEncoding<TIn,TFormat,TOut>} MixedEncoding\n * @template TIn, TFormat, TOut\n */\n\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\nconst aliases = {\n  binary: encodings.buffer,\n  'utf-8': encodings.utf8\n}\n\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\nconst lookup = {\n  ...encodings,\n  ...aliases\n}\n\nlet anonymousCount = 0\n"]},"metadata":{},"sourceType":"script"}