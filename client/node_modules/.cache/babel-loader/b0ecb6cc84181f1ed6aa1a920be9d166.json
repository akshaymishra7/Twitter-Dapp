{"ast":null,"code":"import { randomBytes } from '@libp2p/crypto';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { peerIdFromBytes, peerIdFromKeys } from '@libp2p/peer-id';\nimport { codes } from './errors.js';\nimport { CodeError } from '@libp2p/interfaces/errors';\n/**\n * Generate a random sequence number\n */\n\nexport function randomSeqno() {\n  return BigInt(`0x${uint8ArrayToString(randomBytes(8), 'base16')}`);\n}\n/**\n * Generate a message id, based on the `key` and `seqno`\n */\n\nexport const msgId = (key, seqno) => {\n  const seqnoBytes = uint8ArrayFromString(seqno.toString(16).padStart(16, '0'), 'base16');\n  const msgId = new Uint8Array(key.length + seqnoBytes.length);\n  msgId.set(key, 0);\n  msgId.set(seqnoBytes, key.length);\n  return msgId;\n};\n/**\n * Generate a message id, based on message `data`\n */\n\nexport const noSignMsgId = data => {\n  return sha256.encode(data);\n};\n/**\n * Check if any member of the first set is also a member\n * of the second set\n */\n\nexport const anyMatch = (a, b) => {\n  let bHas;\n\n  if (Array.isArray(b)) {\n    bHas = val => b.includes(val);\n  } else {\n    bHas = val => b.has(val);\n  }\n\n  for (const val of a) {\n    if (bHas(val)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Make everything an array\n */\n\nexport const ensureArray = function (maybeArray) {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray];\n  }\n\n  return maybeArray;\n};\n\nconst isSigned = async message => {\n  if (message.sequenceNumber == null || message.from == null || message.signature == null) {\n    return false;\n  } // if a public key is present in the `from` field, the message should be signed\n\n\n  const fromID = peerIdFromBytes(message.from);\n\n  if (fromID.publicKey != null) {\n    return true;\n  }\n\n  if (message.key != null) {\n    const signingID = await peerIdFromKeys(message.key);\n    return signingID.equals(fromID);\n  }\n\n  return false;\n};\n\nexport const toMessage = async message => {\n  if (message.from == null) {\n    throw new CodeError('RPC message was missing from', codes.ERR_MISSING_FROM);\n  }\n\n  if (!(await isSigned(message))) {\n    return {\n      type: 'unsigned',\n      topic: message.topic ?? '',\n      data: message.data ?? new Uint8Array(0)\n    };\n  }\n\n  const from = peerIdFromBytes(message.from);\n  const msg = {\n    type: 'signed',\n    from: peerIdFromBytes(message.from),\n    topic: message.topic ?? '',\n    sequenceNumber: bigIntFromBytes(message.sequenceNumber ?? new Uint8Array(0)),\n    data: message.data ?? new Uint8Array(0),\n    signature: message.signature ?? new Uint8Array(0),\n    key: message.key ?? from.publicKey ?? new Uint8Array(0)\n  };\n\n  if (msg.key.length === 0) {\n    throw new CodeError('Signed RPC message was missing key', codes.ERR_MISSING_KEY);\n  }\n\n  return msg;\n};\nexport const toRpcMessage = message => {\n  if (message.type === 'signed') {\n    return {\n      from: message.from.multihash.bytes,\n      data: message.data,\n      sequenceNumber: bigIntToBytes(message.sequenceNumber),\n      topic: message.topic,\n      signature: message.signature,\n      key: message.key\n    };\n  }\n\n  return {\n    data: message.data,\n    topic: message.topic\n  };\n};\nexport const bigIntToBytes = num => {\n  let str = num.toString(16);\n\n  if (str.length % 2 !== 0) {\n    str = `0${str}`;\n  }\n\n  return uint8ArrayFromString(str, 'base16');\n};\nexport const bigIntFromBytes = num => {\n  return BigInt(`0x${uint8ArrayToString(num, 'base16')}`);\n};","map":{"version":3,"mappings":"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","names":["randomBytes","fromString","uint8ArrayFromString","toString","uint8ArrayToString","sha256","peerIdFromBytes","peerIdFromKeys","codes","CodeError","randomSeqno","BigInt","msgId","key","seqno","seqnoBytes","padStart","Uint8Array","length","set","noSignMsgId","data","encode","anyMatch","a","b","bHas","Array","isArray","val","includes","has","ensureArray","maybeArray","isSigned","message","sequenceNumber","from","signature","fromID","publicKey","signingID","equals","toMessage","ERR_MISSING_FROM","type","topic","msg","bigIntFromBytes","ERR_MISSING_KEY","toRpcMessage","multihash","bytes","bigIntToBytes","num","str"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\pubsub\\src\\utils.ts"],"sourcesContent":["import { randomBytes } from '@libp2p/crypto'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport type { Message, PubSubRPCMessage } from '@libp2p/interface-pubsub'\nimport { peerIdFromBytes, peerIdFromKeys } from '@libp2p/peer-id'\nimport { codes } from './errors.js'\nimport { CodeError } from '@libp2p/interfaces/errors'\n\n/**\n * Generate a random sequence number\n */\nexport function randomSeqno (): bigint {\n  return BigInt(`0x${uint8ArrayToString(randomBytes(8), 'base16')}`)\n}\n\n/**\n * Generate a message id, based on the `key` and `seqno`\n */\nexport const msgId = (key: Uint8Array, seqno: bigint): Uint8Array => {\n  const seqnoBytes = uint8ArrayFromString(seqno.toString(16).padStart(16, '0'), 'base16')\n\n  const msgId = new Uint8Array(key.length + seqnoBytes.length)\n  msgId.set(key, 0)\n  msgId.set(seqnoBytes, key.length)\n\n  return msgId\n}\n\n/**\n * Generate a message id, based on message `data`\n */\nexport const noSignMsgId = (data: Uint8Array): Uint8Array | Promise<Uint8Array> => {\n  return sha256.encode(data)\n}\n\n/**\n * Check if any member of the first set is also a member\n * of the second set\n */\nexport const anyMatch = (a: Set<number> | number[], b: Set<number> | number[]): boolean => {\n  let bHas\n  if (Array.isArray(b)) {\n    bHas = (val: number) => b.includes(val)\n  } else {\n    bHas = (val: number) => b.has(val)\n  }\n\n  for (const val of a) {\n    if (bHas(val)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Make everything an array\n */\nexport const ensureArray = function <T> (maybeArray: T | T[]): T[] {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray]\n  }\n\n  return maybeArray\n}\n\nconst isSigned = async (message: PubSubRPCMessage): Promise<boolean> => {\n  if ((message.sequenceNumber == null) || (message.from == null) || (message.signature == null)) {\n    return false\n  }\n  // if a public key is present in the `from` field, the message should be signed\n  const fromID = peerIdFromBytes(message.from)\n  if (fromID.publicKey != null) {\n    return true\n  }\n\n  if (message.key != null) {\n    const signingID = await peerIdFromKeys(message.key)\n    return signingID.equals(fromID)\n  }\n\n  return false\n}\n\nexport const toMessage = async (message: PubSubRPCMessage): Promise<Message> => {\n  if (message.from == null) {\n    throw new CodeError('RPC message was missing from', codes.ERR_MISSING_FROM)\n  }\n\n  if (!await isSigned(message)) {\n    return {\n      type: 'unsigned',\n      topic: message.topic ?? '',\n      data: message.data ?? new Uint8Array(0)\n    }\n  }\n\n  const from = peerIdFromBytes(message.from)\n\n  const msg: Message = {\n    type: 'signed',\n    from: peerIdFromBytes(message.from),\n    topic: message.topic ?? '',\n    sequenceNumber: bigIntFromBytes(message.sequenceNumber ?? new Uint8Array(0)),\n    data: message.data ?? new Uint8Array(0),\n    signature: message.signature ?? new Uint8Array(0),\n    key: message.key ?? from.publicKey ?? new Uint8Array(0)\n  }\n\n  if (msg.key.length === 0) {\n    throw new CodeError('Signed RPC message was missing key', codes.ERR_MISSING_KEY)\n  }\n\n  return msg\n}\n\nexport const toRpcMessage = (message: Message): PubSubRPCMessage => {\n  if (message.type === 'signed') {\n    return {\n      from: message.from.multihash.bytes,\n      data: message.data,\n      sequenceNumber: bigIntToBytes(message.sequenceNumber),\n      topic: message.topic,\n      signature: message.signature,\n      key: message.key\n    }\n  }\n\n  return {\n    data: message.data,\n    topic: message.topic\n  }\n}\n\nexport const bigIntToBytes = (num: bigint): Uint8Array => {\n  let str = num.toString(16)\n\n  if (str.length % 2 !== 0) {\n    str = `0${str}`\n  }\n\n  return uint8ArrayFromString(str, 'base16')\n}\n\nexport const bigIntFromBytes = (num: Uint8Array): bigint => {\n  return BigInt(`0x${uint8ArrayToString(num, 'base16')}`)\n}\n"]},"metadata":{},"sourceType":"module"}