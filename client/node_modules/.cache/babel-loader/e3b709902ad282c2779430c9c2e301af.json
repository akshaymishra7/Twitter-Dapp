{"ast":null,"code":"import errCode from 'err-code';\nimport filter from 'it-filter';\nimport map from 'it-map';\n/**\n * Store the multiaddrs from every peer in the passed peer store\n */\n\nexport async function* storeAddresses(source, peerStore) {\n  yield* map(source, async peer => {\n    // ensure we have the addresses for a given peer\n    await peerStore.addressBook.add(peer.id, peer.multiaddrs);\n    return peer;\n  });\n}\n/**\n * Filter peers by unique peer id\n */\n\nexport function uniquePeers(source) {\n  /** @type Set<string> */\n  const seen = new Set();\n  return filter(source, peer => {\n    // dedupe by peer id\n    if (seen.has(peer.id.toString())) {\n      return false;\n    }\n\n    seen.add(peer.id.toString());\n    return true;\n  });\n}\n/**\n * Require at least `min` peers to be yielded from `source`\n */\n\nexport async function* requirePeers(source) {\n  let min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let seen = 0;\n\n  for await (const peer of source) {\n    seen++;\n    yield peer;\n  }\n\n  if (seen < min) {\n    throw errCode(new Error('not found'), 'NOT_FOUND');\n  }\n}","map":{"version":3,"mappings":"AAAA,OAAOA,OAAP,MAAoB,UAApB;AACA,OAAOC,MAAP,MAAmB,WAAnB;AACA,OAAOC,GAAP,MAAgB,QAAhB;AAKA;;;;AAGA,OAAO,gBAAiBC,cAAjB,CAAiCC,MAAjC,EAA2DC,SAA3D,EAA+E;AACpF,SAAQH,GAAG,CAACE,MAAD,EAAS,MAAOE,IAAP,IAAe;AACjC;AACA,UAAMD,SAAS,CAACE,WAAV,CAAsBC,GAAtB,CAA0BF,IAAI,CAACG,EAA/B,EAAmCH,IAAI,CAACI,UAAxC,CAAN;AAEA,WAAOJ,IAAP;AACD,GALU,CAAX;AAMD;AAED;;;;AAGA,OAAM,SAAUK,WAAV,CAAuBP,MAAvB,EAA+C;AACnD;AACA,QAAMQ,IAAI,GAAG,IAAIC,GAAJ,EAAb;AAEA,SAAOZ,MAAM,CAACG,MAAD,EAAUE,IAAD,IAAS;AAC7B;AACA,QAAIM,IAAI,CAACE,GAAL,CAASR,IAAI,CAACG,EAAL,CAAQM,QAAR,EAAT,CAAJ,EAAkC;AAChC,aAAO,KAAP;AACD;;AAEDH,QAAI,CAACJ,GAAL,CAASF,IAAI,CAACG,EAAL,CAAQM,QAAR,EAAT;AAEA,WAAO,IAAP;AACD,GATY,CAAb;AAUD;AAED;;;;AAGA,OAAO,gBAAiBC,YAAjB,CAA+BZ,MAA/B,EAAwE;AAAA,MAAfa,GAAe,uEAAD,CAAC;AAC7E,MAAIL,IAAI,GAAG,CAAX;;AAEA,aAAW,MAAMN,IAAjB,IAAyBF,MAAzB,EAAiC;AAC/BQ,QAAI;AAEJ,UAAMN,IAAN;AACD;;AAED,MAAIM,IAAI,GAAGK,GAAX,EAAgB;AACd,UAAMjB,OAAO,CAAC,IAAIkB,KAAJ,CAAU,WAAV,CAAD,EAAyB,WAAzB,CAAb;AACD;AACF","names":["errCode","filter","map","storeAddresses","source","peerStore","peer","addressBook","add","id","multiaddrs","uniquePeers","seen","Set","has","toString","requirePeers","min","Error"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\content-routing\\utils.ts"],"sourcesContent":["import errCode from 'err-code'\nimport filter from 'it-filter'\nimport map from 'it-map'\nimport type { Source } from 'it-stream-types'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { PeerStore } from '@libp2p/interface-peer-store'\n\n/**\n * Store the multiaddrs from every peer in the passed peer store\n */\nexport async function * storeAddresses (source: Source<PeerInfo>, peerStore: PeerStore) {\n  yield * map(source, async (peer) => {\n    // ensure we have the addresses for a given peer\n    await peerStore.addressBook.add(peer.id, peer.multiaddrs)\n\n    return peer\n  })\n}\n\n/**\n * Filter peers by unique peer id\n */\nexport function uniquePeers (source: Source<PeerInfo>) {\n  /** @type Set<string> */\n  const seen = new Set()\n\n  return filter(source, (peer) => {\n    // dedupe by peer id\n    if (seen.has(peer.id.toString())) {\n      return false\n    }\n\n    seen.add(peer.id.toString())\n\n    return true\n  })\n}\n\n/**\n * Require at least `min` peers to be yielded from `source`\n */\nexport async function * requirePeers (source: Source<PeerInfo>, min: number = 1) {\n  let seen = 0\n\n  for await (const peer of source) {\n    seen++\n\n    yield peer\n  }\n\n  if (seen < min) {\n    throw errCode(new Error('not found'), 'NOT_FOUND')\n  }\n}\n"]},"metadata":{},"sourceType":"module"}