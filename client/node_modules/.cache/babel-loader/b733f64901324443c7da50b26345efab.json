{"ast":null,"code":"import { InvalidCryptoExchangeError, UnexpectedPeerError } from '@libp2p/interface-connection-encrypter/errors';\nimport { decode0, decode1, decode2, encode0, encode1, encode2 } from './encoder.js';\nimport { XX } from './handshakes/xx.js';\nimport { logger, logLocalStaticKeys, logLocalEphemeralKeys, logRemoteEphemeralKey, logRemoteStaticKey, logCipherState } from './logger.js';\nimport { decodePayload, getPeerIdFromPayload, verifySignedPayload } from './utils.js';\nexport class XXHandshake {\n  constructor(isInitiator, payload, prologue, crypto, staticKeypair, connection, remotePeer, handshake) {\n    this.remoteExtensions = {\n      webtransportCerthashes: []\n    };\n    this.isInitiator = isInitiator;\n    this.payload = payload;\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n\n    this.xx = handshake ?? new XX(crypto);\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n  } // stage 0\n\n\n  async propose() {\n    logLocalStaticKeys(this.session.hs.s);\n\n    if (this.isInitiator) {\n      logger.trace('Stage 0 - Initiator starting to send first message.');\n      const messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0));\n      this.connection.writeLP(encode0(messageBuffer));\n      logger.trace('Stage 0 - Initiator finished sending first message.');\n      logLocalEphemeralKeys(this.session.hs.e);\n    } else {\n      logger.trace('Stage 0 - Responder waiting to receive first message...');\n      const receivedMessageBuffer = decode0((await this.connection.readLP()).subarray());\n      const {\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new InvalidCryptoExchangeError('xx handshake stage 0 validation fail');\n      }\n\n      logger.trace('Stage 0 - Responder received first message.');\n      logRemoteEphemeralKey(this.session.hs.re);\n    }\n  } // stage 1\n\n\n  async exchange() {\n    if (this.isInitiator) {\n      logger.trace('Stage 1 - Initiator waiting to receive first message from responder...');\n      const receivedMessageBuffer = decode1((await this.connection.readLP()).subarray());\n      const {\n        plaintext,\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new InvalidCryptoExchangeError('xx handshake stage 1 validation fail');\n      }\n\n      logger.trace('Stage 1 - Initiator received the message.');\n      logRemoteEphemeralKey(this.session.hs.re);\n      logRemoteStaticKey(this.session.hs.rs);\n      logger.trace(\"Initiator going to check remote's signature...\");\n\n      try {\n        const decodedPayload = decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await getPeerIdFromPayload(decodedPayload));\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteNoiseExtension(decodedPayload.extensions);\n      } catch (e) {\n        const err = e;\n        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`);\n      }\n\n      logger.trace('All good with the signature!');\n    } else {\n      logger.trace('Stage 1 - Responder sending out first message with signed payload and static key.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode1(messageBuffer));\n      logger.trace('Stage 1 - Responder sent the second handshake message with signed payload.');\n      logLocalEphemeralKeys(this.session.hs.e);\n    }\n  } // stage 2\n\n\n  async finish() {\n    if (this.isInitiator) {\n      logger.trace('Stage 2 - Initiator sending third handshake message.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode2(messageBuffer));\n      logger.trace('Stage 2 - Initiator sent message with signed payload.');\n    } else {\n      logger.trace('Stage 2 - Responder waiting for third handshake message...');\n      const receivedMessageBuffer = decode2((await this.connection.readLP()).subarray());\n      const {\n        plaintext,\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new InvalidCryptoExchangeError('xx handshake stage 2 validation fail');\n      }\n\n      logger.trace('Stage 2 - Responder received the message, finished handshake.');\n\n      try {\n        const decodedPayload = decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await getPeerIdFromPayload(decodedPayload));\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteNoiseExtension(decodedPayload.extensions);\n      } catch (e) {\n        const err = e;\n        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`);\n      }\n    }\n\n    logCipherState(this.session);\n  }\n\n  encrypt(plaintext, session) {\n    const cs = this.getCS(session);\n    return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext);\n  }\n\n  decrypt(ciphertext, session, dst) {\n    const cs = this.getCS(session, false);\n    return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext, dst);\n  }\n\n  getRemoteStaticKey() {\n    return this.session.hs.rs;\n  }\n\n  getCS(session) {\n    let encryption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (!session.cs1 || !session.cs2) {\n      throw new InvalidCryptoExchangeError('Handshake not completed properly, cipher state does not exist.');\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  setRemoteNoiseExtension(e) {\n    if (e) {\n      this.remoteExtensions = e;\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["InvalidCryptoExchangeError","UnexpectedPeerError","decode0","decode1","decode2","encode0","encode1","encode2","XX","logger","logLocalStaticKeys","logLocalEphemeralKeys","logRemoteEphemeralKey","logRemoteStaticKey","logCipherState","decodePayload","getPeerIdFromPayload","verifySignedPayload","XXHandshake","constructor","isInitiator","payload","prologue","crypto","staticKeypair","connection","remotePeer","handshake","webtransportCerthashes","xx","session","initSession","propose","hs","s","trace","messageBuffer","sendMessage","Uint8Array","writeLP","e","receivedMessageBuffer","readLP","subarray","valid","recvMessage","re","exchange","plaintext","rs","decodedPayload","setRemoteNoiseExtension","extensions","err","message","finish","encrypt","cs","getCS","encryptWithAd","decrypt","ciphertext","dst","decryptWithAd","getRemoteStaticKey","encryption","cs1","cs2","remoteExtensions"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-noise\\src\\handshake-xx.ts"],"sourcesContent":["import type { PeerId } from '@libp2p/interface-peer-id'\nimport { InvalidCryptoExchangeError, UnexpectedPeerError } from '@libp2p/interface-connection-encrypter/errors'\nimport type { ProtobufStream } from 'it-pb-stream'\nimport type { bytes, bytes32 } from './@types/basic.js'\nimport type { CipherState, NoiseSession } from './@types/handshake.js'\nimport type { KeyPair } from './@types/libp2p.js'\nimport type { IHandshake } from './@types/handshake-interface.js'\nimport type { ICryptoInterface } from './crypto.js'\nimport { decode0, decode1, decode2, encode0, encode1, encode2 } from './encoder.js'\nimport { XX } from './handshakes/xx.js'\nimport {\n  logger,\n  logLocalStaticKeys,\n  logLocalEphemeralKeys,\n  logRemoteEphemeralKey,\n  logRemoteStaticKey,\n  logCipherState\n} from './logger.js'\nimport {\n  decodePayload,\n  getPeerIdFromPayload,\n  verifySignedPayload\n} from './utils.js'\nimport type { NoiseExtensions } from './proto/payload.js'\n\nexport class XXHandshake implements IHandshake {\n  public isInitiator: boolean\n  public session: NoiseSession\n  public remotePeer!: PeerId\n  public remoteExtensions: NoiseExtensions = { webtransportCerthashes: [] }\n\n  protected payload: bytes\n  protected connection: ProtobufStream\n  protected xx: XX\n  protected staticKeypair: KeyPair\n\n  private readonly prologue: bytes32\n\n  constructor (\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    crypto: ICryptoInterface,\n    staticKeypair: KeyPair,\n    connection: ProtobufStream,\n    remotePeer?: PeerId,\n    handshake?: XX\n  ) {\n    this.isInitiator = isInitiator\n    this.payload = payload\n    this.prologue = prologue\n    this.staticKeypair = staticKeypair\n    this.connection = connection\n    if (remotePeer) {\n      this.remotePeer = remotePeer\n    }\n    this.xx = handshake ?? new XX(crypto)\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair)\n  }\n\n  // stage 0\n  public async propose (): Promise<void> {\n    logLocalStaticKeys(this.session.hs.s)\n    if (this.isInitiator) {\n      logger.trace('Stage 0 - Initiator starting to send first message.')\n      const messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0))\n      this.connection.writeLP(encode0(messageBuffer))\n      logger.trace('Stage 0 - Initiator finished sending first message.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger.trace('Stage 0 - Responder waiting to receive first message...')\n      const receivedMessageBuffer = decode0((await this.connection.readLP()).subarray())\n      const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new InvalidCryptoExchangeError('xx handshake stage 0 validation fail')\n      }\n      logger.trace('Stage 0 - Responder received first message.')\n      logRemoteEphemeralKey(this.session.hs.re)\n    }\n  }\n\n  // stage 1\n  public async exchange (): Promise<void> {\n    if (this.isInitiator) {\n      logger.trace('Stage 1 - Initiator waiting to receive first message from responder...')\n      const receivedMessageBuffer = decode1((await this.connection.readLP()).subarray())\n      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new InvalidCryptoExchangeError('xx handshake stage 1 validation fail')\n      }\n      logger.trace('Stage 1 - Initiator received the message.')\n      logRemoteEphemeralKey(this.session.hs.re)\n      logRemoteStaticKey(this.session.hs.rs)\n\n      logger.trace(\"Initiator going to check remote's signature...\")\n      try {\n        const decodedPayload = decodePayload(plaintext)\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload)\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer)\n        this.setRemoteNoiseExtension(decodedPayload.extensions)\n      } catch (e) {\n        const err = e as Error\n        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`)\n      }\n      logger.trace('All good with the signature!')\n    } else {\n      logger.trace('Stage 1 - Responder sending out first message with signed payload and static key.')\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload)\n      this.connection.writeLP(encode1(messageBuffer))\n      logger.trace('Stage 1 - Responder sent the second handshake message with signed payload.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    }\n  }\n\n  // stage 2\n  public async finish (): Promise<void> {\n    if (this.isInitiator) {\n      logger.trace('Stage 2 - Initiator sending third handshake message.')\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload)\n      this.connection.writeLP(encode2(messageBuffer))\n      logger.trace('Stage 2 - Initiator sent message with signed payload.')\n    } else {\n      logger.trace('Stage 2 - Responder waiting for third handshake message...')\n      const receivedMessageBuffer = decode2((await this.connection.readLP()).subarray())\n      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new InvalidCryptoExchangeError('xx handshake stage 2 validation fail')\n      }\n      logger.trace('Stage 2 - Responder received the message, finished handshake.')\n\n      try {\n        const decodedPayload = decodePayload(plaintext)\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload)\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer)\n        this.setRemoteNoiseExtension(decodedPayload.extensions)\n      } catch (e) {\n        const err = e as Error\n        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`)\n      }\n    }\n    logCipherState(this.session)\n  }\n\n  public encrypt (plaintext: Uint8Array, session: NoiseSession): bytes {\n    const cs = this.getCS(session)\n\n    return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext)\n  }\n\n  public decrypt (ciphertext: Uint8Array, session: NoiseSession, dst?: Uint8Array): { plaintext: bytes, valid: boolean } {\n    const cs = this.getCS(session, false)\n\n    return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext, dst)\n  }\n\n  public getRemoteStaticKey (): bytes {\n    return this.session.hs.rs\n  }\n\n  private getCS (session: NoiseSession, encryption = true): CipherState {\n    if (!session.cs1 || !session.cs2) {\n      throw new InvalidCryptoExchangeError('Handshake not completed properly, cipher state does not exist.')\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2\n    } else {\n      return encryption ? session.cs2 : session.cs1\n    }\n  }\n\n  protected setRemoteNoiseExtension (e: NoiseExtensions | null | undefined): void {\n    if (e) {\n      this.remoteExtensions = e\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}