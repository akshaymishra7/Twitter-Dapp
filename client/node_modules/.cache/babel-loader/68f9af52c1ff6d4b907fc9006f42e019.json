{"ast":null,"code":"export class MessageCache {\n  /**\n   * Holds history of messages in timebounded history arrays\n   */\n  constructor(\n  /**\n   * The number of indices in the cache history used for gossiping. That means that a message\n   * won't get gossiped anymore when shift got called `gossip` many times after inserting the\n   * message in the cache.\n   */\n  gossip, historyCapacity, msgIdToStrFn) {\n    this.gossip = gossip;\n    this.msgs = new Map();\n    this.history = [];\n    /** Track with accounting of messages in the mcache that are not yet validated */\n\n    this.notValidatedCount = 0;\n    this.msgIdToStrFn = msgIdToStrFn;\n\n    for (let i = 0; i < historyCapacity; i++) {\n      this.history[i] = [];\n    }\n  }\n\n  get size() {\n    return this.msgs.size;\n  }\n  /**\n   * Adds a message to the current window and the cache\n   * Returns true if the message is not known and is inserted in the cache\n   */\n\n\n  put(messageId, msg) {\n    let validated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const {\n      msgIdStr\n    } = messageId; // Don't add duplicate entries to the cache.\n\n    if (this.msgs.has(msgIdStr)) {\n      return false;\n    }\n\n    this.msgs.set(msgIdStr, {\n      message: msg,\n      validated,\n      originatingPeers: new Set(),\n      iwantCounts: new Map()\n    });\n    this.history[0].push({ ...messageId,\n      topic: msg.topic\n    });\n\n    if (!validated) {\n      this.notValidatedCount++;\n    }\n\n    return true;\n  }\n\n  observeDuplicate(msgId, fromPeerIdStr) {\n    const entry = this.msgs.get(msgId);\n\n    if (entry && // if the message is already validated, we don't need to store extra peers sending us\n    // duplicates as the message has already been forwarded\n    !entry.validated) {\n      entry.originatingPeers.add(fromPeerIdStr);\n    }\n  }\n  /**\n   * Retrieves a message from the cache by its ID, if it is still present\n   */\n\n\n  get(msgId) {\n    return this.msgs.get(this.msgIdToStrFn(msgId))?.message;\n  }\n  /**\n   * Increases the iwant count for the given message by one and returns the message together\n   * with the iwant if the message exists.\n   */\n\n\n  getWithIWantCount(msgIdStr, p) {\n    const msg = this.msgs.get(msgIdStr);\n\n    if (!msg) {\n      return null;\n    }\n\n    const count = (msg.iwantCounts.get(p) ?? 0) + 1;\n    msg.iwantCounts.set(p, count);\n    return {\n      msg: msg.message,\n      count\n    };\n  }\n  /**\n   * Retrieves a list of message IDs for a set of topics\n   */\n\n\n  getGossipIDs(topics) {\n    const msgIdsByTopic = new Map();\n\n    for (let i = 0; i < this.gossip; i++) {\n      this.history[i].forEach(entry => {\n        const msg = this.msgs.get(entry.msgIdStr);\n\n        if (msg && msg.validated && topics.has(entry.topic)) {\n          let msgIds = msgIdsByTopic.get(entry.topic);\n\n          if (!msgIds) {\n            msgIds = [];\n            msgIdsByTopic.set(entry.topic, msgIds);\n          }\n\n          msgIds.push(entry.msgId);\n        }\n      });\n    }\n\n    return msgIdsByTopic;\n  }\n  /**\n   * Gets a message with msgId and tags it as validated.\n   * This function also returns the known peers that have sent us this message. This is used to\n   * prevent us sending redundant messages to peers who have already propagated it.\n   */\n\n\n  validate(msgId) {\n    const entry = this.msgs.get(msgId);\n\n    if (!entry) {\n      return null;\n    }\n\n    if (!entry.validated) {\n      this.notValidatedCount--;\n    }\n\n    const {\n      message,\n      originatingPeers\n    } = entry;\n    entry.validated = true; // Clear the known peers list (after a message is validated, it is forwarded and we no\n    // longer need to store the originating peers).\n\n    entry.originatingPeers = new Set();\n    return {\n      message,\n      originatingPeers\n    };\n  }\n  /**\n   * Shifts the current window, discarding messages older than this.history.length of the cache\n   */\n\n\n  shift() {\n    const lastCacheEntries = this.history[this.history.length - 1];\n    lastCacheEntries.forEach(cacheEntry => {\n      const entry = this.msgs.get(cacheEntry.msgIdStr);\n\n      if (entry) {\n        this.msgs.delete(cacheEntry.msgIdStr);\n\n        if (!entry.validated) {\n          this.notValidatedCount--;\n        }\n      }\n    });\n    this.history.pop();\n    this.history.unshift([]);\n  }\n\n  remove(msgId) {\n    const entry = this.msgs.get(msgId);\n\n    if (!entry) {\n      return null;\n    } // Keep the message on the history vector, it will be dropped on a shift()\n\n\n    this.msgs.delete(msgId);\n    return entry;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["MessageCache","constructor","gossip","historyCapacity","msgIdToStrFn","Map","i","history","size","msgs","put","messageId","msg","validated","msgIdStr","has","set","message","originatingPeers","Set","iwantCounts","push","topic","notValidatedCount","observeDuplicate","msgId","fromPeerIdStr","entry","get","add","getWithIWantCount","p","count","getGossipIDs","topics","msgIdsByTopic","forEach","msgIds","validate","shift","lastCacheEntries","length","cacheEntry","delete","pop","unshift","remove"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\message-cache.ts"],"sourcesContent":["import type { RPC } from './message/rpc.js'\nimport type { MessageId, MsgIdStr, PeerIdStr, TopicStr, MsgIdToStrFn } from './types.js'\n\nexport type CacheEntry = MessageId & {\n  topic: TopicStr\n}\n\ninterface MessageCacheEntry {\n  message: RPC.IMessage\n  /**\n   * Tracks if the message has been validated by the app layer and thus forwarded\n   */\n  validated: boolean\n  /**\n   * Tracks peers that sent this message before it has been validated by the app layer\n   */\n  originatingPeers: Set<PeerIdStr>\n  /**\n   * For every message and peer the number of times this peer asked for the message\n   */\n  iwantCounts: Map<PeerIdStr, number>\n}\n\nexport class MessageCache {\n  msgs = new Map<MsgIdStr, MessageCacheEntry>()\n\n  msgIdToStrFn: MsgIdToStrFn\n\n  history: CacheEntry[][] = []\n\n  /** Track with accounting of messages in the mcache that are not yet validated */\n  notValidatedCount = 0\n\n  /**\n   * Holds history of messages in timebounded history arrays\n   */\n  constructor(\n    /**\n     * The number of indices in the cache history used for gossiping. That means that a message\n     * won't get gossiped anymore when shift got called `gossip` many times after inserting the\n     * message in the cache.\n     */\n    private readonly gossip: number,\n    historyCapacity: number,\n    msgIdToStrFn: MsgIdToStrFn\n  ) {\n    this.msgIdToStrFn = msgIdToStrFn\n    for (let i = 0; i < historyCapacity; i++) {\n      this.history[i] = []\n    }\n  }\n\n  get size(): number {\n    return this.msgs.size\n  }\n\n  /**\n   * Adds a message to the current window and the cache\n   * Returns true if the message is not known and is inserted in the cache\n   */\n  put(messageId: MessageId, msg: RPC.IMessage, validated = false): boolean {\n    const { msgIdStr } = messageId\n    // Don't add duplicate entries to the cache.\n    if (this.msgs.has(msgIdStr)) {\n      return false\n    }\n\n    this.msgs.set(msgIdStr, {\n      message: msg,\n      validated,\n      originatingPeers: new Set(),\n      iwantCounts: new Map()\n    })\n\n    this.history[0].push({ ...messageId, topic: msg.topic })\n\n    if (!validated) {\n      this.notValidatedCount++\n    }\n\n    return true\n  }\n\n  observeDuplicate(msgId: MsgIdStr, fromPeerIdStr: PeerIdStr): void {\n    const entry = this.msgs.get(msgId)\n\n    if (\n      entry &&\n      // if the message is already validated, we don't need to store extra peers sending us\n      // duplicates as the message has already been forwarded\n      !entry.validated\n    ) {\n      entry.originatingPeers.add(fromPeerIdStr)\n    }\n  }\n\n  /**\n   * Retrieves a message from the cache by its ID, if it is still present\n   */\n  get(msgId: Uint8Array): RPC.IMessage | undefined {\n    return this.msgs.get(this.msgIdToStrFn(msgId))?.message\n  }\n\n  /**\n   * Increases the iwant count for the given message by one and returns the message together\n   * with the iwant if the message exists.\n   */\n  getWithIWantCount(msgIdStr: string, p: string): { msg: RPC.IMessage; count: number } | null {\n    const msg = this.msgs.get(msgIdStr)\n    if (!msg) {\n      return null\n    }\n\n    const count = (msg.iwantCounts.get(p) ?? 0) + 1\n    msg.iwantCounts.set(p, count)\n\n    return { msg: msg.message, count }\n  }\n\n  /**\n   * Retrieves a list of message IDs for a set of topics\n   */\n  getGossipIDs(topics: Set<string>): Map<string, Uint8Array[]> {\n    const msgIdsByTopic = new Map<string, Uint8Array[]>()\n    for (let i = 0; i < this.gossip; i++) {\n      this.history[i].forEach((entry) => {\n        const msg = this.msgs.get(entry.msgIdStr)\n        if (msg && msg.validated && topics.has(entry.topic)) {\n          let msgIds = msgIdsByTopic.get(entry.topic)\n          if (!msgIds) {\n            msgIds = []\n            msgIdsByTopic.set(entry.topic, msgIds)\n          }\n          msgIds.push(entry.msgId)\n        }\n      })\n    }\n\n    return msgIdsByTopic\n  }\n\n  /**\n   * Gets a message with msgId and tags it as validated.\n   * This function also returns the known peers that have sent us this message. This is used to\n   * prevent us sending redundant messages to peers who have already propagated it.\n   */\n  validate(msgId: MsgIdStr): { message: RPC.IMessage; originatingPeers: Set<PeerIdStr> } | null {\n    const entry = this.msgs.get(msgId)\n    if (!entry) {\n      return null\n    }\n\n    if (!entry.validated) {\n      this.notValidatedCount--\n    }\n\n    const { message, originatingPeers } = entry\n    entry.validated = true\n    // Clear the known peers list (after a message is validated, it is forwarded and we no\n    // longer need to store the originating peers).\n    entry.originatingPeers = new Set()\n    return { message, originatingPeers }\n  }\n\n  /**\n   * Shifts the current window, discarding messages older than this.history.length of the cache\n   */\n  shift(): void {\n    const lastCacheEntries = this.history[this.history.length - 1]\n    lastCacheEntries.forEach((cacheEntry) => {\n      const entry = this.msgs.get(cacheEntry.msgIdStr)\n      if (entry) {\n        this.msgs.delete(cacheEntry.msgIdStr)\n        if (!entry.validated) {\n          this.notValidatedCount--\n        }\n      }\n    })\n\n    this.history.pop()\n    this.history.unshift([])\n  }\n\n  remove(msgId: MsgIdStr): MessageCacheEntry | null {\n    const entry = this.msgs.get(msgId)\n    if (!entry) {\n      return null\n    }\n\n    // Keep the message on the history vector, it will be dropped on a shift()\n    this.msgs.delete(msgId)\n    return entry\n  }\n}\n"]},"metadata":{},"sourceType":"module"}