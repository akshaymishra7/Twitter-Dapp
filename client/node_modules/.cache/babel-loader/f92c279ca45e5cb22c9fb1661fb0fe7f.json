{"ast":null,"code":"import defer from 'p-defer';\nimport * as Headers from './extract-headers.js';\nimport { lteReader } from './lte-reader.js';\n\nfunction getPadding(size) {\n  size &= 511;\n\n  if (size !== 0) {\n    return 512 - size;\n  }\n\n  return 0;\n}\n\nasync function discardPadding(reader, size) {\n  const overflow = getPadding(size);\n\n  if (overflow > 0) {\n    await reader.next(overflow);\n  }\n}\n\nexport function extract() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  options.highWaterMark = options.highWaterMark ?? 1024 * 16;\n  return async function* (source) {\n    const reader = lteReader(source);\n    let gnuLongPath, gnuLongLinkPath, paxGlobal, pax;\n\n    try {\n      while (true) {\n        let headerBytes;\n\n        try {\n          const result = await reader.next(512);\n\n          if (result.done === true) {\n            return;\n          }\n\n          headerBytes = result.value;\n        } catch (err) {\n          // Is ok, this is the end of the stream!\n          if (err.code === 'ERR_UNDER_READ') {\n            return;\n          }\n\n          throw err;\n        }\n\n        const header = Headers.decode(headerBytes, options.filenameEncoding);\n\n        if (header == null) {\n          continue;\n        }\n\n        if (header.type === 'gnu-long-path') {\n          const {\n            done,\n            value: gnuLongPathBytes\n          } = await reader.next(header.size);\n\n          if (done === true || gnuLongPathBytes == null) {\n            return;\n          }\n\n          gnuLongPath = Headers.decodeLongPath(gnuLongPathBytes, options.filenameEncoding);\n          await discardPadding(reader, header.size);\n          continue;\n        }\n\n        if (header.type === 'gnu-long-link-path') {\n          const {\n            done,\n            value: gnuLongLinkPathBytes\n          } = await reader.next(header.size);\n\n          if (done === true || gnuLongLinkPathBytes == null) {\n            return;\n          }\n\n          gnuLongLinkPath = Headers.decodeLongPath(gnuLongLinkPathBytes, options.filenameEncoding);\n          await discardPadding(reader, header.size);\n          continue;\n        }\n\n        if (header.type === 'pax-global-header') {\n          const {\n            done,\n            value: paxGlobalBytes\n          } = await reader.next(header.size);\n\n          if (done === true || paxGlobalBytes == null) {\n            return;\n          }\n\n          paxGlobal = Headers.decodePax(paxGlobalBytes, options.filenameEncoding);\n          await discardPadding(reader, header.size);\n          continue;\n        }\n\n        if (header.type === 'pax-header') {\n          const {\n            done,\n            value: paxBytes\n          } = await reader.next(header.size);\n\n          if (done === true || paxBytes == null) {\n            return;\n          }\n\n          pax = Headers.decodePax(paxBytes, options.filenameEncoding);\n\n          if (paxGlobal != null) {\n            pax = { ...paxGlobal,\n              ...pax\n            };\n          }\n\n          await discardPadding(reader, header.size);\n          continue;\n        }\n\n        if (gnuLongPath != null) {\n          header.name = gnuLongPath;\n          gnuLongPath = null;\n        }\n\n        if (gnuLongLinkPath != null) {\n          header.linkname = gnuLongLinkPath;\n          gnuLongLinkPath = null;\n        }\n\n        if (pax != null) {\n          if (pax.path != null) {\n            header.name = pax.path;\n          }\n\n          if (pax.linkpath != null) {\n            header.linkname = pax.linkpath;\n          }\n\n          if (pax.size != null) {\n            header.size = parseInt(pax.size, 10);\n          }\n\n          header.pax = pax;\n          pax = null;\n        }\n\n        if (header.size == null || header.size === 0 || header.type === 'directory') {\n          yield {\n            header,\n            body: async function* () {}()\n          };\n          continue;\n        }\n\n        let bytesRemaining = header.size;\n        const bodyConsumed = defer(); // Prefetch the first chunk.\n        // This allows us to stream entries for small files from the tar without\n        // explicitly streaming the body of each.\n\n        const firstChunk = await reader.nextLte(Math.min(bytesRemaining, options.highWaterMark ?? Infinity));\n        bytesRemaining -= firstChunk.value.length;\n\n        if (bytesRemaining === 0) {\n          bodyConsumed.resolve();\n        }\n\n        const body = async function* () {\n          try {\n            yield firstChunk.value.subarray();\n\n            while (bytesRemaining > 0) {\n              const {\n                done,\n                value\n              } = await reader.nextLte(bytesRemaining);\n\n              if (done === true) {\n                bytesRemaining = 0;\n                return;\n              }\n\n              bytesRemaining -= value.length;\n              yield value.subarray();\n            }\n          } finally {\n            bodyConsumed.resolve();\n          }\n        }();\n\n        yield {\n          header,\n          body\n        }; // Wait for the body to be consumed\n\n        await bodyConsumed.promise; // In case the body was not consumed entirely...\n\n        if (bytesRemaining > 0) {\n          for await (const _ of body) {} // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n\n        }\n\n        await discardPadding(reader, header.size);\n      }\n    } finally {\n      await reader.return();\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["defer","Headers","lteReader","getPadding","size","discardPadding","reader","overflow","next","extract","options","highWaterMark","source","gnuLongPath","gnuLongLinkPath","paxGlobal","pax","headerBytes","result","done","value","err","code","header","decode","filenameEncoding","type","gnuLongPathBytes","decodeLongPath","gnuLongLinkPathBytes","paxGlobalBytes","decodePax","paxBytes","name","linkname","path","linkpath","parseInt","body","bytesRemaining","bodyConsumed","firstChunk","nextLte","Math","min","Infinity","length","resolve","subarray","promise","_","return"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-tar\\src\\extract.ts"],"sourcesContent":["import type { Source, Transform } from 'it-stream-types'\nimport defer from 'p-defer'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { SupportedEncodings } from 'uint8arrays/to-string'\nimport * as Headers from './extract-headers.js'\nimport { lteReader } from './lte-reader.js'\nimport type { LteReader } from './lte-reader.js'\nimport type { TarEntry } from './index.js'\n\nfunction getPadding (size: number) {\n  size &= 511\n\n  if (size !== 0) {\n    return 512 - size\n  }\n\n  return 0\n}\n\nasync function discardPadding (reader: LteReader, size: number) {\n  const overflow = getPadding(size)\n  if (overflow > 0) {\n    await reader.next(overflow)\n  }\n}\n\nexport interface ExtractOptions {\n  highWaterMark?: number\n  filenameEncoding?: SupportedEncodings\n}\n\nexport interface Derp {\n  header: any\n  body: Source<Uint8Array>\n}\n\nexport function extract (options: ExtractOptions = {}): Transform<Uint8Array, TarEntry> {\n  options.highWaterMark = options.highWaterMark ?? 1024 * 16\n\n  return async function * (source: Source<Uint8Array>) { // eslint-disable-line complexity\n    const reader = lteReader(source)\n    let gnuLongPath, gnuLongLinkPath, paxGlobal, pax\n\n    try {\n      while (true) {\n        let headerBytes: Uint8ArrayList\n        try {\n          const result = await reader.next(512)\n\n          if (result.done === true) {\n            return\n          }\n\n          headerBytes = result.value\n        } catch (err: any) {\n          // Is ok, this is the end of the stream!\n          if (err.code === 'ERR_UNDER_READ') {\n            return\n          }\n\n          throw err\n        }\n\n        const header = Headers.decode(headerBytes, options.filenameEncoding)\n        if (header == null) {\n          continue\n        }\n\n        if (header.type === 'gnu-long-path') {\n          const { done, value: gnuLongPathBytes } = await reader.next(header.size)\n          if (done === true || gnuLongPathBytes == null) {\n            return\n          }\n          gnuLongPath = Headers.decodeLongPath(gnuLongPathBytes, options.filenameEncoding)\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (header.type === 'gnu-long-link-path') {\n          const { done, value: gnuLongLinkPathBytes } = await reader.next(header.size)\n          if (done === true || gnuLongLinkPathBytes == null) {\n            return\n          }\n          gnuLongLinkPath = Headers.decodeLongPath(gnuLongLinkPathBytes, options.filenameEncoding)\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (header.type === 'pax-global-header') {\n          const { done, value: paxGlobalBytes } = await reader.next(header.size)\n          if (done === true || paxGlobalBytes == null) {\n            return\n          }\n          paxGlobal = Headers.decodePax(paxGlobalBytes, options.filenameEncoding)\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (header.type === 'pax-header') {\n          const { done, value: paxBytes } = await reader.next(header.size)\n          if (done === true || paxBytes == null) {\n            return\n          }\n          pax = Headers.decodePax(paxBytes, options.filenameEncoding)\n          if (paxGlobal != null) {\n            pax = { ...paxGlobal, ...pax }\n          }\n          await discardPadding(reader, header.size)\n          continue\n        }\n\n        if (gnuLongPath != null) {\n          header.name = gnuLongPath\n          gnuLongPath = null\n        }\n\n        if (gnuLongLinkPath != null) {\n          header.linkname = gnuLongLinkPath\n          gnuLongLinkPath = null\n        }\n\n        if (pax != null) {\n          if (pax.path != null) {\n            header.name = pax.path\n          }\n\n          if (pax.linkpath != null) {\n            header.linkname = pax.linkpath\n          }\n\n          if (pax.size != null) {\n            header.size = parseInt(pax.size, 10)\n          }\n\n          header.pax = pax\n          pax = null\n        }\n\n        if (header.size == null || header.size === 0 || header.type === 'directory') {\n          yield { header, body: (async function * () {})() }\n          continue\n        }\n\n        let bytesRemaining = header.size\n        const bodyConsumed = defer()\n\n        // Prefetch the first chunk.\n        // This allows us to stream entries for small files from the tar without\n        // explicitly streaming the body of each.\n        const firstChunk = await reader.nextLte(Math.min(bytesRemaining, options.highWaterMark ?? Infinity))\n        bytesRemaining -= firstChunk.value.length\n\n        if (bytesRemaining === 0) {\n          bodyConsumed.resolve()\n        }\n\n        const body: AsyncIterable<Uint8Array> = (async function * () {\n          try {\n            yield firstChunk.value.subarray()\n\n            while (bytesRemaining > 0) {\n              const { done, value } = await reader.nextLte(bytesRemaining)\n\n              if (done === true) {\n                bytesRemaining = 0\n                return\n              }\n\n              bytesRemaining -= value.length\n\n              yield value.subarray()\n            }\n          } finally {\n            bodyConsumed.resolve()\n          }\n        })()\n\n        yield { header, body }\n\n        // Wait for the body to be consumed\n        await bodyConsumed.promise\n\n        // In case the body was not consumed entirely...\n        if (bytesRemaining > 0) {\n          for await (const _ of body) {} // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n        }\n\n        await discardPadding(reader, header.size)\n      }\n    } finally {\n      await reader.return()\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}