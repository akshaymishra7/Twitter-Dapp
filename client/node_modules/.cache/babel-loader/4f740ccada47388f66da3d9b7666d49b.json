{"ast":null,"code":"import { EventEmitter } from 'events';\nimport { Stat } from './stat.js';\nimport { trackedMap } from '@libp2p/tracked-map';\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\n/**\n * @typedef {[number, number, number]} AverageIntervals\n */\n\nconst defaultOptions = {\n  enabled: false,\n  computeThrottleTimeout: 1000,\n  computeThrottleMaxQueueSize: 1000,\n  movingAverageIntervals:\n  /** @type {AverageIntervals} */\n  [60 * 1000, // 1 minute\n  5 * 60 * 1000, // 5 minutes\n  15 * 60 * 1000 // 15 minutes\n  ]\n};\nexport class Stats extends EventEmitter {\n  /**\n   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p\n   * @param {string[]} [initialCounters]\n   * @param {object} _options\n   * @param {boolean} _options.enabled\n   * @param {number} _options.computeThrottleTimeout\n   * @param {number} _options.computeThrottleMaxQueueSize\n   */\n  constructor(libp2p) {\n    let initialCounters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    let _options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n\n    super();\n    const options = Object.assign({}, defaultOptions, _options);\n\n    if (typeof options.computeThrottleTimeout !== 'number') {\n      throw new Error('need computeThrottleTimeout');\n    }\n\n    if (typeof options.computeThrottleMaxQueueSize !== 'number') {\n      throw new Error('need computeThrottleMaxQueueSize');\n    }\n\n    this._initialCounters = initialCounters;\n    this._options = options;\n    this._enabled = this._options.enabled;\n    this._global = new Stat(initialCounters, options);\n\n    this._global.on('update', stats => this.emit('update', stats));\n    /** @type {Map<string, Stat>} */\n\n\n    this._peers = trackedMap({\n      name: 'ipfs_bitswap_stats_peers',\n      metrics: libp2p.metrics\n    });\n  }\n\n  enable() {\n    this._enabled = true;\n    this._options.enabled = true;\n\n    this._global.enable();\n  }\n\n  disable() {\n    this._enabled = false;\n    this._options.enabled = false;\n\n    this._global.disable();\n  }\n\n  stop() {\n    this._enabled = false;\n\n    this._global.stop();\n\n    for (const peerStat of this._peers) {\n      peerStat[1].stop();\n    }\n  }\n\n  get snapshot() {\n    return this._global.snapshot;\n  }\n\n  get movingAverages() {\n    return this._global.movingAverages;\n  }\n  /**\n   * @param {PeerId|string} peerId\n   * @returns {Stat|undefined}\n   */\n\n\n  forPeer(peerId) {\n    const peerIdStr = typeof peerId !== 'string' && peerId.toString ? peerId.toString() : `${peerId}`;\n    return this._peers.get(peerIdStr);\n  }\n  /**\n   *\n   * @param {string|null} peer\n   * @param {string} counter\n   * @param {number} inc\n   */\n\n\n  push(peer, counter, inc) {\n    if (this._enabled) {\n      this._global.push(counter, inc);\n\n      if (peer) {\n        let peerStats = this._peers.get(peer);\n\n        if (!peerStats) {\n          peerStats = new Stat(this._initialCounters, this._options);\n\n          this._peers.set(peer, peerStats);\n        }\n\n        peerStats.push(counter, inc);\n      }\n    }\n  }\n  /**\n   * @param {PeerId} peer\n   */\n\n\n  disconnected(peer) {\n    const peerId = peer.toString();\n\n    const peerStats = this._peers.get(peerId);\n\n    if (peerStats) {\n      peerStats.stop();\n\n      this._peers.delete(peerId);\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-bitswap/src/stats/index.js"],"names":["EventEmitter","Stat","trackedMap","defaultOptions","enabled","computeThrottleTimeout","computeThrottleMaxQueueSize","movingAverageIntervals","Stats","constructor","libp2p","initialCounters","_options","options","Object","assign","Error","_initialCounters","_enabled","_global","on","stats","emit","_peers","name","metrics","enable","disable","stop","peerStat","snapshot","movingAverages","forPeer","peerId","peerIdStr","toString","get","push","peer","counter","inc","peerStats","set","disconnected","delete"],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events'\nimport { Stat } from './stat.js'\nimport { trackedMap } from '@libp2p/tracked-map'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\n/**\n * @typedef {[number, number, number]} AverageIntervals\n */\nconst defaultOptions = {\n  enabled: false,\n  computeThrottleTimeout: 1000,\n  computeThrottleMaxQueueSize: 1000,\n  movingAverageIntervals: /** @type {AverageIntervals} */ ([\n    60 * 1000, // 1 minute\n    5 * 60 * 1000, // 5 minutes\n    15 * 60 * 1000 // 15 minutes\n  ])\n}\n\nexport class Stats extends EventEmitter {\n  /**\n   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p\n   * @param {string[]} [initialCounters]\n   * @param {object} _options\n   * @param {boolean} _options.enabled\n   * @param {number} _options.computeThrottleTimeout\n   * @param {number} _options.computeThrottleMaxQueueSize\n   */\n  constructor (libp2p, initialCounters = [], _options = defaultOptions) {\n    super()\n\n    const options = Object.assign({}, defaultOptions, _options)\n\n    if (typeof options.computeThrottleTimeout !== 'number') {\n      throw new Error('need computeThrottleTimeout')\n    }\n\n    if (typeof options.computeThrottleMaxQueueSize !== 'number') {\n      throw new Error('need computeThrottleMaxQueueSize')\n    }\n\n    this._initialCounters = initialCounters\n    this._options = options\n    this._enabled = this._options.enabled\n\n    this._global = new Stat(initialCounters, options)\n    this._global.on('update', (stats) => this.emit('update', stats))\n\n    /** @type {Map<string, Stat>} */\n    this._peers = trackedMap({\n      name: 'ipfs_bitswap_stats_peers',\n      metrics: libp2p.metrics\n    })\n  }\n\n  enable () {\n    this._enabled = true\n    this._options.enabled = true\n    this._global.enable()\n  }\n\n  disable () {\n    this._enabled = false\n    this._options.enabled = false\n    this._global.disable()\n  }\n\n  stop () {\n    this._enabled = false\n    this._global.stop()\n    for (const peerStat of this._peers) {\n      peerStat[1].stop()\n    }\n  }\n\n  get snapshot () {\n    return this._global.snapshot\n  }\n\n  get movingAverages () {\n    return this._global.movingAverages\n  }\n\n  /**\n   * @param {PeerId|string} peerId\n   * @returns {Stat|undefined}\n   */\n  forPeer (peerId) {\n    const peerIdStr = (typeof peerId !== 'string' && peerId.toString)\n      ? peerId.toString()\n      : `${peerId}`\n\n    return this._peers.get(peerIdStr)\n  }\n\n  /**\n   *\n   * @param {string|null} peer\n   * @param {string} counter\n   * @param {number} inc\n   */\n  push (peer, counter, inc) {\n    if (this._enabled) {\n      this._global.push(counter, inc)\n\n      if (peer) {\n        let peerStats = this._peers.get(peer)\n        if (!peerStats) {\n          peerStats = new Stat(this._initialCounters, this._options)\n          this._peers.set(peer, peerStats)\n        }\n\n        peerStats.push(counter, inc)\n      }\n    }\n  }\n\n  /**\n   * @param {PeerId} peer\n   */\n  disconnected (peer) {\n    const peerId = peer.toString()\n    const peerStats = this._peers.get(peerId)\n    if (peerStats) {\n      peerStats.stop()\n      this._peers.delete(peerId)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}