{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { connect } from 'socket.io-client';\nimport pDefer from 'p-defer';\nimport { WebRTCReceiver } from '@libp2p/webrtc-peer';\nimport { toMultiaddrConnection } from './socket-to-conn.js';\nimport { cleanUrlSIO } from './utils.js';\nimport { CODE_P2P } from './constants.js';\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';\nconst log = logger('libp2p:webrtc-star:listener');\nconst sioOptions = {\n  transports: ['websocket'],\n  path: '/socket.io-next/' // This should be removed when socket.io@2 support is removed\n\n};\n\nclass SigServer extends EventEmitter {\n  constructor(signallingUrl, signallingAddr, upgrader, handler, channelOptions) {\n    super();\n    this.signallingAddr = signallingAddr;\n    this.socket = connect(signallingUrl, sioOptions);\n    this.connections = [];\n    this.channels = new Map();\n    this.pendingSignals = new Map();\n    this.upgrader = upgrader;\n    this.handler = handler;\n    this.channelOptions = channelOptions;\n    this.handleWsHandshake = this.handleWsHandshake.bind(this);\n    let previouslyConnected = false;\n    this.socket.on('connect_error', err => {\n      // @ts-expect-error `.type` is missing from the types\n      if (previouslyConnected && err.type === 'TransportError') {\n        // if we've had an open connection before, and this is a\n        // transport error, let socket.io's reconnect logic take over\n        return;\n      }\n\n      this.dispatchEvent(new CustomEvent('error', {\n        detail: err\n      }));\n    });\n    this.socket.on('error', err => {\n      this.dispatchEvent(new CustomEvent('error', {\n        detail: err\n      }));\n    });\n    this.socket.on('ws-handshake', this.handleWsHandshake);\n    this.socket.on('ws-peer', maStr => {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: maStr\n      }));\n    });\n    this.socket.on('connect', () => {\n      this.socket.emit('ss-join', this.signallingAddr.toString());\n\n      if (previouslyConnected) {\n        this.dispatchEvent(new CustomEvent('reconnect'));\n      }\n    });\n    this.socket.once('connect', () => {\n      // make sure we can reconnect in future\n      previouslyConnected = true;\n      this.dispatchEvent(new CustomEvent('listening'));\n    });\n    this.socket.on('disconnect', () => {\n      this.dispatchEvent(new CustomEvent('disconnect'));\n    });\n  }\n\n  _createChannel(intentId, srcMultiaddr, dstMultiaddr) {\n    const channelOptions = { ...this.channelOptions\n    };\n    const channel = new WebRTCReceiver(channelOptions);\n\n    const onError = evt => {\n      const err = evt.detail;\n      log.error('incoming connection errored', err);\n    };\n\n    channel.addEventListener('error', onError);\n    channel.addEventListener('close', () => {\n      channel.removeEventListener('error', onError);\n    }, {\n      once: true\n    });\n    channel.addEventListener('signal', evt => {\n      const signal = evt.detail;\n      this.socket.emit('ss-handshake', {\n        intentId,\n        srcMultiaddr,\n        dstMultiaddr,\n        answer: true,\n        signal\n      });\n    });\n    channel.addEventListener('ready', () => {\n      const maConn = toMultiaddrConnection(channel, {\n        remoteAddr: this.signallingAddr\n      });\n      log('new inbound connection %s', maConn.remoteAddr);\n\n      try {\n        this.upgrader.upgradeInbound(maConn).then(conn => {\n          log('inbound connection %s upgraded', maConn.remoteAddr);\n          this.connections.push(maConn);\n\n          const untrackConn = () => {\n            this.connections = this.connections.filter(c => c !== maConn);\n            this.channels.delete(intentId);\n            this.pendingSignals.delete(intentId);\n          };\n\n          channel.addEventListener('close', untrackConn, {\n            once: true\n          });\n          this.dispatchEvent(new CustomEvent('connection', {\n            detail: conn\n          }));\n          this.handler(conn);\n        }).catch(err => {\n          log.error('inbound connection failed to upgrade', err);\n          maConn.close().catch(err => {\n            log.error('inbound connection failed to close after failing to upgrade', err);\n          });\n        });\n      } catch (err) {\n        log.error('inbound connection failed to upgrade', err);\n        maConn.close().catch(err => {\n          log.error('inbound connection failed to close after failing to upgrade', err);\n        });\n      }\n    }, {\n      once: true\n    });\n    return channel;\n  }\n\n  handleWsHandshake(offer) {\n    log('incoming handshake. signal type \"%s\" is answer %s', offer.signal.type, offer.answer);\n\n    if (offer.answer === true || offer.err != null || offer.intentId == null) {\n      return;\n    }\n\n    const intentId = offer.intentId;\n    let pendingSignals = this.pendingSignals.get(intentId);\n\n    if (pendingSignals == null) {\n      pendingSignals = [];\n      this.pendingSignals.set(intentId, pendingSignals);\n    }\n\n    pendingSignals.push(offer);\n    let channel = this.channels.get(intentId);\n\n    if (channel == null) {\n      if (offer.signal.type !== 'offer') {\n        log('handshake is not an offer and channel does not exist, buffering until we receive an offer');\n        return;\n      }\n\n      log('creating new channel to handle offer handshake');\n      channel = this._createChannel(offer.intentId, offer.srcMultiaddr, offer.dstMultiaddr);\n      this.channels.set(intentId, channel);\n    } else {\n      log('channel already exists, using it to handle handshake');\n    }\n\n    while (pendingSignals.length > 0) {\n      const handshake = pendingSignals.shift();\n\n      if (handshake?.signal != null) {\n        channel.handleSignal(handshake.signal);\n      }\n    }\n  }\n\n  async close() {\n    // Close listener\n    this.socket.emit('ss-leave', this.signallingAddr.toString());\n    this.socket.removeAllListeners();\n    this.socket.close();\n    await Promise.all([...this.connections.map(async maConn => await maConn.close()), ...Array.from(this.channels.values()).map(async channel => await channel.close())]);\n    this.dispatchEvent(new CustomEvent('close'));\n  }\n\n}\n\nclass WebRTCListener extends EventEmitter {\n  constructor(upgrader, handler, peerId, transport, options) {\n    super();\n    this.upgrader = upgrader;\n    this.handler = handler;\n    this.peerId = peerId;\n    this.transport = transport;\n    this.options = options;\n  }\n\n  async listen(ma) {\n    // Should only be used if not already listening\n    if (this.listeningAddr != null) {\n      throw errCode(new Error('listener already in use'), 'ERR_ALREADY_LISTENING');\n    }\n\n    const defer = pDefer(); // eslint-disable-line @typescript-eslint/no-invalid-void-type\n    // Should be kept unmodified\n\n    this.listeningAddr = ma;\n    let signallingAddr;\n\n    if (!ma.protoCodes().includes(CODE_P2P)) {\n      signallingAddr = ma.encapsulate(`/p2p/${this.peerId.toString()}`);\n    } else {\n      signallingAddr = ma;\n    }\n\n    const signallingUrl = this.signallingUrl = cleanUrlSIO(ma);\n    log('connecting to signalling server on: %s', this.signallingUrl);\n    const server = new SigServer(this.signallingUrl, signallingAddr, this.upgrader, this.handler, this.options.channelOptions);\n    server.addEventListener('error', evt => {\n      const err = evt.detail;\n      log('error connecting to signalling server %o', err);\n      server.close().catch(err => {\n        log.error('error closing server after error', err);\n      });\n      defer.reject(err);\n    });\n    server.addEventListener('listening', () => {\n      log('connected to signalling server');\n      this.dispatchEvent(new CustomEvent('listening'));\n      defer.resolve();\n    });\n    server.addEventListener('peer', evt => {\n      this.transport.peerDiscovered(evt.detail);\n    });\n    server.addEventListener('connection', evt => {\n      const conn = evt.detail;\n\n      if (conn.remoteAddr == null) {\n        try {\n          conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toString()}`);\n        } catch (err) {\n          log.error('could not determine remote address', err);\n        }\n      }\n\n      this.dispatchEvent(new CustomEvent('connection', {\n        detail: conn\n      }));\n    });\n    server.addEventListener('disconnect', () => {\n      // Ensure we error if we try to dial while we are disconnected from\n      // the signalling server\n      this.transport.sigServers.delete(signallingUrl);\n    });\n    server.addEventListener('reconnect', () => {\n      // We can dial via the signalling server again\n      this.transport.sigServers.set(signallingUrl, server);\n    }); // Store listen and signal reference addresses\n\n    this.transport.sigServers.set(this.signallingUrl, server);\n    return await defer.promise;\n  }\n\n  async close() {\n    if (this.signallingUrl != null) {\n      const server = this.transport.sigServers.get(this.signallingUrl);\n\n      if (server != null) {\n        await server.close();\n        this.transport.sigServers.delete(this.signallingUrl);\n      }\n    }\n\n    this.dispatchEvent(new CustomEvent('close')); // Reset state\n\n    this.listeningAddr = undefined;\n  }\n\n  getAddrs() {\n    if (this.listeningAddr != null) {\n      return [this.listeningAddr];\n    }\n\n    return [];\n  }\n\n}\n\nexport function createListener(upgrader, handler, peerId, transport, options) {\n  return new WebRTCListener(upgrader, handler, peerId, transport, options);\n}","map":{"version":3,"mappings":"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","names":["logger","errCode","connect","pDefer","WebRTCReceiver","toMultiaddrConnection","cleanUrlSIO","CODE_P2P","EventEmitter","CustomEvent","log","sioOptions","transports","path","SigServer","constructor","signallingUrl","signallingAddr","upgrader","handler","channelOptions","socket","connections","channels","Map","pendingSignals","handleWsHandshake","bind","previouslyConnected","on","err","type","dispatchEvent","detail","maStr","emit","toString","once","_createChannel","intentId","srcMultiaddr","dstMultiaddr","channel","onError","evt","error","addEventListener","removeEventListener","signal","answer","maConn","remoteAddr","upgradeInbound","then","conn","push","untrackConn","filter","c","delete","catch","close","offer","get","set","length","handshake","shift","handleSignal","removeAllListeners","Promise","all","map","Array","from","values","WebRTCListener","peerId","transport","options","listen","ma","listeningAddr","Error","defer","protoCodes","includes","encapsulate","server","reject","resolve","peerDiscovered","decapsulateCode","remotePeer","sigServers","promise","undefined","getAddrs","createListener"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\webrtc-star\\src\\listener.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { connect, ManagerOptions, SocketOptions } from 'socket.io-client'\nimport pDefer from 'p-defer'\nimport { WebRTCReceiver } from '@libp2p/webrtc-peer'\nimport { toMultiaddrConnection } from './socket-to-conn.js'\nimport { cleanUrlSIO } from './utils.js'\nimport { CODE_P2P } from './constants.js'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { Upgrader, ConnectionHandler, Listener, ListenerEvents } from '@libp2p/interface-transport'\nimport type { WebRTCStar, WebRTCStarListenerOptions, SignalServer, SignalServerServerEvents } from './transport.js'\nimport type { WebRTCReceiverInit } from '@libp2p/webrtc-peer'\nimport type { WebRTCStarSocket, HandshakeSignal } from '@libp2p/webrtc-star-protocol'\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events'\n\nconst log = logger('libp2p:webrtc-star:listener')\n\nconst sioOptions: Partial<ManagerOptions & SocketOptions> = {\n  transports: ['websocket'],\n  path: '/socket.io-next/' // This should be removed when socket.io@2 support is removed\n}\n\nclass SigServer extends EventEmitter<SignalServerServerEvents> implements SignalServer {\n  public signallingAddr: Multiaddr\n  public socket: WebRTCStarSocket\n  public connections: MultiaddrConnection[]\n  public channels: Map<string, WebRTCReceiver>\n  public pendingSignals: Map<string, HandshakeSignal[]>\n\n  private readonly upgrader: Upgrader\n  private readonly handler: ConnectionHandler\n  private readonly channelOptions?: WebRTCReceiverInit\n\n  constructor (signallingUrl: string, signallingAddr: Multiaddr, upgrader: Upgrader, handler: ConnectionHandler, channelOptions?: WebRTCReceiverInit) {\n    super()\n\n    this.signallingAddr = signallingAddr\n    this.socket = connect(signallingUrl, sioOptions)\n    this.connections = []\n    this.channels = new Map()\n    this.pendingSignals = new Map()\n\n    this.upgrader = upgrader\n    this.handler = handler\n    this.channelOptions = channelOptions\n\n    this.handleWsHandshake = this.handleWsHandshake.bind(this)\n\n    let previouslyConnected = false\n\n    this.socket.on('connect_error', err => {\n      // @ts-expect-error `.type` is missing from the types\n      if (previouslyConnected && err.type === 'TransportError') {\n        // if we've had an open connection before, and this is a\n        // transport error, let socket.io's reconnect logic take over\n        return\n      }\n\n      this.dispatchEvent(new CustomEvent('error', {\n        detail: err\n      }))\n    })\n    this.socket.on('error', (err: Error) => {\n      this.dispatchEvent(new CustomEvent('error', {\n        detail: err\n      }))\n    })\n    this.socket.on('ws-handshake', this.handleWsHandshake)\n    this.socket.on('ws-peer', (maStr) => {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: maStr\n      }))\n    })\n    this.socket.on('connect', () => {\n      this.socket.emit('ss-join', this.signallingAddr.toString())\n\n      if (previouslyConnected) {\n        this.dispatchEvent(new CustomEvent('reconnect'))\n      }\n    })\n    this.socket.once('connect', () => {\n      // make sure we can reconnect in future\n      previouslyConnected = true\n      this.dispatchEvent(new CustomEvent('listening'))\n    })\n    this.socket.on('disconnect', () => {\n      this.dispatchEvent(new CustomEvent('disconnect'))\n    })\n  }\n\n  _createChannel (intentId: string, srcMultiaddr: string, dstMultiaddr: string) {\n    const channelOptions: WebRTCReceiverInit = {\n      ...this.channelOptions\n    }\n\n    const channel = new WebRTCReceiver(channelOptions)\n\n    const onError = (evt: CustomEvent<Error>) => {\n      const err = evt.detail\n\n      log.error('incoming connection errored', err)\n    }\n\n    channel.addEventListener('error', onError)\n    channel.addEventListener('close', () => {\n      channel.removeEventListener('error', onError)\n    }, {\n      once: true\n    })\n\n    channel.addEventListener('signal', (evt) => {\n      const signal = evt.detail\n\n      this.socket.emit('ss-handshake', {\n        intentId,\n        srcMultiaddr,\n        dstMultiaddr,\n        answer: true,\n        signal\n      })\n    })\n\n    channel.addEventListener('ready', () => {\n      const maConn = toMultiaddrConnection(channel, { remoteAddr: this.signallingAddr })\n      log('new inbound connection %s', maConn.remoteAddr)\n\n      try {\n        this.upgrader.upgradeInbound(maConn)\n          .then(conn => {\n            log('inbound connection %s upgraded', maConn.remoteAddr)\n\n            this.connections.push(maConn)\n\n            const untrackConn = () => {\n              this.connections = this.connections.filter(c => c !== maConn)\n              this.channels.delete(intentId)\n              this.pendingSignals.delete(intentId)\n            }\n\n            channel.addEventListener('close', untrackConn, {\n              once: true\n            })\n\n            this.dispatchEvent(new CustomEvent('connection', {\n              detail: conn\n            }))\n            this.handler(conn)\n          })\n          .catch(err => {\n            log.error('inbound connection failed to upgrade', err)\n            maConn.close().catch(err => {\n              log.error('inbound connection failed to close after failing to upgrade', err)\n            })\n          })\n      } catch (err: any) {\n        log.error('inbound connection failed to upgrade', err)\n        maConn.close().catch(err => {\n          log.error('inbound connection failed to close after failing to upgrade', err)\n        })\n      }\n    }, {\n      once: true\n    })\n\n    return channel\n  }\n\n  handleWsHandshake (offer: HandshakeSignal) {\n    log('incoming handshake. signal type \"%s\" is answer %s', offer.signal.type, offer.answer)\n\n    if (offer.answer === true || offer.err != null || offer.intentId == null) {\n      return\n    }\n\n    const intentId = offer.intentId\n    let pendingSignals = this.pendingSignals.get(intentId)\n\n    if (pendingSignals == null) {\n      pendingSignals = []\n      this.pendingSignals.set(intentId, pendingSignals)\n    }\n\n    pendingSignals.push(offer)\n\n    let channel = this.channels.get(intentId)\n\n    if (channel == null) {\n      if (offer.signal.type !== 'offer') {\n        log('handshake is not an offer and channel does not exist, buffering until we receive an offer')\n        return\n      }\n\n      log('creating new channel to handle offer handshake')\n      channel = this._createChannel(offer.intentId, offer.srcMultiaddr, offer.dstMultiaddr)\n      this.channels.set(intentId, channel)\n    } else {\n      log('channel already exists, using it to handle handshake')\n    }\n\n    while (pendingSignals.length > 0) {\n      const handshake = pendingSignals.shift()\n\n      if (handshake?.signal != null) {\n        channel.handleSignal(handshake.signal)\n      }\n    }\n  }\n\n  async close () {\n    // Close listener\n    this.socket.emit('ss-leave', this.signallingAddr.toString())\n    this.socket.removeAllListeners()\n    this.socket.close()\n\n    await Promise.all([\n      ...this.connections.map(async maConn => await maConn.close()),\n      ...Array.from(this.channels.values()).map(async channel => await channel.close())\n    ])\n\n    this.dispatchEvent(new CustomEvent('close'))\n  }\n}\n\nclass WebRTCListener extends EventEmitter<ListenerEvents> implements Listener {\n  private listeningAddr?: Multiaddr\n  private signallingUrl?: string\n  private readonly upgrader: Upgrader\n  private readonly handler: ConnectionHandler\n  private readonly peerId: PeerId\n  private readonly transport: WebRTCStar\n  private readonly options: WebRTCStarListenerOptions\n\n  constructor (upgrader: Upgrader, handler: ConnectionHandler, peerId: PeerId, transport: WebRTCStar, options: WebRTCStarListenerOptions) {\n    super()\n\n    this.upgrader = upgrader\n    this.handler = handler\n    this.peerId = peerId\n    this.transport = transport\n    this.options = options\n  }\n\n  async listen (ma: Multiaddr) {\n    // Should only be used if not already listening\n    if (this.listeningAddr != null) {\n      throw errCode(new Error('listener already in use'), 'ERR_ALREADY_LISTENING')\n    }\n\n    const defer = pDefer<void>() // eslint-disable-line @typescript-eslint/no-invalid-void-type\n\n    // Should be kept unmodified\n    this.listeningAddr = ma\n\n    let signallingAddr: Multiaddr\n    if (!ma.protoCodes().includes(CODE_P2P)) {\n      signallingAddr = ma.encapsulate(`/p2p/${this.peerId.toString()}`)\n    } else {\n      signallingAddr = ma\n    }\n\n    const signallingUrl = this.signallingUrl = cleanUrlSIO(ma)\n\n    log('connecting to signalling server on: %s', this.signallingUrl)\n    const server: SignalServer = new SigServer(this.signallingUrl, signallingAddr, this.upgrader, this.handler, this.options.channelOptions)\n    server.addEventListener('error', (evt) => {\n      const err = evt.detail\n\n      log('error connecting to signalling server %o', err)\n      server.close().catch(err => {\n        log.error('error closing server after error', err)\n      })\n      defer.reject(err)\n    })\n    server.addEventListener('listening', () => {\n      log('connected to signalling server')\n      this.dispatchEvent(new CustomEvent('listening'))\n      defer.resolve()\n    })\n    server.addEventListener('peer', (evt) => {\n      this.transport.peerDiscovered(evt.detail)\n    })\n    server.addEventListener('connection', (evt) => {\n      const conn = evt.detail\n\n      if (conn.remoteAddr == null) {\n        try {\n          conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toString()}`)\n        } catch (err) {\n          log.error('could not determine remote address', err)\n        }\n      }\n\n      this.dispatchEvent(new CustomEvent('connection', {\n        detail: conn\n      }))\n    })\n    server.addEventListener('disconnect', () => {\n      // Ensure we error if we try to dial while we are disconnected from\n      // the signalling server\n      this.transport.sigServers.delete(signallingUrl)\n    })\n    server.addEventListener('reconnect', () => {\n      // We can dial via the signalling server again\n      this.transport.sigServers.set(signallingUrl, server)\n    })\n\n    // Store listen and signal reference addresses\n    this.transport.sigServers.set(this.signallingUrl, server)\n\n    return await defer.promise\n  }\n\n  async close () {\n    if (this.signallingUrl != null) {\n      const server = this.transport.sigServers.get(this.signallingUrl)\n\n      if (server != null) {\n        await server.close()\n        this.transport.sigServers.delete(this.signallingUrl)\n      }\n    }\n\n    this.dispatchEvent(new CustomEvent('close'))\n\n    // Reset state\n    this.listeningAddr = undefined\n  }\n\n  getAddrs () {\n    if (this.listeningAddr != null) {\n      return [\n        this.listeningAddr\n      ]\n    }\n\n    return []\n  }\n}\n\nexport function createListener (upgrader: Upgrader, handler: ConnectionHandler, peerId: PeerId, transport: WebRTCStar, options: WebRTCStarListenerOptions) {\n  return new WebRTCListener(upgrader, handler, peerId, transport, options)\n}\n"]},"metadata":{},"sourceType":"module"}