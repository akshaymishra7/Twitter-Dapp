{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport parseDuration from 'parse-duration';\nimport { importKey, unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport errcode from 'err-code';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { OFFLINE_ERROR, normalizePath } from '../../utils.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { resolvePath } from './utils.js';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nconst log = logger('ipfs:name:publish');\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {object} config\n * @param {import('../ipns').IPNSAPI} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('ipfs-core-types/src/root').API<{}>[\"isOnline\"]} config.isOnline\n * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n */\n\nexport function createPublish(_ref) {\n  let {\n    ipns,\n    repo,\n    codecs,\n    peerId,\n    isOnline,\n    keychain\n  } = _ref;\n\n  /**\n   * @param {string} keyName\n   */\n  const lookupKey = async keyName => {\n    /** @type {import('@libp2p/interface-keys').PrivateKey} */\n    let privateKey;\n\n    if (keyName === 'self' && peerId.privateKey != null) {\n      privateKey = await unmarshalPrivateKey(peerId.privateKey);\n    } else {\n      try {\n        // We're exporting and immediately importing the key, so we can just use a throw away password\n        const pem = await keychain.exportKey(keyName, 'temp');\n        privateKey = await importKey(pem, 'temp');\n      } catch (\n      /** @type {any} */\n      err) {\n        log.error(err);\n        throw errcode(err, 'ERR_CANNOT_GET_KEY');\n      }\n    }\n\n    return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes);\n  };\n  /**\n   * @type {import('ipfs-core-types/src/name').API<{}>[\"publish\"]}\n   */\n\n\n  async function publish(value) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const resolve = !(options.resolve === false);\n    const lifetime = options.lifetime || '24h';\n    const key = options.key || 'self';\n\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n    } // TODO: params related logic should be in the core implementation\n    // Normalize path value\n\n\n    try {\n      value = normalizePath(value);\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n      throw err;\n    }\n\n    let pubLifetime = 0;\n\n    try {\n      pubLifetime = parseDuration(lifetime) || 0; // Calculate lifetime with nanoseconds precision\n\n      pubLifetime = parseFloat(pubLifetime.toFixed(6));\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n      throw err;\n    } // TODO: ttl human for cache\n\n\n    const results = await Promise.all([// verify if the path exists, if not, an error will stop the execution\n    lookupKey(key), // if resolving, do a get so we make sure we have the blocks\n    resolve ? resolvePath({\n      ipns,\n      repo,\n      codecs\n    }, value) : Promise.resolve()]);\n    const bytes = uint8ArrayFromString(value); // Start publishing process\n\n    const result = await ipns.publish(results[0], bytes, pubLifetime, options);\n    return {\n      name: result.name,\n      value: uint8ArrayToString(result.value)\n    };\n  }\n\n  return withTimeoutOption(publish);\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/name/publish.js"],"names":["logger","parseDuration","importKey","unmarshalPrivateKey","errcode","fromString","uint8ArrayFromString","toString","uint8ArrayToString","OFFLINE_ERROR","normalizePath","withTimeoutOption","resolvePath","peerIdFromKeys","log","createPublish","ipns","repo","codecs","peerId","isOnline","keychain","lookupKey","keyName","privateKey","pem","exportKey","err","error","public","bytes","publish","value","options","resolve","lifetime","key","Error","pubLifetime","parseFloat","toFixed","results","Promise","all","result","name"],"mappings":"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","sourcesContent":["import { logger } from '@libp2p/logger'\nimport parseDuration from 'parse-duration'\nimport { importKey, unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport errcode from 'err-code'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { OFFLINE_ERROR, normalizePath } from '../../utils.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { resolvePath } from './utils.js'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\n\nconst log = logger('ipfs:name:publish')\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {object} config\n * @param {import('../ipns').IPNSAPI} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('ipfs-core-types/src/root').API<{}>[\"isOnline\"]} config.isOnline\n * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n */\nexport function createPublish ({ ipns, repo, codecs, peerId, isOnline, keychain }) {\n  /**\n   * @param {string} keyName\n   */\n  const lookupKey = async keyName => {\n    /** @type {import('@libp2p/interface-keys').PrivateKey} */\n    let privateKey\n\n    if (keyName === 'self' && peerId.privateKey != null) {\n      privateKey = await unmarshalPrivateKey(peerId.privateKey)\n    } else {\n      try {\n        // We're exporting and immediately importing the key, so we can just use a throw away password\n        const pem = await keychain.exportKey(keyName, 'temp')\n        privateKey = await importKey(pem, 'temp')\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n        throw errcode(err, 'ERR_CANNOT_GET_KEY')\n      }\n    }\n\n    return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes)\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/name').API<{}>[\"publish\"]}\n   */\n  async function publish (value, options = {}) {\n    const resolve = !(options.resolve === false)\n    const lifetime = options.lifetime || '24h'\n    const key = options.key || 'self'\n\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    // TODO: params related logic should be in the core implementation\n    // Normalize path value\n    try {\n      value = normalizePath(value)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw err\n    }\n\n    let pubLifetime = 0\n    try {\n      pubLifetime = parseDuration(lifetime) || 0\n\n      // Calculate lifetime with nanoseconds precision\n      pubLifetime = parseFloat(pubLifetime.toFixed(6))\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw err\n    }\n\n    // TODO: ttl human for cache\n    const results = await Promise.all([\n      // verify if the path exists, if not, an error will stop the execution\n      lookupKey(key),\n      // if resolving, do a get so we make sure we have the blocks\n      resolve ? resolvePath({ ipns, repo, codecs }, value) : Promise.resolve()\n    ])\n\n    const bytes = uint8ArrayFromString(value)\n\n    // Start publishing process\n    const result = await ipns.publish(results[0], bytes, pubLifetime, options)\n\n    return {\n      name: result.name,\n      value: uint8ArrayToString(result.value)\n    }\n  }\n\n  return withTimeoutOption(publish)\n}\n"]},"metadata":{},"sourceType":"module"}