{"ast":null,"code":"import { nanoid } from 'nanoid';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nconst pathSepS = '/';\nconst pathSepB = new TextEncoder().encode(pathSepS);\nconst pathSep = pathSepB[0];\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\n\nexport class Key {\n  /**\n   * @param {string | Uint8Array} s\n   * @param {boolean} [clean]\n   */\n  constructor(s, clean) {\n    if (typeof s === 'string') {\n      this._buf = uint8ArrayFromString(s);\n    } else if (s instanceof Uint8Array) {\n      this._buf = s;\n    } else {\n      throw new Error('Invalid key, should be String of Uint8Array');\n    }\n\n    if (clean == null) {\n      clean = true;\n    }\n\n    if (clean) {\n      this.clean();\n    }\n\n    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n      throw new Error('Invalid key');\n    }\n  }\n  /**\n   * Convert to the string representation\n   *\n   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.\n   * @returns {string}\n   */\n\n\n  toString() {\n    let encoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'utf8';\n    return uint8ArrayToString(this._buf, encoding);\n  }\n  /**\n   * Return the Uint8Array representation of the key\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  uint8Array() {\n    return this._buf;\n  }\n  /**\n   * Return string representation of the key\n   *\n   * @returns {string}\n   */\n\n\n  get [Symbol.toStringTag]() {\n    return `Key(${this.toString()})`;\n  }\n  /**\n   * Constructs a key out of a namespace array.\n   *\n   * @param {Array<string>} list - The array of namespaces\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.withNamespaces(['one', 'two'])\n   * // => Key('/one/two')\n   * ```\n   */\n\n\n  static withNamespaces(list) {\n    return new Key(list.join(pathSepS));\n  }\n  /**\n   * Returns a randomly (uuid) generated key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.random()\n   * // => Key('/f98719ea086343f7b71f32ea9d9d521d')\n   * ```\n   */\n\n\n  static random() {\n    return new Key(nanoid().replace(/-/g, ''));\n  }\n  /**\n   * @param {*} other\n   */\n\n\n  static asKey(other) {\n    if (other instanceof Uint8Array || typeof other === 'string') {\n      // we can create a key from this\n      return new Key(other);\n    }\n\n    if (typeof other.uint8Array === 'function') {\n      // this is an older version or may have crossed the esm/cjs boundary\n      return new Key(other.uint8Array());\n    }\n\n    return null;\n  }\n  /**\n   * Cleanup the current key\n   *\n   * @returns {void}\n   */\n\n\n  clean() {\n    if (this._buf == null || this._buf.byteLength === 0) {\n      this._buf = pathSepB;\n    }\n\n    if (this._buf[0] !== pathSep) {\n      const bytes = new Uint8Array(this._buf.byteLength + 1);\n      bytes.fill(pathSep, 0, 1);\n      bytes.set(this._buf, 1);\n      this._buf = bytes;\n    } // normalize does not remove trailing slashes\n\n\n    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n      this._buf = this._buf.subarray(0, -1);\n    }\n  }\n  /**\n   * Check if the given key is sorted lower than ourself.\n   *\n   * @param {Key} key - The other Key to check against\n   * @returns {boolean}\n   */\n\n\n  less(key) {\n    const list1 = this.list();\n    const list2 = key.list();\n\n    for (let i = 0; i < list1.length; i++) {\n      if (list2.length < i + 1) {\n        return false;\n      }\n\n      const c1 = list1[i];\n      const c2 = list2[i];\n\n      if (c1 < c2) {\n        return true;\n      } else if (c1 > c2) {\n        return false;\n      }\n    }\n\n    return list1.length < list2.length;\n  }\n  /**\n   * Returns the key with all parts in reversed order.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n   * ```\n   */\n\n\n  reverse() {\n    return Key.withNamespaces(this.list().slice().reverse());\n  }\n  /**\n   * Returns the `namespaces` making up this Key.\n   *\n   * @returns {Array<string>}\n   */\n\n\n  namespaces() {\n    return this.list();\n  }\n  /** Returns the \"base\" namespace of this key.\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n   * // => 'Actor:JohnCleese'\n   * ```\n   */\n\n\n  baseNamespace() {\n    const ns = this.namespaces();\n    return ns[ns.length - 1];\n  }\n  /**\n   * Returns the `list` representation of this key.\n   *\n   * @returns {Array<string>}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n   * ```\n   */\n\n\n  list() {\n    return this.toString().split(pathSepS).slice(1);\n  }\n  /**\n   * Returns the \"type\" of this key (value of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n   * // => 'Actor'\n   * ```\n   */\n\n\n  type() {\n    return namespaceType(this.baseNamespace());\n  }\n  /**\n   * Returns the \"name\" of this key (field of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n   * // => 'JohnCleese'\n   * ```\n   */\n\n\n  name() {\n    return namespaceValue(this.baseNamespace());\n  }\n  /**\n   * Returns an \"instance\" of this type key (appends value to namespace).\n   *\n   * @param {string} s - The string to append.\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n\n\n  instance(s) {\n    return new Key(this.toString() + ':' + s);\n  }\n  /**\n   * Returns the \"path\" of this key (parent + type).\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n   * // => Key('/Comedy/MontyPython/Actor')\n   * ```\n   */\n\n\n  path() {\n    let p = this.parent().toString();\n\n    if (!p.endsWith(pathSepS)) {\n      p += pathSepS;\n    }\n\n    p += this.type();\n    return new Key(p);\n  }\n  /**\n   * Returns the `parent` Key of this Key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n   * // => Key(\"/Comedy/MontyPython\")\n   * ```\n   */\n\n\n  parent() {\n    const list = this.list();\n\n    if (list.length === 1) {\n      return new Key(pathSepS);\n    }\n\n    return new Key(list.slice(0, -1).join(pathSepS));\n  }\n  /**\n   * Returns the `child` Key of this Key.\n   *\n   * @param {Key} key - The child Key to add\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n\n\n  child(key) {\n    if (this.toString() === pathSepS) {\n      return key;\n    } else if (key.toString() === pathSepS) {\n      return this;\n    }\n\n    return new Key(this.toString() + key.toString(), false);\n  }\n  /**\n   * Returns whether this key is a prefix of `other`\n   *\n   * @param {Key} other - The other key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n   * // => true\n   * ```\n   */\n\n\n  isAncestorOf(other) {\n    if (other.toString() === this.toString()) {\n      return false;\n    }\n\n    return other.toString().startsWith(this.toString());\n  }\n  /**\n   * Returns whether this key is a contains another as prefix.\n   *\n   * @param {Key} other - The other Key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n   * // => true\n   * ```\n   */\n\n\n  isDecendantOf(other) {\n    if (other.toString() === this.toString()) {\n      return false;\n    }\n\n    return this.toString().startsWith(other.toString());\n  }\n  /**\n   * Checks if this key has only one namespace.\n   *\n   * @returns {boolean}\n   *\n   */\n\n\n  isTopLevel() {\n    return this.list().length === 1;\n  }\n  /**\n   * Concats one or more Keys into one new Key.\n   *\n   * @param {Array<Key>} keys - The array of keys to concatenate\n   * @returns {Key}\n   */\n\n\n  concat() {\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n\n    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))]);\n  }\n\n}\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\n\nfunction namespaceType(ns) {\n  const parts = ns.split(':');\n\n  if (parts.length < 2) {\n    return '';\n  }\n\n  return parts.slice(0, -1).join(':');\n}\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\n\n\nfunction namespaceValue(ns) {\n  const parts = ns.split(':');\n  return parts[parts.length - 1];\n}\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */\n\n\nfunction flatten(arr) {\n  return [].concat(...arr);\n}","map":{"version":3,"mappings":"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","names":["nanoid","toString","uint8ArrayToString","fromString","uint8ArrayFromString","pathSepS","pathSepB","TextEncoder","encode","pathSep","Key","constructor","s","clean","_buf","Uint8Array","Error","byteLength","encoding","uint8Array","Symbol","toStringTag","withNamespaces","list","join","random","replace","asKey","other","bytes","fill","set","subarray","less","key","list1","list2","i","length","c1","c2","reverse","slice","namespaces","baseNamespace","ns","split","type","namespaceType","name","namespaceValue","instance","path","p","parent","endsWith","child","isAncestorOf","startsWith","isDecendantOf","isTopLevel","concat","keys","flatten","map","parts","arr"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\interface-datastore\\src\\key.ts"],"sourcesContent":["\nimport { nanoid } from 'nanoid'\nimport { SupportedEncodings, toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\n\nconst pathSepS = '/'\nconst pathSepB = new TextEncoder().encode(pathSepS)\nconst pathSep = pathSepB[0]\n\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nexport class Key {\n  private _buf: Uint8Array\n\n  /**\n   * @param {string | Uint8Array} s\n   * @param {boolean} [clean]\n   */\n  constructor (s: string | Uint8Array, clean?: boolean) {\n    if (typeof s === 'string') {\n      this._buf = uint8ArrayFromString(s)\n    } else if (s instanceof Uint8Array) {\n      this._buf = s\n    } else {\n      throw new Error('Invalid key, should be String of Uint8Array')\n    }\n\n    if (clean == null) {\n      clean = true\n    }\n\n    if (clean) {\n      this.clean()\n    }\n\n    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n      throw new Error('Invalid key')\n    }\n  }\n\n  /**\n   * Convert to the string representation\n   *\n   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.\n   * @returns {string}\n   */\n  toString (encoding: SupportedEncodings = 'utf8'): string {\n    return uint8ArrayToString(this._buf, encoding)\n  }\n\n  /**\n   * Return the Uint8Array representation of the key\n   *\n   * @returns {Uint8Array}\n   */\n  uint8Array (): Uint8Array {\n    return this._buf\n  }\n\n  /**\n   * Return string representation of the key\n   *\n   * @returns {string}\n   */\n  get [Symbol.toStringTag] (): string {\n    return `Key(${this.toString()})`\n  }\n\n  /**\n   * Constructs a key out of a namespace array.\n   *\n   * @param {Array<string>} list - The array of namespaces\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.withNamespaces(['one', 'two'])\n   * // => Key('/one/two')\n   * ```\n   */\n  static withNamespaces (list: string[]): Key {\n    return new Key(list.join(pathSepS))\n  }\n\n  /**\n   * Returns a randomly (uuid) generated key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.random()\n   * // => Key('/f98719ea086343f7b71f32ea9d9d521d')\n   * ```\n   */\n  static random (): Key {\n    return new Key(nanoid().replace(/-/g, ''))\n  }\n\n  /**\n   * @param {*} other\n   */\n  static asKey (other: any): Key | null {\n    if (other instanceof Uint8Array || typeof other === 'string') {\n      // we can create a key from this\n      return new Key(other)\n    }\n\n    if (typeof other.uint8Array === 'function') {\n      // this is an older version or may have crossed the esm/cjs boundary\n      return new Key(other.uint8Array())\n    }\n\n    return null\n  }\n\n  /**\n   * Cleanup the current key\n   *\n   * @returns {void}\n   */\n  clean (): void {\n    if (this._buf == null || this._buf.byteLength === 0) {\n      this._buf = pathSepB\n    }\n\n    if (this._buf[0] !== pathSep) {\n      const bytes = new Uint8Array(this._buf.byteLength + 1)\n      bytes.fill(pathSep, 0, 1)\n      bytes.set(this._buf, 1)\n      this._buf = bytes\n    }\n\n    // normalize does not remove trailing slashes\n    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n      this._buf = this._buf.subarray(0, -1)\n    }\n  }\n\n  /**\n   * Check if the given key is sorted lower than ourself.\n   *\n   * @param {Key} key - The other Key to check against\n   * @returns {boolean}\n   */\n  less (key: Key): boolean {\n    const list1 = this.list()\n    const list2 = key.list()\n\n    for (let i = 0; i < list1.length; i++) {\n      if (list2.length < i + 1) {\n        return false\n      }\n\n      const c1 = list1[i]\n      const c2 = list2[i]\n\n      if (c1 < c2) {\n        return true\n      } else if (c1 > c2) {\n        return false\n      }\n    }\n\n    return list1.length < list2.length\n  }\n\n  /**\n   * Returns the key with all parts in reversed order.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n   * ```\n   */\n  reverse (): Key {\n    return Key.withNamespaces(this.list().slice().reverse())\n  }\n\n  /**\n   * Returns the `namespaces` making up this Key.\n   *\n   * @returns {Array<string>}\n   */\n  namespaces (): string[] {\n    return this.list()\n  }\n\n  /** Returns the \"base\" namespace of this key.\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n   * // => 'Actor:JohnCleese'\n   * ```\n   */\n  baseNamespace (): string {\n    const ns = this.namespaces()\n    return ns[ns.length - 1]\n  }\n\n  /**\n   * Returns the `list` representation of this key.\n   *\n   * @returns {Array<string>}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n   * ```\n   */\n  list (): string[] {\n    return this.toString().split(pathSepS).slice(1)\n  }\n\n  /**\n   * Returns the \"type\" of this key (value of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n   * // => 'Actor'\n   * ```\n   */\n  type (): string {\n    return namespaceType(this.baseNamespace())\n  }\n\n  /**\n   * Returns the \"name\" of this key (field of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n   * // => 'JohnCleese'\n   * ```\n   */\n  name (): string {\n    return namespaceValue(this.baseNamespace())\n  }\n\n  /**\n   * Returns an \"instance\" of this type key (appends value to namespace).\n   *\n   * @param {string} s - The string to append.\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n  instance (s: string): Key {\n    return new Key(this.toString() + ':' + s)\n  }\n\n  /**\n   * Returns the \"path\" of this key (parent + type).\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n   * // => Key('/Comedy/MontyPython/Actor')\n   * ```\n   */\n  path (): Key {\n    let p = this.parent().toString()\n    if (!p.endsWith(pathSepS)) {\n      p += pathSepS\n    }\n    p += this.type()\n    return new Key(p)\n  }\n\n  /**\n   * Returns the `parent` Key of this Key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n   * // => Key(\"/Comedy/MontyPython\")\n   * ```\n   */\n  parent (): Key {\n    const list = this.list()\n    if (list.length === 1) {\n      return new Key(pathSepS)\n    }\n\n    return new Key(list.slice(0, -1).join(pathSepS))\n  }\n\n  /**\n   * Returns the `child` Key of this Key.\n   *\n   * @param {Key} key - The child Key to add\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n  child (key: Key): Key {\n    if (this.toString() === pathSepS) {\n      return key\n    } else if (key.toString() === pathSepS) {\n      return this\n    }\n\n    return new Key(this.toString() + key.toString(), false)\n  }\n\n  /**\n   * Returns whether this key is a prefix of `other`\n   *\n   * @param {Key} other - The other key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n   * // => true\n   * ```\n   */\n  isAncestorOf (other: Key): boolean {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return other.toString().startsWith(this.toString())\n  }\n\n  /**\n   * Returns whether this key is a contains another as prefix.\n   *\n   * @param {Key} other - The other Key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n   * // => true\n   * ```\n   */\n  isDecendantOf (other: Key): boolean {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return this.toString().startsWith(other.toString())\n  }\n\n  /**\n   * Checks if this key has only one namespace.\n   *\n   * @returns {boolean}\n   *\n   */\n  isTopLevel (): boolean {\n    return this.list().length === 1\n  }\n\n  /**\n   * Concats one or more Keys into one new Key.\n   *\n   * @param {Array<Key>} keys - The array of keys to concatenate\n   * @returns {Key}\n   */\n  concat (...keys: Key[]): Key {\n    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))])\n  }\n}\n\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType (ns: string): string {\n  const parts = ns.split(':')\n  if (parts.length < 2) {\n    return ''\n  }\n  return parts.slice(0, -1).join(':')\n}\n\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue (ns: string): string {\n  const parts = ns.split(':')\n  return parts[parts.length - 1]\n}\n\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */\nfunction flatten (arr: any[]): string[] {\n  return ([]).concat(...arr)\n}\n"]},"metadata":{},"sourceType":"module"}