{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { RELAY_CODEC } from './multicodec.js';\nimport { canHop } from './circuit/hop.js';\nimport { namespaceToCid } from './utils.js';\nimport { CIRCUIT_PROTO_CODE, HOP_METADATA_KEY, HOP_METADATA_VALUE, RELAY_RENDEZVOUS_NS } from './constants.js';\nimport sort from 'it-sort';\nimport all from 'it-all';\nimport { pipe } from 'it-pipe';\nimport { publicAddressesFirst } from '@libp2p/utils/address-sort';\nconst log = logger('libp2p:auto-relay');\n\nconst noop = () => {};\n\nexport class AutoRelay {\n  constructor(components, init) {\n    this.components = components;\n    this.addressSorter = init.addressSorter ?? publicAddressesFirst;\n    this.maxListeners = init.maxListeners ?? 1;\n    this.listenRelays = new Set();\n    this.onError = init.onError ?? noop;\n    this._onProtocolChange = this._onProtocolChange.bind(this);\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);\n    this.components.peerStore.addEventListener('change:protocols', evt => {\n      void this._onProtocolChange(evt).catch(err => {\n        log.error(err);\n      });\n    });\n    this.components.connectionManager.addEventListener('peer:disconnect', this._onPeerDisconnected);\n  }\n  /**\n   * Check if a peer supports the relay protocol.\n   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.\n   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if\n   * inside the threshold.\n   */\n\n\n  async _onProtocolChange(evt) {\n    const {\n      peerId,\n      protocols\n    } = evt.detail;\n    const id = peerId.toString(); // Check if it has the protocol\n\n    const hasProtocol = protocols.find(protocol => protocol === RELAY_CODEC); // If no protocol, check if we were keeping the peer before as a listenRelay\n\n    if (hasProtocol == null) {\n      if (this.listenRelays.has(id)) {\n        await this._removeListenRelay(id);\n      }\n\n      return;\n    }\n\n    if (this.listenRelays.has(id)) {\n      return;\n    } // If protocol, check if can hop, store info in the metadataBook and listen on it\n\n\n    try {\n      const connections = this.components.connectionManager.getConnections(peerId);\n\n      if (connections.length === 0) {\n        return;\n      }\n\n      const connection = connections[0]; // Do not hop on a relayed connection\n\n      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {\n        log(`relayed connection to ${id} will not be used to hop on`);\n        return;\n      }\n\n      const supportsHop = await canHop({\n        connection\n      });\n\n      if (supportsHop) {\n        await this.components.peerStore.metadataBook.setValue(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE));\n        await this._addListenRelay(connection, id);\n      }\n    } catch (err) {\n      this.onError(err);\n    }\n  }\n  /**\n   * Peer disconnects\n   */\n\n\n  _onPeerDisconnected(evt) {\n    const connection = evt.detail;\n    const peerId = connection.remotePeer;\n    const id = peerId.toString(); // Not listening on this relay\n\n    if (!this.listenRelays.has(id)) {\n      return;\n    }\n\n    this._removeListenRelay(id).catch(err => {\n      log.error(err);\n    });\n  }\n  /**\n   * Attempt to listen on the given relay connection\n   */\n\n\n  async _addListenRelay(connection, id) {\n    try {\n      // Check if already listening on enough relays\n      if (this.listenRelays.size >= this.maxListeners) {\n        return;\n      } // Get peer known addresses and sort them with public addresses first\n\n\n      const remoteAddrs = await pipe(await this.components.peerStore.addressBook.get(connection.remotePeer), source => sort(source, this.addressSorter), async source => await all(source)); // Attempt to listen on relay\n\n      const result = await Promise.all(remoteAddrs.map(async addr => {\n        try {\n          let multiaddr = addr.multiaddr;\n\n          if (multiaddr.getPeerId() == null) {\n            multiaddr = multiaddr.encapsulate(`/p2p/${connection.remotePeer.toString()}`);\n          }\n\n          multiaddr = multiaddr.encapsulate('/p2p-circuit'); // Announce multiaddrs will update on listen success by TransportManager event being triggered\n\n          await this.components.transportManager.listen([multiaddr]);\n          return true;\n        } catch (err) {\n          log.error('error listening on circuit address', err);\n          this.onError(err);\n        }\n\n        return false;\n      }));\n\n      if (result.includes(true)) {\n        this.listenRelays.add(id);\n      }\n    } catch (err) {\n      this.onError(err);\n      this.listenRelays.delete(id);\n    }\n  }\n  /**\n   * Remove listen relay\n   */\n\n\n  async _removeListenRelay(id) {\n    if (this.listenRelays.delete(id)) {\n      // TODO: this should be responsibility of the connMgr\n      await this._listenOnAvailableHopRelays([id]);\n    }\n  }\n  /**\n   * Try to listen on available hop relay connections.\n   * The following order will happen while we do not have enough relays.\n   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.\n   * 2. Dial and try to listen on the peers we know that support hop but are not connected.\n   * 3. Search the network.\n   */\n\n\n  async _listenOnAvailableHopRelays() {\n    let peersToIgnore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    // TODO: The peer redial issue on disconnect should be handled by connection gating\n    // Check if already listening on enough relays\n    if (this.listenRelays.size >= this.maxListeners) {\n      return;\n    }\n\n    const knownHopsToDial = [];\n    const peers = await this.components.peerStore.all(); // Check if we have known hop peers to use and attempt to listen on the already connected\n\n    for (const {\n      id,\n      metadata\n    } of peers) {\n      const idStr = id.toString(); // Continue to next if listening on this or peer to ignore\n\n      if (this.listenRelays.has(idStr)) {\n        continue;\n      }\n\n      if (peersToIgnore.includes(idStr)) {\n        continue;\n      }\n\n      const supportsHop = metadata.get(HOP_METADATA_KEY); // Continue to next if it does not support Hop\n\n      if (supportsHop == null || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {\n        continue;\n      }\n\n      const connections = this.components.connectionManager.getConnections(id); // If not connected, store for possible later use.\n\n      if (connections.length === 0) {\n        knownHopsToDial.push(id);\n        continue;\n      }\n\n      await this._addListenRelay(connections[0], idStr); // Check if already listening on enough relays\n\n      if (this.listenRelays.size >= this.maxListeners) {\n        return;\n      }\n    } // Try to listen on known peers that are not connected\n\n\n    for (const peerId of knownHopsToDial) {\n      await this._tryToListenOnRelay(peerId); // Check if already listening on enough relays\n\n      if (this.listenRelays.size >= this.maxListeners) {\n        return;\n      }\n    } // Try to find relays to hop on the network\n\n\n    try {\n      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);\n\n      for await (const provider of this.components.contentRouting.findProviders(cid)) {\n        if (provider.multiaddrs.length === 0) {\n          continue;\n        }\n\n        const peerId = provider.id;\n\n        if (peerId.equals(this.components.peerId)) {\n          // Skip the provider if it's us as dialing will fail\n          continue;\n        }\n\n        await this.components.peerStore.addressBook.add(peerId, provider.multiaddrs);\n        await this._tryToListenOnRelay(peerId); // Check if already listening on enough relays\n\n        if (this.listenRelays.size >= this.maxListeners) {\n          return;\n        }\n      }\n    } catch (err) {\n      this.onError(err);\n    }\n  }\n\n  async _tryToListenOnRelay(peerId) {\n    try {\n      const connection = await this.components.connectionManager.openConnection(peerId);\n      await this._addListenRelay(connection, peerId.toString());\n    } catch (err) {\n      log.error('Could not use %p as relay', peerId, err);\n      this.onError(err, `could not connect and listen on known hop relay ${peerId.toString()}`);\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","fromString","uint8ArrayFromString","toString","uint8ArrayToString","RELAY_CODEC","canHop","namespaceToCid","CIRCUIT_PROTO_CODE","HOP_METADATA_KEY","HOP_METADATA_VALUE","RELAY_RENDEZVOUS_NS","sort","all","pipe","publicAddressesFirst","log","noop","AutoRelay","constructor","components","init","addressSorter","maxListeners","listenRelays","Set","onError","_onProtocolChange","bind","_onPeerDisconnected","peerStore","addEventListener","evt","catch","err","error","connectionManager","peerId","protocols","detail","id","hasProtocol","find","protocol","has","_removeListenRelay","connections","getConnections","length","connection","remoteAddr","protoCodes","includes","supportsHop","metadataBook","setValue","_addListenRelay","remotePeer","size","remoteAddrs","addressBook","get","source","result","Promise","map","addr","multiaddr","getPeerId","encapsulate","transportManager","listen","add","delete","_listenOnAvailableHopRelays","peersToIgnore","knownHopsToDial","peers","metadata","idStr","push","_tryToListenOnRelay","cid","provider","contentRouting","findProviders","multiaddrs","equals","openConnection"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\circuit\\auto-relay.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { RELAY_CODEC } from './multicodec.js'\nimport { canHop } from './circuit/hop.js'\nimport { namespaceToCid } from './utils.js'\nimport {\n  CIRCUIT_PROTO_CODE,\n  HOP_METADATA_KEY,\n  HOP_METADATA_VALUE,\n  RELAY_RENDEZVOUS_NS\n} from './constants.js'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { AddressSorter, PeerProtocolsChangeData } from '@libp2p/interface-peer-store'\nimport type { Connection } from '@libp2p/interface-connection'\nimport sort from 'it-sort'\nimport all from 'it-all'\nimport { pipe } from 'it-pipe'\nimport { publicAddressesFirst } from '@libp2p/utils/address-sort'\nimport type { RelayComponents } from './index.js'\n\nconst log = logger('libp2p:auto-relay')\n\nconst noop = () => {}\n\nexport interface AutoRelayInit {\n  addressSorter?: AddressSorter\n  maxListeners?: number\n  onError?: (error: Error, msg?: string) => void\n}\n\nexport class AutoRelay {\n  private readonly components: RelayComponents\n  private readonly addressSorter: AddressSorter\n  private readonly maxListeners: number\n  private readonly listenRelays: Set<string>\n  private readonly onError: (error: Error, msg?: string) => void\n\n  constructor (components: RelayComponents, init: AutoRelayInit) {\n    this.components = components\n    this.addressSorter = init.addressSorter ?? publicAddressesFirst\n    this.maxListeners = init.maxListeners ?? 1\n    this.listenRelays = new Set()\n    this.onError = init.onError ?? noop\n\n    this._onProtocolChange = this._onProtocolChange.bind(this)\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this)\n\n    this.components.peerStore.addEventListener('change:protocols', (evt) => {\n      void this._onProtocolChange(evt).catch(err => {\n        log.error(err)\n      })\n    })\n    this.components.connectionManager.addEventListener('peer:disconnect', this._onPeerDisconnected)\n  }\n\n  /**\n   * Check if a peer supports the relay protocol.\n   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.\n   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if\n   * inside the threshold.\n   */\n  async _onProtocolChange (evt: CustomEvent<PeerProtocolsChangeData>) {\n    const {\n      peerId,\n      protocols\n    } = evt.detail\n    const id = peerId.toString()\n\n    // Check if it has the protocol\n    const hasProtocol = protocols.find(protocol => protocol === RELAY_CODEC)\n\n    // If no protocol, check if we were keeping the peer before as a listenRelay\n    if (hasProtocol == null) {\n      if (this.listenRelays.has(id)) {\n        await this._removeListenRelay(id)\n      }\n\n      return\n    }\n\n    if (this.listenRelays.has(id)) {\n      return\n    }\n\n    // If protocol, check if can hop, store info in the metadataBook and listen on it\n    try {\n      const connections = this.components.connectionManager.getConnections(peerId)\n\n      if (connections.length === 0) {\n        return\n      }\n\n      const connection = connections[0]\n\n      // Do not hop on a relayed connection\n      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {\n        log(`relayed connection to ${id} will not be used to hop on`)\n        return\n      }\n\n      const supportsHop = await canHop({ connection })\n\n      if (supportsHop) {\n        await this.components.peerStore.metadataBook.setValue(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE))\n        await this._addListenRelay(connection, id)\n      }\n    } catch (err: any) {\n      this.onError(err)\n    }\n  }\n\n  /**\n   * Peer disconnects\n   */\n  _onPeerDisconnected (evt: CustomEvent<Connection>) {\n    const connection = evt.detail\n    const peerId = connection.remotePeer\n    const id = peerId.toString()\n\n    // Not listening on this relay\n    if (!this.listenRelays.has(id)) {\n      return\n    }\n\n    this._removeListenRelay(id).catch(err => {\n      log.error(err)\n    })\n  }\n\n  /**\n   * Attempt to listen on the given relay connection\n   */\n  async _addListenRelay (connection: Connection, id: string): Promise<void> {\n    try {\n      // Check if already listening on enough relays\n      if (this.listenRelays.size >= this.maxListeners) {\n        return\n      }\n\n      // Get peer known addresses and sort them with public addresses first\n      const remoteAddrs = await pipe(\n        await this.components.peerStore.addressBook.get(connection.remotePeer),\n        (source) => sort(source, this.addressSorter),\n        async (source) => await all(source)\n      )\n\n      // Attempt to listen on relay\n      const result = await Promise.all(\n        remoteAddrs.map(async addr => {\n          try {\n            let multiaddr = addr.multiaddr\n\n            if (multiaddr.getPeerId() == null) {\n              multiaddr = multiaddr.encapsulate(`/p2p/${connection.remotePeer.toString()}`)\n            }\n\n            multiaddr = multiaddr.encapsulate('/p2p-circuit')\n\n            // Announce multiaddrs will update on listen success by TransportManager event being triggered\n            await this.components.transportManager.listen([multiaddr])\n            return true\n          } catch (err: any) {\n            log.error('error listening on circuit address', err)\n            this.onError(err)\n          }\n\n          return false\n        })\n      )\n\n      if (result.includes(true)) {\n        this.listenRelays.add(id)\n      }\n    } catch (err: any) {\n      this.onError(err)\n      this.listenRelays.delete(id)\n    }\n  }\n\n  /**\n   * Remove listen relay\n   */\n  async _removeListenRelay (id: string) {\n    if (this.listenRelays.delete(id)) {\n      // TODO: this should be responsibility of the connMgr\n      await this._listenOnAvailableHopRelays([id])\n    }\n  }\n\n  /**\n   * Try to listen on available hop relay connections.\n   * The following order will happen while we do not have enough relays.\n   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.\n   * 2. Dial and try to listen on the peers we know that support hop but are not connected.\n   * 3. Search the network.\n   */\n  async _listenOnAvailableHopRelays (peersToIgnore: string[] = []) {\n    // TODO: The peer redial issue on disconnect should be handled by connection gating\n    // Check if already listening on enough relays\n    if (this.listenRelays.size >= this.maxListeners) {\n      return\n    }\n\n    const knownHopsToDial = []\n    const peers = await this.components.peerStore.all()\n\n    // Check if we have known hop peers to use and attempt to listen on the already connected\n    for (const { id, metadata } of peers) {\n      const idStr = id.toString()\n\n      // Continue to next if listening on this or peer to ignore\n      if (this.listenRelays.has(idStr)) {\n        continue\n      }\n\n      if (peersToIgnore.includes(idStr)) {\n        continue\n      }\n\n      const supportsHop = metadata.get(HOP_METADATA_KEY)\n\n      // Continue to next if it does not support Hop\n      if ((supportsHop == null) || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {\n        continue\n      }\n\n      const connections = this.components.connectionManager.getConnections(id)\n\n      // If not connected, store for possible later use.\n      if (connections.length === 0) {\n        knownHopsToDial.push(id)\n        continue\n      }\n\n      await this._addListenRelay(connections[0], idStr)\n\n      // Check if already listening on enough relays\n      if (this.listenRelays.size >= this.maxListeners) {\n        return\n      }\n    }\n\n    // Try to listen on known peers that are not connected\n    for (const peerId of knownHopsToDial) {\n      await this._tryToListenOnRelay(peerId)\n\n      // Check if already listening on enough relays\n      if (this.listenRelays.size >= this.maxListeners) {\n        return\n      }\n    }\n\n    // Try to find relays to hop on the network\n    try {\n      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS)\n      for await (const provider of this.components.contentRouting.findProviders(cid)) {\n        if (provider.multiaddrs.length === 0) {\n          continue\n        }\n\n        const peerId = provider.id\n\n        if (peerId.equals(this.components.peerId)) {\n          // Skip the provider if it's us as dialing will fail\n          continue\n        }\n\n        await this.components.peerStore.addressBook.add(peerId, provider.multiaddrs)\n\n        await this._tryToListenOnRelay(peerId)\n\n        // Check if already listening on enough relays\n        if (this.listenRelays.size >= this.maxListeners) {\n          return\n        }\n      }\n    } catch (err: any) {\n      this.onError(err)\n    }\n  }\n\n  async _tryToListenOnRelay (peerId: PeerId) {\n    try {\n      const connection = await this.components.connectionManager.openConnection(peerId)\n      await this._addListenRelay(connection, peerId.toString())\n    } catch (err: any) {\n      log.error('Could not use %p as relay', peerId, err)\n      this.onError(err, `could not connect and listen on known hop relay ${peerId.toString()}`)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}