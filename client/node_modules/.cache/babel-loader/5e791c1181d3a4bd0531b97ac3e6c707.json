{"ast":null,"code":"/* eslint-disable import/export */\n\n/* eslint-disable complexity */\n\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var IpnsEntry;\n\n(function (IpnsEntry) {\n  let ValidityType;\n\n  (function (ValidityType) {\n    ValidityType[\"EOL\"] = \"EOL\";\n  })(ValidityType = IpnsEntry.ValidityType || (IpnsEntry.ValidityType = {}));\n\n  let __ValidityTypeValues;\n\n  (function (__ValidityTypeValues) {\n    __ValidityTypeValues[__ValidityTypeValues[\"EOL\"] = 0] = \"EOL\";\n  })(__ValidityTypeValues || (__ValidityTypeValues = {}));\n\n  (function (ValidityType) {\n    ValidityType.codec = () => {\n      return enumeration(__ValidityTypeValues);\n    };\n  })(ValidityType = IpnsEntry.ValidityType || (IpnsEntry.ValidityType = {}));\n\n  let _codec;\n\n  IpnsEntry.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.value != null) {\n          w.uint32(10);\n          w.bytes(obj.value);\n        }\n\n        if (obj.signature != null) {\n          w.uint32(18);\n          w.bytes(obj.signature);\n        }\n\n        if (obj.validityType != null) {\n          w.uint32(24);\n          IpnsEntry.ValidityType.codec().encode(obj.validityType, w);\n        }\n\n        if (obj.validity != null) {\n          w.uint32(34);\n          w.bytes(obj.validity);\n        }\n\n        if (obj.sequence != null) {\n          w.uint32(40);\n          w.uint64(obj.sequence);\n        }\n\n        if (obj.ttl != null) {\n          w.uint32(48);\n          w.uint64(obj.ttl);\n        }\n\n        if (obj.pubKey != null) {\n          w.uint32(58);\n          w.bytes(obj.pubKey);\n        }\n\n        if (obj.signatureV2 != null) {\n          w.uint32(66);\n          w.bytes(obj.signatureV2);\n        }\n\n        if (obj.data != null) {\n          w.uint32(74);\n          w.bytes(obj.data);\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {};\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.value = reader.bytes();\n              break;\n\n            case 2:\n              obj.signature = reader.bytes();\n              break;\n\n            case 3:\n              obj.validityType = IpnsEntry.ValidityType.codec().decode(reader);\n              break;\n\n            case 4:\n              obj.validity = reader.bytes();\n              break;\n\n            case 5:\n              obj.sequence = reader.uint64();\n              break;\n\n            case 6:\n              obj.ttl = reader.uint64();\n              break;\n\n            case 7:\n              obj.pubKey = reader.bytes();\n              break;\n\n            case 8:\n              obj.signatureV2 = reader.bytes();\n              break;\n\n            case 9:\n              obj.data = reader.bytes();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  IpnsEntry.encode = obj => {\n    return encodeMessage(obj, IpnsEntry.codec());\n  };\n\n  IpnsEntry.decode = buf => {\n    return decodeMessage(buf, IpnsEntry.codec());\n  };\n})(IpnsEntry || (IpnsEntry = {}));","map":{"version":3,"mappings":"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","names":["enumeration","encodeMessage","decodeMessage","message","IpnsEntry","ValidityType","__ValidityTypeValues","_codec","obj","w","opts","lengthDelimited","fork","value","uint32","bytes","signature","validityType","codec","encode","validity","sequence","uint64","ttl","pubKey","signatureV2","data","ldelim","reader","length","end","len","pos","tag","decode","skipType","buf"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\ipns\\src\\pb\\ipns.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { Codec } from 'protons-runtime'\n\nexport interface IpnsEntry {\n  value?: Uint8Array\n  signature?: Uint8Array\n  validityType?: IpnsEntry.ValidityType\n  validity?: Uint8Array\n  sequence?: bigint\n  ttl?: bigint\n  pubKey?: Uint8Array\n  signatureV2?: Uint8Array\n  data?: Uint8Array\n}\n\nexport namespace IpnsEntry {\n  export enum ValidityType {\n    EOL = 'EOL'\n  }\n\n  enum __ValidityTypeValues {\n    EOL = 0\n  }\n\n  export namespace ValidityType {\n    export const codec = (): Codec<ValidityType> => {\n      return enumeration<ValidityType>(__ValidityTypeValues)\n    }\n  }\n\n  let _codec: Codec<IpnsEntry>\n\n  export const codec = (): Codec<IpnsEntry> => {\n    if (_codec == null) {\n      _codec = message<IpnsEntry>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.value != null) {\n          w.uint32(10)\n          w.bytes(obj.value)\n        }\n\n        if (obj.signature != null) {\n          w.uint32(18)\n          w.bytes(obj.signature)\n        }\n\n        if (obj.validityType != null) {\n          w.uint32(24)\n          IpnsEntry.ValidityType.codec().encode(obj.validityType, w)\n        }\n\n        if (obj.validity != null) {\n          w.uint32(34)\n          w.bytes(obj.validity)\n        }\n\n        if (obj.sequence != null) {\n          w.uint32(40)\n          w.uint64(obj.sequence)\n        }\n\n        if (obj.ttl != null) {\n          w.uint32(48)\n          w.uint64(obj.ttl)\n        }\n\n        if (obj.pubKey != null) {\n          w.uint32(58)\n          w.bytes(obj.pubKey)\n        }\n\n        if (obj.signatureV2 != null) {\n          w.uint32(66)\n          w.bytes(obj.signatureV2)\n        }\n\n        if (obj.data != null) {\n          w.uint32(74)\n          w.bytes(obj.data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.value = reader.bytes()\n              break\n            case 2:\n              obj.signature = reader.bytes()\n              break\n            case 3:\n              obj.validityType = IpnsEntry.ValidityType.codec().decode(reader)\n              break\n            case 4:\n              obj.validity = reader.bytes()\n              break\n            case 5:\n              obj.sequence = reader.uint64()\n              break\n            case 6:\n              obj.ttl = reader.uint64()\n              break\n            case 7:\n              obj.pubKey = reader.bytes()\n              break\n            case 8:\n              obj.signatureV2 = reader.bytes()\n              break\n            case 9:\n              obj.data = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: IpnsEntry): Uint8Array => {\n    return encodeMessage(obj, IpnsEntry.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): IpnsEntry => {\n    return decodeMessage(buf, IpnsEntry.codec())\n  }\n}\n"]},"metadata":{},"sourceType":"module"}