{"ast":null,"code":"const MAX_HEADER_LENGTH = 2000;\nconst THROW_ON_MAX_HEADER_LENGTH_EXCEEDED = false;\n\nfunction hasRel(x) {\n  return x && x.rel;\n}\n\nfunction intoRels(acc, x) {\n  function splitRel(rel) {\n    acc[rel] = Object.assign({}, x, {\n      rel: rel\n    });\n  }\n\n  x.rel.split(/\\s+/).forEach(splitRel);\n  return acc;\n}\n\nfunction createObjects(acc, p) {\n  // rel=\"next\" => 1: rel 2: next\n  const m = p.match(/\\s*(.+)\\s*=\\s*\"?([^\"]+)\"?/);\n  if (m) acc[m[1]] = m[2];\n  return acc;\n}\n\nfunction parseLink(link) {\n  try {\n    const m = link.match(/<?([^>]*)>(.*)/);\n    const linkUrl = m[1];\n    const parts = m[2].split(';');\n    const qry = {}; // The origin is unused but it's required to parse relative URLs\n\n    const url = new URL(linkUrl, 'https://example.com');\n\n    for (const [key, value] of url.searchParams) {\n      qry[key] = value;\n    }\n\n    parts.shift();\n    let info = parts.reduce(createObjects, {});\n    info = Object.assign({}, qry, info);\n    info.url = linkUrl;\n    return info;\n  } catch {\n    return null;\n  }\n}\n\nfunction checkHeader(linkHeader, options) {\n  if (!linkHeader) return false;\n  options = options || {};\n  const maxHeaderLength = options.maxHeaderLength || MAX_HEADER_LENGTH;\n  const throwOnMaxHeaderLengthExceeded = options.throwOnMaxHeaderLengthExceeded || THROW_ON_MAX_HEADER_LENGTH_EXCEEDED;\n\n  if (linkHeader.length > maxHeaderLength) {\n    if (throwOnMaxHeaderLengthExceeded) {\n      throw new Error('Input string too long, it should be under ' + maxHeaderLength + ' characters.');\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction parseLinkHeader(linkHeader, options) {\n  if (!checkHeader(linkHeader, options)) return null;\n  return linkHeader.split(/,\\s*</).map(parseLink).filter(hasRel).reduce(intoRels, {});\n}\n\nexport { parseLinkHeader };","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/client/node_modules/@web3-storage/parse-link-header/index.js"],"names":["MAX_HEADER_LENGTH","THROW_ON_MAX_HEADER_LENGTH_EXCEEDED","hasRel","x","rel","intoRels","acc","splitRel","Object","assign","split","forEach","createObjects","p","m","match","parseLink","link","linkUrl","parts","qry","url","URL","key","value","searchParams","shift","info","reduce","checkHeader","linkHeader","options","maxHeaderLength","throwOnMaxHeaderLengthExceeded","length","Error","parseLinkHeader","map","filter"],"mappings":"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","sourcesContent":["const MAX_HEADER_LENGTH = 2000\nconst THROW_ON_MAX_HEADER_LENGTH_EXCEEDED = false\n\nfunction hasRel (x) {\n  return x && x.rel\n}\n\nfunction intoRels (acc, x) {\n  function splitRel (rel) {\n    acc[rel] = Object.assign({}, x, { rel: rel })\n  }\n\n  x.rel.split(/\\s+/).forEach(splitRel)\n\n  return acc\n}\n\nfunction createObjects (acc, p) {\n  // rel=\"next\" => 1: rel 2: next\n  const m = p.match(/\\s*(.+)\\s*=\\s*\"?([^\"]+)\"?/)\n  if (m) acc[m[1]] = m[2]\n  return acc\n}\n\nfunction parseLink (link) {\n  try {\n    const m = link.match(/<?([^>]*)>(.*)/)\n    const linkUrl = m[1]\n    const parts = m[2].split(';')\n    const qry = {}\n    // The origin is unused but it's required to parse relative URLs\n    const url = new URL(linkUrl, 'https://example.com')\n\n    for (const [key, value] of url.searchParams) {\n      qry[key] = value\n    }\n\n    parts.shift()\n\n    let info = parts.reduce(createObjects, {})\n    info = Object.assign({}, qry, info)\n    info.url = linkUrl\n    return info\n  } catch {\n    return null\n  }\n}\n\nfunction checkHeader (linkHeader, options) {\n  if (!linkHeader) return false\n\n  options = options || {}\n  const maxHeaderLength = options.maxHeaderLength || MAX_HEADER_LENGTH\n  const throwOnMaxHeaderLengthExceeded = options.throwOnMaxHeaderLengthExceeded || THROW_ON_MAX_HEADER_LENGTH_EXCEEDED\n\n  if (linkHeader.length > maxHeaderLength) {\n    if (throwOnMaxHeaderLengthExceeded) {\n      throw new Error('Input string too long, it should be under ' + maxHeaderLength + ' characters.')\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\nfunction parseLinkHeader (linkHeader, options) {\n  if (!checkHeader(linkHeader, options)) return null\n\n  return linkHeader.split(/,\\s*</)\n    .map(parseLink)\n    .filter(hasRel)\n    .reduce(intoRels, {})\n}\n\nexport { parseLinkHeader }\n"]},"metadata":{},"sourceType":"module"}