{"ast":null,"code":"export const topologySymbol = Symbol.for('@libp2p/topology');\nexport function isTopology(other) {\n  return other != null && Boolean(other[topologySymbol]);\n}","map":{"version":3,"mappings":"AAiHA,OAAO,MAAMA,cAAc,GAAGC,MAAM,CAACC,GAAP,CAAW,kBAAX,CAAvB;AAEP,OAAM,SAAUC,UAAV,CAAsBC,KAAtB,EAAgC;AACpC,SAAOA,KAAK,IAAI,IAAT,IAAiBC,OAAO,CAACD,KAAK,CAACJ,cAAD,CAAN,CAA/B;AACD","names":["topologySymbol","Symbol","for","isTopology","other","Boolean"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\interface-registrar\\src\\index.ts"],"sourcesContent":["import type { Connection, Stream } from '@libp2p/interface-connection'\nimport type { PeerId } from '@libp2p/interface-peer-id'\n\nexport interface IncomingStreamData {\n  stream: Stream\n  connection: Connection\n}\n\nexport interface StreamHandler {\n  (data: IncomingStreamData): void\n}\n\nexport interface StreamHandlerOptions {\n  /**\n   * How many incoming streams can be open for this protocol at the same time on each connection (default: 32)\n   */\n  maxInboundStreams?: number\n\n  /**\n   * How many outgoing streams can be open for this protocol at the same time on each connection (default: 64)\n   */\n  maxOutboundStreams?: number\n}\n\nexport interface StreamHandlerRecord {\n  handler: StreamHandler\n  options: StreamHandlerOptions\n}\n\nexport interface Registrar {\n  /**\n   * Return the list of protocols with registered handlers\n   */\n  getProtocols: () => string[]\n\n  /**\n   * Add a protocol handler\n   */\n  handle: (protocol: string, handler: StreamHandler, options?: StreamHandlerOptions) => Promise<void>\n\n  /**\n   * Remove a protocol handler\n   */\n  unhandle: (protocol: string) => Promise<void>\n\n  /**\n   * Return the handler for the passed protocol\n   */\n  getHandler: (protocol: string) => StreamHandlerRecord\n\n  /**\n   * Register a topology handler for a protocol - the topology will be\n   * invoked when peers are discovered on the network that support the\n   * passed protocol.\n   *\n   * An id will be returned that can later be used to unregister the\n   * topology.\n   */\n  register: (protocol: string, topology: Topology) => Promise<string>\n\n  /**\n   * Remove the topology handler with the passed id.\n   */\n  unregister: (id: string) => void\n\n  /**\n   * Return all topology handlers that wish to be informed about peers\n   * that support the passed protocol.\n   */\n  getTopologies: (protocol: string) => Topology[]\n}\n\nexport interface onConnectHandler {\n  (peerId: PeerId, conn: Connection): void\n}\n\nexport interface onDisconnectHandler {\n  (peerId: PeerId, conn?: Connection): void\n}\n\nexport interface TopologyInit {\n  /**\n   * minimum needed connections\n   */\n  min?: number\n\n  /**\n   * maximum needed connections\n   */\n  max?: number\n\n  /**\n   * Invoked when a new peer is connects that supports the configured\n   * protocol\n   */\n  onConnect?: onConnectHandler\n\n  /**\n   * Invoked when a peer that supports the configured protocol disconnects\n   */\n  onDisconnect?: onDisconnectHandler\n}\n\nexport interface Topology {\n  min: number\n  max: number\n  peers: Set<string>\n\n  onConnect: (peerId: PeerId, conn: Connection) => void\n  onDisconnect: (peerId: PeerId) => void\n  setRegistrar: (registrar: Registrar) => Promise<void>\n}\n\nexport const topologySymbol = Symbol.for('@libp2p/topology')\n\nexport function isTopology (other: any): other is Topology {\n  return other != null && Boolean(other[topologySymbol])\n}\n"]},"metadata":{},"sourceType":"module"}