{"ast":null,"code":"/**\n * @packageDocumentation\n *\n * Use the `createLibp2p` function to create a libp2p node.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n *\n * const node = await createLibp2p({\n *   // ...other options\n * })\n * ```\n */\nimport { createLibp2pNode } from './libp2p.js';\n/**\n * Returns a new instance of the Libp2p interface, generating a new PeerId\n * if one is not passed as part of the options.\n *\n * The node will be started unless `start: false` is passed as an option.\n *\n * @example\n *\n * ```js\n * import { createLibp2p } from 'libp2p'\n * import { tcp } from '@libp2p/tcp'\n * import { mplex } from '@libp2p/mplex'\n * import { noise } from '@chainsafe/libp2p-noise'\n *\n * // specify options\n * const options = {\n *   transports: [tcp()],\n *   streamMuxers: [mplex()],\n *   connectionEncryption: [noise()]\n * }\n *\n * // create libp2p\n * const libp2p = await createLibp2p(options)\n * ```\n */\n\nexport async function createLibp2p(options) {\n  const node = await createLibp2pNode(options);\n\n  if (options.start !== false) {\n    await node.start();\n  }\n\n  return node;\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAASA,gBAAT,QAAiC,aAAjC;AA8JA;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAO,eAAeC,YAAf,CAA6BC,OAA7B,EAAmD;AACxD,QAAMC,IAAI,GAAG,MAAMH,gBAAgB,CAACE,OAAD,CAAnC;;AAEA,MAAIA,OAAO,CAACE,KAAR,KAAkB,KAAtB,EAA6B;AAC3B,UAAMD,IAAI,CAACC,KAAL,EAAN;AACD;;AAED,SAAOD,IAAP;AACD","names":["createLibp2pNode","createLibp2p","options","node","start"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\index.ts"],"sourcesContent":["/**\n * @packageDocumentation\n *\n * Use the `createLibp2p` function to create a libp2p node.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n *\n * const node = await createLibp2p({\n *   // ...other options\n * })\n * ```\n */\n\nimport { createLibp2pNode } from './libp2p.js'\nimport type { RecursivePartial } from '@libp2p/interfaces'\nimport type { TransportManagerInit } from './transport-manager.js'\nimport type { IdentifyServiceInit } from './identify/index.js'\nimport type { DualDHT } from '@libp2p/interface-dht'\nimport type { Datastore } from 'interface-datastore'\nimport type { PeerStoreInit } from '@libp2p/interface-peer-store'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { RelayConfig } from './circuit/index.js'\nimport type { PeerDiscovery } from '@libp2p/interface-peer-discovery'\nimport type { ConnectionGater, ConnectionProtector } from '@libp2p/interface-connection'\nimport type { Transport } from '@libp2p/interface-transport'\nimport type { StreamMuxerFactory } from '@libp2p/interface-stream-muxer'\nimport type { ConnectionEncrypter } from '@libp2p/interface-connection-encrypter'\nimport type { PeerRouting } from '@libp2p/interface-peer-routing'\nimport type { ContentRouting } from '@libp2p/interface-content-routing'\nimport type { PubSub } from '@libp2p/interface-pubsub'\nimport type { Metrics } from '@libp2p/interface-metrics'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { PingServiceInit } from './ping/index.js'\nimport type { FetchServiceInit } from './fetch/index.js'\nimport type { Components } from './components.js'\nimport type { Libp2p } from '@libp2p/interface-libp2p'\nimport type { KeyChainInit } from './keychain/index.js'\nimport type { NatManagerInit } from './nat-manager.js'\nimport type { AddressManagerInit } from './address-manager/index.js'\nimport type { PeerRoutingInit } from './peer-routing.js'\nimport type { ConnectionManagerInit } from './connection-manager/index.js'\n\n/**\n * For Libp2p configurations and modules details read the [Configuration Document](./CONFIGURATION.md).\n */\nexport interface Libp2pInit {\n  /**\n   * peerId instance (it will be created if not provided)\n   */\n  peerId: PeerId\n\n  /**\n   * Addresses for transport listening and to advertise to the network\n   */\n  addresses: AddressManagerInit\n\n  /**\n   * libp2p Connection Manager configuration\n   */\n  connectionManager: ConnectionManagerInit\n\n  /**\n   * A connection gater can deny new connections based on user criteria\n   */\n  connectionGater: Partial<ConnectionGater>\n\n  /**\n   * libp2p transport manager configuration\n   */\n  transportManager: TransportManagerInit\n\n  /**\n   * An optional datastore to persist peer information, DHT records, etc.\n   *\n   * An in-memory datastore will be used if one is not provided.\n   */\n  datastore: Datastore\n\n  /**\n   * libp2p PeerStore configuration\n   */\n  peerStore: PeerStoreInit\n\n  /**\n   * libp2p Peer routing service configuration\n   */\n  peerRouting: PeerRoutingInit\n\n  /**\n   * keychain configuration\n   */\n  keychain: KeyChainInit\n\n  /**\n   * The NAT manager controls uPNP hole punching\n   */\n  nat: NatManagerInit\n\n  /**\n   * If configured as a relay this node will relay certain\n   * types of traffic for other peers\n   */\n  relay: RelayConfig\n\n  /**\n   * libp2p identify protocol options\n   */\n  identify: IdentifyServiceInit\n\n  /**\n   * libp2p ping protocol options\n   */\n  ping: PingServiceInit\n\n  /**\n   * libp2p fetch protocol options\n   */\n  fetch: FetchServiceInit\n\n  /**\n   * An array that must include at least 1 compliant transport\n   */\n  transports: Array<(components: Components) => Transport>\n  streamMuxers?: Array<(components: Components) => StreamMuxerFactory>\n  connectionEncryption?: Array<(components: Components) => ConnectionEncrypter>\n  peerDiscovery?: Array<(components: Components) => PeerDiscovery>\n  peerRouters?: Array<(components: Components) => PeerRouting>\n  contentRouters?: Array<(components: Components) => ContentRouting>\n\n  /**\n   * Pass a DHT implementation to enable DHT operations\n   */\n  dht?: (components: Components) => DualDHT\n\n  /**\n   * A Metrics implementation can be supplied to collect metrics on this node\n   */\n  metrics?: (components: Components) => Metrics\n\n  /**\n   * If a PubSub implmentation is supplied, PubSub operations will become available\n   */\n  pubsub?: (components: Components) => PubSub\n\n  /**\n   * A ConnectionProtector can be used to create a secure overlay on top of the network using pre-shared keys\n   */\n  connectionProtector?: (components: Components) => ConnectionProtector\n}\n\n/**\n * Once you have a libp2p instance, you can listen to several events it emits, so that you can be notified of relevant network events.\n */\nexport interface Libp2pEvents {\n  /**\n   * @example\n   *\n   * ```js\n   * libp2p.addEventListener('peer:discovery', (event) => {\n   *    const peerInfo = event.detail\n   *    // ...\n   * })\n   * ```\n   */\n  'peer:discovery': CustomEvent<PeerInfo>\n}\n\nexport type { Libp2p }\n\nexport type Libp2pOptions = RecursivePartial<Libp2pInit> & { start?: boolean }\n\n/**\n * Returns a new instance of the Libp2p interface, generating a new PeerId\n * if one is not passed as part of the options.\n *\n * The node will be started unless `start: false` is passed as an option.\n *\n * @example\n *\n * ```js\n * import { createLibp2p } from 'libp2p'\n * import { tcp } from '@libp2p/tcp'\n * import { mplex } from '@libp2p/mplex'\n * import { noise } from '@chainsafe/libp2p-noise'\n *\n * // specify options\n * const options = {\n *   transports: [tcp()],\n *   streamMuxers: [mplex()],\n *   connectionEncryption: [noise()]\n * }\n *\n * // create libp2p\n * const libp2p = await createLibp2p(options)\n * ```\n */\nexport async function createLibp2p (options: Libp2pOptions): Promise<Libp2p> {\n  const node = await createLibp2pNode(options)\n\n  if (options.start !== false) {\n    await node.start()\n  }\n\n  return node\n}\n"]},"metadata":{},"sourceType":"module"}