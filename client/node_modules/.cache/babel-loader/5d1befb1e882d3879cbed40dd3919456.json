{"ast":null,"code":"const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\n\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterMySQL extends RateLimiterStoreAbstract {\n  /**\n   * @callback callback\n   * @param {Object} err\n   *\n   * @param {Object} opts\n   * @param {callback} cb\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: anySqlClient,\n   *   storeType: 'knex', // required only for Knex instance\n   *   dbName: 'string',\n   *   tableName: 'string',\n   * }\n   */\n  constructor(opts) {\n    let cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(opts);\n    this.client = opts.storeClient;\n    this.clientType = opts.storeType;\n    this.dbName = opts.dbName;\n    this.tableName = opts.tableName;\n    this.clearExpiredByTimeout = opts.clearExpiredByTimeout;\n    this.tableCreated = opts.tableCreated;\n\n    if (!this.tableCreated) {\n      this._createDbAndTable().then(() => {\n        this.tableCreated = true;\n\n        if (this.clearExpiredByTimeout) {\n          this._clearExpiredHourAgo();\n        }\n\n        if (typeof cb === 'function') {\n          cb();\n        }\n      }).catch(err => {\n        if (typeof cb === 'function') {\n          cb(err);\n        } else {\n          throw err;\n        }\n      });\n    } else {\n      if (this.clearExpiredByTimeout) {\n        this._clearExpiredHourAgo();\n      }\n\n      if (typeof cb === 'function') {\n        cb();\n      }\n    }\n  }\n\n  clearExpired(expire) {\n    return new Promise(resolve => {\n      this._getConnection().then(conn => {\n        conn.query(`DELETE FROM ??.?? WHERE expire < ?`, [this.dbName, this.tableName, expire], () => {\n          this._releaseConnection(conn);\n\n          resolve();\n        });\n      }).catch(() => {\n        resolve();\n      });\n    });\n  }\n\n  _clearExpiredHourAgo() {\n    if (this._clearExpiredTimeoutId) {\n      clearTimeout(this._clearExpiredTimeoutId);\n    }\n\n    this._clearExpiredTimeoutId = setTimeout(() => {\n      this.clearExpired(Date.now() - 3600000) // Never rejected\n      .then(() => {\n        this._clearExpiredHourAgo();\n      });\n    }, 300000);\n\n    this._clearExpiredTimeoutId.unref();\n  }\n  /**\n   *\n   * @return Promise<any>\n   * @private\n   */\n\n\n  _getConnection() {\n    switch (this.clientType) {\n      case 'pool':\n        return new Promise((resolve, reject) => {\n          this.client.getConnection((errConn, conn) => {\n            if (errConn) {\n              return reject(errConn);\n            }\n\n            resolve(conn);\n          });\n        });\n\n      case 'sequelize':\n        return this.client.connectionManager.getConnection();\n\n      case 'knex':\n        return this.client.client.acquireConnection();\n\n      default:\n        return Promise.resolve(this.client);\n    }\n  }\n\n  _releaseConnection(conn) {\n    switch (this.clientType) {\n      case 'pool':\n        return conn.release();\n\n      case 'sequelize':\n        return this.client.connectionManager.releaseConnection(conn);\n\n      case 'knex':\n        return this.client.client.releaseConnection(conn);\n\n      default:\n        return true;\n    }\n  }\n  /**\n   *\n   * @returns {Promise<any>}\n   * @private\n   */\n\n\n  _createDbAndTable() {\n    return new Promise((resolve, reject) => {\n      this._getConnection().then(conn => {\n        conn.query(`CREATE DATABASE IF NOT EXISTS \\`${this.dbName}\\`;`, errDb => {\n          if (errDb) {\n            this._releaseConnection(conn);\n\n            return reject(errDb);\n          }\n\n          conn.query(this._getCreateTableStmt(), err => {\n            if (err) {\n              this._releaseConnection(conn);\n\n              return reject(err);\n            }\n\n            this._releaseConnection(conn);\n\n            resolve();\n          });\n        });\n      }).catch(err => {\n        reject(err);\n      });\n    });\n  }\n\n  _getCreateTableStmt() {\n    return `CREATE TABLE IF NOT EXISTS \\`${this.dbName}\\`.\\`${this.tableName}\\` (` + '`key` VARCHAR(255) CHARACTER SET utf8 NOT NULL,' + '`points` INT(9) NOT NULL default 0,' + '`expire` BIGINT UNSIGNED,' + 'PRIMARY KEY (`key`)' + ') ENGINE = INNODB;';\n  }\n\n  get clientType() {\n    return this._clientType;\n  }\n\n  set clientType(value) {\n    if (typeof value === 'undefined') {\n      if (this.client.constructor.name === 'Connection') {\n        value = 'connection';\n      } else if (this.client.constructor.name === 'Pool') {\n        value = 'pool';\n      } else if (this.client.constructor.name === 'Sequelize') {\n        value = 'sequelize';\n      } else {\n        throw new Error('storeType is not defined');\n      }\n    }\n\n    this._clientType = value.toLowerCase();\n  }\n\n  get dbName() {\n    return this._dbName;\n  }\n\n  set dbName(value) {\n    this._dbName = typeof value === 'undefined' ? 'rtlmtrflx' : value;\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get tableCreated() {\n    return this._tableCreated;\n  }\n\n  set tableCreated(value) {\n    this._tableCreated = typeof value === 'undefined' ? false : !!value;\n  }\n\n  get clearExpiredByTimeout() {\n    return this._clearExpiredByTimeout;\n  }\n\n  set clearExpiredByTimeout(value) {\n    this._clearExpiredByTimeout = typeof value === 'undefined' ? true : Boolean(value);\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    const [row] = result;\n    res.isFirstInDuration = changedPoints === row.points;\n    res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;\n    return res;\n  }\n\n  _upsertTransaction(conn, key, points, msDuration, forceExpire) {\n    return new Promise((resolve, reject) => {\n      conn.query('BEGIN', errBegin => {\n        if (errBegin) {\n          conn.rollback();\n          return reject(errBegin);\n        }\n\n        const dateNow = Date.now();\n        const newExpire = msDuration > 0 ? dateNow + msDuration : null;\n        let q;\n        let values;\n\n        if (forceExpire) {\n          q = `INSERT INTO ??.?? VALUES (?, ?, ?)\n          ON DUPLICATE KEY UPDATE \n            points = ?, \n            expire = ?;`;\n          values = [this.dbName, this.tableName, key, points, newExpire, points, newExpire];\n        } else {\n          q = `INSERT INTO ??.?? VALUES (?, ?, ?)\n          ON DUPLICATE KEY UPDATE \n            points = IF(expire <= ?, ?, points + (?)), \n            expire = IF(expire <= ?, ?, expire);`;\n          values = [this.dbName, this.tableName, key, points, newExpire, dateNow, points, points, dateNow, newExpire];\n        }\n\n        conn.query(q, values, errUpsert => {\n          if (errUpsert) {\n            conn.rollback();\n            return reject(errUpsert);\n          }\n\n          conn.query('SELECT points, expire FROM ??.?? WHERE `key` = ?;', [this.dbName, this.tableName, key], (errSelect, res) => {\n            if (errSelect) {\n              conn.rollback();\n              return reject(errSelect);\n            }\n\n            conn.query('COMMIT', err => {\n              if (err) {\n                conn.rollback();\n                return reject(err);\n              }\n\n              resolve(res);\n            });\n          });\n        });\n      });\n    });\n  }\n\n  _upsert(key, points, msDuration) {\n    let forceExpire = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._getConnection().then(conn => {\n        this._upsertTransaction(conn, key, points, msDuration, forceExpire).then(res => {\n          resolve(res);\n\n          this._releaseConnection(conn);\n        }).catch(err => {\n          reject(err);\n\n          this._releaseConnection(conn);\n        });\n      }).catch(err => {\n        reject(err);\n      });\n    });\n  }\n\n  _get(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._getConnection().then(conn => {\n        conn.query('SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)', [this.dbName, this.tableName, rlKey, Date.now()], (err, res) => {\n          if (err) {\n            reject(err);\n          } else if (res.length === 0) {\n            resolve(null);\n          } else {\n            resolve(res);\n          }\n\n          this._releaseConnection(conn);\n        } // eslint-disable-line\n        );\n      }).catch(err => {\n        reject(err);\n      });\n    });\n  }\n\n  _delete(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._getConnection().then(conn => {\n        conn.query('DELETE FROM ??.?? WHERE `key` = ?', [this.dbName, this.tableName, rlKey], (err, res) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(res.affectedRows > 0);\n          }\n\n          this._releaseConnection(conn);\n        } // eslint-disable-line\n        );\n      }).catch(err => {\n        reject(err);\n      });\n    });\n  }\n\n}\n\nmodule.exports = RateLimiterMySQL;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/rate-limiter-flexible/lib/RateLimiterMySQL.js"],"names":["RateLimiterStoreAbstract","require","RateLimiterRes","RateLimiterMySQL","constructor","opts","cb","client","storeClient","clientType","storeType","dbName","tableName","clearExpiredByTimeout","tableCreated","_createDbAndTable","then","_clearExpiredHourAgo","catch","err","clearExpired","expire","Promise","resolve","_getConnection","conn","query","_releaseConnection","_clearExpiredTimeoutId","clearTimeout","setTimeout","Date","now","unref","reject","getConnection","errConn","connectionManager","acquireConnection","release","releaseConnection","errDb","_getCreateTableStmt","_clientType","value","name","Error","toLowerCase","_dbName","_tableName","keyPrefix","_tableCreated","_clearExpiredByTimeout","Boolean","_getRateLimiterRes","rlKey","changedPoints","result","res","row","isFirstInDuration","points","consumedPoints","remainingPoints","Math","max","msBeforeNext","_upsertTransaction","key","msDuration","forceExpire","errBegin","rollback","dateNow","newExpire","q","values","errUpsert","errSelect","_upsert","_get","length","_delete","affectedRows","module","exports"],"mappings":"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","sourcesContent":["const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterMySQL extends RateLimiterStoreAbstract {\n  /**\n   * @callback callback\n   * @param {Object} err\n   *\n   * @param {Object} opts\n   * @param {callback} cb\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: anySqlClient,\n   *   storeType: 'knex', // required only for Knex instance\n   *   dbName: 'string',\n   *   tableName: 'string',\n   * }\n   */\n  constructor(opts, cb = null) {\n    super(opts);\n\n    this.client = opts.storeClient;\n    this.clientType = opts.storeType;\n\n    this.dbName = opts.dbName;\n    this.tableName = opts.tableName;\n\n    this.clearExpiredByTimeout = opts.clearExpiredByTimeout;\n\n    this.tableCreated = opts.tableCreated;\n    if (!this.tableCreated) {\n      this._createDbAndTable()\n        .then(() => {\n          this.tableCreated = true;\n          if (this.clearExpiredByTimeout) {\n            this._clearExpiredHourAgo();\n          }\n          if (typeof cb === 'function') {\n            cb();\n          }\n        })\n        .catch((err) => {\n          if (typeof cb === 'function') {\n            cb(err);\n          } else {\n            throw err;\n          }\n        });\n    } else {\n      if (this.clearExpiredByTimeout) {\n        this._clearExpiredHourAgo();\n      }\n      if (typeof cb === 'function') {\n        cb();\n      }\n    }\n  }\n\n  clearExpired(expire) {\n    return new Promise((resolve) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(`DELETE FROM ??.?? WHERE expire < ?`, [this.dbName, this.tableName, expire], () => {\n            this._releaseConnection(conn);\n            resolve();\n          });\n        })\n        .catch(() => {\n          resolve();\n        });\n    });\n  }\n\n  _clearExpiredHourAgo() {\n    if (this._clearExpiredTimeoutId) {\n      clearTimeout(this._clearExpiredTimeoutId);\n    }\n    this._clearExpiredTimeoutId = setTimeout(() => {\n      this.clearExpired(Date.now() - 3600000) // Never rejected\n        .then(() => {\n          this._clearExpiredHourAgo();\n        });\n    }, 300000);\n    this._clearExpiredTimeoutId.unref();\n  }\n\n  /**\n   *\n   * @return Promise<any>\n   * @private\n   */\n  _getConnection() {\n    switch (this.clientType) {\n      case 'pool':\n        return new Promise((resolve, reject) => {\n          this.client.getConnection((errConn, conn) => {\n            if (errConn) {\n              return reject(errConn);\n            }\n\n            resolve(conn);\n          });\n        });\n      case 'sequelize':\n        return this.client.connectionManager.getConnection();\n      case 'knex':\n        return this.client.client.acquireConnection();\n      default:\n        return Promise.resolve(this.client);\n    }\n  }\n\n  _releaseConnection(conn) {\n    switch (this.clientType) {\n      case 'pool':\n        return conn.release();\n      case 'sequelize':\n        return this.client.connectionManager.releaseConnection(conn);\n      case 'knex':\n        return this.client.client.releaseConnection(conn);\n      default:\n        return true;\n    }\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   * @private\n   */\n  _createDbAndTable() {\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(`CREATE DATABASE IF NOT EXISTS \\`${this.dbName}\\`;`, (errDb) => {\n            if (errDb) {\n              this._releaseConnection(conn);\n              return reject(errDb);\n            }\n            conn.query(this._getCreateTableStmt(), (err) => {\n              if (err) {\n                this._releaseConnection(conn);\n                return reject(err);\n              }\n              this._releaseConnection(conn);\n              resolve();\n            });\n          });\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _getCreateTableStmt() {\n    return `CREATE TABLE IF NOT EXISTS \\`${this.dbName}\\`.\\`${this.tableName}\\` (` +\n      '`key` VARCHAR(255) CHARACTER SET utf8 NOT NULL,' +\n      '`points` INT(9) NOT NULL default 0,' +\n      '`expire` BIGINT UNSIGNED,' +\n      'PRIMARY KEY (`key`)' +\n      ') ENGINE = INNODB;';\n  }\n\n  get clientType() {\n    return this._clientType;\n  }\n\n  set clientType(value) {\n    if (typeof value === 'undefined') {\n      if (this.client.constructor.name === 'Connection') {\n        value = 'connection';\n      } else if (this.client.constructor.name === 'Pool') {\n        value = 'pool';\n      } else if (this.client.constructor.name === 'Sequelize') {\n        value = 'sequelize';\n      } else {\n        throw new Error('storeType is not defined');\n      }\n    }\n    this._clientType = value.toLowerCase();\n  }\n\n  get dbName() {\n    return this._dbName;\n  }\n\n  set dbName(value) {\n    this._dbName = typeof value === 'undefined' ? 'rtlmtrflx' : value;\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get tableCreated() {\n    return this._tableCreated\n  }\n\n  set tableCreated(value) {\n    this._tableCreated = typeof value === 'undefined' ? false : !!value;\n  }\n\n  get clearExpiredByTimeout() {\n    return this._clearExpiredByTimeout;\n  }\n\n  set clearExpiredByTimeout(value) {\n    this._clearExpiredByTimeout = typeof value === 'undefined' ? true : Boolean(value);\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    const [row] = result;\n\n    res.isFirstInDuration = changedPoints === row.points;\n    res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;\n\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = row.expire\n      ? Math.max(row.expire - Date.now(), 0)\n      : -1;\n\n    return res;\n  }\n\n  _upsertTransaction(conn, key, points, msDuration, forceExpire) {\n    return new Promise((resolve, reject) => {\n      conn.query('BEGIN', (errBegin) => {\n        if (errBegin) {\n          conn.rollback();\n\n          return reject(errBegin);\n        }\n\n        const dateNow = Date.now();\n        const newExpire = msDuration > 0 ? dateNow + msDuration : null;\n\n        let q;\n        let values;\n        if (forceExpire) {\n          q = `INSERT INTO ??.?? VALUES (?, ?, ?)\n          ON DUPLICATE KEY UPDATE \n            points = ?, \n            expire = ?;`;\n          values = [\n            this.dbName, this.tableName, key, points, newExpire,\n            points,\n            newExpire,\n          ];\n        } else {\n          q = `INSERT INTO ??.?? VALUES (?, ?, ?)\n          ON DUPLICATE KEY UPDATE \n            points = IF(expire <= ?, ?, points + (?)), \n            expire = IF(expire <= ?, ?, expire);`;\n          values = [\n            this.dbName, this.tableName, key, points, newExpire,\n            dateNow, points, points,\n            dateNow, newExpire,\n          ];\n        }\n\n        conn.query(q, values, (errUpsert) => {\n          if (errUpsert) {\n            conn.rollback();\n\n            return reject(errUpsert);\n          }\n          conn.query('SELECT points, expire FROM ??.?? WHERE `key` = ?;', [this.dbName, this.tableName, key], (errSelect, res) => {\n            if (errSelect) {\n              conn.rollback();\n\n              return reject(errSelect);\n            }\n\n            conn.query('COMMIT', (err) => {\n              if (err) {\n                conn.rollback();\n\n                return reject(err);\n              }\n\n              resolve(res);\n            });\n          });\n        });\n      });\n    });\n  }\n\n  _upsert(key, points, msDuration, forceExpire = false) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          this._upsertTransaction(conn, key, points, msDuration, forceExpire)\n            .then((res) => {\n              resolve(res);\n              this._releaseConnection(conn);\n            })\n            .catch((err) => {\n              reject(err);\n              this._releaseConnection(conn);\n            });\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _get(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(\n            'SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)',\n            [this.dbName, this.tableName, rlKey, Date.now()],\n            (err, res) => {\n              if (err) {\n                reject(err);\n              } else if (res.length === 0) {\n                resolve(null);\n              } else {\n                resolve(res);\n              }\n\n              this._releaseConnection(conn);\n            } // eslint-disable-line\n          );\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _delete(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(\n            'DELETE FROM ??.?? WHERE `key` = ?',\n            [this.dbName, this.tableName, rlKey],\n            (err, res) => {\n              if (err) {\n                reject(err);\n              } else {\n                resolve(res.affectedRows > 0);\n              }\n\n              this._releaseConnection(conn);\n            } // eslint-disable-line\n          );\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n}\n\nmodule.exports = RateLimiterMySQL;\n"]},"metadata":{},"sourceType":"script"}