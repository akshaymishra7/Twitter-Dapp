{"ast":null,"code":"import mergeOpts from 'merge-options';\nimport { toMfsPath } from './utils/to-mfs-path.js';\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { UnixFS } from 'ipfs-unixfs';\nimport { toTrail } from './utils/to-trail.js';\nimport { addLink } from './utils/add-link.js';\nimport { updateTree } from './utils/update-tree.js';\nimport { updateMfsRoot } from './utils/update-mfs-root.js';\nimport * as dagPB from '@ipld/dag-pb';\nimport { CID } from 'multiformats/cid';\nimport { pipe } from 'it-pipe';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { recursive } from 'ipfs-unixfs-exporter';\nimport last from 'it-last';\nimport { createCp } from './cp.js';\nimport { createRm } from './rm.js';\nimport { persist } from './utils/persist.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nconst log = logger('ipfs:mfs:touch');\n/**\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n};\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\n\nfunction calculateModification(mode, originalMode, isDirectory) {\n  let modification = 0;\n\n  if (mode.includes('x') || mode.includes('X') && (isDirectory || originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)) {\n    modification += 1;\n  }\n\n  if (mode.includes('w')) {\n    modification += 2;\n  }\n\n  if (mode.includes('r')) {\n    modification += 4;\n  }\n\n  return modification;\n}\n/**\n * @param {string} references\n * @param {number} modification\n */\n\n\nfunction calculateUGO(references, modification) {\n  let ugo = 0;\n\n  if (references.includes('u')) {\n    ugo += modification << 6;\n  }\n\n  if (references.includes('g')) {\n    ugo += modification << 3;\n  }\n\n  if (references.includes('o')) {\n    ugo += modification;\n  }\n\n  return ugo;\n}\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\n\n\nfunction calculateSpecial(references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8);\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8);\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8);\n    }\n  }\n\n  return modification;\n}\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\n\n\nfunction parseSymbolicMode(input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0;\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/);\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`);\n  }\n\n  let [, references, operator, mode] = match;\n\n  if (references === 'a' || !references) {\n    references = 'ugo';\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory);\n  modification = calculateUGO(references, modification);\n  modification = calculateSpecial(references, mode, modification);\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    return originalMode;\n  }\n\n  if (operator === '+') {\n    return modification | originalMode;\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode;\n  }\n\n  return originalMode;\n}\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\n\n\nfunction calculateMode(mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${mode}`;\n\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8);\n    } else {\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory());\n      }, metadata.mode || 0);\n    }\n  }\n\n  return mode;\n}\n/**\n * @param {MfsContext} context\n */\n\n\nexport function createChmod(context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"chmod\"]}\n   */\n  async function mfsChmod(path, mode) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options);\n    log(`Fetching stats for ${path}`);\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, opts);\n\n    if (cid.code !== dagPB.code) {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n    }\n\n    if (opts.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(async function* () {\n        for await (const entry of recursive(cid, context.repo.blocks)) {\n          if (entry.type !== 'file' && entry.type !== 'directory') {\n            throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n          }\n\n          entry.unixfs.mode = calculateMode(mode, entry.unixfs);\n          const node = dagPB.prepare({\n            Data: entry.unixfs.marshal(),\n            Links: entry.node.Links\n          });\n          yield {\n            path: entry.path,\n            content: node\n          };\n        }\n      }, // @ts-expect-error we account for the incompatible source type with our custom dag builder below\n      source => importer(source, context.repo.blocks, { ...opts,\n        pin: false,\n        dagBuilder: async function* (source, block, opts) {\n          for await (const entry of source) {\n            yield async function () {\n              /** @type {PBNode} */\n              // @ts-expect-error - cannot derive type\n              const node = entry.content;\n              const buf = dagPB.encode(node);\n              const cid = await persist(buf, block, opts);\n\n              if (!node.Data) {\n                throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE');\n              }\n\n              const unixfs = UnixFS.unmarshal(node.Data);\n              return {\n                cid,\n                size: buf.length,\n                path: entry.path,\n                unixfs\n              };\n            };\n          }\n        }\n      }), nodes => last(nodes));\n\n      if (!root) {\n        throw errCode(new Error(`Could not chmod ${path}`), 'ERR_COULD_NOT_CHMOD');\n      } // remove old path from mfs\n\n\n      await createRm(context)(path, opts); // add newly created tree to mfs at path\n\n      await createCp(context)(`/ipfs/${root.cid}`, path, opts);\n      return;\n    }\n\n    const block = await context.repo.blocks.get(cid);\n    const node = dagPB.decode(block);\n\n    if (!node.Data) {\n      throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE');\n    }\n\n    const metadata = UnixFS.unmarshal(node.Data);\n    metadata.mode = calculateMode(mode, metadata);\n    const updatedBlock = dagPB.encode({\n      Data: metadata.marshal(),\n      Links: node.Links\n    });\n    const hashAlg = opts.hashAlg || defaultOptions.hashAlg;\n    const hasher = await context.hashers.getHasher(hashAlg);\n    const hash = await hasher.digest(updatedBlock);\n    const updatedCid = CID.create(opts.cidVersion, dagPB.code, hash);\n\n    if (opts.flush) {\n      await context.repo.blocks.put(updatedCid, updatedBlock);\n    }\n\n    const trail = await toTrail(context, mfsDirectory);\n    const parent = trail[trail.length - 1];\n    const parentCid = CID.decode(parent.cid.bytes);\n    const parentBlock = await context.repo.blocks.get(parentCid);\n    const parentNode = dagPB.decode(parentBlock);\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: opts.flush,\n      // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n      hashAlg,\n      cidVersion: cid.version,\n      shardSplitThreshold: Infinity\n    });\n    parent.cid = result.cid; // update the tree with the new child\n\n    const newRootCid = await updateTree(context, trail, opts); // Update the MFS record with the new CID for the root of the tree\n\n    await updateMfsRoot(context, newRootCid, opts);\n  }\n\n  return withTimeoutOption(mfsChmod);\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/files/chmod.js"],"names":["mergeOpts","toMfsPath","logger","errCode","UnixFS","toTrail","addLink","updateTree","updateMfsRoot","dagPB","CID","pipe","importer","recursive","last","createCp","createRm","persist","withTimeoutOption","mergeOptions","bind","ignoreUndefined","log","defaultOptions","flush","shardSplitThreshold","hashAlg","cidVersion","calculateModification","mode","originalMode","isDirectory","modification","includes","calculateUGO","references","ugo","calculateSpecial","parseInt","parseSymbolicMode","input","match","Error","operator","calculateMode","metadata","String","strMode","split","reduce","curr","acc","createChmod","context","mfsChmod","path","options","opts","cid","mfsDirectory","name","code","root","entry","repo","blocks","type","unixfs","node","prepare","Data","marshal","Links","content","source","pin","dagBuilder","block","buf","encode","unmarshal","size","length","nodes","get","decode","updatedBlock","hasher","hashers","getHasher","hash","digest","updatedCid","create","put","trail","parent","parentCid","bytes","parentBlock","parentNode","result","version","Infinity","newRootCid"],"mappings":"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","sourcesContent":["import mergeOpts from 'merge-options'\nimport { toMfsPath } from './utils/to-mfs-path.js'\nimport { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { toTrail } from './utils/to-trail.js'\nimport { addLink } from './utils/add-link.js'\nimport { updateTree } from './utils/update-tree.js'\nimport { updateMfsRoot } from './utils/update-mfs-root.js'\nimport * as dagPB from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { pipe } from 'it-pipe'\nimport { importer } from 'ipfs-unixfs-importer'\nimport { recursive } from 'ipfs-unixfs-exporter'\nimport last from 'it-last'\nimport { createCp } from './cp.js'\nimport { createRm } from './rm.js'\nimport { persist } from './utils/persist.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('ipfs:mfs:touch')\n\n/**\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n}\n\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction calculateModification (mode, originalMode, isDirectory) {\n  let modification = 0\n\n  if (mode.includes('x') || (mode.includes('X') && (isDirectory || (originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)))) {\n    modification += 1\n  }\n\n  if (mode.includes('w')) {\n    modification += 2\n  }\n\n  if (mode.includes('r')) {\n    modification += 4\n  }\n\n  return modification\n}\n\n/**\n * @param {string} references\n * @param {number} modification\n */\nfunction calculateUGO (references, modification) {\n  let ugo = 0\n\n  if (references.includes('u')) {\n    ugo += (modification << 6)\n  }\n\n  if (references.includes('g')) {\n    ugo += (modification << 3)\n  }\n\n  if (references.includes('o')) {\n    ugo += (modification)\n  }\n\n  return ugo\n}\n\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\nfunction calculateSpecial (references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8)\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8)\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8)\n    }\n  }\n\n  return modification\n}\n\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction parseSymbolicMode (input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/)\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`)\n  }\n\n  let [\n    ,\n    references,\n    operator,\n    mode\n  ] = match\n\n  if (references === 'a' || !references) {\n    references = 'ugo'\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory)\n  modification = calculateUGO(references, modification)\n  modification = calculateSpecial(references, mode, modification)\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    return originalMode\n  }\n\n  if (operator === '+') {\n    return modification | originalMode\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode\n  }\n\n  return originalMode\n}\n\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\nfunction calculateMode (mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${mode}`\n\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8)\n    } else {\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory())\n      }, metadata.mode || 0)\n    }\n  }\n\n  return mode\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createChmod (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"chmod\"]}\n   */\n  async function mfsChmod (path, mode, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options)\n\n    log(`Fetching stats for ${path}`)\n\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, opts)\n\n    if (cid.code !== dagPB.code) {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n    }\n\n    if (opts.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(\n        async function * () {\n          for await (const entry of recursive(cid, context.repo.blocks)) {\n            if (entry.type !== 'file' && entry.type !== 'directory') {\n              throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n            }\n\n            entry.unixfs.mode = calculateMode(mode, entry.unixfs)\n\n            const node = dagPB.prepare({\n              Data: entry.unixfs.marshal(),\n              Links: entry.node.Links\n            })\n\n            yield {\n              path: entry.path,\n              content: node\n            }\n          }\n        },\n        // @ts-expect-error we account for the incompatible source type with our custom dag builder below\n        (source) => importer(source, context.repo.blocks, {\n          ...opts,\n          pin: false,\n          dagBuilder: async function * (source, block, opts) {\n            for await (const entry of source) {\n              yield async function () {\n                /** @type {PBNode} */\n                // @ts-expect-error - cannot derive type\n                const node = entry.content\n\n                const buf = dagPB.encode(node)\n                const cid = await persist(buf, block, opts)\n\n                if (!node.Data) {\n                  throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n                }\n\n                const unixfs = UnixFS.unmarshal(node.Data)\n\n                return {\n                  cid,\n                  size: buf.length,\n                  path: entry.path,\n                  unixfs\n                }\n              }\n            }\n          }\n        }),\n        (nodes) => last(nodes)\n      )\n\n      if (!root) {\n        throw errCode(new Error(`Could not chmod ${path}`), 'ERR_COULD_NOT_CHMOD')\n      }\n\n      // remove old path from mfs\n      await createRm(context)(path, opts)\n\n      // add newly created tree to mfs at path\n      await createCp(context)(`/ipfs/${root.cid}`, path, opts)\n\n      return\n    }\n\n    const block = await context.repo.blocks.get(cid)\n    const node = dagPB.decode(block)\n\n    if (!node.Data) {\n      throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n    }\n\n    const metadata = UnixFS.unmarshal(node.Data)\n    metadata.mode = calculateMode(mode, metadata)\n    const updatedBlock = dagPB.encode({\n      Data: metadata.marshal(),\n      Links: node.Links\n    })\n\n    const hashAlg = opts.hashAlg || defaultOptions.hashAlg\n    const hasher = await context.hashers.getHasher(hashAlg)\n    const hash = await hasher.digest(updatedBlock)\n    const updatedCid = CID.create(opts.cidVersion, dagPB.code, hash)\n\n    if (opts.flush) {\n      await context.repo.blocks.put(updatedCid, updatedBlock)\n    }\n\n    const trail = await toTrail(context, mfsDirectory)\n    const parent = trail[trail.length - 1]\n    const parentCid = CID.decode(parent.cid.bytes)\n    const parentBlock = await context.repo.blocks.get(parentCid)\n    const parentNode = dagPB.decode(parentBlock)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: opts.flush,\n      // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n      hashAlg,\n      cidVersion: cid.version,\n      shardSplitThreshold: Infinity\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, opts)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts)\n  }\n\n  return withTimeoutOption(mfsChmod)\n}\n"]},"metadata":{},"sourceType":"module"}