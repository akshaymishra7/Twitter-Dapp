{"ast":null,"code":"import * as lp from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport { createTopology } from '@libp2p/topology';\nimport { BitswapMessage as Message } from './message/index.js';\nimport * as CONSTANTS from './constants.js';\nimport { logger } from './utils/index.js';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { abortableSource } from 'abortable-iterator';\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n * @typedef {import('@libp2p/interface-connection').Connection} Connection\n * @typedef {import('@libp2p/interface-connection').Stream} Stream\n * @typedef {import('./types').MultihashHasherLoader} MultihashHasherLoader\n *\n * @typedef {object} Provider\n * @property {PeerId} id\n * @property {Multiaddr[]} multiaddrs\n *\n * @typedef {import('it-stream-types').Duplex<Uint8Array>} Duplex\n */\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0';\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0';\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0';\nconst DEFAULT_MAX_INBOUND_STREAMS = 32;\nconst DEFAULT_MAX_OUTBOUND_STREAMS = 128;\nconst DEFAULT_INCOMING_STREAM_TIMEOUT = 30000;\nexport class Network {\n  /**\n   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p\n   * @param {import('./bitswap').Bitswap} bitswap\n   * @param {import('./stats').Stats} stats\n   * @param {object} [options]\n   * @param {boolean} [options.b100Only]\n   * @param {MultihashHasherLoader} [options.hashLoader]\n   * @param {number} [options.maxInboundStreams=32]\n   * @param {number} [options.maxOutboundStreams=32]\n   * @param {number} [options.incomingStreamTimeout=30000]\n   */\n  constructor(libp2p, bitswap, stats) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this._log = logger(libp2p.peerId, 'network');\n    this._libp2p = libp2p;\n    this._bitswap = bitswap;\n    this._protocols = [BITSWAP100];\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this._protocols.unshift(BITSWAP110);\n\n      this._protocols.unshift(BITSWAP120);\n    }\n\n    this._stats = stats;\n    this._running = false; // bind event listeners\n\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n    this._hashLoader = options.hashLoader;\n    this._maxInboundStreams = options.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS;\n    this._maxOutboundStreams = options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;\n    this._incomingStreamTimeout = options.incomingStreamTimeout ?? DEFAULT_INCOMING_STREAM_TIMEOUT;\n  }\n\n  async start() {\n    this._running = true;\n    await this._libp2p.handle(this._protocols, this._onConnection, {\n      maxInboundStreams: this._maxInboundStreams,\n      maxOutboundStreams: this._maxOutboundStreams\n    }); // register protocol with topology\n\n    const topology = createTopology({\n      onConnect: this._onPeerConnect,\n      onDisconnect: this._onPeerDisconnect\n    });\n    /** @type {string[]} */\n\n    this._registrarIds = [];\n\n    for (const protocol of this._protocols) {\n      this._registrarIds.push(await this._libp2p.register(protocol, topology));\n    } // All existing connections are like new ones for us\n\n\n    this._libp2p.getConnections().forEach(conn => {\n      this._onPeerConnect(conn.remotePeer);\n    });\n  }\n\n  async stop() {\n    this._running = false; // Unhandle both, libp2p doesn't care if it's not already handled\n\n    await this._libp2p.unhandle(this._protocols); // unregister protocol and handlers\n\n    if (this._registrarIds != null) {\n      for (const id of this._registrarIds) {\n        this._libp2p.unregister(id);\n      }\n\n      this._registrarIds = [];\n    }\n  }\n  /**\n   * Handles both types of incoming bitswap messages\n   *\n   * @private\n   * @param {object} connection\n   * @param {Stream} connection.stream - A duplex iterable stream\n   * @param {Connection} connection.connection - A libp2p Connection\n   */\n\n\n  _onConnection(_ref) {\n    let {\n      stream,\n      connection\n    } = _ref;\n\n    if (!this._running) {\n      return;\n    }\n\n    const controller = new TimeoutController(this._incomingStreamTimeout);\n    Promise.resolve().then(async () => {\n      this._log('incoming new bitswap %s connection from %p', stream.stat.protocol, connection.remotePeer);\n\n      await pipe(abortableSource(stream.source, controller.signal), lp.decode(), async source => {\n        for await (const data of source) {\n          try {\n            const message = await Message.deserialize(data.subarray(), this._hashLoader);\n            await this._bitswap._receiveMessage(connection.remotePeer, message);\n          } catch (\n          /** @type {any} */\n          err) {\n            this._bitswap._receiveError(err);\n\n            break;\n          } // we have received some data so reset the timeout controller\n\n\n          controller.reset();\n        }\n      });\n    }).catch(err => {\n      this._log(err);\n\n      stream.abort(err);\n    }).finally(() => {\n      controller.clear();\n      stream.close();\n    });\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerConnect(peerId) {\n    this._bitswap._onPeerConnected(peerId);\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerDisconnect(peerId) {\n    this._bitswap._onPeerDisconnected(peerId);\n  }\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {AsyncIterable<Provider>}\n   */\n\n\n  findProviders(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this._libp2p.contentRouting.findProviders(cid, options);\n  }\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async findAndConnect(cid, options) {\n    const connectAttempts = [];\n    let found = 0;\n\n    for await (const provider of this.findProviders(cid, options)) {\n      this._log(`connecting to provider ${provider.id}`);\n\n      connectAttempts.push(this.connectTo(provider.id, options).catch(err => {\n        // Prevent unhandled promise rejection\n        this._log.error(err);\n      }));\n      found++;\n\n      if (found === CONSTANTS.maxProvidersPerRequest) {\n        break;\n      }\n    }\n\n    await Promise.all(connectAttempts);\n  }\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async provide(cid, options) {\n    await this._libp2p.contentRouting.provide(cid, options);\n  }\n  /**\n   * Connect to the given peer\n   * Send the given msg (instance of Message) to the given peer\n   *\n   * @param {PeerId} peer\n   * @param {Message} msg\n   */\n\n\n  async sendMessage(peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running');\n    const stringId = peer.toString();\n\n    this._log('sendMessage to %s', stringId, msg);\n\n    const connection = await this._libp2p.dial(peer);\n    const stream = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100]);\n    await writeMessage(stream, msg, this._log);\n\n    this._updateSentStats(peer, msg.blocks);\n  }\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n\n\n  async connectTo(peer, options) {\n    // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running');\n    }\n\n    return this._libp2p.dial(peer, options);\n  }\n  /**\n   * @private\n   * @param {PeerId} peer\n   * @param {Map<string, Uint8Array>} blocks\n   */\n\n\n  _updateSentStats(peer, blocks) {\n    const peerId = peer.toString();\n\n    if (this._stats) {\n      for (const block of blocks.values()) {\n        this._stats.push(peerId, 'dataSent', block.length);\n      }\n\n      this._stats.push(peerId, 'blocksSent', blocks.size);\n    }\n  }\n\n}\n/**\n *\n * @param {Stream} stream\n * @param {Message} msg\n * @param {*} log\n */\n\nasync function writeMessage(stream, msg, log) {\n  try {\n    /** @type {Uint8Array} */\n    let serialized;\n\n    switch (stream.stat.protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100();\n        break;\n\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110();\n        break;\n\n      default:\n        throw new Error('Unknown protocol: ' + stream.stat.protocol);\n    }\n\n    await pipe([serialized], lp.encode(), stream);\n  } catch (err) {\n    log(err);\n  } finally {\n    stream.close();\n  }\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-bitswap/src/network.js"],"names":["lp","pipe","createTopology","BitswapMessage","Message","CONSTANTS","logger","TimeoutController","abortableSource","BITSWAP100","BITSWAP110","BITSWAP120","DEFAULT_MAX_INBOUND_STREAMS","DEFAULT_MAX_OUTBOUND_STREAMS","DEFAULT_INCOMING_STREAM_TIMEOUT","Network","constructor","libp2p","bitswap","stats","options","_log","peerId","_libp2p","_bitswap","_protocols","b100Only","unshift","_stats","_running","_onPeerConnect","bind","_onPeerDisconnect","_onConnection","_hashLoader","hashLoader","_maxInboundStreams","maxInboundStreams","_maxOutboundStreams","maxOutboundStreams","_incomingStreamTimeout","incomingStreamTimeout","start","handle","topology","onConnect","onDisconnect","_registrarIds","protocol","push","register","getConnections","forEach","conn","remotePeer","stop","unhandle","id","unregister","stream","connection","controller","Promise","resolve","then","stat","source","signal","decode","data","message","deserialize","subarray","_receiveMessage","err","_receiveError","reset","catch","abort","finally","clear","close","_onPeerConnected","_onPeerDisconnected","findProviders","cid","contentRouting","findAndConnect","connectAttempts","found","provider","connectTo","error","maxProvidersPerRequest","all","provide","sendMessage","peer","msg","Error","stringId","toString","dial","newStream","writeMessage","_updateSentStats","blocks","block","values","length","size","log","serialized","serializeToBitswap100","serializeToBitswap110","encode"],"mappings":"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","sourcesContent":["import * as lp from 'it-length-prefixed'\nimport { pipe } from 'it-pipe'\nimport { createTopology } from '@libp2p/topology'\nimport { BitswapMessage as Message } from './message/index.js'\nimport * as CONSTANTS from './constants.js'\nimport { logger } from './utils/index.js'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { abortableSource } from 'abortable-iterator'\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n * @typedef {import('@libp2p/interface-connection').Connection} Connection\n * @typedef {import('@libp2p/interface-connection').Stream} Stream\n * @typedef {import('./types').MultihashHasherLoader} MultihashHasherLoader\n *\n * @typedef {object} Provider\n * @property {PeerId} id\n * @property {Multiaddr[]} multiaddrs\n *\n * @typedef {import('it-stream-types').Duplex<Uint8Array>} Duplex\n */\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0'\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0'\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0'\n\nconst DEFAULT_MAX_INBOUND_STREAMS = 32\nconst DEFAULT_MAX_OUTBOUND_STREAMS = 128\nconst DEFAULT_INCOMING_STREAM_TIMEOUT = 30000\n\nexport class Network {\n  /**\n   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p\n   * @param {import('./bitswap').Bitswap} bitswap\n   * @param {import('./stats').Stats} stats\n   * @param {object} [options]\n   * @param {boolean} [options.b100Only]\n   * @param {MultihashHasherLoader} [options.hashLoader]\n   * @param {number} [options.maxInboundStreams=32]\n   * @param {number} [options.maxOutboundStreams=32]\n   * @param {number} [options.incomingStreamTimeout=30000]\n   */\n  constructor (libp2p, bitswap, stats, options = {}) {\n    this._log = logger(libp2p.peerId, 'network')\n    this._libp2p = libp2p\n    this._bitswap = bitswap\n    this._protocols = [BITSWAP100]\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this._protocols.unshift(BITSWAP110)\n      this._protocols.unshift(BITSWAP120)\n    }\n\n    this._stats = stats\n    this._running = false\n\n    // bind event listeners\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)\n    this._onConnection = this._onConnection.bind(this)\n    this._hashLoader = options.hashLoader\n    this._maxInboundStreams = options.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS\n    this._maxOutboundStreams = options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS\n    this._incomingStreamTimeout = options.incomingStreamTimeout ?? DEFAULT_INCOMING_STREAM_TIMEOUT\n  }\n\n  async start () {\n    this._running = true\n    await this._libp2p.handle(this._protocols, this._onConnection, {\n      maxInboundStreams: this._maxInboundStreams,\n      maxOutboundStreams: this._maxOutboundStreams\n    })\n\n    // register protocol with topology\n    const topology = createTopology({\n      onConnect: this._onPeerConnect,\n      onDisconnect: this._onPeerDisconnect\n    })\n\n    /** @type {string[]} */\n    this._registrarIds = []\n\n    for (const protocol of this._protocols) {\n      this._registrarIds.push(await this._libp2p.register(protocol, topology))\n    }\n\n    // All existing connections are like new ones for us\n    this._libp2p.getConnections().forEach(conn => {\n      this._onPeerConnect(conn.remotePeer)\n    })\n  }\n\n  async stop () {\n    this._running = false\n\n    // Unhandle both, libp2p doesn't care if it's not already handled\n    await this._libp2p.unhandle(this._protocols)\n\n    // unregister protocol and handlers\n    if (this._registrarIds != null) {\n      for (const id of this._registrarIds) {\n        this._libp2p.unregister(id)\n      }\n\n      this._registrarIds = []\n    }\n  }\n\n  /**\n   * Handles both types of incoming bitswap messages\n   *\n   * @private\n   * @param {object} connection\n   * @param {Stream} connection.stream - A duplex iterable stream\n   * @param {Connection} connection.connection - A libp2p Connection\n   */\n  _onConnection ({ stream, connection }) {\n    if (!this._running) {\n      return\n    }\n\n    const controller = new TimeoutController(this._incomingStreamTimeout)\n\n    Promise.resolve().then(async () => {\n      this._log('incoming new bitswap %s connection from %p', stream.stat.protocol, connection.remotePeer)\n\n      await pipe(\n        abortableSource(stream.source, controller.signal),\n        lp.decode(),\n        async (source) => {\n          for await (const data of source) {\n            try {\n              const message = await Message.deserialize(data.subarray(), this._hashLoader)\n              await this._bitswap._receiveMessage(connection.remotePeer, message)\n            } catch (/** @type {any} */ err) {\n              this._bitswap._receiveError(err)\n              break\n            }\n\n            // we have received some data so reset the timeout controller\n            controller.reset()\n          }\n        }\n      )\n    })\n      .catch(err => {\n        this._log(err)\n        stream.abort(err)\n      })\n      .finally(() => {\n        controller.clear()\n        stream.close()\n      })\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerConnect (peerId) {\n    this._bitswap._onPeerConnected(peerId)\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnect (peerId) {\n    this._bitswap._onPeerDisconnected(peerId)\n  }\n\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {AsyncIterable<Provider>}\n   */\n  findProviders (cid, options = {}) {\n    return this._libp2p.contentRouting.findProviders(cid, options)\n  }\n\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async findAndConnect (cid, options) {\n    const connectAttempts = []\n    let found = 0\n\n    for await (const provider of this.findProviders(cid, options)) {\n      this._log(`connecting to provider ${provider.id}`)\n      connectAttempts.push(\n        this.connectTo(provider.id, options)\n          .catch(err => {\n            // Prevent unhandled promise rejection\n            this._log.error(err)\n          })\n      )\n\n      found++\n\n      if (found === CONSTANTS.maxProvidersPerRequest) {\n        break\n      }\n    }\n\n    await Promise.all(connectAttempts)\n  }\n\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async provide (cid, options) {\n    await this._libp2p.contentRouting.provide(cid, options)\n  }\n\n  /**\n   * Connect to the given peer\n   * Send the given msg (instance of Message) to the given peer\n   *\n   * @param {PeerId} peer\n   * @param {Message} msg\n   */\n  async sendMessage (peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running')\n\n    const stringId = peer.toString()\n    this._log('sendMessage to %s', stringId, msg)\n\n    const connection = await this._libp2p.dial(peer)\n    const stream = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100])\n\n    await writeMessage(stream, msg, this._log)\n\n    this._updateSentStats(peer, msg.blocks)\n  }\n\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  async connectTo (peer, options) { // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running')\n    }\n\n    return this._libp2p.dial(peer, options)\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peer\n   * @param {Map<string, Uint8Array>} blocks\n   */\n  _updateSentStats (peer, blocks) {\n    const peerId = peer.toString()\n\n    if (this._stats) {\n      for (const block of blocks.values()) {\n        this._stats.push(peerId, 'dataSent', block.length)\n      }\n\n      this._stats.push(peerId, 'blocksSent', blocks.size)\n    }\n  }\n}\n\n/**\n *\n * @param {Stream} stream\n * @param {Message} msg\n * @param {*} log\n */\nasync function writeMessage (stream, msg, log) {\n  try {\n    /** @type {Uint8Array} */\n    let serialized\n    switch (stream.stat.protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100()\n        break\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110()\n        break\n      default:\n        throw new Error('Unknown protocol: ' + stream.stat.protocol)\n    }\n\n    await pipe(\n      [serialized],\n      lp.encode(),\n      stream\n    )\n  } catch (err) {\n    log(err)\n  } finally {\n    stream.close()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}