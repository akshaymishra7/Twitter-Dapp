{"ast":null,"code":"import extractDataFromBlock from '../../../utils/extract-data-from-block.js';\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js';\nimport { UnixFS } from 'ipfs-unixfs';\nimport errCode from 'err-code';\nimport * as dagPb from '@ipld/dag-pb';\nimport * as dagCbor from '@ipld/dag-cbor';\nimport * as raw from 'multiformats/codecs/raw';\n\nasync function* emitBytes(blockstore, node, start, end) {\n  let streamPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let options = arguments.length > 5 ? arguments[5] : undefined;\n\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end);\n\n    if (buf.length) {\n      yield buf;\n    }\n\n    streamPosition += buf.length;\n    return streamPosition;\n  }\n\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n  }\n\n  let file;\n\n  try {\n    file = UnixFS.unmarshal(node.Data);\n  } catch (err) {\n    throw errCode(err, 'ERR_NOT_UNIXFS');\n  }\n\n  if (file.data && file.data.length) {\n    const buf = extractDataFromBlock(file.data, streamPosition, start, end);\n\n    if (buf.length) {\n      yield buf;\n    }\n\n    streamPosition += file.data.length;\n  }\n\n  let childStart = streamPosition;\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i];\n    const childEnd = streamPosition + file.blockSizes[i];\n\n    if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {\n      const block = await blockstore.get(childLink.Hash, {\n        signal: options.signal\n      });\n      let child;\n\n      switch (childLink.Hash.code) {\n        case dagPb.code:\n          child = await dagPb.decode(block);\n          break;\n\n        case raw.code:\n          child = block;\n          break;\n\n        case dagCbor.code:\n          child = await dagCbor.decode(block);\n          break;\n\n        default:\n          throw Error(`Unsupported codec: ${childLink.Hash.code}`);\n      }\n\n      for await (const buf of emitBytes(blockstore, child, start, end, streamPosition, options)) {\n        streamPosition += buf.length;\n        yield buf;\n      }\n    }\n\n    streamPosition = childEnd;\n    childStart = childEnd + 1;\n  }\n}\n\nconst fileContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldFileContent() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const fileSize = unixfs.fileSize();\n\n    if (fileSize === undefined) {\n      throw new Error('File was a directory');\n    }\n\n    const {\n      offset,\n      length\n    } = validateOffsetAndLength(fileSize, options.offset, options.length);\n    const start = offset;\n    const end = offset + length;\n    return emitBytes(blockstore, node, start, end, 0, options);\n  }\n\n  return yieldFileContent;\n};\n\nexport default fileContent;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/client/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/file.js"],"names":["extractDataFromBlock","validateOffsetAndLength","UnixFS","errCode","dagPb","dagCbor","raw","emitBytes","blockstore","node","start","end","streamPosition","options","Uint8Array","buf","length","Data","Error","file","unmarshal","err","data","childStart","i","Links","childLink","childEnd","blockSizes","block","get","Hash","signal","child","code","decode","fileContent","cid","unixfs","path","resolve","depth","yieldFileContent","fileSize","undefined","offset"],"mappings":"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","sourcesContent":["import extractDataFromBlock from '../../../utils/extract-data-from-block.js';\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js';\nimport { UnixFS } from 'ipfs-unixfs';\nimport errCode from 'err-code';\nimport * as dagPb from '@ipld/dag-pb';\nimport * as dagCbor from '@ipld/dag-cbor';\nimport * as raw from 'multiformats/codecs/raw';\nasync function* emitBytes(blockstore, node, start, end, streamPosition = 0, options) {\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end);\n    if (buf.length) {\n      yield buf;\n    }\n    streamPosition += buf.length;\n    return streamPosition;\n  }\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n  }\n  let file;\n  try {\n    file = UnixFS.unmarshal(node.Data);\n  } catch (err) {\n    throw errCode(err, 'ERR_NOT_UNIXFS');\n  }\n  if (file.data && file.data.length) {\n    const buf = extractDataFromBlock(file.data, streamPosition, start, end);\n    if (buf.length) {\n      yield buf;\n    }\n    streamPosition += file.data.length;\n  }\n  let childStart = streamPosition;\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i];\n    const childEnd = streamPosition + file.blockSizes[i];\n    if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {\n      const block = await blockstore.get(childLink.Hash, { signal: options.signal });\n      let child;\n      switch (childLink.Hash.code) {\n      case dagPb.code:\n        child = await dagPb.decode(block);\n        break;\n      case raw.code:\n        child = block;\n        break;\n      case dagCbor.code:\n        child = await dagCbor.decode(block);\n        break;\n      default:\n        throw Error(`Unsupported codec: ${ childLink.Hash.code }`);\n      }\n      for await (const buf of emitBytes(blockstore, child, start, end, streamPosition, options)) {\n        streamPosition += buf.length;\n        yield buf;\n      }\n    }\n    streamPosition = childEnd;\n    childStart = childEnd + 1;\n  }\n}\nconst fileContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldFileContent(options = {}) {\n    const fileSize = unixfs.fileSize();\n    if (fileSize === undefined) {\n      throw new Error('File was a directory');\n    }\n    const {offset, length} = validateOffsetAndLength(fileSize, options.offset, options.length);\n    const start = offset;\n    const end = offset + length;\n    return emitBytes(blockstore, node, start, end, 0, options);\n  }\n  return yieldFileContent;\n};\nexport default fileContent;"]},"metadata":{},"sourceType":"module"}