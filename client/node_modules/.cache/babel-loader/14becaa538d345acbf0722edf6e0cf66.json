{"ast":null,"code":"import { exporter } from 'ipfs-unixfs-exporter';\nimport { toMfsPath } from './utils/to-mfs-path.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport map from 'it-map';\n/**\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {import('ipfs-core-types/src/files').MFSEntry} MFSEntry\n */\n\n/**\n * @param {import('ipfs-unixfs-exporter').UnixFSEntry} fsEntry\n */\n\nconst toOutput = fsEntry => {\n  /** @type {MFSEntry} */\n  const output = {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type: fsEntry.type === 'directory' ? 'directory' : 'file',\n    size: fsEntry.size\n  };\n\n  if (fsEntry.type === 'file' || fsEntry.type === 'directory') {\n    output.mode = fsEntry.unixfs.mode;\n    output.mtime = fsEntry.unixfs.mtime;\n  }\n\n  return output;\n};\n/**\n * @param {MfsContext} context\n */\n\n\nexport function createLs(context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"ls\"]}\n   */\n  async function* mfsLs(path) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const mfsPath = await toMfsPath(context, path, options);\n    const fsEntry = await exporter(mfsPath.mfsPath, context.repo.blocks); // directory, perhaps sharded\n\n    if (fsEntry.type === 'directory') {\n      yield* map(fsEntry.content(options), toOutput);\n      return;\n    } // single file/node\n\n\n    yield toOutput(fsEntry);\n  }\n\n  return withTimeoutOption(mfsLs);\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/files/ls.js"],"names":["exporter","toMfsPath","withTimeoutOption","map","toOutput","fsEntry","output","cid","name","type","size","mode","unixfs","mtime","createLs","context","mfsLs","path","options","mfsPath","repo","blocks","content"],"mappings":"AAAA,SAASA,QAAT,QAAyB,sBAAzB;AACA,SAASC,SAAT,QAA0B,wBAA1B;AACA,SAASC,iBAAT,QAAkC,qCAAlC;AACA,OAAOC,GAAP,MAAgB,QAAhB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA,MAAMC,QAAQ,GAAIC,OAAD,IAAa;AAC5B;AACA,QAAMC,MAAM,GAAG;AACbC,IAAAA,GAAG,EAAEF,OAAO,CAACE,GADA;AAEbC,IAAAA,IAAI,EAAEH,OAAO,CAACG,IAFD;AAGbC,IAAAA,IAAI,EAAEJ,OAAO,CAACI,IAAR,KAAiB,WAAjB,GAA+B,WAA/B,GAA6C,MAHtC;AAIbC,IAAAA,IAAI,EAAEL,OAAO,CAACK;AAJD,GAAf;;AAOA,MAAIL,OAAO,CAACI,IAAR,KAAiB,MAAjB,IAA2BJ,OAAO,CAACI,IAAR,KAAiB,WAAhD,EAA6D;AAC3DH,IAAAA,MAAM,CAACK,IAAP,GAAcN,OAAO,CAACO,MAAR,CAAeD,IAA7B;AACAL,IAAAA,MAAM,CAACO,KAAP,GAAeR,OAAO,CAACO,MAAR,CAAeC,KAA9B;AACD;;AAED,SAAOP,MAAP;AACD,CAfD;AAiBA;AACA;AACA;;;AACA,OAAO,SAASQ,QAAT,CAAmBC,OAAnB,EAA4B;AACjC;AACF;AACA;AACE,kBAAiBC,KAAjB,CAAwBC,IAAxB,EAA4C;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAC1C,UAAMC,OAAO,GAAG,MAAMlB,SAAS,CAACc,OAAD,EAAUE,IAAV,EAAgBC,OAAhB,CAA/B;AACA,UAAMb,OAAO,GAAG,MAAML,QAAQ,CAACmB,OAAO,CAACA,OAAT,EAAkBJ,OAAO,CAACK,IAAR,CAAaC,MAA/B,CAA9B,CAF0C,CAI1C;;AACA,QAAIhB,OAAO,CAACI,IAAR,KAAiB,WAArB,EAAkC;AAChC,aAAQN,GAAG,CAACE,OAAO,CAACiB,OAAR,CAAgBJ,OAAhB,CAAD,EAA2Bd,QAA3B,CAAX;AAEA;AACD,KATyC,CAW1C;;;AACA,UAAMA,QAAQ,CAACC,OAAD,CAAd;AACD;;AAED,SAAOH,iBAAiB,CAACc,KAAD,CAAxB;AACD","sourcesContent":["import { exporter } from 'ipfs-unixfs-exporter'\nimport { toMfsPath } from './utils/to-mfs-path.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport map from 'it-map'\n\n/**\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {import('ipfs-core-types/src/files').MFSEntry} MFSEntry\n */\n\n/**\n * @param {import('ipfs-unixfs-exporter').UnixFSEntry} fsEntry\n */\nconst toOutput = (fsEntry) => {\n  /** @type {MFSEntry} */\n  const output = {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type: fsEntry.type === 'directory' ? 'directory' : 'file',\n    size: fsEntry.size\n  }\n\n  if (fsEntry.type === 'file' || fsEntry.type === 'directory') {\n    output.mode = fsEntry.unixfs.mode\n    output.mtime = fsEntry.unixfs.mtime\n  }\n\n  return output\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createLs (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"ls\"]}\n   */\n  async function * mfsLs (path, options = {}) {\n    const mfsPath = await toMfsPath(context, path, options)\n    const fsEntry = await exporter(mfsPath.mfsPath, context.repo.blocks)\n\n    // directory, perhaps sharded\n    if (fsEntry.type === 'directory') {\n      yield * map(fsEntry.content(options), toOutput)\n\n      return\n    }\n\n    // single file/node\n    yield toOutput(fsEntry)\n  }\n\n  return withTimeoutOption(mfsLs)\n}\n"]},"metadata":{},"sourceType":"module"}