{"ast":null,"code":"import { Key } from 'interface-datastore';\nimport { readShardFun, SHARDING_FN, README_FN, readme } from './shard.js';\nimport { BaseDatastore } from './base.js';\nimport { KeyTransformDatastore } from './keytransform.js';\nimport * as Errors from './errors.js';\nconst shardKey = new Key(SHARDING_FN);\nconst shardReadmeKey = new Key(README_FN);\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').QueryFilter} QueryFilter\n * @typedef {import('interface-datastore').QueryOrder} QueryOrder\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').KeyQueryFilter} KeyQueryFilter\n * @typedef {import('interface-datastore').KeyQueryOrder} KeyQueryOrder\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('./types').Shard} Shard\n *\n */\n\n/**\n * @template TValue\n * @typedef {import('interface-store').Await<TValue> } Await\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\n\nexport class ShardingDatastore extends BaseDatastore {\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  constructor(store, shard) {\n    super();\n    this.child = new KeyTransformDatastore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    });\n    this.shard = shard;\n  }\n\n  async open() {\n    await this.child.open();\n    this.shard = await ShardingDatastore.create(this.child, this.shard);\n  }\n  /**\n   * @param {Key} key\n   */\n\n\n  _convertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    const parent = new Key(this.shard.fun(s));\n    return parent.child(key);\n  }\n  /**\n   * @param {Key} key\n   */\n\n\n  _invertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    return Key.withNamespaces(key.list().slice(1));\n  }\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n\n\n  static async createOrOpen(store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard);\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err && err.message !== 'datastore exists') throw err;\n    }\n\n    return ShardingDatastore.open(store);\n  }\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   */\n\n\n  static async open(store) {\n    const shard = await readShardFun('/', store);\n    return new ShardingDatastore(store, shard);\n  }\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n\n\n  static async create(store, shard) {\n    const hasShard = await store.has(shardKey);\n\n    if (!hasShard && !shard) {\n      throw Errors.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'));\n    }\n\n    if (!hasShard) {\n      // @ts-ignore i have no idea what putRaw is or saw any implementation\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n      await Promise.all([put(shardKey, new TextEncoder().encode(shard.toString() + '\\n')), put(shardReadmeKey, new TextEncoder().encode(readme))]);\n      return shard;\n    } // test shards\n\n\n    const diskShard = await readShardFun('/', store);\n    const a = (diskShard || '').toString();\n    const b = shard.toString();\n\n    if (a !== b) {\n      throw new Error(`specified fun ${b} does not match repo shard fun ${a}`);\n    }\n\n    return diskShard;\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} val\n   * @param {Options} [options]\n   */\n\n\n  put(key, val, options) {\n    return this.child.put(key, val, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  get(key, options) {\n    return this.child.get(key, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  has(key, options) {\n    return this.child.has(key, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  delete(key, options) {\n    return this.child.delete(key, options);\n  }\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n\n\n  async *putMany(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.child.putMany(source, options);\n  }\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Uint8Array>}\n   */\n\n\n  async *getMany(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.child.getMany(source, options);\n  }\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n\n\n  async *deleteMany(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.child.deleteMany(source, options);\n  }\n\n  batch() {\n    return this.child.batch();\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    /** @type {Query} */\n    const tq = { ...q,\n      filters: [\n      /** @type {QueryFilter} */\n      _ref => {\n        let {\n          key\n        } = _ref;\n        return key.toString() !== shardKey.toString();\n      },\n      /** @type {QueryFilter} */\n      _ref2 => {\n        let {\n          key\n        } = _ref2;\n        return key.toString() !== shardReadmeKey.toString();\n      }].concat(q.filters || [])\n    };\n    return this.child.query(tq, options);\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n\n\n  queryKeys(q, options) {\n    /** @type {KeyQuery} */\n    const tq = { ...q,\n      filters: [\n      /** @type {KeyQueryFilter} */\n      key => key.toString() !== shardKey.toString(),\n      /** @type {KeyQueryFilter} */\n      key => key.toString() !== shardReadmeKey.toString()].concat(q.filters || [])\n    };\n    return this.child.queryKeys(tq, options);\n  }\n\n  close() {\n    return this.child.close();\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/datastore-core/src/sharding.js"],"names":["Key","readShardFun","SHARDING_FN","README_FN","readme","BaseDatastore","KeyTransformDatastore","Errors","shardKey","shardReadmeKey","ShardingDatastore","constructor","store","shard","child","convert","_convertKey","bind","invert","_invertKey","open","create","key","s","toString","parent","fun","withNamespaces","list","slice","createOrOpen","err","message","hasShard","has","dbOpenFailedError","Error","put","putRaw","Promise","all","TextEncoder","encode","diskShard","a","b","val","options","get","delete","putMany","source","getMany","deleteMany","batch","query","q","tq","filters","concat","queryKeys","close"],"mappings":"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","sourcesContent":["import { Key } from 'interface-datastore'\nimport {\n  readShardFun,\n  SHARDING_FN,\n  README_FN,\n  readme\n} from './shard.js'\nimport { BaseDatastore } from './base.js'\nimport { KeyTransformDatastore } from './keytransform.js'\nimport * as Errors from './errors.js'\n\nconst shardKey = new Key(SHARDING_FN)\nconst shardReadmeKey = new Key(README_FN)\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').QueryFilter} QueryFilter\n * @typedef {import('interface-datastore').QueryOrder} QueryOrder\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').KeyQueryFilter} KeyQueryFilter\n * @typedef {import('interface-datastore').KeyQueryOrder} KeyQueryOrder\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('./types').Shard} Shard\n *\n */\n/**\n * @template TValue\n * @typedef {import('interface-store').Await<TValue> } Await\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\nexport class ShardingDatastore extends BaseDatastore {\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  constructor (store, shard) {\n    super()\n\n    this.child = new KeyTransformDatastore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    })\n    this.shard = shard\n  }\n\n  async open () {\n    await this.child.open()\n\n    this.shard = await ShardingDatastore.create(this.child, this.shard)\n  }\n\n  /**\n   * @param {Key} key\n   */\n  _convertKey (key) {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n\n    const parent = new Key(this.shard.fun(s))\n    return parent.child(key)\n  }\n\n  /**\n   * @param {Key} key\n   */\n  _invertKey (key) {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n    return Key.withNamespaces(key.list().slice(1))\n  }\n\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  static async createOrOpen (store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard)\n    } catch (/** @type {any} */ err) {\n      if (err && err.message !== 'datastore exists') throw err\n    }\n    return ShardingDatastore.open(store)\n  }\n\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   */\n  static async open (store) {\n    const shard = await readShardFun('/', store)\n    return new ShardingDatastore(store, shard)\n  }\n\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  static async create (store, shard) {\n    const hasShard = await store.has(shardKey)\n    if (!hasShard && !shard) {\n      throw Errors.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'))\n    }\n    if (!hasShard) {\n      // @ts-ignore i have no idea what putRaw is or saw any implementation\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store)\n      await Promise.all([\n        put(shardKey, new TextEncoder().encode(shard.toString() + '\\n')),\n        put(shardReadmeKey, new TextEncoder().encode(readme))\n      ])\n\n      return shard\n    }\n\n    // test shards\n    const diskShard = await readShardFun('/', store)\n    const a = (diskShard || '').toString()\n    const b = shard.toString()\n    if (a !== b) {\n      throw new Error(`specified fun ${b} does not match repo shard fun ${a}`)\n    }\n    return diskShard\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} val\n   * @param {Options} [options]\n   */\n  put (key, val, options) {\n    return this.child.put(key, val, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  get (key, options) {\n    return this.child.get(key, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  has (key, options) {\n    return this.child.has(key, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  delete (key, options) {\n    return this.child.delete(key, options)\n  }\n\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n  async * putMany (source, options = {}) {\n    yield * this.child.putMany(source, options)\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Uint8Array>}\n   */\n  async * getMany (source, options = {}) {\n    yield * this.child.getMany(source, options)\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n  async * deleteMany (source, options = {}) {\n    yield * this.child.deleteMany(source, options)\n  }\n\n  batch () {\n    return this.child.batch()\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query (q, options) {\n    /** @type {Query} */\n    const tq = {\n      ...q,\n      filters: [\n        /** @type {QueryFilter} */\n        ({ key }) => key.toString() !== shardKey.toString(),\n        /** @type {QueryFilter} */\n        ({ key }) => key.toString() !== shardReadmeKey.toString()\n      ].concat(q.filters || [])\n    }\n\n    return this.child.query(tq, options)\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys (q, options) {\n    /** @type {KeyQuery} */\n    const tq = {\n      ...q,\n      filters: [\n        /** @type {KeyQueryFilter} */\n        key => key.toString() !== shardKey.toString(),\n        /** @type {KeyQueryFilter} */\n        key => key.toString() !== shardReadmeKey.toString()\n      ].concat(q.filters || [])\n    }\n\n    return this.child.queryKeys(tq, options)\n  }\n\n  close () {\n    return this.child.close()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}