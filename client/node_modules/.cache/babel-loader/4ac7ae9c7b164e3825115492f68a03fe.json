{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { EventEmitter } from '@libp2p/interfaces/events';\nimport { PeerStoreAddressBook } from './address-book.js';\nimport { PeerStoreKeyBook } from './key-book.js';\nimport { PeerStoreMetadataBook } from './metadata-book.js';\nimport { PeerStoreProtoBook } from './proto-book.js';\nimport { PersistentStore } from './store.js';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { Tags } from './pb/tags.js';\nconst log = logger('libp2p:peer-store');\n/**\n * An implementation of PeerStore that stores data in a Datastore\n */\n\nexport class PersistentPeerStore extends EventEmitter {\n  constructor(components) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.components = components;\n    this.store = new PersistentStore(components);\n    this.addressBook = new PeerStoreAddressBook(this.dispatchEvent.bind(this), this.store, init.addressFilter);\n    this.keyBook = new PeerStoreKeyBook(this.dispatchEvent.bind(this), this.store);\n    this.metadataBook = new PeerStoreMetadataBook(this.dispatchEvent.bind(this), this.store);\n    this.protoBook = new PeerStoreProtoBook(this.dispatchEvent.bind(this), this.store);\n  }\n\n  async forEach(fn) {\n    log.trace('getPeers await read lock');\n    const release = await this.store.lock.readLock();\n    log.trace('getPeers got read lock');\n\n    try {\n      for await (const peer of this.store.all()) {\n        if (peer.id.equals(this.components.peerId)) {\n          // Skip self peer if present\n          continue;\n        }\n\n        fn(peer);\n      }\n    } finally {\n      log.trace('getPeers release read lock');\n      release();\n    }\n  }\n\n  async all() {\n    const output = [];\n    await this.forEach(peer => {\n      output.push(peer);\n    });\n    return output;\n  }\n  /**\n   * Delete the information of the given peer in every book\n   */\n\n\n  async delete(peerId) {\n    log.trace('delete await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('delete got write lock');\n\n    try {\n      await this.store.delete(peerId);\n    } finally {\n      log.trace('delete release write lock');\n      release();\n    }\n  }\n  /**\n   * Get the stored information of a given peer\n   */\n\n\n  async get(peerId) {\n    log.trace('get await read lock');\n    const release = await this.store.lock.readLock();\n    log.trace('get got read lock');\n\n    try {\n      return await this.store.load(peerId);\n    } finally {\n      log.trace('get release read lock');\n      release();\n    }\n  }\n  /**\n   * Returns true if we have a record of the peer\n   */\n\n\n  async has(peerId) {\n    log.trace('has await read lock');\n    const release = await this.store.lock.readLock();\n    log.trace('has got read lock');\n\n    try {\n      return await this.store.has(peerId);\n    } finally {\n      log.trace('has release read lock');\n      release();\n    }\n  }\n\n  async tagPeer(peerId, tag) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const providedValue = options.value ?? 0;\n    const value = Math.round(providedValue);\n    const ttl = options.ttl ?? undefined;\n\n    if (value !== providedValue || value < 0 || value > 100) {\n      throw new CodeError('Tag value must be between 0-100', 'ERR_TAG_VALUE_OUT_OF_BOUNDS');\n    }\n\n    const buf = await this.metadataBook.getValue(peerId, 'tags');\n    let tags = [];\n\n    if (buf != null) {\n      tags = Tags.decode(buf).tags;\n    } // do not allow duplicate tags\n\n\n    tags = tags.filter(t => t.name !== tag);\n    tags.push({\n      name: tag,\n      value,\n      expiry: ttl == null ? undefined : BigInt(Date.now() + ttl)\n    });\n    await this.metadataBook.setValue(peerId, 'tags', Tags.encode({\n      tags\n    }).subarray());\n  }\n\n  async unTagPeer(peerId, tag) {\n    const buf = await this.metadataBook.getValue(peerId, 'tags');\n    let tags = [];\n\n    if (buf != null) {\n      tags = Tags.decode(buf).tags;\n    }\n\n    tags = tags.filter(t => t.name !== tag);\n    await this.metadataBook.setValue(peerId, 'tags', Tags.encode({\n      tags\n    }).subarray());\n  }\n\n  async getTags(peerId) {\n    const buf = await this.metadataBook.getValue(peerId, 'tags');\n    let tags = [];\n\n    if (buf != null) {\n      tags = Tags.decode(buf).tags;\n    }\n\n    const now = BigInt(Date.now());\n    const unexpiredTags = tags.filter(tag => tag.expiry == null || tag.expiry > now);\n\n    if (unexpiredTags.length !== tags.length) {\n      // remove any expired tags\n      await this.metadataBook.setValue(peerId, 'tags', Tags.encode({\n        tags: unexpiredTags\n      }).subarray());\n    }\n\n    return unexpiredTags.map(t => ({\n      name: t.name,\n      value: t.value ?? 0\n    }));\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,QAAuB,gBAAvB;AACA,SAASC,YAAT,QAA6B,2BAA7B;AACA,SAASC,oBAAT,QAAqC,mBAArC;AACA,SAASC,gBAAT,QAAiC,eAAjC;AACA,SAASC,qBAAT,QAAsC,oBAAtC;AACA,SAASC,kBAAT,QAAmC,iBAAnC;AACA,SAASC,eAAT,QAAuC,YAAvC;AAGA,SAASC,SAAT,QAA0B,2BAA1B;AACA,SAAcC,IAAd,QAA0B,cAA1B;AAGA,MAAMC,GAAG,GAAGT,MAAM,CAAC,mBAAD,CAAlB;AAOA;;;;AAGA,OAAM,MAAOU,mBAAP,SAAmCT,YAAnC,CAAgE;AASpEU,cAAaC,UAAb,EAAgF;AAAA,QAAxBC,IAAwB,uEAAF,EAAE;AAC9E;AAEA,SAAKD,UAAL,GAAkBA,UAAlB;AACA,SAAKE,KAAL,GAAa,IAAIR,eAAJ,CAAoBM,UAApB,CAAb;AACA,SAAKG,WAAL,GAAmB,IAAIb,oBAAJ,CAAyB,KAAKc,aAAL,CAAmBC,IAAnB,CAAwB,IAAxB,CAAzB,EAAwD,KAAKH,KAA7D,EAAoED,IAAI,CAACK,aAAzE,CAAnB;AACA,SAAKC,OAAL,GAAe,IAAIhB,gBAAJ,CAAqB,KAAKa,aAAL,CAAmBC,IAAnB,CAAwB,IAAxB,CAArB,EAAoD,KAAKH,KAAzD,CAAf;AACA,SAAKM,YAAL,GAAoB,IAAIhB,qBAAJ,CAA0B,KAAKY,aAAL,CAAmBC,IAAnB,CAAwB,IAAxB,CAA1B,EAAyD,KAAKH,KAA9D,CAApB;AACA,SAAKO,SAAL,GAAiB,IAAIhB,kBAAJ,CAAuB,KAAKW,aAAL,CAAmBC,IAAnB,CAAwB,IAAxB,CAAvB,EAAsD,KAAKH,KAA3D,CAAjB;AACD;;AAEY,QAAPQ,OAAO,CAAEC,EAAF,EAA0B;AACrCd,OAAG,CAACe,KAAJ,CAAU,0BAAV;AACA,UAAMC,OAAO,GAAG,MAAM,KAAKX,KAAL,CAAWY,IAAX,CAAgBC,QAAhB,EAAtB;AACAlB,OAAG,CAACe,KAAJ,CAAU,wBAAV;;AAEA,QAAI;AACF,iBAAW,MAAMI,IAAjB,IAAyB,KAAKd,KAAL,CAAWe,GAAX,EAAzB,EAA2C;AACzC,YAAID,IAAI,CAACE,EAAL,CAAQC,MAAR,CAAe,KAAKnB,UAAL,CAAgBoB,MAA/B,CAAJ,EAA4C;AAC1C;AACA;AACD;;AAEDT,UAAE,CAACK,IAAD,CAAF;AACD;AACF,KATD,SASU;AACRnB,SAAG,CAACe,KAAJ,CAAU,4BAAV;AACAC,aAAO;AACR;AACF;;AAEQ,QAAHI,GAAG;AACP,UAAMI,MAAM,GAAW,EAAvB;AAEA,UAAM,KAAKX,OAAL,CAAaM,IAAI,IAAG;AACxBK,YAAM,CAACC,IAAP,CAAYN,IAAZ;AACD,KAFK,CAAN;AAIA,WAAOK,MAAP;AACD;AAED;;;;;AAGY,QAANE,MAAM,CAAEH,MAAF,EAAgB;AAC1BvB,OAAG,CAACe,KAAJ,CAAU,yBAAV;AACA,UAAMC,OAAO,GAAG,MAAM,KAAKX,KAAL,CAAWY,IAAX,CAAgBU,SAAhB,EAAtB;AACA3B,OAAG,CAACe,KAAJ,CAAU,uBAAV;;AAEA,QAAI;AACF,YAAM,KAAKV,KAAL,CAAWqB,MAAX,CAAkBH,MAAlB,CAAN;AACD,KAFD,SAEU;AACRvB,SAAG,CAACe,KAAJ,CAAU,2BAAV;AACAC,aAAO;AACR;AACF;AAED;;;;;AAGS,QAAHY,GAAG,CAAEL,MAAF,EAAgB;AACvBvB,OAAG,CAACe,KAAJ,CAAU,qBAAV;AACA,UAAMC,OAAO,GAAG,MAAM,KAAKX,KAAL,CAAWY,IAAX,CAAgBC,QAAhB,EAAtB;AACAlB,OAAG,CAACe,KAAJ,CAAU,mBAAV;;AAEA,QAAI;AACF,aAAO,MAAM,KAAKV,KAAL,CAAWwB,IAAX,CAAgBN,MAAhB,CAAb;AACD,KAFD,SAEU;AACRvB,SAAG,CAACe,KAAJ,CAAU,uBAAV;AACAC,aAAO;AACR;AACF;AAED;;;;;AAGS,QAAHc,GAAG,CAAEP,MAAF,EAAgB;AACvBvB,OAAG,CAACe,KAAJ,CAAU,qBAAV;AACA,UAAMC,OAAO,GAAG,MAAM,KAAKX,KAAL,CAAWY,IAAX,CAAgBC,QAAhB,EAAtB;AACAlB,OAAG,CAACe,KAAJ,CAAU,mBAAV;;AAEA,QAAI;AACF,aAAO,MAAM,KAAKV,KAAL,CAAWyB,GAAX,CAAeP,MAAf,CAAb;AACD,KAFD,SAEU;AACRvB,SAAG,CAACe,KAAJ,CAAU,uBAAV;AACAC,aAAO;AACR;AACF;;AAEY,QAAPe,OAAO,CAAER,MAAF,EAAkBS,GAAlB,EAAuD;AAAA,QAAxBC,OAAwB,uEAAF,EAAE;AAClE,UAAMC,aAAa,GAAGD,OAAO,CAACE,KAAR,IAAiB,CAAvC;AACA,UAAMA,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWH,aAAX,CAAd;AACA,UAAMI,GAAG,GAAGL,OAAO,CAACK,GAAR,IAAeC,SAA3B;;AAEA,QAAIJ,KAAK,KAAKD,aAAV,IAA2BC,KAAK,GAAG,CAAnC,IAAwCA,KAAK,GAAG,GAApD,EAAyD;AACvD,YAAM,IAAIrC,SAAJ,CAAc,iCAAd,EAAiD,6BAAjD,CAAN;AACD;;AAED,UAAM0C,GAAG,GAAG,MAAM,KAAK7B,YAAL,CAAkB8B,QAAlB,CAA2BlB,MAA3B,EAAmC,MAAnC,CAAlB;AACA,QAAImB,IAAI,GAAU,EAAlB;;AAEA,QAAIF,GAAG,IAAI,IAAX,EAAiB;AACfE,UAAI,GAAG3C,IAAI,CAAC4C,MAAL,CAAYH,GAAZ,EAAiBE,IAAxB;AACD,KAdiE,CAgBlE;;;AACAA,QAAI,GAAGA,IAAI,CAACE,MAAL,CAAYC,CAAC,IAAIA,CAAC,CAACC,IAAF,KAAWd,GAA5B,CAAP;AAEAU,QAAI,CAACjB,IAAL,CAAU;AACRqB,UAAI,EAAEd,GADE;AAERG,WAFQ;AAGRY,YAAM,EAAET,GAAG,IAAI,IAAP,GAAcC,SAAd,GAA0BS,MAAM,CAACC,IAAI,CAACC,GAAL,KAAaZ,GAAd;AAHhC,KAAV;AAMA,UAAM,KAAK3B,YAAL,CAAkBwC,QAAlB,CAA2B5B,MAA3B,EAAmC,MAAnC,EAA2CxB,IAAI,CAACqD,MAAL,CAAY;AAAEV;AAAF,KAAZ,EAAsBW,QAAtB,EAA3C,CAAN;AACD;;AAEc,QAATC,SAAS,CAAE/B,MAAF,EAAkBS,GAAlB,EAA6B;AAC1C,UAAMQ,GAAG,GAAG,MAAM,KAAK7B,YAAL,CAAkB8B,QAAlB,CAA2BlB,MAA3B,EAAmC,MAAnC,CAAlB;AACA,QAAImB,IAAI,GAAU,EAAlB;;AAEA,QAAIF,GAAG,IAAI,IAAX,EAAiB;AACfE,UAAI,GAAG3C,IAAI,CAAC4C,MAAL,CAAYH,GAAZ,EAAiBE,IAAxB;AACD;;AAEDA,QAAI,GAAGA,IAAI,CAACE,MAAL,CAAYC,CAAC,IAAIA,CAAC,CAACC,IAAF,KAAWd,GAA5B,CAAP;AAEA,UAAM,KAAKrB,YAAL,CAAkBwC,QAAlB,CAA2B5B,MAA3B,EAAmC,MAAnC,EAA2CxB,IAAI,CAACqD,MAAL,CAAY;AAAEV;AAAF,KAAZ,EAAsBW,QAAtB,EAA3C,CAAN;AACD;;AAEY,QAAPE,OAAO,CAAEhC,MAAF,EAAgB;AAC3B,UAAMiB,GAAG,GAAG,MAAM,KAAK7B,YAAL,CAAkB8B,QAAlB,CAA2BlB,MAA3B,EAAmC,MAAnC,CAAlB;AACA,QAAImB,IAAI,GAAU,EAAlB;;AAEA,QAAIF,GAAG,IAAI,IAAX,EAAiB;AACfE,UAAI,GAAG3C,IAAI,CAAC4C,MAAL,CAAYH,GAAZ,EAAiBE,IAAxB;AACD;;AAED,UAAMQ,GAAG,GAAGF,MAAM,CAACC,IAAI,CAACC,GAAL,EAAD,CAAlB;AACA,UAAMM,aAAa,GAAGd,IAAI,CAACE,MAAL,CAAYZ,GAAG,IAAIA,GAAG,CAACe,MAAJ,IAAc,IAAd,IAAsBf,GAAG,CAACe,MAAJ,GAAaG,GAAtD,CAAtB;;AAEA,QAAIM,aAAa,CAACC,MAAd,KAAyBf,IAAI,CAACe,MAAlC,EAA0C;AACxC;AACA,YAAM,KAAK9C,YAAL,CAAkBwC,QAAlB,CAA2B5B,MAA3B,EAAmC,MAAnC,EAA2CxB,IAAI,CAACqD,MAAL,CAAY;AAAEV,YAAI,EAAEc;AAAR,OAAZ,EAAqCH,QAArC,EAA3C,CAAN;AACD;;AAED,WAAOG,aAAa,CAACE,GAAd,CAAkBb,CAAC,KAAK;AAC7BC,UAAI,EAAED,CAAC,CAACC,IADqB;AAE7BX,WAAK,EAAEU,CAAC,CAACV,KAAF,IAAW;AAFW,KAAL,CAAnB,CAAP;AAID;;AA/JmE","names":["logger","EventEmitter","PeerStoreAddressBook","PeerStoreKeyBook","PeerStoreMetadataBook","PeerStoreProtoBook","PersistentStore","CodeError","Tags","log","PersistentPeerStore","constructor","components","init","store","addressBook","dispatchEvent","bind","addressFilter","keyBook","metadataBook","protoBook","forEach","fn","trace","release","lock","readLock","peer","all","id","equals","peerId","output","push","delete","writeLock","get","load","has","tagPeer","tag","options","providedValue","value","Math","round","ttl","undefined","buf","getValue","tags","decode","filter","t","name","expiry","BigInt","Date","now","setValue","encode","subarray","unTagPeer","getTags","unexpiredTags","length","map"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\peer-store\\src\\index.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { EventEmitter } from '@libp2p/interfaces/events'\nimport { PeerStoreAddressBook } from './address-book.js'\nimport { PeerStoreKeyBook } from './key-book.js'\nimport { PeerStoreMetadataBook } from './metadata-book.js'\nimport { PeerStoreProtoBook } from './proto-book.js'\nimport { PersistentStore, Store } from './store.js'\nimport type { PeerStore, AddressBook, KeyBook, MetadataBook, ProtoBook, PeerStoreEvents, PeerStoreInit, Peer, TagOptions } from '@libp2p/interface-peer-store'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { Tag, Tags } from './pb/tags.js'\nimport type { Datastore } from 'interface-datastore'\n\nconst log = logger('libp2p:peer-store')\n\nexport interface PersistentPeerStoreComponents {\n  peerId: PeerId\n  datastore: Datastore\n}\n\n/**\n * An implementation of PeerStore that stores data in a Datastore\n */\nexport class PersistentPeerStore extends EventEmitter<PeerStoreEvents> implements PeerStore {\n  public addressBook: AddressBook\n  public keyBook: KeyBook\n  public metadataBook: MetadataBook\n  public protoBook: ProtoBook\n\n  private readonly components: PersistentPeerStoreComponents\n  private readonly store: Store\n\n  constructor (components: PersistentPeerStoreComponents, init: PeerStoreInit = {}) {\n    super()\n\n    this.components = components\n    this.store = new PersistentStore(components)\n    this.addressBook = new PeerStoreAddressBook(this.dispatchEvent.bind(this), this.store, init.addressFilter)\n    this.keyBook = new PeerStoreKeyBook(this.dispatchEvent.bind(this), this.store)\n    this.metadataBook = new PeerStoreMetadataBook(this.dispatchEvent.bind(this), this.store)\n    this.protoBook = new PeerStoreProtoBook(this.dispatchEvent.bind(this), this.store)\n  }\n\n  async forEach (fn: (peer: Peer) => void): Promise<void> {\n    log.trace('getPeers await read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('getPeers got read lock')\n\n    try {\n      for await (const peer of this.store.all()) {\n        if (peer.id.equals(this.components.peerId)) {\n          // Skip self peer if present\n          continue\n        }\n\n        fn(peer)\n      }\n    } finally {\n      log.trace('getPeers release read lock')\n      release()\n    }\n  }\n\n  async all (): Promise<Peer[]> {\n    const output: Peer[] = []\n\n    await this.forEach(peer => {\n      output.push(peer)\n    })\n\n    return output\n  }\n\n  /**\n   * Delete the information of the given peer in every book\n   */\n  async delete (peerId: PeerId): Promise<void> {\n    log.trace('delete await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('delete got write lock')\n\n    try {\n      await this.store.delete(peerId)\n    } finally {\n      log.trace('delete release write lock')\n      release()\n    }\n  }\n\n  /**\n   * Get the stored information of a given peer\n   */\n  async get (peerId: PeerId): Promise<Peer> {\n    log.trace('get await read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('get got read lock')\n\n    try {\n      return await this.store.load(peerId)\n    } finally {\n      log.trace('get release read lock')\n      release()\n    }\n  }\n\n  /**\n   * Returns true if we have a record of the peer\n   */\n  async has (peerId: PeerId): Promise<boolean> {\n    log.trace('has await read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('has got read lock')\n\n    try {\n      return await this.store.has(peerId)\n    } finally {\n      log.trace('has release read lock')\n      release()\n    }\n  }\n\n  async tagPeer (peerId: PeerId, tag: string, options: TagOptions = {}): Promise<void> {\n    const providedValue = options.value ?? 0\n    const value = Math.round(providedValue)\n    const ttl = options.ttl ?? undefined\n\n    if (value !== providedValue || value < 0 || value > 100) {\n      throw new CodeError('Tag value must be between 0-100', 'ERR_TAG_VALUE_OUT_OF_BOUNDS')\n    }\n\n    const buf = await this.metadataBook.getValue(peerId, 'tags')\n    let tags: Tag[] = []\n\n    if (buf != null) {\n      tags = Tags.decode(buf).tags\n    }\n\n    // do not allow duplicate tags\n    tags = tags.filter(t => t.name !== tag)\n\n    tags.push({\n      name: tag,\n      value,\n      expiry: ttl == null ? undefined : BigInt(Date.now() + ttl)\n    })\n\n    await this.metadataBook.setValue(peerId, 'tags', Tags.encode({ tags }).subarray())\n  }\n\n  async unTagPeer (peerId: PeerId, tag: string): Promise<void> {\n    const buf = await this.metadataBook.getValue(peerId, 'tags')\n    let tags: Tag[] = []\n\n    if (buf != null) {\n      tags = Tags.decode(buf).tags\n    }\n\n    tags = tags.filter(t => t.name !== tag)\n\n    await this.metadataBook.setValue(peerId, 'tags', Tags.encode({ tags }).subarray())\n  }\n\n  async getTags (peerId: PeerId): Promise<Array<{ name: string, value: number }>> {\n    const buf = await this.metadataBook.getValue(peerId, 'tags')\n    let tags: Tag[] = []\n\n    if (buf != null) {\n      tags = Tags.decode(buf).tags\n    }\n\n    const now = BigInt(Date.now())\n    const unexpiredTags = tags.filter(tag => tag.expiry == null || tag.expiry > now)\n\n    if (unexpiredTags.length !== tags.length) {\n      // remove any expired tags\n      await this.metadataBook.setValue(peerId, 'tags', Tags.encode({ tags: unexpiredTags }).subarray())\n    }\n\n    return unexpiredTags.map(t => ({\n      name: t.name,\n      value: t.value ?? 0\n    }))\n  }\n}\n"]},"metadata":{},"sourceType":"module"}