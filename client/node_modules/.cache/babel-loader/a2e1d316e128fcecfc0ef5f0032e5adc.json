{"ast":null,"code":"import toIterable from 'browser-readablestream-to-it';\nimport { CarBlockIterator } from '@ipld/car/iterator';\nimport { recursive as unixFsExporter } from 'ipfs-unixfs-exporter';\nimport { VerifyingGetOnlyBlockStore } from \"./utils/verifying-get-only-blockstore.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\"; // Export unixfs entries from car file\n\nexport async function* unpack(carReader, roots) {\n  const verifyingBlockService = VerifyingGetOnlyBlockStore.fromCarReader(carReader);\n\n  if (!roots || roots.length === 0) {\n    roots = await carReader.getRoots();\n  }\n\n  for (const root of roots) {\n    yield* unixFsExporter(root, verifyingBlockService, {\n      /* options */\n    });\n  }\n}\nexport async function* unpackStream(readable) {\n  let {\n    roots,\n    blockstore: userBlockstore\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const carIterator = await CarBlockIterator.fromIterable(asAsyncIterable(readable));\n  const blockstore = userBlockstore || new MemoryBlockStore();\n\n  for await (const block of carIterator) {\n    await blockstore.put(block.cid, block.bytes);\n  }\n\n  const verifyingBlockStore = VerifyingGetOnlyBlockStore.fromBlockstore(blockstore);\n\n  if (!roots || roots.length === 0) {\n    roots = await carIterator.getRoots();\n  }\n\n  for (const root of roots) {\n    yield* unixFsExporter(root, verifyingBlockStore);\n  }\n}\n/**\n * Upgrade a ReadableStream to an AsyncIterable if it isn't already\n *\n * ReadableStream (e.g res.body) is asyncIterable in node, but not in chrome, yet.\n * see: https://bugs.chromium.org/p/chromium/issues/detail?id=929585\n */\n\nfunction asAsyncIterable(readable) {\n  // @ts-ignore how to convince tsc that we are checking the type here?\n  return Symbol.asyncIterator in readable ? readable : toIterable(readable);\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/client/node_modules/ipfs-car/dist/esm/unpack/index.js"],"names":["toIterable","CarBlockIterator","recursive","unixFsExporter","VerifyingGetOnlyBlockStore","MemoryBlockStore","unpack","carReader","roots","verifyingBlockService","fromCarReader","length","getRoots","root","unpackStream","readable","blockstore","userBlockstore","carIterator","fromIterable","asAsyncIterable","block","put","cid","bytes","verifyingBlockStore","fromBlockstore","Symbol","asyncIterator"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,8BAAvB;AACA,SAASC,gBAAT,QAAiC,oBAAjC;AACA,SAASC,SAAS,IAAIC,cAAtB,QAA4C,sBAA5C;AACA,SAASC,0BAAT,QAA2C,0CAA3C;AACA,SAASC,gBAAT,QAAiC,yBAAjC,C,CACA;;AACA,OAAO,gBAAgBC,MAAhB,CAAuBC,SAAvB,EAAkCC,KAAlC,EAAyC;AAC5C,QAAMC,qBAAqB,GAAGL,0BAA0B,CAACM,aAA3B,CAAyCH,SAAzC,CAA9B;;AACA,MAAI,CAACC,KAAD,IAAUA,KAAK,CAACG,MAAN,KAAiB,CAA/B,EAAkC;AAC9BH,IAAAA,KAAK,GAAG,MAAMD,SAAS,CAACK,QAAV,EAAd;AACH;;AACD,OAAK,MAAMC,IAAX,IAAmBL,KAAnB,EAA0B;AACtB,WAAOL,cAAc,CAACU,IAAD,EAAOJ,qBAAP,EAA8B;AAAE;AAAF,KAA9B,CAArB;AACH;AACJ;AACD,OAAO,gBAAgBK,YAAhB,CAA6BC,QAA7B,EAAmF;AAAA,MAA5C;AAAEP,IAAAA,KAAF;AAASQ,IAAAA,UAAU,EAAEC;AAArB,GAA4C,uEAAJ,EAAI;AACtF,QAAMC,WAAW,GAAG,MAAMjB,gBAAgB,CAACkB,YAAjB,CAA8BC,eAAe,CAACL,QAAD,CAA7C,CAA1B;AACA,QAAMC,UAAU,GAAGC,cAAc,IAAI,IAAIZ,gBAAJ,EAArC;;AACA,aAAW,MAAMgB,KAAjB,IAA0BH,WAA1B,EAAuC;AACnC,UAAMF,UAAU,CAACM,GAAX,CAAeD,KAAK,CAACE,GAArB,EAA0BF,KAAK,CAACG,KAAhC,CAAN;AACH;;AACD,QAAMC,mBAAmB,GAAGrB,0BAA0B,CAACsB,cAA3B,CAA0CV,UAA1C,CAA5B;;AACA,MAAI,CAACR,KAAD,IAAUA,KAAK,CAACG,MAAN,KAAiB,CAA/B,EAAkC;AAC9BH,IAAAA,KAAK,GAAG,MAAMU,WAAW,CAACN,QAAZ,EAAd;AACH;;AACD,OAAK,MAAMC,IAAX,IAAmBL,KAAnB,EAA0B;AACtB,WAAOL,cAAc,CAACU,IAAD,EAAOY,mBAAP,CAArB;AACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;;AACA,SAASL,eAAT,CAAyBL,QAAzB,EAAmC;AAC/B;AACA,SAAOY,MAAM,CAACC,aAAP,IAAwBb,QAAxB,GAAmCA,QAAnC,GAA8Cf,UAAU,CAACe,QAAD,CAA/D;AACH","sourcesContent":["import toIterable from 'browser-readablestream-to-it';\nimport { CarBlockIterator } from '@ipld/car/iterator';\nimport { recursive as unixFsExporter } from 'ipfs-unixfs-exporter';\nimport { VerifyingGetOnlyBlockStore } from \"./utils/verifying-get-only-blockstore.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\n// Export unixfs entries from car file\nexport async function* unpack(carReader, roots) {\n    const verifyingBlockService = VerifyingGetOnlyBlockStore.fromCarReader(carReader);\n    if (!roots || roots.length === 0) {\n        roots = await carReader.getRoots();\n    }\n    for (const root of roots) {\n        yield* unixFsExporter(root, verifyingBlockService, { /* options */});\n    }\n}\nexport async function* unpackStream(readable, { roots, blockstore: userBlockstore } = {}) {\n    const carIterator = await CarBlockIterator.fromIterable(asAsyncIterable(readable));\n    const blockstore = userBlockstore || new MemoryBlockStore();\n    for await (const block of carIterator) {\n        await blockstore.put(block.cid, block.bytes);\n    }\n    const verifyingBlockStore = VerifyingGetOnlyBlockStore.fromBlockstore(blockstore);\n    if (!roots || roots.length === 0) {\n        roots = await carIterator.getRoots();\n    }\n    for (const root of roots) {\n        yield* unixFsExporter(root, verifyingBlockStore);\n    }\n}\n/**\n * Upgrade a ReadableStream to an AsyncIterable if it isn't already\n *\n * ReadableStream (e.g res.body) is asyncIterable in node, but not in chrome, yet.\n * see: https://bugs.chromium.org/p/chromium/issues/detail?id=929585\n */\nfunction asAsyncIterable(readable) {\n    // @ts-ignore how to convince tsc that we are checking the type here?\n    return Symbol.asyncIterator in readable ? readable : toIterable(readable);\n}\n"]},"metadata":{},"sourceType":"module"}