{"ast":null,"code":"import { Key } from 'interface-datastore/key';\nimport { Libp2pRecord } from '@libp2p/record';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nconst log = logger('ipfs:ipns:offline-datastore');\n/**\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n// Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\n\nexport class OfflineDatastore {\n  /**\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor(datastore) {\n    this._datastore = datastore;\n    /** @type {any[]} */\n\n    this.stores = [];\n  }\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   * @param {AbortOptions} [options]\n   */\n\n\n  async put(key, value, options) {\n    // eslint-disable-line require-await\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');\n    }\n\n    if (!(value instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore value must be a Uint8Array'), 'ERR_INVALID_VALUE');\n    }\n\n    let routingKey;\n\n    try {\n      routingKey = this._routingKey(key);\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n    } // Marshal to libp2p record as the DHT does\n\n\n    const record = new Libp2pRecord(key, value, new Date());\n    await this._datastore.put(routingKey, record.serialize(), options);\n  }\n  /**\n   * Get a value from the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   * @param {AbortOptions} [options]\n   */\n\n\n  async get(key, options) {\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');\n    }\n\n    let routingKey;\n\n    try {\n      routingKey = this._routingKey(key);\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n    }\n\n    const res = await this._datastore.get(routingKey, options); // Unmarshal libp2p record as the DHT does\n\n    let record;\n\n    try {\n      record = Libp2pRecord.deserialize(res);\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n      throw err;\n    }\n\n    return record.value;\n  }\n  /**\n   * encode key properly - base32(/ipns/{cid})\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  _routingKey(key) {\n    return new Key('/dht/record/' + uint8ArrayToString(key, 'base32'), false);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/ipns/routing/offline-datastore.js"],"names":["Key","Libp2pRecord","errcode","logger","toString","uint8ArrayToString","log","OfflineDatastore","constructor","datastore","_datastore","stores","put","key","value","options","Uint8Array","Error","routingKey","_routingKey","err","error","record","Date","serialize","get","res","deserialize"],"mappings":"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","sourcesContent":["import { Key } from 'interface-datastore/key'\nimport { Libp2pRecord } from '@libp2p/record'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nconst log = logger('ipfs:ipns:offline-datastore')\n\n/**\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\n// Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\nexport class OfflineDatastore {\n  /**\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor (datastore) {\n    this._datastore = datastore\n    /** @type {any[]} */\n    this.stores = []\n  }\n\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   * @param {AbortOptions} [options]\n   */\n  async put (key, value, options) { // eslint-disable-line require-await\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY')\n    }\n\n    if (!(value instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore value must be a Uint8Array'), 'ERR_INVALID_VALUE')\n    }\n\n    let routingKey\n\n    try {\n      routingKey = this._routingKey(key)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY')\n    }\n\n    // Marshal to libp2p record as the DHT does\n    const record = new Libp2pRecord(key, value, new Date())\n\n    await this._datastore.put(routingKey, record.serialize(), options)\n  }\n\n  /**\n   * Get a value from the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   * @param {AbortOptions} [options]\n   */\n  async get (key, options) {\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY')\n    }\n\n    let routingKey\n\n    try {\n      routingKey = this._routingKey(key)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY')\n    }\n\n    const res = await this._datastore.get(routingKey, options)\n\n    // Unmarshal libp2p record as the DHT does\n    let record\n    try {\n      record = Libp2pRecord.deserialize(res)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw err\n    }\n\n    return record.value\n  }\n\n  /**\n   * encode key properly - base32(/ipns/{cid})\n   *\n   * @param {Uint8Array} key\n   */\n  _routingKey (key) {\n    return new Key('/dht/record/' + uint8ArrayToString(key, 'base32'), false)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}