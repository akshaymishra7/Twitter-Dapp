{"ast":null,"code":"import { CID } from 'multiformats/cid';\nimport errCode from 'err-code';\nimport * as dagCbor from '@ipld/dag-cbor';\n/**\n * @typedef {import('../types').Resolver} Resolver\n */\n\n/**\n * @type {Resolver}\n */\n\nconst resolve = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid);\n  const object = dagCbor.decode(block);\n  let subObject = object;\n  let subPath = path;\n\n  while (toResolve.length) {\n    const prop = toResolve[0];\n\n    if (prop in subObject) {\n      // remove the bit of the path we have resolved\n      toResolve.shift();\n      subPath = `${subPath}/${prop}`;\n      const subObjectCid = CID.asCID(subObject[prop]);\n\n      if (subObjectCid) {\n        return {\n          entry: {\n            type: 'object',\n            name,\n            path,\n            cid,\n            node: block,\n            depth,\n            size: block.length,\n            content: async function* () {\n              yield object;\n            }\n          },\n          next: {\n            cid: subObjectCid,\n            name: prop,\n            path: subPath,\n            toResolve\n          }\n        };\n      }\n\n      subObject = subObject[prop];\n    } else {\n      // cannot resolve further\n      throw errCode(new Error(`No property named ${prop} found in cbor node ${cid}`), 'ERR_NO_PROP');\n    }\n  }\n\n  return {\n    entry: {\n      type: 'object',\n      name,\n      path,\n      cid,\n      node: block,\n      depth,\n      size: block.length,\n      content: async function* () {\n        yield object;\n      }\n    }\n  };\n};\n\nexport default resolve;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-unixfs-exporter/src/resolvers/dag-cbor.js"],"names":["CID","errCode","dagCbor","resolve","cid","name","path","toResolve","depth","blockstore","options","block","get","object","decode","subObject","subPath","length","prop","shift","subObjectCid","asCID","entry","type","node","size","content","next","Error"],"mappings":"AAAA,SAASA,GAAT,QAAoB,kBAApB;AACA,OAAOC,OAAP,MAAoB,UAApB;AACA,OAAO,KAAKC,OAAZ,MAAyB,gBAAzB;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AACA,MAAMC,OAAO,GAAG,OAAOC,GAAP,EAAYC,IAAZ,EAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCJ,OAAnC,EAA4CK,KAA5C,EAAmDC,UAAnD,EAA+DC,OAA/D,KAA2E;AACzF,QAAMC,KAAK,GAAG,MAAMF,UAAU,CAACG,GAAX,CAAeR,GAAf,CAApB;AACA,QAAMS,MAAM,GAAGX,OAAO,CAACY,MAAR,CAAeH,KAAf,CAAf;AACA,MAAII,SAAS,GAAGF,MAAhB;AACA,MAAIG,OAAO,GAAGV,IAAd;;AAEA,SAAOC,SAAS,CAACU,MAAjB,EAAyB;AACvB,UAAMC,IAAI,GAAGX,SAAS,CAAC,CAAD,CAAtB;;AAEA,QAAIW,IAAI,IAAIH,SAAZ,EAAuB;AACrB;AACAR,MAAAA,SAAS,CAACY,KAAV;AACAH,MAAAA,OAAO,GAAI,GAAEA,OAAQ,IAAGE,IAAK,EAA7B;AAEA,YAAME,YAAY,GAAGpB,GAAG,CAACqB,KAAJ,CAAUN,SAAS,CAACG,IAAD,CAAnB,CAArB;;AACA,UAAIE,YAAJ,EAAkB;AAChB,eAAO;AACLE,UAAAA,KAAK,EAAE;AACLC,YAAAA,IAAI,EAAE,QADD;AAELlB,YAAAA,IAFK;AAGLC,YAAAA,IAHK;AAILF,YAAAA,GAJK;AAKLoB,YAAAA,IAAI,EAAEb,KALD;AAMLH,YAAAA,KANK;AAOLiB,YAAAA,IAAI,EAAEd,KAAK,CAACM,MAPP;AAQLS,YAAAA,OAAO,EAAE,mBAAoB;AAC3B,oBAAMb,MAAN;AACD;AAVI,WADF;AAaLc,UAAAA,IAAI,EAAE;AACJvB,YAAAA,GAAG,EAAEgB,YADD;AAEJf,YAAAA,IAAI,EAAEa,IAFF;AAGJZ,YAAAA,IAAI,EAAEU,OAHF;AAIJT,YAAAA;AAJI;AAbD,SAAP;AAoBD;;AAEDQ,MAAAA,SAAS,GAAGA,SAAS,CAACG,IAAD,CAArB;AACD,KA9BD,MA8BO;AACL;AACA,YAAMjB,OAAO,CAAC,IAAI2B,KAAJ,CAAW,qBAAoBV,IAAK,uBAAsBd,GAAI,EAA9D,CAAD,EAAmE,aAAnE,CAAb;AACD;AACF;;AAED,SAAO;AACLkB,IAAAA,KAAK,EAAE;AACLC,MAAAA,IAAI,EAAE,QADD;AAELlB,MAAAA,IAFK;AAGLC,MAAAA,IAHK;AAILF,MAAAA,GAJK;AAKLoB,MAAAA,IAAI,EAAEb,KALD;AAMLH,MAAAA,KANK;AAOLiB,MAAAA,IAAI,EAAEd,KAAK,CAACM,MAPP;AAQLS,MAAAA,OAAO,EAAE,mBAAoB;AAC3B,cAAMb,MAAN;AACD;AAVI;AADF,GAAP;AAcD,CA3DD;;AA6DA,eAAeV,OAAf","sourcesContent":["import { CID } from 'multiformats/cid'\nimport errCode from 'err-code'\nimport * as dagCbor from '@ipld/dag-cbor'\n\n/**\n * @typedef {import('../types').Resolver} Resolver\n */\n\n/**\n * @type {Resolver}\n */\nconst resolve = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid)\n  const object = dagCbor.decode(block)\n  let subObject = object\n  let subPath = path\n\n  while (toResolve.length) {\n    const prop = toResolve[0]\n\n    if (prop in subObject) {\n      // remove the bit of the path we have resolved\n      toResolve.shift()\n      subPath = `${subPath}/${prop}`\n\n      const subObjectCid = CID.asCID(subObject[prop])\n      if (subObjectCid) {\n        return {\n          entry: {\n            type: 'object',\n            name,\n            path,\n            cid,\n            node: block,\n            depth,\n            size: block.length,\n            content: async function * () {\n              yield object\n            }\n          },\n          next: {\n            cid: subObjectCid,\n            name: prop,\n            path: subPath,\n            toResolve\n          }\n        }\n      }\n\n      subObject = subObject[prop]\n    } else {\n      // cannot resolve further\n      throw errCode(new Error(`No property named ${prop} found in cbor node ${cid}`), 'ERR_NO_PROP')\n    }\n  }\n\n  return {\n    entry: {\n      type: 'object',\n      name,\n      path,\n      cid,\n      node: block,\n      depth,\n      size: block.length,\n      content: async function * () {\n        yield object\n      }\n    }\n  }\n}\n\nexport default resolve\n"]},"metadata":{},"sourceType":"module"}