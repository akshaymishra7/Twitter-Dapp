{"ast":null,"code":"import DirFlat from './dir-flat.js';\nimport flatToShard from './flat-to-shard.js';\nimport Dir from './dir.js';\nimport toPathComponents from './utils/to-path-components.js';\n/**\n * @typedef {import('./types').ImportResult} ImportResult\n * @typedef {import('./types').InProgressImportResult} InProgressImportResult\n * @typedef {import('./types').ImporterOptions} ImporterOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {(source: AsyncIterable<InProgressImportResult>, blockstore: Blockstore, options: ImporterOptions) => AsyncIterable<ImportResult>} TreeBuilder\n */\n\n/**\n * @param {InProgressImportResult} elem\n * @param {Dir} tree\n * @param {ImporterOptions} options\n */\n\nasync function addToTree(elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '');\n  const lastIndex = pathElems.length - 1;\n  let parent = tree;\n  let currentPath = '';\n\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i];\n    currentPath += `${currentPath ? '/' : ''}${pathElem}`;\n    const last = i === lastIndex;\n    parent.dirty = true;\n    parent.cid = undefined;\n    parent.size = undefined;\n\n    if (last) {\n      await parent.put(pathElem, elem);\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options);\n    } else {\n      let dir = await parent.get(pathElem);\n\n      if (!dir || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          root: false,\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir && dir.unixfs && dir.unixfs.mtime,\n          mode: dir && dir.unixfs && dir.unixfs.mode\n        }, options);\n      }\n\n      await parent.put(pathElem, dir);\n      parent = dir;\n    }\n  }\n\n  return tree;\n}\n/**\n * @param {Dir | InProgressImportResult} tree\n * @param {Blockstore} blockstore\n */\n\n\nasync function* flushAndYield(tree, blockstore) {\n  if (!(tree instanceof Dir)) {\n    if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n      yield tree;\n    }\n\n    return;\n  }\n\n  yield* tree.flush(blockstore);\n}\n/**\n * @type {TreeBuilder}\n */\n\n\nasync function* treeBuilder(source, block, options) {\n  /** @type {Dir} */\n  let tree = new DirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options);\n\n  for await (const entry of source) {\n    if (!entry) {\n      continue;\n    }\n\n    tree = await addToTree(entry, tree, options);\n\n    if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n      yield entry;\n    }\n  }\n\n  if (options.wrapWithDirectory) {\n    yield* flushAndYield(tree, block);\n  } else {\n    for await (const unwrapped of tree.eachChildSeries()) {\n      if (!unwrapped) {\n        continue;\n      }\n\n      yield* flushAndYield(unwrapped.child, block);\n    }\n  }\n}\n\nexport default treeBuilder;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-unixfs-importer/src/tree-builder.js"],"names":["DirFlat","flatToShard","Dir","toPathComponents","addToTree","elem","tree","options","pathElems","path","lastIndex","length","parent","currentPath","i","pathElem","last","dirty","cid","undefined","size","put","shardSplitThreshold","dir","get","root","parentKey","flat","mtime","unixfs","mode","flushAndYield","blockstore","isDirectory","flush","treeBuilder","source","block","entry","wrapWithDirectory","unwrapped","eachChildSeries","child"],"mappings":"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","sourcesContent":["import DirFlat from './dir-flat.js'\nimport flatToShard from './flat-to-shard.js'\nimport Dir from './dir.js'\nimport toPathComponents from './utils/to-path-components.js'\n\n/**\n * @typedef {import('./types').ImportResult} ImportResult\n * @typedef {import('./types').InProgressImportResult} InProgressImportResult\n * @typedef {import('./types').ImporterOptions} ImporterOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {(source: AsyncIterable<InProgressImportResult>, blockstore: Blockstore, options: ImporterOptions) => AsyncIterable<ImportResult>} TreeBuilder\n */\n\n/**\n * @param {InProgressImportResult} elem\n * @param {Dir} tree\n * @param {ImporterOptions} options\n */\nasync function addToTree (elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '')\n  const lastIndex = pathElems.length - 1\n  let parent = tree\n  let currentPath = ''\n\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i]\n\n    currentPath += `${currentPath ? '/' : ''}${pathElem}`\n\n    const last = (i === lastIndex)\n    parent.dirty = true\n    parent.cid = undefined\n    parent.size = undefined\n\n    if (last) {\n      await parent.put(pathElem, elem)\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options)\n    } else {\n      let dir = await parent.get(pathElem)\n\n      if (!dir || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          root: false,\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir && dir.unixfs && dir.unixfs.mtime,\n          mode: dir && dir.unixfs && dir.unixfs.mode\n        }, options)\n      }\n\n      await parent.put(pathElem, dir)\n\n      parent = dir\n    }\n  }\n\n  return tree\n}\n\n/**\n * @param {Dir | InProgressImportResult} tree\n * @param {Blockstore} blockstore\n */\nasync function * flushAndYield (tree, blockstore) {\n  if (!(tree instanceof Dir)) {\n    if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n      yield tree\n    }\n\n    return\n  }\n\n  yield * tree.flush(blockstore)\n}\n\n/**\n * @type {TreeBuilder}\n */\nasync function * treeBuilder (source, block, options) {\n  /** @type {Dir} */\n  let tree = new DirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options)\n\n  for await (const entry of source) {\n    if (!entry) {\n      continue\n    }\n\n    tree = await addToTree(entry, tree, options)\n\n    if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n      yield entry\n    }\n  }\n\n  if (options.wrapWithDirectory) {\n    yield * flushAndYield(tree, block)\n  } else {\n    for await (const unwrapped of tree.eachChildSeries()) {\n      if (!unwrapped) {\n        continue\n      }\n\n      yield * flushAndYield(unwrapped.child, block)\n    }\n  }\n}\n\nexport default treeBuilder\n"]},"metadata":{},"sourceType":"module"}