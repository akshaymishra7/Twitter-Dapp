{"ast":null,"code":"import get from 'dlv';\nimport mergeOpts from 'merge-options';\nimport errCode from 'err-code';\nimport { routers } from 'ipfs-core-config/libp2p-pubsub-routers';\nimport { delegatedPeerRouting } from '@libp2p/delegated-peer-routing';\nimport { delegatedContentRouting } from '@libp2p/delegated-content-routing';\nimport { create as ipfsHttpClient } from 'ipfs-http-client';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { ipfsCore as pkgversion } from '../version.js';\nimport { libp2pConfig as getEnvLibp2pOptions } from 'ipfs-core-config/libp2p';\nimport { createLibp2p as createNode } from 'libp2p';\nimport { kadDHT } from '@libp2p/kad-dht';\nimport { bootstrap } from '@libp2p/bootstrap';\nimport { ipnsValidator } from 'ipns/validator';\nimport { ipnsSelector } from 'ipns/selector';\nimport { webSockets } from '@libp2p/websockets';\nimport { mplex } from '@libp2p/mplex';\nimport { noise } from '@chainsafe/libp2p-noise';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true,\n  concatArrays: true\n});\n/**\n * @typedef {object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {object} KeychainConfig\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n *\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('libp2p').Libp2p} LibP2P\n * @typedef {import('libp2p').Libp2pOptions} Libp2pOptions\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {object} config\n * @param {Repo} config.repo\n * @param {IPFSOptions|undefined} config.options\n * @param {PeerId} config.peerId\n * @param {Multiaddr[]|undefined} config.multiaddrs\n * @param {KeychainConfig|undefined} config.keychainConfig\n * @param {Partial<IPFSConfig>|undefined} config.config\n */\n\nexport function createLibp2p(_ref) {\n  let {\n    options = {},\n    peerId,\n    multiaddrs = [],\n    repo,\n    keychainConfig = {},\n    config = {}\n  } = _ref;\n  const {\n    datastore\n  } = repo;\n  const libp2pOptions = getLibp2pOptions({\n    options,\n    config,\n    datastore,\n    keychainConfig,\n    peerId,\n    multiaddrs\n  });\n\n  if (typeof options.libp2p === 'function') {\n    return options.libp2p({\n      libp2pOptions,\n      options,\n      config,\n      datastore,\n      peerId\n    });\n  } // do not start by default\n\n\n  libp2pOptions.start = false;\n  return createNode(libp2pOptions);\n}\n/**\n * @param {object} input\n * @param {IPFSOptions} input.options\n * @param {Partial<IPFSConfig>} input.config\n * @param {Repo['datastore']} input.datastore\n * @param {KeychainConfig} input.keychainConfig\n * @param {PeerId} input.peerId\n * @param {Multiaddr[]} input.multiaddrs\n * @returns {Libp2pOptions}\n */\n\nfunction getLibp2pOptions(_ref2) {\n  let {\n    options,\n    config,\n    datastore,\n    keychainConfig,\n    peerId,\n    multiaddrs\n  } = _ref2;\n\n  const getPubsubRouter = () => {\n    const router = get(config, 'Pubsub.Router') || 'gossipsub';\n    const availableRouters = routers();\n\n    if (!availableRouters[router]) {\n      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED');\n    }\n\n    return availableRouters[router];\n  };\n  /** @type {Libp2pOptions} */\n\n\n  const libp2pDefaults = {\n    datastore,\n    peerId: peerId\n  };\n  /** @type {Libp2pOptions} */\n\n  const libp2pOptions = {\n    addresses: {\n      listen: multiaddrs.map(ma => ma.toString()),\n      announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', [])),\n      noAnnounce: get(options, 'addresses.noAnnounce', get(config, 'Addresses.NoAnnounce', []))\n    },\n    connectionManager: get(options, 'connectionManager', {\n      maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),\n      minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))\n    }),\n    keychain: keychainConfig,\n    identify: {\n      host: {\n        agentVersion: `js-ipfs/${pkgversion}`\n      }\n    },\n    contentRouters: [],\n    peerRouters: [],\n    peerDiscovery: [],\n    transports: [],\n    streamMuxers: [mplex({\n      maxInboundStreams: 256,\n      maxOutboundStreams: 1024\n    })],\n    connectionEncryption: [noise()],\n    relay: {\n      enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),\n      hop: {\n        enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),\n        active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))\n      }\n    },\n    nat: {\n      enabled: !get(config, 'Swarm.DisableNatPortMap', false)\n    }\n  };\n\n  if (get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))) {\n    libp2pOptions.pubsub = getPubsubRouter();\n  }\n\n  if (get(config, 'Routing.Type', 'dhtclient') !== 'none') {\n    libp2pOptions.dht = kadDHT({\n      clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',\n      kBucketSize: get(options, 'dht.kBucketSize', 20),\n      validators: {\n        ipns: ipnsValidator\n      },\n      selectors: {\n        ipns: ipnsSelector\n      }\n    });\n  }\n\n  const boostrapNodes = get(options, 'config.Bootstrap', get(config, 'Bootstrap', []));\n\n  if (boostrapNodes.length > 0) {\n    libp2pOptions.peerDiscovery?.push(bootstrap({\n      list: boostrapNodes\n    }));\n  }\n  /** @type {import('libp2p').Libp2pOptions | undefined} */\n\n\n  let constructorOptions = get(options, 'libp2p', undefined);\n\n  if (typeof constructorOptions === 'function') {\n    constructorOptions = undefined;\n  } // Merge defaults with Node.js/browser/other environments options and configuration\n\n  /** @type {Libp2pOptions} */\n\n\n  const libp2pFinalConfig = mergeOptions(libp2pDefaults, getEnvLibp2pOptions(), libp2pOptions, constructorOptions); // Set up Delegate Routing based on the presence of Delegates in the config\n\n  const delegateHosts = get(options, 'config.Addresses.Delegates', get(config, 'Addresses.Delegates', []));\n\n  if (delegateHosts.length > 0) {\n    // Pick a random delegate host\n    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];\n    const delegateAddr = multiaddr(delegateString).toOptions();\n    const delegateApiOptions = {\n      host: delegateAddr.host,\n      // port is a string atm, so we need to convert for the check\n      // @ts-expect-error - parseInt(input:string) => number\n      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',\n      port: delegateAddr.port\n    };\n    const delegateHttpClient = ipfsHttpClient(delegateApiOptions);\n    libp2pFinalConfig.contentRouters?.push(delegatedContentRouting(delegateHttpClient));\n    libp2pFinalConfig.peerRouters?.push(delegatedPeerRouting(delegateHttpClient));\n  } // TODO: fixme\n\n\n  if (!get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))) {\n    libp2pFinalConfig.peerDiscovery = libp2pFinalConfig.peerDiscovery?.filter(d => {\n      try {\n        if (typeof d === 'function') {\n          // @ts-expect-error not components\n          return d({})[Symbol.toStringTag] !== '@libp2p/mdns';\n        }\n      } catch {}\n\n      return true;\n    });\n  }\n\n  if (libp2pFinalConfig.transports == null) {\n    libp2pFinalConfig.transports = [];\n  } // add WebSocket transport if not overridden by user config\n\n\n  if (libp2pFinalConfig.transports.find(t => {\n    try {\n      if (typeof t === 'function') {\n        return t({})[Symbol.toStringTag] === '@libp2p/websockets';\n      }\n    } catch {}\n\n    return false;\n  }) == null) {\n    libp2pFinalConfig.transports.push(webSockets());\n  }\n\n  return libp2pFinalConfig;\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/libp2p.js"],"names":["get","mergeOpts","errCode","routers","delegatedPeerRouting","delegatedContentRouting","create","ipfsHttpClient","multiaddr","ipfsCore","pkgversion","libp2pConfig","getEnvLibp2pOptions","createLibp2p","createNode","kadDHT","bootstrap","ipnsValidator","ipnsSelector","webSockets","mplex","noise","mergeOptions","bind","ignoreUndefined","concatArrays","options","peerId","multiaddrs","repo","keychainConfig","config","datastore","libp2pOptions","getLibp2pOptions","libp2p","start","getPubsubRouter","router","availableRouters","Error","libp2pDefaults","addresses","listen","map","ma","toString","announce","noAnnounce","connectionManager","maxConnections","minConnections","keychain","identify","host","agentVersion","contentRouters","peerRouters","peerDiscovery","transports","streamMuxers","maxInboundStreams","maxOutboundStreams","connectionEncryption","relay","enabled","hop","active","nat","pubsub","dht","clientMode","kBucketSize","validators","ipns","selectors","boostrapNodes","length","push","list","constructorOptions","undefined","libp2pFinalConfig","delegateHosts","delegateString","Math","floor","random","delegateAddr","toOptions","delegateApiOptions","protocol","parseInt","port","delegateHttpClient","filter","d","Symbol","toStringTag","find","t"],"mappings":"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","sourcesContent":["import get from 'dlv'\nimport mergeOpts from 'merge-options'\nimport errCode from 'err-code'\nimport { routers } from 'ipfs-core-config/libp2p-pubsub-routers'\nimport { delegatedPeerRouting } from '@libp2p/delegated-peer-routing'\nimport { delegatedContentRouting } from '@libp2p/delegated-content-routing'\nimport { create as ipfsHttpClient } from 'ipfs-http-client'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { ipfsCore as pkgversion } from '../version.js'\nimport { libp2pConfig as getEnvLibp2pOptions } from 'ipfs-core-config/libp2p'\nimport { createLibp2p as createNode } from 'libp2p'\nimport { kadDHT } from '@libp2p/kad-dht'\nimport { bootstrap } from '@libp2p/bootstrap'\nimport { ipnsValidator } from 'ipns/validator'\nimport { ipnsSelector } from 'ipns/selector'\nimport { webSockets } from '@libp2p/websockets'\nimport { mplex } from '@libp2p/mplex'\nimport { noise } from '@chainsafe/libp2p-noise'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true, concatArrays: true })\n\n/**\n * @typedef {object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {object} KeychainConfig\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n *\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('libp2p').Libp2p} LibP2P\n * @typedef {import('libp2p').Libp2pOptions} Libp2pOptions\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {object} config\n * @param {Repo} config.repo\n * @param {IPFSOptions|undefined} config.options\n * @param {PeerId} config.peerId\n * @param {Multiaddr[]|undefined} config.multiaddrs\n * @param {KeychainConfig|undefined} config.keychainConfig\n * @param {Partial<IPFSConfig>|undefined} config.config\n */\nexport function createLibp2p ({\n  options = {},\n  peerId,\n  multiaddrs = [],\n  repo,\n  keychainConfig = {},\n  config = {}\n}) {\n  const { datastore } = repo\n\n  const libp2pOptions = getLibp2pOptions({\n    options,\n    config,\n    datastore,\n    keychainConfig,\n    peerId,\n    multiaddrs\n  })\n\n  if (typeof options.libp2p === 'function') {\n    return options.libp2p({ libp2pOptions, options, config, datastore, peerId })\n  }\n\n  // do not start by default\n  libp2pOptions.start = false\n\n  return createNode(libp2pOptions)\n}\n\n/**\n * @param {object} input\n * @param {IPFSOptions} input.options\n * @param {Partial<IPFSConfig>} input.config\n * @param {Repo['datastore']} input.datastore\n * @param {KeychainConfig} input.keychainConfig\n * @param {PeerId} input.peerId\n * @param {Multiaddr[]} input.multiaddrs\n * @returns {Libp2pOptions}\n */\nfunction getLibp2pOptions ({ options, config, datastore, keychainConfig, peerId, multiaddrs }) {\n  const getPubsubRouter = () => {\n    const router = get(config, 'Pubsub.Router') || 'gossipsub'\n\n    const availableRouters = routers()\n\n    if (!availableRouters[router]) {\n      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED')\n    }\n\n    return availableRouters[router]\n  }\n\n  /** @type {Libp2pOptions} */\n  const libp2pDefaults = {\n    datastore,\n    peerId: peerId\n  }\n\n  /** @type {Libp2pOptions} */\n  const libp2pOptions = {\n    addresses: {\n      listen: multiaddrs.map(ma => ma.toString()),\n      announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', [])),\n      noAnnounce: get(options, 'addresses.noAnnounce', get(config, 'Addresses.NoAnnounce', []))\n    },\n    connectionManager: get(options, 'connectionManager', {\n      maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),\n      minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))\n    }),\n    keychain: keychainConfig,\n    identify: {\n      host: {\n        agentVersion: `js-ipfs/${pkgversion}`\n      }\n    },\n    contentRouters: [],\n    peerRouters: [],\n    peerDiscovery: [],\n    transports: [],\n    streamMuxers: [\n      mplex({\n        maxInboundStreams: 256,\n        maxOutboundStreams: 1024\n      })\n    ],\n    connectionEncryption: [\n      noise()\n    ],\n    relay: {\n      enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),\n      hop: {\n        enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),\n        active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))\n      }\n    },\n    nat: {\n      enabled: !get(config, 'Swarm.DisableNatPortMap', false)\n    }\n  }\n\n  if (get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))) {\n    libp2pOptions.pubsub = getPubsubRouter()\n  }\n\n  if (get(config, 'Routing.Type', 'dhtclient') !== 'none') {\n    libp2pOptions.dht = kadDHT({\n      clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',\n      kBucketSize: get(options, 'dht.kBucketSize', 20),\n      validators: {\n        ipns: ipnsValidator\n      },\n      selectors: {\n        ipns: ipnsSelector\n      }\n    })\n  }\n\n  const boostrapNodes = get(options, 'config.Bootstrap', get(config, 'Bootstrap', []))\n\n  if (boostrapNodes.length > 0) {\n    libp2pOptions.peerDiscovery?.push(\n      bootstrap({\n        list: boostrapNodes\n      })\n    )\n  }\n\n  /** @type {import('libp2p').Libp2pOptions | undefined} */\n  let constructorOptions = get(options, 'libp2p', undefined)\n\n  if (typeof constructorOptions === 'function') {\n    constructorOptions = undefined\n  }\n\n  // Merge defaults with Node.js/browser/other environments options and configuration\n  /** @type {Libp2pOptions} */\n  const libp2pFinalConfig = mergeOptions(\n    libp2pDefaults,\n    getEnvLibp2pOptions(),\n    libp2pOptions,\n    constructorOptions\n  )\n\n  // Set up Delegate Routing based on the presence of Delegates in the config\n  const delegateHosts = get(options, 'config.Addresses.Delegates',\n    get(config, 'Addresses.Delegates', [])\n  )\n\n  if (delegateHosts.length > 0) {\n    // Pick a random delegate host\n    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)]\n    const delegateAddr = multiaddr(delegateString).toOptions()\n    const delegateApiOptions = {\n      host: delegateAddr.host,\n      // port is a string atm, so we need to convert for the check\n      // @ts-expect-error - parseInt(input:string) => number\n      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',\n      port: delegateAddr.port\n    }\n\n    const delegateHttpClient = ipfsHttpClient(delegateApiOptions)\n\n    libp2pFinalConfig.contentRouters?.push(delegatedContentRouting(delegateHttpClient))\n    libp2pFinalConfig.peerRouters?.push(delegatedPeerRouting(delegateHttpClient))\n  }\n\n  // TODO: fixme\n  if (!get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))) {\n    libp2pFinalConfig.peerDiscovery = libp2pFinalConfig.peerDiscovery?.filter(d => {\n      try {\n        if (typeof d === 'function') {\n          // @ts-expect-error not components\n          return d({})[Symbol.toStringTag] !== '@libp2p/mdns'\n        }\n      } catch {}\n      return true\n    })\n  }\n\n  if (libp2pFinalConfig.transports == null) {\n    libp2pFinalConfig.transports = []\n  }\n\n  // add WebSocket transport if not overridden by user config\n  if (libp2pFinalConfig.transports.find(t => {\n    try {\n      if (typeof t === 'function') {\n        return t({})[Symbol.toStringTag] === '@libp2p/websockets'\n      }\n    } catch {}\n    return false\n  }) == null) {\n    libp2pFinalConfig.transports.push(webSockets())\n  }\n\n  return libp2pFinalConfig\n}\n"]},"metadata":{},"sourceType":"module"}