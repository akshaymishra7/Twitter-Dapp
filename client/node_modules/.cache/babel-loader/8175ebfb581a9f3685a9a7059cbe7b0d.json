{"ast":null,"code":"import { CID } from 'multiformats/cid';\nimport { createEncoder, createHeader } from './encoder.js';\nimport { create as iteratorChannel } from './iterator-channel.js';\nimport { bytesReader, readHeader } from './decoder.js';\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockWriter} BlockWriter\n * @typedef {import('./api').WriterChannel} WriterChannel\n * @typedef {import('./coding').CarEncoder} CarEncoder\n * @typedef {import('./coding').IteratorChannel<Uint8Array>} IteratorChannel\n */\n\n/**\n * Provides a writer interface for the creation of CAR files.\n *\n * Creation of a `CarWriter` involves the instatiation of an input / output pair\n * in the form of a `WriterChannel`, which is a\n * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair. These two\n * components form what can be thought of as a stream-like interface. The\n * `writer` component (an instantiated `CarWriter`), has methods to\n * {@link CarWriter.put `put()`} new blocks and {@link CarWriter.put `close()`}\n * the writing operation (finalising the CAR archive). The `out` component is\n * an `AsyncIterable` that yields the bytes of the archive. This can be\n * redirected to a file or other sink. In Node.js, you can use the\n * [`Readable.from()`](https://nodejs.org/api/stream.html#stream_stream_readable_from_iterable_options)\n * API to convert this to a standard Node.js stream, or it can be directly fed\n * to a\n * [`stream.pipeline()`](https://nodejs.org/api/stream.html#stream_stream_pipeline_source_transforms_destination_callback).\n *\n * The channel will provide a form of backpressure. The `Promise` from a\n * `write()` won't resolve until the resulting data is drained from the `out`\n * iterable.\n *\n * It is also possible to ignore the `Promise` from `write()` calls and allow\n * the generated data to queue in memory. This should be avoided for large CAR\n * archives of course due to the memory costs and potential for memory overflow.\n *\n * Load this class with either\n * `import { CarWriter } from '@ipld/car/writer'`\n * (`const { CarWriter } = require('@ipld/car/writer')`). Or\n * `import { CarWriter } from '@ipld/car'`\n * (`const { CarWriter } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarWriter\n * @class\n * @implements {BlockWriter}\n */\n\nexport class CarWriter {\n  /**\n   * @param {CID[]} roots\n   * @param {CarEncoder} encoder\n   */\n  constructor(roots, encoder) {\n    this._encoder = encoder;\n    /** @type {Promise<void>} */\n\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {Promise<void>} The returned promise will only resolve once the\n   * bytes this block generates are written to the `out` iterable.\n   */\n\n\n  async put(block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n\n    const cid = CID.asCID(block.cid);\n\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({\n      cid,\n      bytes: block.bytes\n    }));\n    return this._mutex;\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n  /**\n   * Finalise the CAR archive and signal that the `out` iterable should end once\n   * any remaining bytes are written.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @returns {Promise<void>}\n   */\n\n\n  async close() {\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n\n    await this._mutex;\n    this._ended = true;\n    return this._encoder.close();\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n  /**\n   * Create a new CAR writer \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {CID[] | CID | void} roots\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n\n\n  static create(roots) {\n    roots = toRoots(roots);\n    const {\n      encoder,\n      iterator\n    } = encodeWriter();\n    const writer = new CarWriter(roots, encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  /**\n   * Create a new CAR appender \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   * This appender does not consider roots and does not produce a CAR header.\n   * It is designed to append blocks to an _existing_ CAR archive. It is\n   * expected that `out` will be concatenated onto the end of an existing\n   * archive that already has a properly formatted header.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n\n\n  static createAppender() {\n    const {\n      encoder,\n      iterator\n    } = encodeWriter();\n\n    encoder.setRoots = () => Promise.resolve();\n\n    const writer = new CarWriter([], encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  /**\n   * Update the list of roots in the header of an existing CAR as represented\n   * in a Uint8Array.\n   *\n   * This operation is an _overwrite_, the total length of the CAR will not be\n   * modified. A rejection will occur if the new header will not be the same\n   * length as the existing header, in which case the CAR will not be modified.\n   * It is the responsibility of the user to ensure that the roots being\n   * replaced encode as the same length as the new roots.\n   *\n   * The byte array passed in an argument will be modified and also returned\n   * upon successful modification.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {Uint8Array} bytes\n   * @param {CID[]} roots - A new list of roots to replace the existing list in\n   * the CAR header. The new header must take up the same number of bytes as the\n   * existing header, so the roots should collectively be the same byte length\n   * as the existing roots.\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  static async updateRootsInBytes(bytes, roots) {\n    const reader = bytesReader(bytes);\n    await readHeader(reader);\n    const newHeader = createHeader(roots);\n\n    if (Number(reader.pos) !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);\n    }\n\n    bytes.set(newHeader, 0);\n    return bytes;\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n}\n/**\n * @class\n * @implements {AsyncIterable<Uint8Array>}\n */\n\nexport class CarWriterOut {\n  /**\n   * @param {AsyncIterator<Uint8Array>} iterator\n   */\n  constructor(iterator) {\n    this._iterator = iterator;\n  }\n\n  [Symbol.asyncIterator]() {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported');\n    }\n\n    this._iterating = true;\n    return this._iterator;\n  }\n\n}\n\nfunction encodeWriter() {\n  /** @type {IteratorChannel} */\n  const iw = iteratorChannel();\n  const {\n    writer,\n    iterator\n  } = iw;\n  const encoder = createEncoder(writer);\n  return {\n    encoder,\n    iterator\n  };\n}\n/**\n * @private\n * @param {CID[] | CID | void} roots\n * @returns {CID[]}\n */\n\n\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots);\n\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n\n    return [cid];\n  }\n\n  const _roots = [];\n\n  for (const root of roots) {\n    const _root = CID.asCID(root);\n\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n\n    _roots.push(_root);\n  }\n\n  return _roots;\n}\n\nexport const __browser = true;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/@ipld/car/src/writer-browser.js"],"names":["CID","createEncoder","createHeader","create","iteratorChannel","bytesReader","readHeader","CarWriter","constructor","roots","encoder","_encoder","_mutex","setRoots","_ended","put","block","bytes","Uint8Array","cid","TypeError","Error","asCID","then","writeBlock","close","toRoots","iterator","encodeWriter","writer","out","CarWriterOut","createAppender","Promise","resolve","updateRootsInBytes","reader","newHeader","Number","pos","length","set","_iterator","Symbol","asyncIterator","_iterating","iw","undefined","Array","isArray","_roots","root","_root","push","__browser"],"mappings":"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","sourcesContent":["import { CID } from 'multiformats/cid'\nimport { createEncoder, createHeader } from './encoder.js'\nimport { create as iteratorChannel } from './iterator-channel.js'\nimport { bytesReader, readHeader } from './decoder.js'\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockWriter} BlockWriter\n * @typedef {import('./api').WriterChannel} WriterChannel\n * @typedef {import('./coding').CarEncoder} CarEncoder\n * @typedef {import('./coding').IteratorChannel<Uint8Array>} IteratorChannel\n */\n\n/**\n * Provides a writer interface for the creation of CAR files.\n *\n * Creation of a `CarWriter` involves the instatiation of an input / output pair\n * in the form of a `WriterChannel`, which is a\n * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair. These two\n * components form what can be thought of as a stream-like interface. The\n * `writer` component (an instantiated `CarWriter`), has methods to\n * {@link CarWriter.put `put()`} new blocks and {@link CarWriter.put `close()`}\n * the writing operation (finalising the CAR archive). The `out` component is\n * an `AsyncIterable` that yields the bytes of the archive. This can be\n * redirected to a file or other sink. In Node.js, you can use the\n * [`Readable.from()`](https://nodejs.org/api/stream.html#stream_stream_readable_from_iterable_options)\n * API to convert this to a standard Node.js stream, or it can be directly fed\n * to a\n * [`stream.pipeline()`](https://nodejs.org/api/stream.html#stream_stream_pipeline_source_transforms_destination_callback).\n *\n * The channel will provide a form of backpressure. The `Promise` from a\n * `write()` won't resolve until the resulting data is drained from the `out`\n * iterable.\n *\n * It is also possible to ignore the `Promise` from `write()` calls and allow\n * the generated data to queue in memory. This should be avoided for large CAR\n * archives of course due to the memory costs and potential for memory overflow.\n *\n * Load this class with either\n * `import { CarWriter } from '@ipld/car/writer'`\n * (`const { CarWriter } = require('@ipld/car/writer')`). Or\n * `import { CarWriter } from '@ipld/car'`\n * (`const { CarWriter } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarWriter\n * @class\n * @implements {BlockWriter}\n */\nexport class CarWriter {\n  /**\n   * @param {CID[]} roots\n   * @param {CarEncoder} encoder\n   */\n  constructor (roots, encoder) {\n    this._encoder = encoder\n    /** @type {Promise<void>} */\n    this._mutex = encoder.setRoots(roots)\n    this._ended = false\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {Promise<void>} The returned promise will only resolve once the\n   * bytes this block generates are written to the `out` iterable.\n   */\n  async put (block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    const cid = CID.asCID(block.cid)\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid, bytes: block.bytes }))\n    return this._mutex\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  /**\n   * Finalise the CAR archive and signal that the `out` iterable should end once\n   * any remaining bytes are written.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    await this._mutex\n    this._ended = true\n    return this._encoder.close()\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  /**\n   * Create a new CAR writer \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {CID[] | CID | void} roots\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static create (roots) {\n    roots = toRoots(roots)\n    const { encoder, iterator } = encodeWriter()\n    const writer = new CarWriter(roots, encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Create a new CAR appender \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   * This appender does not consider roots and does not produce a CAR header.\n   * It is designed to append blocks to an _existing_ CAR archive. It is\n   * expected that `out` will be concatenated onto the end of an existing\n   * archive that already has a properly formatted header.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static createAppender () {\n    const { encoder, iterator } = encodeWriter()\n    encoder.setRoots = () => Promise.resolve()\n    const writer = new CarWriter([], encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Update the list of roots in the header of an existing CAR as represented\n   * in a Uint8Array.\n   *\n   * This operation is an _overwrite_, the total length of the CAR will not be\n   * modified. A rejection will occur if the new header will not be the same\n   * length as the existing header, in which case the CAR will not be modified.\n   * It is the responsibility of the user to ensure that the roots being\n   * replaced encode as the same length as the new roots.\n   *\n   * The byte array passed in an argument will be modified and also returned\n   * upon successful modification.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {Uint8Array} bytes\n   * @param {CID[]} roots - A new list of roots to replace the existing list in\n   * the CAR header. The new header must take up the same number of bytes as the\n   * existing header, so the roots should collectively be the same byte length\n   * as the existing roots.\n   * @returns {Promise<Uint8Array>}\n   */\n  static async updateRootsInBytes (bytes, roots) {\n    const reader = bytesReader(bytes)\n    await readHeader(reader)\n    const newHeader = createHeader(roots)\n    if (Number(reader.pos) !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`)\n    }\n    bytes.set(newHeader, 0)\n    return bytes\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n}\n\n/**\n * @class\n * @implements {AsyncIterable<Uint8Array>}\n */\nexport class CarWriterOut {\n  /**\n   * @param {AsyncIterator<Uint8Array>} iterator\n   */\n  constructor (iterator) {\n    this._iterator = iterator\n  }\n\n  [Symbol.asyncIterator] () {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported')\n    }\n    this._iterating = true\n    return this._iterator\n  }\n}\n\nfunction encodeWriter () {\n  /** @type {IteratorChannel} */\n  const iw = iteratorChannel()\n  const { writer, iterator } = iw\n  const encoder = createEncoder(writer)\n  return { encoder, iterator }\n}\n\n/**\n * @private\n * @param {CID[] | CID | void} roots\n * @returns {CID[]}\n */\nfunction toRoots (roots) {\n  if (roots === undefined) {\n    return []\n  }\n\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots)\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    return [cid]\n  }\n\n  const _roots = []\n  for (const root of roots) {\n    const _root = CID.asCID(root)\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    _roots.push(_root)\n  }\n  return _roots\n}\n\nexport const __browser = true\n"]},"metadata":{},"sourceType":"module"}