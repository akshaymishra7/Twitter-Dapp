{"ast":null,"code":"import { WantManager } from './want-manager/index.js';\nimport { Network } from './network.js';\nimport { DecisionEngine } from './decision-engine/index.js';\nimport { Notifications } from './notifications.js';\nimport { logger } from './utils/index.js';\nimport { Stats } from './stats/index.js';\nimport { anySignal } from 'any-signal';\nimport { BaseBlockstore } from 'blockstore-core/base';\nimport { CID } from 'multiformats/cid';\n/**\n * @typedef {import('./types').IPFSBitswap} IPFSBitswap\n * @typedef {import('./types').MultihashHasherLoader} MultihashHasherLoader\n * @typedef {import('./message').BitswapMessage} BitswapMessage\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n */\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nconst statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @implements {IPFSBitswap}\n */\n\nexport class Bitswap extends BaseBlockstore {\n  /**\n   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p\n   * @param {Blockstore} blockstore\n   * @param {object} [options]\n   * @param {boolean} [options.statsEnabled=false]\n   * @param {number} [options.statsComputeThrottleTimeout=1000]\n   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]\n   * @param {number} [options.maxInboundStreams=32]\n   * @param {number} [options.maxOutboundStreams=32]\n   * @param {number} [options.incomingStreamTimeout=30000]\n   * @param {MultihashHasherLoader} [options.hashLoader]\n   */\n  constructor(libp2p, blockstore) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this._libp2p = libp2p;\n    this._log = logger(this.peerId);\n    this._options = Object.assign({}, defaultOptions, options); // stats\n\n    this._stats = new Stats(libp2p, statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    }); // the network delivers messages\n\n    this.network = new Network(libp2p, this, this._stats, {\n      hashLoader: options.hashLoader,\n      maxInboundStreams: options.maxInboundStreams,\n      maxOutboundStreams: options.maxOutboundStreams,\n      incomingStreamTimeout: options.incomingStreamTimeout\n    }); // local database\n\n    this.blockstore = blockstore;\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats, libp2p); // handle message sending\n\n    this.wm = new WantManager(this.peerId, this.network, this._stats, libp2p);\n    this.notifications = new Notifications(this.peerId);\n    this.started = false;\n  }\n\n  isStarted() {\n    return this.started;\n  }\n  /**\n   * @type {PeerId}\n   */\n\n\n  get peerId() {\n    return this._libp2p.peerId;\n  }\n  /**\n   * handle messages received through the network\n   *\n   * @param {PeerId} peerId\n   * @param {BitswapMessage} incoming\n   */\n\n\n  async _receiveMessage(peerId, incoming) {\n    try {\n      // Note: this allows the engine to respond to any wants in the message.\n      // Processing of the blocks in the message happens below, after the\n      // blocks have been added to the blockstore.\n      await this.engine.messageReceived(peerId, incoming);\n    } catch (err) {\n      // Log instead of throwing an error so as to process as much as\n      // possible of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming);\n    }\n\n    if (incoming.blocks.size === 0) {\n      return;\n    }\n    /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n\n\n    const received = [];\n\n    for (const [cidStr, data] of incoming.blocks.entries()) {\n      const cid = CID.parse(cidStr);\n      received.push({\n        wasWanted: this.wm.wantlist.contains(cid),\n        cid,\n        data\n      });\n    } // quickly send out cancels, reduces chances of duplicate block receives\n\n\n    this.wm.cancelWants(received.filter(_ref => {\n      let {\n        wasWanted\n      } = _ref;\n      return wasWanted;\n    }).map(_ref2 => {\n      let {\n        cid\n      } = _ref2;\n      return cid;\n    }));\n    await Promise.all(received.map(_ref3 => {\n      let {\n        cid,\n        wasWanted,\n        data\n      } = _ref3;\n      return this._handleReceivedBlock(peerId, cid, data, wasWanted);\n    }));\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} wasWanted\n   */\n\n\n  async _handleReceivedBlock(peerId, cid, data, wasWanted) {\n    this._log('received block');\n\n    const has = await this.blockstore.has(cid);\n\n    this._updateReceiveCounters(peerId.toString(), cid, data, has);\n\n    if (!wasWanted) {\n      return;\n    }\n\n    await this.put(cid, data);\n  }\n  /**\n   * @private\n   * @param {string} peerIdStr\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} exists\n   */\n\n\n  _updateReceiveCounters(peerIdStr, cid, data, exists) {\n    this._stats.push(peerIdStr, 'blocksReceived', 1);\n\n    this._stats.push(peerIdStr, 'dataReceived', data.length);\n\n    if (exists) {\n      this._stats.push(peerIdStr, 'dupBlksReceived', 1);\n\n      this._stats.push(peerIdStr, 'dupDataReceived', data.length);\n    }\n  }\n  /**\n   * handle errors on the receiving channel\n   *\n   * @param {Error} err\n   */\n\n\n  _receiveError(err) {\n    this._log.error('ReceiveError: %s', err.message);\n  }\n  /**\n   * handle new peers\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerConnected(peerId) {\n    this.wm.connected(peerId);\n  }\n  /**\n   * handle peers being disconnected\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerDisconnected(peerId) {\n    this.wm.disconnected(peerId);\n    this.engine.peerDisconnected(peerId);\n\n    this._stats.disconnected(peerId);\n  }\n\n  enableStats() {\n    this._stats.enable();\n  }\n\n  disableStats() {\n    this._stats.disable();\n  }\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @param {any} [_options]\n   */\n\n\n  wantlistForPeer(peerId, _options) {\n    return this.engine.wantlistForPeer(peerId);\n  }\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  ledgerForPeer(peerId) {\n    return this.engine.ledgerForPeer(peerId);\n  }\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async get(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * @param {CID} cid\n     * @param {object} options\n     * @param {AbortSignal} options.signal\n     */\n    const fetchFromNetwork = (cid, options) => {\n      // add it to the want list - n.b. later we will abort the AbortSignal\n      // so no need to remove the blocks from the wantlist after we have it\n      this.wm.wantBlocks([cid], options);\n      return this.notifications.wantBlock(cid, options);\n    };\n\n    let promptedNetwork = false;\n    /**\n     *\n     * @param {CID} cid\n     * @param {object} options\n     * @param {AbortSignal} options.signal\n     */\n\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        // have to await here as we want to handle ERR_NOT_FOUND\n        const block = await this.blockstore.get(cid, options);\n        return block;\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n\n        if (!promptedNetwork) {\n          promptedNetwork = true;\n          this.network.findAndConnect(cid, options).catch(err => this._log.error(err));\n        } // we don't have the block locally so fetch it from the network\n\n\n        return fetchFromNetwork(cid, options);\n      }\n    }; // depending on implementation it's possible for blocks to come in while\n    // we do the async operations to get them from the blockstore leading to\n    // a race condition, so register for incoming block notifications as well\n    // as trying to get it from the datastore\n\n\n    const controller = new AbortController();\n    const signal = options.signal ? anySignal([options.signal, controller.signal]) : controller.signal;\n\n    try {\n      const block = await Promise.race([this.notifications.wantBlock(cid, {\n        signal\n      }), loadOrFetchFromNetwork(cid, {\n        signal\n      })]);\n      return block;\n    } finally {\n      // since we have the block we can now remove our listener\n      controller.abort();\n    }\n  }\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterable<CID>|Iterable<CID>} cids\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async *getMany(cids) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for await (const cid of cids) {\n      yield this.get(cid, options);\n    }\n  }\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {CID[]|CID} cids\n   */\n\n\n  unwant(cids) {\n    const cidsArray = Array.isArray(cids) ? cids : [cids];\n    this.wm.unwantBlocks(cidsArray);\n    cidsArray.forEach(cid => this.notifications.unwantBlock(cid));\n  }\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {CID[]|CID} cids\n   */\n\n\n  cancelWants(cids) {\n    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);\n  }\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {any} [_options]\n   */\n\n\n  async put(cid, block, _options) {\n    await this.blockstore.put(cid, block);\n\n    this._sendHaveBlockNotifications(cid, block);\n  }\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {Iterable<Pair> | AsyncIterable<Pair>} source\n   * @param {Options} [options]\n   */\n\n\n  async *putMany(source, options) {\n    for await (const {\n      key,\n      value\n    } of this.blockstore.putMany(source, options)) {\n      this._sendHaveBlockNotifications(key, value);\n\n      yield {\n        key,\n        value\n      };\n    }\n  }\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @private\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   */\n\n\n  _sendHaveBlockNotifications(cid, data) {\n    this.notifications.hasBlock(cid, data);\n    this.engine.receivedBlocks([{\n      cid,\n      data\n    }]); // Note: Don't wait for provide to finish before returning\n\n    this.network.provide(cid).catch(err => {\n      this._log.error('Failed to provide: %s', err.message);\n    });\n  }\n  /**\n   * Get the current list of wants\n   */\n\n\n  getWantlist() {\n    return this.wm.wantlist.entries();\n  }\n  /**\n   * Get the current list of partners\n   */\n\n\n  peers() {\n    return this.engine.peers();\n  }\n  /**\n   * Get stats about the bitswap node\n   */\n\n\n  stat() {\n    return this._stats;\n  }\n  /**\n   * Start the bitswap node\n   */\n\n\n  async start() {\n    this.wm.start();\n    await this.network.start();\n    this.engine.start();\n    this.started = true;\n  }\n  /**\n   * Stop the bitswap node\n   */\n\n\n  async stop() {\n    this._stats.stop();\n\n    this.wm.stop();\n    await this.network.stop();\n    this.engine.stop();\n    this.started = false;\n  }\n\n  unwrap() {\n    return this.blockstore;\n  }\n  /**\n   * @param {CID} cid\n   * @returns {Promise<boolean>}\n   */\n\n\n  has(cid) {\n    return this.blockstore.has(cid);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-bitswap/src/bitswap.js"],"names":["WantManager","Network","DecisionEngine","Notifications","logger","Stats","anySignal","BaseBlockstore","CID","defaultOptions","statsEnabled","statsComputeThrottleTimeout","statsComputeThrottleMaxQueueSize","statsKeys","Bitswap","constructor","libp2p","blockstore","options","_libp2p","_log","peerId","_options","Object","assign","_stats","enabled","computeThrottleTimeout","computeThrottleMaxQueueSize","network","hashLoader","maxInboundStreams","maxOutboundStreams","incomingStreamTimeout","engine","wm","notifications","started","isStarted","_receiveMessage","incoming","messageReceived","err","blocks","size","received","cidStr","data","entries","cid","parse","push","wasWanted","wantlist","contains","cancelWants","filter","map","Promise","all","_handleReceivedBlock","has","_updateReceiveCounters","toString","put","peerIdStr","exists","length","_receiveError","error","message","_onPeerConnected","connected","_onPeerDisconnected","disconnected","peerDisconnected","enableStats","enable","disableStats","disable","wantlistForPeer","ledgerForPeer","get","fetchFromNetwork","wantBlocks","wantBlock","promptedNetwork","loadOrFetchFromNetwork","block","code","findAndConnect","catch","controller","AbortController","signal","race","abort","getMany","cids","unwant","cidsArray","Array","isArray","unwantBlocks","forEach","unwantBlock","_sendHaveBlockNotifications","putMany","source","key","value","hasBlock","receivedBlocks","provide","getWantlist","peers","stat","start","stop","unwrap"],"mappings":"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","sourcesContent":["import { WantManager } from './want-manager/index.js'\nimport { Network } from './network.js'\nimport { DecisionEngine } from './decision-engine/index.js'\nimport { Notifications } from './notifications.js'\nimport { logger } from './utils/index.js'\nimport { Stats } from './stats/index.js'\nimport { anySignal } from 'any-signal'\nimport { BaseBlockstore } from 'blockstore-core/base'\nimport { CID } from 'multiformats/cid'\n\n/**\n * @typedef {import('./types').IPFSBitswap} IPFSBitswap\n * @typedef {import('./types').MultihashHasherLoader} MultihashHasherLoader\n * @typedef {import('./message').BitswapMessage} BitswapMessage\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n */\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n}\nconst statsKeys = [\n  'blocksReceived',\n  'dataReceived',\n  'dupBlksReceived',\n  'dupDataReceived',\n  'blocksSent',\n  'dataSent',\n  'providesBufferLength',\n  'wantListLength',\n  'peerCount'\n]\n\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @implements {IPFSBitswap}\n */\nexport class Bitswap extends BaseBlockstore {\n  /**\n   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p\n   * @param {Blockstore} blockstore\n   * @param {object} [options]\n   * @param {boolean} [options.statsEnabled=false]\n   * @param {number} [options.statsComputeThrottleTimeout=1000]\n   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]\n   * @param {number} [options.maxInboundStreams=32]\n   * @param {number} [options.maxOutboundStreams=32]\n   * @param {number} [options.incomingStreamTimeout=30000]\n   * @param {MultihashHasherLoader} [options.hashLoader]\n   */\n  constructor (libp2p, blockstore, options = {}) {\n    super()\n\n    this._libp2p = libp2p\n    this._log = logger(this.peerId)\n\n    this._options = Object.assign({}, defaultOptions, options)\n\n    // stats\n    this._stats = new Stats(libp2p, statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    })\n\n    // the network delivers messages\n    this.network = new Network(libp2p, this, this._stats, {\n      hashLoader: options.hashLoader,\n      maxInboundStreams: options.maxInboundStreams,\n      maxOutboundStreams: options.maxOutboundStreams,\n      incomingStreamTimeout: options.incomingStreamTimeout\n    })\n\n    // local database\n    this.blockstore = blockstore\n\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats, libp2p)\n\n    // handle message sending\n    this.wm = new WantManager(this.peerId, this.network, this._stats, libp2p)\n\n    this.notifications = new Notifications(this.peerId)\n\n    this.started = false\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * @type {PeerId}\n   */\n  get peerId () {\n    return this._libp2p.peerId\n  }\n\n  /**\n   * handle messages received through the network\n   *\n   * @param {PeerId} peerId\n   * @param {BitswapMessage} incoming\n   */\n  async _receiveMessage (peerId, incoming) {\n    try {\n      // Note: this allows the engine to respond to any wants in the message.\n      // Processing of the blocks in the message happens below, after the\n      // blocks have been added to the blockstore.\n      await this.engine.messageReceived(peerId, incoming)\n    } catch (err) {\n      // Log instead of throwing an error so as to process as much as\n      // possible of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming)\n    }\n\n    if (incoming.blocks.size === 0) {\n      return\n    }\n\n    /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n    const received = []\n\n    for (const [cidStr, data] of incoming.blocks.entries()) {\n      const cid = CID.parse(cidStr)\n\n      received.push({\n        wasWanted: this.wm.wantlist.contains(cid),\n        cid,\n        data\n      })\n    }\n\n    // quickly send out cancels, reduces chances of duplicate block receives\n    this.wm.cancelWants(\n      received\n        .filter(({ wasWanted }) => wasWanted)\n        .map(({ cid }) => cid)\n    )\n\n    await Promise.all(\n      received.map(\n        ({ cid, wasWanted, data }) => this._handleReceivedBlock(peerId, cid, data, wasWanted)\n      )\n    )\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} wasWanted\n   */\n  async _handleReceivedBlock (peerId, cid, data, wasWanted) {\n    this._log('received block')\n\n    const has = await this.blockstore.has(cid)\n\n    this._updateReceiveCounters(peerId.toString(), cid, data, has)\n\n    if (!wasWanted) {\n      return\n    }\n\n    await this.put(cid, data)\n  }\n\n  /**\n   * @private\n   * @param {string} peerIdStr\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} exists\n   */\n  _updateReceiveCounters (peerIdStr, cid, data, exists) {\n    this._stats.push(peerIdStr, 'blocksReceived', 1)\n    this._stats.push(peerIdStr, 'dataReceived', data.length)\n\n    if (exists) {\n      this._stats.push(peerIdStr, 'dupBlksReceived', 1)\n      this._stats.push(peerIdStr, 'dupDataReceived', data.length)\n    }\n  }\n\n  /**\n   * handle errors on the receiving channel\n   *\n   * @param {Error} err\n   */\n  _receiveError (err) {\n    this._log.error('ReceiveError: %s', err.message)\n  }\n\n  /**\n   * handle new peers\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerConnected (peerId) {\n    this.wm.connected(peerId)\n  }\n\n  /**\n   * handle peers being disconnected\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnected (peerId) {\n    this.wm.disconnected(peerId)\n    this.engine.peerDisconnected(peerId)\n    this._stats.disconnected(peerId)\n  }\n\n  enableStats () {\n    this._stats.enable()\n  }\n\n  disableStats () {\n    this._stats.disable()\n  }\n\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @param {any} [_options]\n   */\n  wantlistForPeer (peerId, _options) {\n    return this.engine.wantlistForPeer(peerId)\n  }\n\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   */\n  ledgerForPeer (peerId) {\n    return this.engine.ledgerForPeer(peerId)\n  }\n\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async get (cid, options = {}) {\n    /**\n     * @param {CID} cid\n     * @param {object} options\n     * @param {AbortSignal} options.signal\n     */\n    const fetchFromNetwork = (cid, options) => {\n      // add it to the want list - n.b. later we will abort the AbortSignal\n      // so no need to remove the blocks from the wantlist after we have it\n      this.wm.wantBlocks([cid], options)\n\n      return this.notifications.wantBlock(cid, options)\n    }\n\n    let promptedNetwork = false\n\n    /**\n     *\n     * @param {CID} cid\n     * @param {object} options\n     * @param {AbortSignal} options.signal\n     */\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        // have to await here as we want to handle ERR_NOT_FOUND\n        const block = await this.blockstore.get(cid, options)\n\n        return block\n      } catch (/** @type {any} */ err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n\n        if (!promptedNetwork) {\n          promptedNetwork = true\n\n          this.network.findAndConnect(cid, options)\n            .catch((err) => this._log.error(err))\n        }\n\n        // we don't have the block locally so fetch it from the network\n        return fetchFromNetwork(cid, options)\n      }\n    }\n\n    // depending on implementation it's possible for blocks to come in while\n    // we do the async operations to get them from the blockstore leading to\n    // a race condition, so register for incoming block notifications as well\n    // as trying to get it from the datastore\n    const controller = new AbortController()\n    const signal = options.signal\n      ? anySignal([options.signal, controller.signal])\n      : controller.signal\n\n    try {\n      const block = await Promise.race([\n        this.notifications.wantBlock(cid, {\n          signal\n        }),\n        loadOrFetchFromNetwork(cid, {\n          signal\n        })\n      ])\n\n      return block\n    } finally {\n      // since we have the block we can now remove our listener\n      controller.abort()\n    }\n  }\n\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterable<CID>|Iterable<CID>} cids\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * getMany (cids, options = {}) {\n    for await (const cid of cids) {\n      yield this.get(cid, options)\n    }\n  }\n\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {CID[]|CID} cids\n   */\n  unwant (cids) {\n    const cidsArray = Array.isArray(cids) ? cids : [cids]\n\n    this.wm.unwantBlocks(cidsArray)\n    cidsArray.forEach((cid) => this.notifications.unwantBlock(cid))\n  }\n\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {CID[]|CID} cids\n   */\n  cancelWants (cids) {\n    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids])\n  }\n\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {any} [_options]\n   */\n  async put (cid, block, _options) {\n    await this.blockstore.put(cid, block)\n    this._sendHaveBlockNotifications(cid, block)\n  }\n\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {Iterable<Pair> | AsyncIterable<Pair>} source\n   * @param {Options} [options]\n   */\n  async * putMany (source, options) {\n    for await (const { key, value } of this.blockstore.putMany(source, options)) {\n      this._sendHaveBlockNotifications(key, value)\n\n      yield { key, value }\n    }\n  }\n\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @private\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   */\n  _sendHaveBlockNotifications (cid, data) {\n    this.notifications.hasBlock(cid, data)\n    this.engine.receivedBlocks([{ cid, data }])\n    // Note: Don't wait for provide to finish before returning\n    this.network.provide(cid).catch((err) => {\n      this._log.error('Failed to provide: %s', err.message)\n    })\n  }\n\n  /**\n   * Get the current list of wants\n   */\n  getWantlist () {\n    return this.wm.wantlist.entries()\n  }\n\n  /**\n   * Get the current list of partners\n   */\n  peers () {\n    return this.engine.peers()\n  }\n\n  /**\n   * Get stats about the bitswap node\n   */\n  stat () {\n    return this._stats\n  }\n\n  /**\n   * Start the bitswap node\n   */\n  async start () {\n    this.wm.start()\n    await this.network.start()\n    this.engine.start()\n    this.started = true\n  }\n\n  /**\n   * Stop the bitswap node\n   */\n  async stop () {\n    this._stats.stop()\n    this.wm.stop()\n    await this.network.stop()\n    this.engine.stop()\n    this.started = false\n  }\n\n  unwrap () {\n    return this.blockstore\n  }\n\n  /**\n   * @param {CID} cid\n   * @returns {Promise<boolean>}\n   */\n  has (cid) {\n    return this.blockstore.has(cid)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}