{"ast":null,"code":"import { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nexport function createListener(options) {\n  const listeningAddrs = new Map();\n  /**\n   * Add swarm handler and listen for incoming connections\n   */\n\n  async function listen(addr) {\n    const addrString = addr.toString().split('/p2p-circuit').find(a => a !== '');\n    const ma = multiaddr(addrString);\n    const relayPeerStr = ma.getPeerId();\n\n    if (relayPeerStr == null) {\n      throw new Error('Could not determine relay peer from multiaddr');\n    }\n\n    const relayPeerId = peerIdFromString(relayPeerStr);\n    await options.peerStore.addressBook.add(relayPeerId, [ma]);\n    const relayConn = await options.connectionManager.openConnection(relayPeerId);\n    const relayedAddr = relayConn.remoteAddr.encapsulate('/p2p-circuit');\n    listeningAddrs.set(relayConn.remotePeer.toString(), relayedAddr);\n    listener.dispatchEvent(new CustomEvent('listening'));\n  }\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   * `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   * address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   * `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   * addr, such when dialing over a relay with this address, it will create the circuit using\n   * the encapsulated transport address. This is useful when for example, a peer should only\n   * be dialed over TCP rather than any other transport\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  function getAddrs() {\n    const addrs = [];\n\n    for (const addr of listeningAddrs.values()) {\n      addrs.push(addr);\n    }\n\n    return addrs;\n  }\n\n  const listener = Object.assign(new EventEmitter(), {\n    close: async () => await Promise.resolve(),\n    listen,\n    getAddrs\n  }); // Remove listeningAddrs when a peer disconnects\n\n  options.connectionManager.addEventListener('peer:disconnect', evt => {\n    const {\n      detail: connection\n    } = evt;\n    const deleted = listeningAddrs.delete(connection.remotePeer.toString());\n\n    if (deleted) {\n      // Announce listen addresses change\n      listener.dispatchEvent(new CustomEvent('close'));\n    }\n  });\n  return listener;\n}","map":{"version":3,"mappings":"AAAA,SAASA,WAAT,EAAsBC,YAAtB,QAA0C,2BAA1C;AAIA,SAASC,gBAAT,QAAiC,iBAAjC;AAEA,SAASC,SAAT,QAA0B,yBAA1B;AAOA,OAAM,SAAUC,cAAV,CAA0BC,OAA1B,EAAkD;AACtD,QAAMC,cAAc,GAAG,IAAIC,GAAJ,EAAvB;AAEA;;;;AAGA,iBAAeC,MAAf,CAAuBC,IAAvB,EAAsC;AACpC,UAAMC,UAAU,GAAGD,IAAI,CAACE,QAAL,GAAgBC,KAAhB,CAAsB,cAAtB,EAAsCC,IAAtC,CAA2CC,CAAC,IAAIA,CAAC,KAAK,EAAtD,CAAnB;AACA,UAAMC,EAAE,GAAGZ,SAAS,CAACO,UAAD,CAApB;AAEA,UAAMM,YAAY,GAAGD,EAAE,CAACE,SAAH,EAArB;;AAEA,QAAID,YAAY,IAAI,IAApB,EAA0B;AACxB,YAAM,IAAIE,KAAJ,CAAU,+CAAV,CAAN;AACD;;AAED,UAAMC,WAAW,GAAGjB,gBAAgB,CAACc,YAAD,CAApC;AAEA,UAAMX,OAAO,CAACe,SAAR,CAAkBC,WAAlB,CAA8BC,GAA9B,CAAkCH,WAAlC,EAA+C,CAACJ,EAAD,CAA/C,CAAN;AAEA,UAAMQ,SAAS,GAAG,MAAMlB,OAAO,CAACmB,iBAAR,CAA0BC,cAA1B,CAAyCN,WAAzC,CAAxB;AACA,UAAMO,WAAW,GAAGH,SAAS,CAACI,UAAV,CAAqBC,WAArB,CAAiC,cAAjC,CAApB;AAEAtB,kBAAc,CAACuB,GAAf,CAAmBN,SAAS,CAACO,UAAV,CAAqBnB,QAArB,EAAnB,EAAoDe,WAApD;AACAK,YAAQ,CAACC,aAAT,CAAuB,IAAIhC,WAAJ,CAAgB,WAAhB,CAAvB;AACD;AAED;;;;;;;;;;;;;;;;;;AAgBA,WAASiC,QAAT,GAAiB;AACf,UAAMC,KAAK,GAAG,EAAd;;AACA,SAAK,MAAMzB,IAAX,IAAmBH,cAAc,CAAC6B,MAAf,EAAnB,EAA4C;AAC1CD,WAAK,CAACE,IAAN,CAAW3B,IAAX;AACD;;AACD,WAAOyB,KAAP;AACD;;AAED,QAAMH,QAAQ,GAAaM,MAAM,CAACC,MAAP,CAAc,IAAIrC,YAAJ,EAAd,EAAkC;AAC3DsC,SAAK,EAAE,YAAY,MAAMC,OAAO,CAACC,OAAR,EADkC;AAE3DjC,UAF2D;AAG3DyB;AAH2D,GAAlC,CAA3B,CAnDsD,CAyDtD;;AACA5B,SAAO,CAACmB,iBAAR,CAA0BkB,gBAA1B,CAA2C,iBAA3C,EAA+DC,GAAD,IAAQ;AACpE,UAAM;AAAEC,YAAM,EAAEC;AAAV,QAAyBF,GAA/B;AACA,UAAMG,OAAO,GAAGxC,cAAc,CAACyC,MAAf,CAAsBF,UAAU,CAACf,UAAX,CAAsBnB,QAAtB,EAAtB,CAAhB;;AAEA,QAAImC,OAAJ,EAAa;AACX;AACAf,cAAQ,CAACC,aAAT,CAAuB,IAAIhC,WAAJ,CAAgB,OAAhB,CAAvB;AACD;AACF,GARD;AAUA,SAAO+B,QAAP;AACD","names":["CustomEvent","EventEmitter","peerIdFromString","multiaddr","createListener","options","listeningAddrs","Map","listen","addr","addrString","toString","split","find","a","ma","relayPeerStr","getPeerId","Error","relayPeerId","peerStore","addressBook","add","relayConn","connectionManager","openConnection","relayedAddr","remoteAddr","encapsulate","set","remotePeer","listener","dispatchEvent","getAddrs","addrs","values","push","Object","assign","close","Promise","resolve","addEventListener","evt","detail","connection","deleted","delete"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\circuit\\listener.ts"],"sourcesContent":["import { CustomEvent, EventEmitter } from '@libp2p/interfaces/events'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\nimport type { PeerStore } from '@libp2p/interface-peer-store'\nimport type { Listener } from '@libp2p/interface-transport'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport { multiaddr } from '@multiformats/multiaddr'\n\nexport interface ListenerOptions {\n  peerStore: PeerStore\n  connectionManager: ConnectionManager\n}\n\nexport function createListener (options: ListenerOptions): Listener {\n  const listeningAddrs = new Map()\n\n  /**\n   * Add swarm handler and listen for incoming connections\n   */\n  async function listen (addr: Multiaddr): Promise<void> {\n    const addrString = addr.toString().split('/p2p-circuit').find(a => a !== '')\n    const ma = multiaddr(addrString)\n\n    const relayPeerStr = ma.getPeerId()\n\n    if (relayPeerStr == null) {\n      throw new Error('Could not determine relay peer from multiaddr')\n    }\n\n    const relayPeerId = peerIdFromString(relayPeerStr)\n\n    await options.peerStore.addressBook.add(relayPeerId, [ma])\n\n    const relayConn = await options.connectionManager.openConnection(relayPeerId)\n    const relayedAddr = relayConn.remoteAddr.encapsulate('/p2p-circuit')\n\n    listeningAddrs.set(relayConn.remotePeer.toString(), relayedAddr)\n    listener.dispatchEvent(new CustomEvent('listening'))\n  }\n\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   * `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   * address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   * `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   * addr, such when dialing over a relay with this address, it will create the circuit using\n   * the encapsulated transport address. This is useful when for example, a peer should only\n   * be dialed over TCP rather than any other transport\n   *\n   * @returns {Multiaddr[]}\n   */\n  function getAddrs () {\n    const addrs = []\n    for (const addr of listeningAddrs.values()) {\n      addrs.push(addr)\n    }\n    return addrs\n  }\n\n  const listener: Listener = Object.assign(new EventEmitter(), {\n    close: async () => await Promise.resolve(),\n    listen,\n    getAddrs\n  })\n\n  // Remove listeningAddrs when a peer disconnects\n  options.connectionManager.addEventListener('peer:disconnect', (evt) => {\n    const { detail: connection } = evt\n    const deleted = listeningAddrs.delete(connection.remotePeer.toString())\n\n    if (deleted) {\n      // Announce listen addresses change\n      listener.dispatchEvent(new CustomEvent('close'))\n    }\n  })\n\n  return listener\n}\n"]},"metadata":{},"sourceType":"module"}