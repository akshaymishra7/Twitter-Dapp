{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport pSettle from 'p-settle';\nimport { codes } from './errors.js';\nimport errCode from 'err-code';\nimport { FaultTolerance } from '@libp2p/interface-transport';\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { trackedMap } from '@libp2p/tracked-map';\nconst log = logger('libp2p:transports');\nexport class DefaultTransportManager extends EventEmitter {\n  constructor(components) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.components = components;\n    this.started = false;\n    this.transports = new Map();\n    this.listeners = trackedMap({\n      name: 'libp2p_transport_manager_listeners',\n      metrics: this.components.metrics\n    });\n    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;\n  }\n  /**\n   * Adds a `Transport` to the manager\n   */\n\n\n  add(transport) {\n    const tag = transport[Symbol.toStringTag];\n\n    if (tag == null) {\n      throw errCode(new Error('Transport must have a valid tag'), codes.ERR_INVALID_KEY);\n    }\n\n    if (this.transports.has(tag)) {\n      throw errCode(new Error('There is already a transport with this tag'), codes.ERR_DUPLICATE_TRANSPORT);\n    }\n\n    log('adding transport %s', tag);\n    this.transports.set(tag, transport);\n\n    if (!this.listeners.has(tag)) {\n      this.listeners.set(tag, []);\n    }\n  }\n\n  isStarted() {\n    return this.started;\n  }\n\n  async start() {\n    // Listen on the provided transports for the provided addresses\n    const addrs = this.components.addressManager.getListenAddrs();\n    await this.listen(addrs);\n    this.started = true;\n  }\n  /**\n   * Stops all listeners\n   */\n\n\n  async stop() {\n    const tasks = [];\n\n    for (const [key, listeners] of this.listeners) {\n      log('closing listeners for %s', key);\n\n      while (listeners.length > 0) {\n        const listener = listeners.pop();\n\n        if (listener == null) {\n          continue;\n        }\n\n        tasks.push(listener.close());\n      }\n    }\n\n    await Promise.all(tasks);\n    log('all listeners closed');\n\n    for (const key of this.listeners.keys()) {\n      this.listeners.set(key, []);\n    }\n\n    this.started = false;\n  }\n  /**\n   * Dials the given Multiaddr over it's supported transport\n   */\n\n\n  async dial(ma, options) {\n    const transport = this.transportForMultiaddr(ma);\n\n    if (transport == null) {\n      throw errCode(new Error(`No transport available for address ${String(ma)}`), codes.ERR_TRANSPORT_UNAVAILABLE);\n    }\n\n    try {\n      return await transport.dial(ma, { ...options,\n        upgrader: this.components.upgrader\n      });\n    } catch (err) {\n      if (err.code == null) {\n        err.code = codes.ERR_TRANSPORT_DIAL_FAILED;\n      }\n\n      throw err;\n    }\n  }\n  /**\n   * Returns all Multiaddr's the listeners are using\n   */\n\n\n  getAddrs() {\n    let addrs = [];\n\n    for (const listeners of this.listeners.values()) {\n      for (const listener of listeners) {\n        addrs = [...addrs, ...listener.getAddrs()];\n      }\n    }\n\n    return addrs;\n  }\n  /**\n   * Returns all the transports instances\n   */\n\n\n  getTransports() {\n    return Array.of(...this.transports.values());\n  }\n  /**\n   * Finds a transport that matches the given Multiaddr\n   */\n\n\n  transportForMultiaddr(ma) {\n    for (const transport of this.transports.values()) {\n      const addrs = transport.filter([ma]);\n\n      if (addrs.length > 0) {\n        return transport;\n      }\n    }\n  }\n  /**\n   * Starts listeners for each listen Multiaddr\n   */\n\n\n  async listen(addrs) {\n    if (addrs == null || addrs.length === 0) {\n      log('no addresses were provided for listening, this node is dial only');\n      return;\n    }\n\n    const couldNotListen = [];\n\n    for (const [key, transport] of this.transports.entries()) {\n      const supportedAddrs = transport.filter(addrs);\n      const tasks = []; // For each supported multiaddr, create a listener\n\n      for (const addr of supportedAddrs) {\n        log('creating listener for %s on %s', key, addr);\n        const listener = transport.createListener({\n          upgrader: this.components.upgrader\n        });\n        let listeners = this.listeners.get(key);\n\n        if (listeners == null) {\n          listeners = [];\n          this.listeners.set(key, listeners);\n        }\n\n        listeners.push(listener); // Track listen/close events\n\n        listener.addEventListener('listening', () => {\n          this.dispatchEvent(new CustomEvent('listener:listening', {\n            detail: listener\n          }));\n        });\n        listener.addEventListener('close', () => {\n          this.dispatchEvent(new CustomEvent('listener:close', {\n            detail: listener\n          }));\n        }); // We need to attempt to listen on everything\n\n        tasks.push(listener.listen(addr));\n      } // Keep track of transports we had no addresses for\n\n\n      if (tasks.length === 0) {\n        couldNotListen.push(key);\n        continue;\n      }\n\n      const results = await pSettle(tasks); // If we are listening on at least 1 address, succeed.\n      // TODO: we should look at adding a retry (`p-retry`) here to better support\n      // listening on remote addresses as they may be offline. We could then potentially\n      // just wait for any (`p-any`) listener to succeed on each transport before returning\n\n      const isListening = results.find(r => r.isFulfilled);\n\n      if (isListening == null && this.faultTolerance !== FaultTolerance.NO_FATAL) {\n        throw errCode(new Error(`Transport (${key}) could not listen on any available address`), codes.ERR_NO_VALID_ADDRESSES);\n      }\n    } // If no transports were able to listen, throw an error. This likely\n    // means we were given addresses we do not have transports for\n\n\n    if (couldNotListen.length === this.transports.size) {\n      const message = `no valid addresses were provided for transports [${couldNotListen.join(', ')}]`;\n\n      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {\n        throw errCode(new Error(message), codes.ERR_NO_VALID_ADDRESSES);\n      }\n\n      log(`libp2p in dial mode only: ${message}`);\n    }\n  }\n  /**\n   * Removes the given transport from the manager.\n   * If a transport has any running listeners, they will be closed.\n   */\n\n\n  async remove(key) {\n    log('removing %s', key); // Close any running listeners\n\n    for (const listener of this.listeners.get(key) ?? []) {\n      await listener.close();\n    }\n\n    this.transports.delete(key);\n    this.listeners.delete(key);\n  }\n  /**\n   * Removes all transports from the manager.\n   * If any listeners are running, they will be closed.\n   *\n   * @async\n   */\n\n\n  async removeAll() {\n    const tasks = [];\n\n    for (const key of this.transports.keys()) {\n      tasks.push(this.remove(key));\n    }\n\n    await Promise.all(tasks);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","pSettle","codes","errCode","FaultTolerance","CustomEvent","EventEmitter","trackedMap","log","DefaultTransportManager","constructor","components","init","started","transports","Map","listeners","name","metrics","faultTolerance","FATAL_ALL","add","transport","tag","Symbol","toStringTag","Error","ERR_INVALID_KEY","has","ERR_DUPLICATE_TRANSPORT","set","isStarted","start","addrs","addressManager","getListenAddrs","listen","stop","tasks","key","length","listener","pop","push","close","Promise","all","keys","dial","ma","options","transportForMultiaddr","String","ERR_TRANSPORT_UNAVAILABLE","upgrader","err","code","ERR_TRANSPORT_DIAL_FAILED","getAddrs","values","getTransports","Array","of","filter","couldNotListen","entries","supportedAddrs","addr","createListener","get","addEventListener","dispatchEvent","detail","results","isListening","find","r","isFulfilled","NO_FATAL","ERR_NO_VALID_ADDRESSES","size","message","join","remove","delete","removeAll"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\transport-manager.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport pSettle from 'p-settle'\nimport { codes } from './errors.js'\nimport errCode from 'err-code'\nimport { FaultTolerance } from '@libp2p/interface-transport'\nimport type { Listener, Transport, TransportManager, TransportManagerEvents, Upgrader } from '@libp2p/interface-transport'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Connection } from '@libp2p/interface-connection'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport { trackedMap } from '@libp2p/tracked-map'\nimport type { Metrics } from '@libp2p/interface-metrics'\nimport type { AddressManager } from '@libp2p/interface-address-manager'\n\nconst log = logger('libp2p:transports')\n\nexport interface TransportManagerInit {\n  faultTolerance?: FaultTolerance\n}\n\nexport interface DefaultTransportManagerComponents {\n  metrics?: Metrics\n  addressManager: AddressManager\n  upgrader: Upgrader\n}\n\nexport class DefaultTransportManager extends EventEmitter<TransportManagerEvents> implements TransportManager, Startable {\n  private readonly components: DefaultTransportManagerComponents\n  private readonly transports: Map<string, Transport>\n  private readonly listeners: Map<string, Listener[]>\n  private readonly faultTolerance: FaultTolerance\n  private started: boolean\n\n  constructor (components: DefaultTransportManagerComponents, init: TransportManagerInit = {}) {\n    super()\n\n    this.components = components\n    this.started = false\n    this.transports = new Map<string, Transport>()\n    this.listeners = trackedMap({\n      name: 'libp2p_transport_manager_listeners',\n      metrics: this.components.metrics\n    })\n    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL\n  }\n\n  /**\n   * Adds a `Transport` to the manager\n   */\n  add (transport: Transport) {\n    const tag = transport[Symbol.toStringTag]\n\n    if (tag == null) {\n      throw errCode(new Error('Transport must have a valid tag'), codes.ERR_INVALID_KEY)\n    }\n\n    if (this.transports.has(tag)) {\n      throw errCode(new Error('There is already a transport with this tag'), codes.ERR_DUPLICATE_TRANSPORT)\n    }\n\n    log('adding transport %s', tag)\n\n    this.transports.set(tag, transport)\n\n    if (!this.listeners.has(tag)) {\n      this.listeners.set(tag, [])\n    }\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  async start () {\n    // Listen on the provided transports for the provided addresses\n    const addrs = this.components.addressManager.getListenAddrs()\n\n    await this.listen(addrs)\n\n    this.started = true\n  }\n\n  /**\n   * Stops all listeners\n   */\n  async stop () {\n    const tasks = []\n    for (const [key, listeners] of this.listeners) {\n      log('closing listeners for %s', key)\n      while (listeners.length > 0) {\n        const listener = listeners.pop()\n\n        if (listener == null) {\n          continue\n        }\n\n        tasks.push(listener.close())\n      }\n    }\n\n    await Promise.all(tasks)\n    log('all listeners closed')\n    for (const key of this.listeners.keys()) {\n      this.listeners.set(key, [])\n    }\n\n    this.started = false\n  }\n\n  /**\n   * Dials the given Multiaddr over it's supported transport\n   */\n  async dial (ma: Multiaddr, options?: AbortOptions): Promise<Connection> {\n    const transport = this.transportForMultiaddr(ma)\n\n    if (transport == null) {\n      throw errCode(new Error(`No transport available for address ${String(ma)}`), codes.ERR_TRANSPORT_UNAVAILABLE)\n    }\n\n    try {\n      return await transport.dial(ma, {\n        ...options,\n        upgrader: this.components.upgrader\n      })\n    } catch (err: any) {\n      if (err.code == null) {\n        err.code = codes.ERR_TRANSPORT_DIAL_FAILED\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Returns all Multiaddr's the listeners are using\n   */\n  getAddrs (): Multiaddr[] {\n    let addrs: Multiaddr[] = []\n    for (const listeners of this.listeners.values()) {\n      for (const listener of listeners) {\n        addrs = [...addrs, ...listener.getAddrs()]\n      }\n    }\n    return addrs\n  }\n\n  /**\n   * Returns all the transports instances\n   */\n  getTransports () {\n    return Array.of(...this.transports.values())\n  }\n\n  /**\n   * Finds a transport that matches the given Multiaddr\n   */\n  transportForMultiaddr (ma: Multiaddr) {\n    for (const transport of this.transports.values()) {\n      const addrs = transport.filter([ma])\n\n      if (addrs.length > 0) {\n        return transport\n      }\n    }\n  }\n\n  /**\n   * Starts listeners for each listen Multiaddr\n   */\n  async listen (addrs: Multiaddr[]) {\n    if (addrs == null || addrs.length === 0) {\n      log('no addresses were provided for listening, this node is dial only')\n      return\n    }\n\n    const couldNotListen = []\n\n    for (const [key, transport] of this.transports.entries()) {\n      const supportedAddrs = transport.filter(addrs)\n      const tasks = []\n\n      // For each supported multiaddr, create a listener\n      for (const addr of supportedAddrs) {\n        log('creating listener for %s on %s', key, addr)\n        const listener = transport.createListener({\n          upgrader: this.components.upgrader\n        })\n\n        let listeners = this.listeners.get(key)\n\n        if (listeners == null) {\n          listeners = []\n          this.listeners.set(key, listeners)\n        }\n\n        listeners.push(listener)\n\n        // Track listen/close events\n        listener.addEventListener('listening', () => {\n          this.dispatchEvent(new CustomEvent<Listener>('listener:listening', {\n            detail: listener\n          }))\n        })\n        listener.addEventListener('close', () => {\n          this.dispatchEvent(new CustomEvent<Listener>('listener:close', {\n            detail: listener\n          }))\n        })\n\n        // We need to attempt to listen on everything\n        tasks.push(listener.listen(addr))\n      }\n\n      // Keep track of transports we had no addresses for\n      if (tasks.length === 0) {\n        couldNotListen.push(key)\n        continue\n      }\n\n      const results = await pSettle(tasks)\n      // If we are listening on at least 1 address, succeed.\n      // TODO: we should look at adding a retry (`p-retry`) here to better support\n      // listening on remote addresses as they may be offline. We could then potentially\n      // just wait for any (`p-any`) listener to succeed on each transport before returning\n      const isListening = results.find(r => r.isFulfilled)\n      if ((isListening == null) && this.faultTolerance !== FaultTolerance.NO_FATAL) {\n        throw errCode(new Error(`Transport (${key}) could not listen on any available address`), codes.ERR_NO_VALID_ADDRESSES)\n      }\n    }\n\n    // If no transports were able to listen, throw an error. This likely\n    // means we were given addresses we do not have transports for\n    if (couldNotListen.length === this.transports.size) {\n      const message = `no valid addresses were provided for transports [${couldNotListen.join(', ')}]`\n      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {\n        throw errCode(new Error(message), codes.ERR_NO_VALID_ADDRESSES)\n      }\n      log(`libp2p in dial mode only: ${message}`)\n    }\n  }\n\n  /**\n   * Removes the given transport from the manager.\n   * If a transport has any running listeners, they will be closed.\n   */\n  async remove (key: string) {\n    log('removing %s', key)\n\n    // Close any running listeners\n    for (const listener of this.listeners.get(key) ?? []) {\n      await listener.close()\n    }\n\n    this.transports.delete(key)\n    this.listeners.delete(key)\n  }\n\n  /**\n   * Removes all transports from the manager.\n   * If any listeners are running, they will be closed.\n   *\n   * @async\n   */\n  async removeAll () {\n    const tasks = []\n    for (const key of this.transports.keys()) {\n      tasks.push(this.remove(key))\n    }\n\n    await Promise.all(tasks)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}