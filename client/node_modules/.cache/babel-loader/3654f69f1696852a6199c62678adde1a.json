{"ast":null,"code":"/**\n * @packageDocumentation\n *\n * @example\n *\n * ```js\n * import { abortableSource } from 'abortable-iterator'\n *\n * async function main () {\n *   // An example function that creates an async iterator that yields an increasing\n *   // number every x milliseconds and NEVER ENDS!\n *   const asyncCounter = async function * (start, delay) {\n *     let i = start\n *     while (true) {\n *       yield new Promise(resolve => setTimeout(() => resolve(i++), delay))\n *     }\n *   }\n *\n *   // Create a counter that'll yield numbers from 0 upwards every second\n *   const everySecond = asyncCounter(0, 1000)\n *\n *   // Make everySecond abortable!\n *   const controller = new AbortController()\n *   const abortableEverySecond = abortableSource(everySecond, controller.signal)\n *\n *   // Abort after 5 seconds\n *   setTimeout(() => controller.abort(), 5000)\n *\n *   try {\n *     // Start the iteration, which will throw after 5 seconds when it is aborted\n *     for await (const n of abortableEverySecond) {\n *       console.log(n)\n *     }\n *   } catch (err) {\n *     if (err.code === 'ERR_ABORTED') {\n *       // Expected - all ok :D\n *     } else {\n *       throw err\n *     }\n *   }\n * }\n *\n * main()\n * ```\n */\nimport { AbortError } from './abort-error.js';\nimport { getIterator } from 'get-iterator';\n/**\n * Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\n */\n\nexport function abortableSource(source, signal, options) {\n  const opts = options ?? {};\n  const iterator = getIterator(source);\n\n  async function* abortable() {\n    let nextAbortHandler;\n\n    const abortHandler = () => {\n      if (nextAbortHandler != null) nextAbortHandler();\n    };\n\n    signal.addEventListener('abort', abortHandler);\n\n    while (true) {\n      let result;\n\n      try {\n        if (signal.aborted) {\n          const {\n            abortMessage,\n            abortCode\n          } = opts;\n          throw new AbortError(abortMessage, abortCode);\n        }\n\n        const abort = new Promise((resolve, reject) => {\n          nextAbortHandler = () => {\n            const {\n              abortMessage,\n              abortCode\n            } = opts;\n            reject(new AbortError(abortMessage, abortCode));\n          };\n        }); // Race the iterator and the abort signals\n\n        result = await Promise.race([abort, iterator.next()]);\n        nextAbortHandler = null;\n      } catch (err) {\n        signal.removeEventListener('abort', abortHandler); // Might not have been aborted by a known signal\n\n        const isKnownAborter = err.type === 'aborted' && signal.aborted;\n\n        if (isKnownAborter && opts.onAbort != null) {\n          // Do any custom abort handling for the iterator\n          opts.onAbort(source);\n        } // End the iterator if it is a generator\n\n\n        if (typeof iterator.return === 'function') {\n          try {\n            const p = iterator.return();\n\n            if (p instanceof Promise) {\n              // eslint-disable-line max-depth\n              p.catch(err => {\n                if (opts.onReturnError != null) {\n                  opts.onReturnError(err);\n                }\n              });\n            }\n          } catch (err) {\n            if (opts.onReturnError != null) {\n              // eslint-disable-line max-depth\n              opts.onReturnError(err);\n            }\n          }\n        }\n\n        if (isKnownAborter && opts.returnOnAbort === true) {\n          return;\n        }\n\n        throw err;\n      }\n\n      if (result.done === true) {\n        break;\n      }\n\n      yield result.value;\n    }\n\n    signal.removeEventListener('abort', abortHandler);\n  }\n\n  return abortable();\n}\nexport function abortableSink(sink, signal, options) {\n  return source => sink(abortableSource(source, signal, options));\n}\nexport function abortableDuplex(duplex, signal, options) {\n  return {\n    sink: abortableSink(duplex.sink, signal, { ...options,\n      onAbort: undefined\n    }),\n    source: abortableSource(duplex.source, signal, options)\n  };\n}\nexport { AbortError };\nexport { abortableSink as abortableTransform };","map":{"version":3,"mappings":"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","names":["AbortError","getIterator","abortableSource","source","signal","options","opts","iterator","abortable","nextAbortHandler","abortHandler","addEventListener","result","aborted","abortMessage","abortCode","abort","Promise","resolve","reject","race","next","err","removeEventListener","isKnownAborter","type","onAbort","return","p","catch","onReturnError","returnOnAbort","done","value","abortableSink","sink","abortableDuplex","duplex","undefined","abortableTransform"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\multistream-select\\node_modules\\abortable-iterator\\src\\index.ts"],"sourcesContent":["/**\n * @packageDocumentation\n *\n * @example\n *\n * ```js\n * import { abortableSource } from 'abortable-iterator'\n *\n * async function main () {\n *   // An example function that creates an async iterator that yields an increasing\n *   // number every x milliseconds and NEVER ENDS!\n *   const asyncCounter = async function * (start, delay) {\n *     let i = start\n *     while (true) {\n *       yield new Promise(resolve => setTimeout(() => resolve(i++), delay))\n *     }\n *   }\n *\n *   // Create a counter that'll yield numbers from 0 upwards every second\n *   const everySecond = asyncCounter(0, 1000)\n *\n *   // Make everySecond abortable!\n *   const controller = new AbortController()\n *   const abortableEverySecond = abortableSource(everySecond, controller.signal)\n *\n *   // Abort after 5 seconds\n *   setTimeout(() => controller.abort(), 5000)\n *\n *   try {\n *     // Start the iteration, which will throw after 5 seconds when it is aborted\n *     for await (const n of abortableEverySecond) {\n *       console.log(n)\n *     }\n *   } catch (err) {\n *     if (err.code === 'ERR_ABORTED') {\n *       // Expected - all ok :D\n *     } else {\n *       throw err\n *     }\n *   }\n * }\n *\n * main()\n * ```\n */\n\nimport { AbortError } from './abort-error.js'\nimport { getIterator } from 'get-iterator'\nimport type { Duplex, Source, Sink } from 'it-stream-types'\n\nexport interface Options<T> {\n  onReturnError?: (err: Error) => void\n  onAbort?: (source: Source<T>) => void\n  abortMessage?: string\n  abortCode?: string\n  returnOnAbort?: boolean\n}\n\n/**\n * Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\n */\nexport function abortableSource <T> (source: Source<T>, signal: AbortSignal, options?: Options<T>): AsyncGenerator<T> {\n  const opts: Options<T> = options ?? {}\n  const iterator = getIterator<T>(source)\n\n  async function * abortable (): AsyncGenerator<Awaited<T>, void, unknown> {\n    let nextAbortHandler: (() => void) | null\n    const abortHandler = (): void => {\n      if (nextAbortHandler != null) nextAbortHandler()\n    }\n\n    signal.addEventListener('abort', abortHandler)\n\n    while (true) {\n      let result: IteratorResult<T, any>\n      try {\n        if (signal.aborted) {\n          const { abortMessage, abortCode } = opts\n          throw new AbortError(abortMessage, abortCode)\n        }\n\n        const abort = new Promise<any>((resolve, reject) => { // eslint-disable-line no-loop-func\n          nextAbortHandler = () => {\n            const { abortMessage, abortCode } = opts\n            reject(new AbortError(abortMessage, abortCode))\n          }\n        })\n\n        // Race the iterator and the abort signals\n        result = await Promise.race([abort, iterator.next()])\n        nextAbortHandler = null\n      } catch (err: any) {\n        signal.removeEventListener('abort', abortHandler)\n\n        // Might not have been aborted by a known signal\n        const isKnownAborter = err.type === 'aborted' && signal.aborted\n\n        if (isKnownAborter && (opts.onAbort != null)) {\n          // Do any custom abort handling for the iterator\n          opts.onAbort(source)\n        }\n\n        // End the iterator if it is a generator\n        if (typeof iterator.return === 'function') {\n          try {\n            const p = iterator.return()\n\n            if (p instanceof Promise) { // eslint-disable-line max-depth\n              p.catch(err => {\n                if (opts.onReturnError != null) {\n                  opts.onReturnError(err)\n                }\n              })\n            }\n          } catch (err: any) {\n            if (opts.onReturnError != null) { // eslint-disable-line max-depth\n              opts.onReturnError(err)\n            }\n          }\n        }\n\n        if (isKnownAborter && opts.returnOnAbort === true) {\n          return\n        }\n\n        throw err\n      }\n\n      if (result.done === true) {\n        break\n      }\n\n      yield result.value\n    }\n\n    signal.removeEventListener('abort', abortHandler)\n  }\n\n  return abortable()\n}\n\nexport function abortableSink <T, R = Promise<void>> (sink: Sink<AsyncIterable<T>, R>, signal: AbortSignal, options?: Options<T>): Sink<Source<T>, R> {\n  return (source: Source<T>) => sink(abortableSource(source, signal, options))\n}\n\nexport function abortableDuplex <TSource, TSink = TSource, RSink = Promise<void>> (duplex: Duplex<AsyncIterable<TSource>, Source<TSink>, RSink>, signal: AbortSignal, options?: Options<TSource>): Duplex<AsyncGenerator<TSource>, Source<TSink>, RSink> {\n  return {\n    sink: abortableSink(duplex.sink, signal, {\n      ...options,\n      onAbort: undefined\n    }),\n    source: abortableSource(duplex.source, signal, options)\n  }\n}\n\nexport { AbortError }\nexport { abortableSink as abortableTransform }\n"]},"metadata":{},"sourceType":"module"}