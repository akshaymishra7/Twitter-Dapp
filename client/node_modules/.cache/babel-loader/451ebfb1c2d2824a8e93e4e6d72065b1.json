{"ast":null,"code":"import { WebRTCPeer } from './peer.js';\nimport { WebRTCHandshake } from './handshake.js';\nimport randombytes from 'iso-random-stream/src/random.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { pEvent } from 'p-event';\nimport delay from 'delay';\nimport { CustomEvent } from '@libp2p/interfaces/events';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:webrtc-peer:initator');\nconst ICECOMPLETE_TIMEOUT = 1000;\nexport class WebRTCInitiator extends WebRTCPeer {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({ ...opts,\n      logPrefix: 'initiator'\n    });\n    this.handleDataChannelEvent({\n      channel: this.peerConnection.createDataChannel(opts.dataChannelLabel ?? uint8ArrayToString(randombytes(20), 'hex').slice(0, 7), opts.dataChannelInit)\n    });\n    this.handshake = new WebRTCInitiatorHandshake({\n      log: this.log,\n      peerConnection: this.peerConnection,\n      wrtc: this.wrtc,\n      offerOptions: opts.offerOptions\n    });\n    this.handshake.addEventListener('signal', event => {\n      this.dispatchEvent(new CustomEvent('signal', {\n        detail: event.detail\n      }));\n    });\n  }\n\n  handleSignal(signal) {\n    this.handshake.handleSignal(signal).catch(err => {\n      this.log('error handling signal %o %o', signal, err);\n    });\n  }\n\n}\n\nclass WebRTCInitiatorHandshake extends WebRTCHandshake {\n  constructor(options) {\n    super(options);\n    this.options = options;\n    this.status = 'idle';\n    this.peerConnection.addEventListener('icecandidate', event => {\n      if (event.candidate == null) {\n        return;\n      }\n\n      const signal = {\n        type: 'candidate',\n        candidate: {\n          candidate: event.candidate.candidate,\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          sdpMid: event.candidate.sdpMid\n        }\n      };\n      log.trace('create candidate', signal);\n      this.dispatchEvent(new CustomEvent('signal', {\n        detail: signal\n      }));\n      this.dispatchEvent(new CustomEvent('ice-candidate'));\n    });\n  }\n\n  async handleRenegotiate() {\n    if (this.status === 'negotiating') {\n      this.log('already negotiating, queueing');\n      return;\n    }\n\n    this.status = 'negotiating';\n    const offer = await this.peerConnection.createOffer(this.options.offerOptions);\n    await this.peerConnection.setLocalDescription(offer); // wait for at least one candidate before sending the offer\n\n    await pEvent(this, 'ice-candidate');\n    await delay(ICECOMPLETE_TIMEOUT);\n    log.trace('renegotiate', this.peerConnection.localDescription);\n    this.dispatchEvent(new CustomEvent('signal', {\n      detail: this.peerConnection.localDescription ?? offer\n    }));\n  }\n\n  async handleAnswer(signal) {\n    log.trace('handle answer', signal);\n    await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(signal));\n    this.status = 'idle';\n  }\n\n}","map":{"version":3,"mappings":"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","names":["WebRTCPeer","WebRTCHandshake","randombytes","toString","uint8ArrayToString","pEvent","delay","CustomEvent","logger","log","ICECOMPLETE_TIMEOUT","WebRTCInitiator","constructor","opts","logPrefix","handleDataChannelEvent","channel","peerConnection","createDataChannel","dataChannelLabel","slice","dataChannelInit","handshake","WebRTCInitiatorHandshake","wrtc","offerOptions","addEventListener","event","dispatchEvent","detail","handleSignal","signal","catch","err","options","status","candidate","type","sdpMLineIndex","sdpMid","trace","handleRenegotiate","offer","createOffer","setLocalDescription","localDescription","handleAnswer","setRemoteDescription","RTCSessionDescription"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\webrtc-peer\\src\\initiator.ts"],"sourcesContent":["import { WebRTCPeer } from './peer.js'\nimport { WebRTCHandshake } from './handshake.js'\nimport randombytes from 'iso-random-stream/src/random.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { pEvent } from 'p-event'\nimport delay from 'delay'\nimport { CustomEvent } from '@libp2p/interfaces/events'\nimport { logger } from '@libp2p/logger'\nimport type { WebRTCHandshakeOptions } from './handshake.js'\nimport type { WebRTCInitiatorInit, AnswerSignal, Signal } from './index.js'\n\nconst log = logger('libp2p:webrtc-peer:initator')\n\nconst ICECOMPLETE_TIMEOUT = 1000\n\nexport class WebRTCInitiator extends WebRTCPeer {\n  private readonly handshake: WebRTCInitiatorHandshake\n\n  constructor (opts: WebRTCInitiatorInit = {}) {\n    super({\n      ...opts,\n      logPrefix: 'initiator'\n    })\n\n    this.handleDataChannelEvent({\n      channel: this.peerConnection.createDataChannel(\n        opts.dataChannelLabel ?? uint8ArrayToString(randombytes(20), 'hex').slice(0, 7),\n        opts.dataChannelInit\n      )\n    })\n\n    this.handshake = new WebRTCInitiatorHandshake({\n      log: this.log,\n      peerConnection: this.peerConnection,\n      wrtc: this.wrtc,\n      offerOptions: opts.offerOptions\n    })\n    this.handshake.addEventListener('signal', event => {\n      this.dispatchEvent(new CustomEvent('signal', { detail: event.detail }))\n    })\n  }\n\n  handleSignal (signal: Signal) {\n    this.handshake.handleSignal(signal).catch(err => {\n      this.log('error handling signal %o %o', signal, err)\n    })\n  }\n}\n\ninterface WebRTCInitiatorHandshakeOptions extends WebRTCHandshakeOptions {\n  offerOptions?: RTCOfferOptions\n}\n\nclass WebRTCInitiatorHandshake extends WebRTCHandshake {\n  private readonly options: WebRTCInitiatorHandshakeOptions\n\n  constructor (options: WebRTCInitiatorHandshakeOptions) {\n    super(options)\n\n    this.options = options\n    this.status = 'idle'\n\n    this.peerConnection.addEventListener('icecandidate', (event) => {\n      if (event.candidate == null) {\n        return\n      }\n\n      const signal = {\n        type: 'candidate',\n        candidate: {\n          candidate: event.candidate.candidate,\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          sdpMid: event.candidate.sdpMid\n        }\n      }\n\n      log.trace('create candidate', signal)\n\n      this.dispatchEvent(new CustomEvent('signal', {\n        detail: signal\n      }))\n      this.dispatchEvent(new CustomEvent('ice-candidate'))\n    })\n  }\n\n  async handleRenegotiate () {\n    if (this.status === 'negotiating') {\n      this.log('already negotiating, queueing')\n      return\n    }\n\n    this.status = 'negotiating'\n\n    const offer = await this.peerConnection.createOffer(this.options.offerOptions)\n\n    await this.peerConnection.setLocalDescription(offer)\n\n    // wait for at least one candidate before sending the offer\n    await pEvent(this, 'ice-candidate')\n    await delay(ICECOMPLETE_TIMEOUT)\n\n    log.trace('renegotiate', this.peerConnection.localDescription)\n\n    this.dispatchEvent(new CustomEvent('signal', {\n      detail: this.peerConnection.localDescription ?? offer\n    }))\n  }\n\n  async handleAnswer (signal: AnswerSignal) {\n    log.trace('handle answer', signal)\n\n    await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(signal))\n    this.status = 'idle'\n  }\n}\n"]},"metadata":{},"sourceType":"module"}