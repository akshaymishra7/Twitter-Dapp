{"ast":null,"code":"/**\n * This is similar to https://github.com/daviddias/time-cache/blob/master/src/index.js\n * for our own need, we don't use lodash throttle to improve performance.\n * This gives 4x - 5x performance gain compared to npm TimeCache\n */\nexport class SimpleTimeCache {\n  constructor(opts) {\n    this.entries = new Map();\n    this.validityMs = opts.validityMs; // allow negative validityMs so that this does not cache anything, spec test compliance.spec.js\n    // sends duplicate messages and expect peer to receive all. Application likely uses positive validityMs\n  }\n\n  get size() {\n    return this.entries.size;\n  }\n  /** Returns true if there was a key collision and the entry is dropped */\n\n\n  put(key, value) {\n    if (this.entries.has(key)) {\n      // Key collisions break insertion order in the entries cache, which break prune logic.\n      // prune relies on each iterated entry to have strictly ascending validUntilMs, else it\n      // won't prune expired entries and SimpleTimeCache will grow unexpectedly.\n      // As of Oct 2022 NodeJS v16, inserting the same key twice with different value does not\n      // change the key position in the iterator stream. A unit test asserts this behaviour.\n      return true;\n    }\n\n    this.entries.set(key, {\n      value,\n      validUntilMs: Date.now() + this.validityMs\n    });\n    return false;\n  }\n\n  prune() {\n    const now = Date.now();\n\n    for (const [k, v] of this.entries.entries()) {\n      if (v.validUntilMs < now) {\n        this.entries.delete(k);\n      } else {\n        // Entries are inserted with strictly ascending validUntilMs.\n        // Stop early to save iterations\n        break;\n      }\n    }\n  }\n\n  has(key) {\n    return this.entries.has(key);\n  }\n\n  get(key) {\n    const value = this.entries.get(key);\n    return value && value.validUntilMs >= Date.now() ? value.value : undefined;\n  }\n\n  clear() {\n    this.entries.clear();\n  }\n\n}","map":{"version":3,"mappings":"AASA;;;;;AAKA,OAAM,MAAOA,eAAP,CAAsB;AAI1BC,cAAYC,IAAZ,EAAqC;AAHpB,mBAAU,IAAIC,GAAJ,EAAV;AAIf,SAAKC,UAAL,GAAkBF,IAAI,CAACE,UAAvB,CADmC,CAGnC;AACA;AACD;;AAEO,MAAJC,IAAI;AACN,WAAO,KAAKC,OAAL,CAAaD,IAApB;AACD;AAED;;;AACAE,KAAG,CAACC,GAAD,EAAuBC,KAAvB,EAA+B;AAChC,QAAI,KAAKH,OAAL,CAAaI,GAAb,CAAiBF,GAAjB,CAAJ,EAA2B;AACzB;AACA;AACA;AACA;AACA;AACA,aAAO,IAAP;AACD;;AAED,SAAKF,OAAL,CAAaK,GAAb,CAAiBH,GAAjB,EAAsB;AAAEC,WAAF;AAASG,kBAAY,EAAEC,IAAI,CAACC,GAAL,KAAa,KAAKV;AAAzC,KAAtB;AACA,WAAO,KAAP;AACD;;AAEDW,OAAK;AACH,UAAMD,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAZ;;AAEA,SAAK,MAAM,CAACE,CAAD,EAAIC,CAAJ,CAAX,IAAqB,KAAKX,OAAL,CAAaA,OAAb,EAArB,EAA6C;AAC3C,UAAIW,CAAC,CAACL,YAAF,GAAiBE,GAArB,EAA0B;AACxB,aAAKR,OAAL,CAAaY,MAAb,CAAoBF,CAApB;AACD,OAFD,MAEO;AACL;AACA;AACA;AACD;AACF;AACF;;AAEDN,KAAG,CAACF,GAAD,EAAY;AACb,WAAO,KAAKF,OAAL,CAAaI,GAAb,CAAiBF,GAAjB,CAAP;AACD;;AAEDW,KAAG,CAACX,GAAD,EAAqB;AACtB,UAAMC,KAAK,GAAG,KAAKH,OAAL,CAAaa,GAAb,CAAiBX,GAAjB,CAAd;AACA,WAAOC,KAAK,IAAIA,KAAK,CAACG,YAAN,IAAsBC,IAAI,CAACC,GAAL,EAA/B,GAA4CL,KAAK,CAACA,KAAlD,GAA0DW,SAAjE;AACD;;AAEDC,OAAK;AACH,SAAKf,OAAL,CAAae,KAAb;AACD;;AAvDyB","names":["SimpleTimeCache","constructor","opts","Map","validityMs","size","entries","put","key","value","has","set","validUntilMs","Date","now","prune","k","v","delete","get","undefined","clear"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\utils\\time-cache.ts"],"sourcesContent":["type SimpleTimeCacheOpts = {\n  validityMs: number\n}\n\ntype CacheValue<T> = {\n  value: T\n  validUntilMs: number\n}\n\n/**\n * This is similar to https://github.com/daviddias/time-cache/blob/master/src/index.js\n * for our own need, we don't use lodash throttle to improve performance.\n * This gives 4x - 5x performance gain compared to npm TimeCache\n */\nexport class SimpleTimeCache<T> {\n  private readonly entries = new Map<string | number, CacheValue<T>>()\n  private readonly validityMs: number\n\n  constructor(opts: SimpleTimeCacheOpts) {\n    this.validityMs = opts.validityMs\n\n    // allow negative validityMs so that this does not cache anything, spec test compliance.spec.js\n    // sends duplicate messages and expect peer to receive all. Application likely uses positive validityMs\n  }\n\n  get size(): number {\n    return this.entries.size\n  }\n\n  /** Returns true if there was a key collision and the entry is dropped */\n  put(key: string | number, value: T): boolean {\n    if (this.entries.has(key)) {\n      // Key collisions break insertion order in the entries cache, which break prune logic.\n      // prune relies on each iterated entry to have strictly ascending validUntilMs, else it\n      // won't prune expired entries and SimpleTimeCache will grow unexpectedly.\n      // As of Oct 2022 NodeJS v16, inserting the same key twice with different value does not\n      // change the key position in the iterator stream. A unit test asserts this behaviour.\n      return true\n    }\n\n    this.entries.set(key, { value, validUntilMs: Date.now() + this.validityMs })\n    return false\n  }\n\n  prune(): void {\n    const now = Date.now()\n\n    for (const [k, v] of this.entries.entries()) {\n      if (v.validUntilMs < now) {\n        this.entries.delete(k)\n      } else {\n        // Entries are inserted with strictly ascending validUntilMs.\n        // Stop early to save iterations\n        break\n      }\n    }\n  }\n\n  has(key: string): boolean {\n    return this.entries.has(key)\n  }\n\n  get(key: string | number): T | undefined {\n    const value = this.entries.get(key)\n    return value && value.validUntilMs >= Date.now() ? value.value : undefined\n  }\n\n  clear(): void {\n    this.entries.clear()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}