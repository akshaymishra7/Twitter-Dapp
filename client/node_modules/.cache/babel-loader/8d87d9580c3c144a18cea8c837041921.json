{"ast":null,"code":"import errCode from 'err-code';\nimport * as ERRORS from './errors.js';\nimport { unmarshalPublicKey } from '@libp2p/crypto/keys';\nimport { peerIdFromBytes, peerIdFromKeys } from '@libp2p/peer-id';\nimport { logger } from '@libp2p/logger';\nimport { IpnsEntry } from './pb/ipns.js';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport * as cborg from 'cborg';\nconst log = logger('ipns:utils');\nconst IPNS_PREFIX = uint8ArrayFromString('/ipns/');\n/**\n * Convert a JavaScript date into an `RFC3339Nano` formatted\n * string\n */\n\nexport function toRFC3339(time) {\n  const year = time.getUTCFullYear();\n  const month = String(time.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(time.getUTCDate()).padStart(2, '0');\n  const hour = String(time.getUTCHours()).padStart(2, '0');\n  const minute = String(time.getUTCMinutes()).padStart(2, '0');\n  const seconds = String(time.getUTCSeconds()).padStart(2, '0');\n  const milliseconds = time.getUTCMilliseconds();\n  const nanoseconds = milliseconds * 1000 * 1000;\n  return `${year}-${month}-${day}T${hour}:${minute}:${seconds}.${nanoseconds}Z`;\n}\n/**\n * Parses a date string formatted as `RFC3339Nano` into a\n * JavaScript Date object\n */\n\nexport function parseRFC3339(time) {\n  const rfc3339Matcher = new RegExp( // 2006-01-02T\n  '(\\\\d{4})-(\\\\d{2})-(\\\\d{2})T' + // 15:04:05\n  '(\\\\d{2}):(\\\\d{2}):(\\\\d{2})' + // .999999999Z\n  '\\\\.(\\\\d+)Z');\n  const m = String(time).trim().match(rfc3339Matcher);\n\n  if (m == null) {\n    throw new Error('Invalid format');\n  }\n\n  const year = parseInt(m[1], 10);\n  const month = parseInt(m[2], 10) - 1;\n  const date = parseInt(m[3], 10);\n  const hour = parseInt(m[4], 10);\n  const minute = parseInt(m[5], 10);\n  const second = parseInt(m[6], 10);\n  const millisecond = parseInt(m[7].slice(0, -6), 10);\n  return new Date(Date.UTC(year, month, date, hour, minute, second, millisecond));\n}\n/**\n * Extracts a public key from the passed PeerId, falling\n * back to the pubKey embedded in the ipns record\n */\n\nexport const extractPublicKey = async (peerId, entry) => {\n  if (entry == null || peerId == null) {\n    const error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n  }\n\n  let pubKey;\n\n  if (entry.pubKey != null) {\n    try {\n      pubKey = unmarshalPublicKey(entry.pubKey);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    const otherId = await peerIdFromKeys(entry.pubKey);\n\n    if (!otherId.equals(peerId)) {\n      throw errCode(new Error('Embedded public key did not match PeerID'), ERRORS.ERR_INVALID_EMBEDDED_KEY);\n    }\n  } else if (peerId.publicKey != null) {\n    pubKey = unmarshalPublicKey(peerId.publicKey);\n  }\n\n  if (pubKey != null) {\n    return pubKey;\n  }\n\n  throw errCode(new Error('no public key is available'), ERRORS.ERR_UNDEFINED_PARAMETER);\n};\n/**\n * Utility for creating the record data for being signed\n */\n\nexport const ipnsEntryDataForV1Sig = (value, validityType, validity) => {\n  const validityTypeBuffer = uint8ArrayFromString(validityType);\n  return uint8ArrayConcat([value, validity, validityTypeBuffer]);\n};\n/**\n * Utility for creating the record data for being signed\n */\n\nexport const ipnsEntryDataForV2Sig = data => {\n  const entryData = uint8ArrayFromString('ipns-signature:');\n  return uint8ArrayConcat([entryData, data]);\n};\nexport const marshal = obj => {\n  return IpnsEntry.encode(obj);\n};\nexport const unmarshal = buf => {\n  const message = IpnsEntry.decode(buf); // protobufjs returns bigints as numbers\n\n  if (message.sequence != null) {\n    message.sequence = BigInt(message.sequence);\n  } // protobufjs returns bigints as numbers\n\n\n  if (message.ttl != null) {\n    message.ttl = BigInt(message.ttl);\n  }\n\n  return {\n    value: message.value ?? new Uint8Array(0),\n    signature: message.signature ?? new Uint8Array(0),\n    validityType: message.validityType ?? IpnsEntry.ValidityType.EOL,\n    validity: message.validity ?? new Uint8Array(0),\n    sequence: message.sequence ?? 0n,\n    pubKey: message.pubKey,\n    ttl: message.ttl ?? undefined,\n    signatureV2: message.signatureV2,\n    data: message.data\n  };\n};\nexport const peerIdToRoutingKey = peerId => {\n  return uint8ArrayConcat([IPNS_PREFIX, peerId.toBytes()]);\n};\nexport const peerIdFromRoutingKey = key => {\n  return peerIdFromBytes(key.slice(IPNS_PREFIX.length));\n};\nexport const createCborData = (value, validity, validityType, sequence, ttl) => {\n  let ValidityType;\n\n  if (validityType === IpnsEntry.ValidityType.EOL) {\n    ValidityType = 0;\n  } else {\n    throw errCode(new Error('Unknown validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n  }\n\n  const data = {\n    Value: value,\n    Validity: validity,\n    ValidityType,\n    Sequence: sequence,\n    TTL: ttl\n  };\n  return cborg.encode(data);\n};\nexport const parseCborData = buf => {\n  const data = cborg.decode(buf);\n\n  if (data.ValidityType === 0) {\n    data.ValidityType = IpnsEntry.ValidityType.EOL;\n  } else {\n    throw errCode(new Error('Unknown validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n  }\n\n  if (Number.isInteger(data.Sequence)) {\n    // sequence must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.Sequence = BigInt(data.Sequence);\n  }\n\n  if (Number.isInteger(data.TTL)) {\n    // ttl must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.TTL = BigInt(data.TTL);\n  }\n\n  return data;\n};","map":{"version":3,"mappings":"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","names":["errCode","ERRORS","unmarshalPublicKey","peerIdFromBytes","peerIdFromKeys","logger","IpnsEntry","fromString","uint8ArrayFromString","concat","uint8ArrayConcat","cborg","log","IPNS_PREFIX","toRFC3339","time","year","getUTCFullYear","month","String","getUTCMonth","padStart","day","getUTCDate","hour","getUTCHours","minute","getUTCMinutes","seconds","getUTCSeconds","milliseconds","getUTCMilliseconds","nanoseconds","parseRFC3339","rfc3339Matcher","RegExp","m","trim","match","Error","parseInt","date","second","millisecond","slice","Date","UTC","extractPublicKey","peerId","entry","error","ERR_UNDEFINED_PARAMETER","pubKey","err","otherId","equals","ERR_INVALID_EMBEDDED_KEY","publicKey","ipnsEntryDataForV1Sig","value","validityType","validity","validityTypeBuffer","ipnsEntryDataForV2Sig","data","entryData","marshal","obj","encode","unmarshal","buf","message","decode","sequence","BigInt","ttl","Uint8Array","signature","ValidityType","EOL","undefined","signatureV2","peerIdToRoutingKey","toBytes","peerIdFromRoutingKey","key","length","createCborData","ERR_UNRECOGNIZED_VALIDITY","Value","Validity","Sequence","TTL","parseCborData","Number","isInteger"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\ipns\\src\\utils.ts"],"sourcesContent":["import errCode from 'err-code'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { IPNSEntry, IPNSEntryData } from './index.js'\nimport * as ERRORS from './errors.js'\nimport { unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { peerIdFromBytes, peerIdFromKeys } from '@libp2p/peer-id'\nimport { logger } from '@libp2p/logger'\nimport { IpnsEntry } from './pb/ipns.js'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport * as cborg from 'cborg'\nimport type { PublicKey } from '@libp2p/interface-keys'\n\nconst log = logger('ipns:utils')\nconst IPNS_PREFIX = uint8ArrayFromString('/ipns/')\n\n/**\n * Convert a JavaScript date into an `RFC3339Nano` formatted\n * string\n */\nexport function toRFC3339 (time: Date): string {\n  const year = time.getUTCFullYear()\n  const month = String(time.getUTCMonth() + 1).padStart(2, '0')\n  const day = String(time.getUTCDate()).padStart(2, '0')\n  const hour = String(time.getUTCHours()).padStart(2, '0')\n  const minute = String(time.getUTCMinutes()).padStart(2, '0')\n  const seconds = String(time.getUTCSeconds()).padStart(2, '0')\n  const milliseconds = time.getUTCMilliseconds()\n  const nanoseconds = milliseconds * 1000 * 1000\n\n  return `${year}-${month}-${day}T${hour}:${minute}:${seconds}.${nanoseconds}Z`\n}\n\n/**\n * Parses a date string formatted as `RFC3339Nano` into a\n * JavaScript Date object\n */\nexport function parseRFC3339 (time: string): Date {\n  const rfc3339Matcher = new RegExp(\n    // 2006-01-02T\n    '(\\\\d{4})-(\\\\d{2})-(\\\\d{2})T' +\n    // 15:04:05\n    '(\\\\d{2}):(\\\\d{2}):(\\\\d{2})' +\n    // .999999999Z\n    '\\\\.(\\\\d+)Z'\n  )\n  const m = String(time).trim().match(rfc3339Matcher)\n\n  if (m == null) {\n    throw new Error('Invalid format')\n  }\n\n  const year = parseInt(m[1], 10)\n  const month = parseInt(m[2], 10) - 1\n  const date = parseInt(m[3], 10)\n  const hour = parseInt(m[4], 10)\n  const minute = parseInt(m[5], 10)\n  const second = parseInt(m[6], 10)\n  const millisecond = parseInt(m[7].slice(0, -6), 10)\n\n  return new Date(Date.UTC(year, month, date, hour, minute, second, millisecond))\n}\n\n/**\n * Extracts a public key from the passed PeerId, falling\n * back to the pubKey embedded in the ipns record\n */\nexport const extractPublicKey = async (peerId: PeerId, entry: IpnsEntry): Promise<PublicKey> => {\n  if (entry == null || peerId == null) {\n    const error = new Error('one or more of the provided parameters are not defined')\n\n    log.error(error)\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER)\n  }\n\n  let pubKey: PublicKey | undefined\n\n  if (entry.pubKey != null) {\n    try {\n      pubKey = unmarshalPublicKey(entry.pubKey)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    const otherId = await peerIdFromKeys(entry.pubKey)\n\n    if (!otherId.equals(peerId)) {\n      throw errCode(new Error('Embedded public key did not match PeerID'), ERRORS.ERR_INVALID_EMBEDDED_KEY)\n    }\n  } else if (peerId.publicKey != null) {\n    pubKey = unmarshalPublicKey(peerId.publicKey)\n  }\n\n  if (pubKey != null) {\n    return pubKey\n  }\n\n  throw errCode(new Error('no public key is available'), ERRORS.ERR_UNDEFINED_PARAMETER)\n}\n\n/**\n * Utility for creating the record data for being signed\n */\nexport const ipnsEntryDataForV1Sig = (value: Uint8Array, validityType: IpnsEntry.ValidityType, validity: Uint8Array): Uint8Array => {\n  const validityTypeBuffer = uint8ArrayFromString(validityType)\n\n  return uint8ArrayConcat([value, validity, validityTypeBuffer])\n}\n\n/**\n * Utility for creating the record data for being signed\n */\nexport const ipnsEntryDataForV2Sig = (data: Uint8Array): Uint8Array => {\n  const entryData = uint8ArrayFromString('ipns-signature:')\n\n  return uint8ArrayConcat([entryData, data])\n}\n\nexport const marshal = (obj: IPNSEntry): Uint8Array => {\n  return IpnsEntry.encode(obj)\n}\n\nexport const unmarshal = (buf: Uint8Array): IPNSEntry => {\n  const message = IpnsEntry.decode(buf)\n\n  // protobufjs returns bigints as numbers\n  if (message.sequence != null) {\n    message.sequence = BigInt(message.sequence)\n  }\n\n  // protobufjs returns bigints as numbers\n  if (message.ttl != null) {\n    message.ttl = BigInt(message.ttl)\n  }\n\n  return {\n    value: message.value ?? new Uint8Array(0),\n    signature: message.signature ?? new Uint8Array(0),\n    validityType: message.validityType ?? IpnsEntry.ValidityType.EOL,\n    validity: message.validity ?? new Uint8Array(0),\n    sequence: message.sequence ?? 0n,\n    pubKey: message.pubKey,\n    ttl: message.ttl ?? undefined,\n    signatureV2: message.signatureV2,\n    data: message.data\n  }\n}\n\nexport const peerIdToRoutingKey = (peerId: PeerId): Uint8Array => {\n  return uint8ArrayConcat([\n    IPNS_PREFIX,\n    peerId.toBytes()\n  ])\n}\n\nexport const peerIdFromRoutingKey = (key: Uint8Array): PeerId => {\n  return peerIdFromBytes(key.slice(IPNS_PREFIX.length))\n}\n\nexport const createCborData = (value: Uint8Array, validity: Uint8Array, validityType: string, sequence: bigint, ttl: bigint): Uint8Array => {\n  let ValidityType\n\n  if (validityType === IpnsEntry.ValidityType.EOL) {\n    ValidityType = 0\n  } else {\n    throw errCode(new Error('Unknown validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n  }\n\n  const data = {\n    Value: value,\n    Validity: validity,\n    ValidityType,\n    Sequence: sequence,\n    TTL: ttl\n  }\n\n  return cborg.encode(data)\n}\n\nexport const parseCborData = (buf: Uint8Array): IPNSEntryData => {\n  const data = cborg.decode(buf)\n\n  if (data.ValidityType === 0) {\n    data.ValidityType = IpnsEntry.ValidityType.EOL\n  } else {\n    throw errCode(new Error('Unknown validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n  }\n\n  if (Number.isInteger(data.Sequence)) {\n    // sequence must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.Sequence = BigInt(data.Sequence)\n  }\n\n  if (Number.isInteger(data.TTL)) {\n    // ttl must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.TTL = BigInt(data.TTL)\n  }\n\n  return data\n}\n"]},"metadata":{},"sourceType":"module"}