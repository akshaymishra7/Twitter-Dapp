{"ast":null,"code":"import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\n/**\n * @typedef {Pong|PingFailure|StatusUpdate} Packet\n * Note that not all ping response objects are \"pongs\".\n * A \"pong\" message can be identified by a truthy success property and an empty\n * text property. Other ping responses are failures or status updates.\n *\n * @typedef {object} Pong\n * @property {true} success\n * @property {number} time\n * @property {''} text\n *\n * @typedef {object} PingFailure\n * @property {false} success\n * @property {number} time\n * @property {string} text\n *\n * @typedef {object} StatusUpdate\n * @property {true} success\n * @property {0} time\n * @property {string} text\n *\n * @typedef {PingSettings & AbortOptions} PingOptions\n *\n * @typedef {object} PingSettings\n * @property {number} [count=10] - The number of ping messages to send\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/** @type {{success:true, time:0, text: ''}} */\n\nconst basePacket = {\n  success: true,\n  time: 0,\n  text: ''\n};\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n */\n\nexport function createPing(_ref) {\n  let {\n    network\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"ping\"]}\n   */\n  async function* ping(peerId) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      libp2p\n    } = await network.use();\n    options.count = options.count || 10;\n    const storedPeer = await libp2p.peerStore.get(peerId);\n    let id = storedPeer && storedPeer.id;\n\n    if (!id) {\n      yield { ...basePacket,\n        text: `Looking up peer ${peerId}`\n      };\n      const remotePeer = await libp2p.peerRouting.findPeer(peerId);\n      id = remotePeer && remotePeer.id;\n    }\n\n    if (!id) {\n      throw new Error('Peer was not found');\n    }\n\n    yield { ...basePacket,\n      text: `PING ${id.toString()}`\n    };\n    let packetCount = 0;\n    let totalTime = 0;\n\n    for (let i = 0; i < options.count; i++) {\n      try {\n        const time = await libp2p.ping(id);\n        totalTime += time;\n        packetCount++;\n        yield { ...basePacket,\n          time\n        };\n      } catch (\n      /** @type {any} */\n      err) {\n        yield { ...basePacket,\n          success: false,\n          text: err.toString()\n        };\n      }\n    }\n\n    if (packetCount) {\n      const average = totalTime / packetCount;\n      yield { ...basePacket,\n        text: `Average latency: ${average}ms`\n      };\n    }\n  }\n\n  return withTimeoutOption(ping);\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/ping.js"],"names":["withTimeoutOption","basePacket","success","time","text","createPing","network","ping","peerId","options","libp2p","use","count","storedPeer","peerStore","get","id","remotePeer","peerRouting","findPeer","Error","toString","packetCount","totalTime","i","err","average"],"mappings":"AAAA,SAASA,iBAAT,QAAkC,qCAAlC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA,MAAMC,UAAU,GAAG;AAAEC,EAAAA,OAAO,EAAE,IAAX;AAAiBC,EAAAA,IAAI,EAAE,CAAvB;AAA0BC,EAAAA,IAAI,EAAE;AAAhC,CAAnB;AAEA;AACA;AACA;AACA;;AACA,OAAO,SAASC,UAAT,OAAkC;AAAA,MAAb;AAAEC,IAAAA;AAAF,GAAa;;AACvC;AACF;AACA;AACE,kBAAiBC,IAAjB,CAAuBC,MAAvB,EAA6C;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAC3C,UAAM;AAAEC,MAAAA;AAAF,QAAa,MAAMJ,OAAO,CAACK,GAAR,EAAzB;AACAF,IAAAA,OAAO,CAACG,KAAR,GAAgBH,OAAO,CAACG,KAAR,IAAiB,EAAjC;AAEA,UAAMC,UAAU,GAAG,MAAMH,MAAM,CAACI,SAAP,CAAiBC,GAAjB,CAAqBP,MAArB,CAAzB;AACA,QAAIQ,EAAE,GAAGH,UAAU,IAAIA,UAAU,CAACG,EAAlC;;AAEA,QAAI,CAACA,EAAL,EAAS;AACP,YAAM,EAAE,GAAGf,UAAL;AAAiBG,QAAAA,IAAI,EAAG,mBAAkBI,MAAO;AAAjD,OAAN;AACA,YAAMS,UAAU,GAAG,MAAMP,MAAM,CAACQ,WAAP,CAAmBC,QAAnB,CAA4BX,MAA5B,CAAzB;AAEAQ,MAAAA,EAAE,GAAGC,UAAU,IAAIA,UAAU,CAACD,EAA9B;AACD;;AAED,QAAI,CAACA,EAAL,EAAS;AACP,YAAM,IAAII,KAAJ,CAAU,oBAAV,CAAN;AACD;;AAED,UAAM,EAAE,GAAGnB,UAAL;AAAiBG,MAAAA,IAAI,EAAG,QAAOY,EAAE,CAACK,QAAH,EAAc;AAA7C,KAAN;AAEA,QAAIC,WAAW,GAAG,CAAlB;AACA,QAAIC,SAAS,GAAG,CAAhB;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGf,OAAO,CAACG,KAA5B,EAAmCY,CAAC,EAApC,EAAwC;AACtC,UAAI;AACF,cAAMrB,IAAI,GAAG,MAAMO,MAAM,CAACH,IAAP,CAAYS,EAAZ,CAAnB;AACAO,QAAAA,SAAS,IAAIpB,IAAb;AACAmB,QAAAA,WAAW;AACX,cAAM,EAAE,GAAGrB,UAAL;AAAiBE,UAAAA;AAAjB,SAAN;AACD,OALD,CAKE;AAAO;AAAmBsB,MAAAA,GAA1B,EAA+B;AAC/B,cAAM,EAAE,GAAGxB,UAAL;AAAiBC,UAAAA,OAAO,EAAE,KAA1B;AAAiCE,UAAAA,IAAI,EAAEqB,GAAG,CAACJ,QAAJ;AAAvC,SAAN;AACD;AACF;;AAED,QAAIC,WAAJ,EAAiB;AACf,YAAMI,OAAO,GAAGH,SAAS,GAAGD,WAA5B;AACA,YAAM,EAAE,GAAGrB,UAAL;AAAiBG,QAAAA,IAAI,EAAG,oBAAmBsB,OAAQ;AAAnD,OAAN;AACD;AACF;;AAED,SAAO1B,iBAAiB,CAACO,IAAD,CAAxB;AACD","sourcesContent":["import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\n/**\n * @typedef {Pong|PingFailure|StatusUpdate} Packet\n * Note that not all ping response objects are \"pongs\".\n * A \"pong\" message can be identified by a truthy success property and an empty\n * text property. Other ping responses are failures or status updates.\n *\n * @typedef {object} Pong\n * @property {true} success\n * @property {number} time\n * @property {''} text\n *\n * @typedef {object} PingFailure\n * @property {false} success\n * @property {number} time\n * @property {string} text\n *\n * @typedef {object} StatusUpdate\n * @property {true} success\n * @property {0} time\n * @property {string} text\n *\n * @typedef {PingSettings & AbortOptions} PingOptions\n *\n * @typedef {object} PingSettings\n * @property {number} [count=10] - The number of ping messages to send\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/** @type {{success:true, time:0, text: ''}} */\nconst basePacket = { success: true, time: 0, text: '' }\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n */\nexport function createPing ({ network }) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"ping\"]}\n   */\n  async function * ping (peerId, options = {}) {\n    const { libp2p } = await network.use()\n    options.count = options.count || 10\n\n    const storedPeer = await libp2p.peerStore.get(peerId)\n    let id = storedPeer && storedPeer.id\n\n    if (!id) {\n      yield { ...basePacket, text: `Looking up peer ${peerId}` }\n      const remotePeer = await libp2p.peerRouting.findPeer(peerId)\n\n      id = remotePeer && remotePeer.id\n    }\n\n    if (!id) {\n      throw new Error('Peer was not found')\n    }\n\n    yield { ...basePacket, text: `PING ${id.toString()}` }\n\n    let packetCount = 0\n    let totalTime = 0\n\n    for (let i = 0; i < options.count; i++) {\n      try {\n        const time = await libp2p.ping(id)\n        totalTime += time\n        packetCount++\n        yield { ...basePacket, time }\n      } catch (/** @type {any} */ err) {\n        yield { ...basePacket, success: false, text: err.toString() }\n      }\n    }\n\n    if (packetCount) {\n      const average = totalTime / packetCount\n      yield { ...basePacket, text: `Average latency: ${average}ms` }\n    }\n  }\n\n  return withTimeoutOption(ping)\n}\n"]},"metadata":{},"sourceType":"module"}