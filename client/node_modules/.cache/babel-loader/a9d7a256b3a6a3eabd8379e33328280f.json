{"ast":null,"code":"import { RejectReason } from './types.js';\n/**\n * IWantTracer is an internal tracer that tracks IWANT requests in order to penalize\n * peers who don't follow up on IWANT requests after an IHAVE advertisement.\n * The tracking of promises is probabilistic to avoid using too much memory.\n *\n * Note: Do not confuse these 'promises' with JS Promise objects.\n * These 'promises' are merely expectations of a peer's behavior.\n */\n\nexport class IWantTracer {\n  constructor(gossipsubIWantFollowupMs, msgIdToStrFn, metrics) {\n    this.gossipsubIWantFollowupMs = gossipsubIWantFollowupMs;\n    this.msgIdToStrFn = msgIdToStrFn;\n    this.metrics = metrics;\n    /**\n     * Promises to deliver a message\n     * Map per message id, per peer, promise expiration time\n     */\n\n    this.promises = new Map();\n    /**\n     * First request time by msgId. Used for metrics to track expire times.\n     * Necessary to know if peers are actually breaking promises or simply sending them a bit later\n     */\n\n    this.requestMsByMsg = new Map();\n    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs;\n  }\n\n  get size() {\n    return this.promises.size;\n  }\n\n  get requestMsByMsgSize() {\n    return this.requestMsByMsg.size;\n  }\n  /**\n   * Track a promise to deliver a message from a list of msgIds we are requesting\n   */\n\n\n  addPromise(from, msgIds) {\n    // pick msgId randomly from the list\n    const ix = Math.floor(Math.random() * msgIds.length);\n    const msgId = msgIds[ix];\n    const msgIdStr = this.msgIdToStrFn(msgId);\n    let expireByPeer = this.promises.get(msgIdStr);\n\n    if (!expireByPeer) {\n      expireByPeer = new Map();\n      this.promises.set(msgIdStr, expireByPeer);\n    }\n\n    const now = Date.now(); // If a promise for this message id and peer already exists we don't update the expiry\n\n    if (!expireByPeer.has(from)) {\n      expireByPeer.set(from, now + this.gossipsubIWantFollowupMs);\n\n      if (this.metrics) {\n        this.metrics.iwantPromiseStarted.inc(1);\n\n        if (!this.requestMsByMsg.has(msgIdStr)) {\n          this.requestMsByMsg.set(msgIdStr, now);\n        }\n      }\n    }\n  }\n  /**\n   * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.\n   *\n   * This should be called not too often relative to the expire times, since it iterates over the whole data.\n   */\n\n\n  getBrokenPromises() {\n    const now = Date.now();\n    const result = new Map();\n    let brokenPromises = 0;\n    this.promises.forEach((expireByPeer, msgId) => {\n      expireByPeer.forEach((expire, p) => {\n        // the promise has been broken\n        if (expire < now) {\n          // add 1 to result\n          result.set(p, (result.get(p) ?? 0) + 1); // delete from tracked promises\n\n          expireByPeer.delete(p); // for metrics\n\n          brokenPromises++;\n        }\n      }); // clean up empty promises for a msgId\n\n      if (!expireByPeer.size) {\n        this.promises.delete(msgId);\n      }\n    });\n    this.metrics?.iwantPromiseBroken.inc(brokenPromises);\n    return result;\n  }\n  /**\n   * Someone delivered a message, stop tracking promises for it\n   */\n\n\n  deliverMessage(msgIdStr) {\n    let isDuplicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.trackMessage(msgIdStr);\n    const expireByPeer = this.promises.get(msgIdStr); // Expired promise, check requestMsByMsg\n\n    if (expireByPeer) {\n      this.promises.delete(msgIdStr);\n\n      if (this.metrics) {\n        this.metrics.iwantPromiseResolved.inc(1);\n        if (isDuplicate) this.metrics.iwantPromiseResolvedFromDuplicate.inc(1);\n        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size);\n      }\n    }\n  }\n  /**\n   * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,\n   * unless its an obviously invalid message.\n   */\n\n\n  rejectMessage(msgIdStr, reason) {\n    this.trackMessage(msgIdStr); // A message got rejected, so we can stop tracking promises and let the score penalty apply.\n    // With the expection of obvious invalid messages\n\n    switch (reason) {\n      case RejectReason.Error:\n        return;\n    }\n\n    this.promises.delete(msgIdStr);\n  }\n\n  clear() {\n    this.promises.clear();\n  }\n\n  prune() {\n    const maxMs = Date.now() - this.requestMsByMsgExpire;\n    let count = 0;\n\n    for (const [k, v] of this.requestMsByMsg.entries()) {\n      if (v < maxMs) {\n        // messages that stay too long in the requestMsByMsg map, delete\n        this.requestMsByMsg.delete(k);\n        count++;\n      } else {\n        // recent messages, keep them\n        // sort by insertion order\n        break;\n      }\n    }\n\n    this.metrics?.iwantMessagePruned.inc(count);\n  }\n\n  trackMessage(msgIdStr) {\n    if (this.metrics) {\n      const requestMs = this.requestMsByMsg.get(msgIdStr);\n\n      if (requestMs !== undefined) {\n        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1000);\n        this.requestMsByMsg.delete(msgIdStr);\n      }\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["RejectReason","IWantTracer","constructor","gossipsubIWantFollowupMs","msgIdToStrFn","metrics","Map","requestMsByMsgExpire","size","promises","requestMsByMsgSize","requestMsByMsg","addPromise","from","msgIds","ix","Math","floor","random","length","msgId","msgIdStr","expireByPeer","get","set","now","Date","has","iwantPromiseStarted","inc","getBrokenPromises","result","brokenPromises","forEach","expire","p","delete","iwantPromiseBroken","deliverMessage","isDuplicate","trackMessage","iwantPromiseResolved","iwantPromiseResolvedFromDuplicate","iwantPromiseResolvedPeers","rejectMessage","reason","Error","clear","prune","maxMs","count","k","v","entries","iwantMessagePruned","requestMs","undefined","iwantPromiseDeliveryTime","observe"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\tracer.ts"],"sourcesContent":["import { MsgIdStr, MsgIdToStrFn, PeerIdStr, RejectReason } from './types.js'\nimport type { Metrics } from './metrics.js'\n\n/**\n * IWantTracer is an internal tracer that tracks IWANT requests in order to penalize\n * peers who don't follow up on IWANT requests after an IHAVE advertisement.\n * The tracking of promises is probabilistic to avoid using too much memory.\n *\n * Note: Do not confuse these 'promises' with JS Promise objects.\n * These 'promises' are merely expectations of a peer's behavior.\n */\nexport class IWantTracer {\n  /**\n   * Promises to deliver a message\n   * Map per message id, per peer, promise expiration time\n   */\n  private readonly promises = new Map<MsgIdStr, Map<PeerIdStr, number>>()\n  /**\n   * First request time by msgId. Used for metrics to track expire times.\n   * Necessary to know if peers are actually breaking promises or simply sending them a bit later\n   */\n  private readonly requestMsByMsg = new Map<MsgIdStr, number>()\n  private readonly requestMsByMsgExpire: number\n\n  constructor(\n    private readonly gossipsubIWantFollowupMs: number,\n    private readonly msgIdToStrFn: MsgIdToStrFn,\n    private readonly metrics: Metrics | null\n  ) {\n    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs\n  }\n\n  get size(): number {\n    return this.promises.size\n  }\n\n  get requestMsByMsgSize(): number {\n    return this.requestMsByMsg.size\n  }\n\n  /**\n   * Track a promise to deliver a message from a list of msgIds we are requesting\n   */\n  addPromise(from: PeerIdStr, msgIds: Uint8Array[]): void {\n    // pick msgId randomly from the list\n    const ix = Math.floor(Math.random() * msgIds.length)\n    const msgId = msgIds[ix]\n    const msgIdStr = this.msgIdToStrFn(msgId)\n\n    let expireByPeer = this.promises.get(msgIdStr)\n    if (!expireByPeer) {\n      expireByPeer = new Map()\n      this.promises.set(msgIdStr, expireByPeer)\n    }\n\n    const now = Date.now()\n\n    // If a promise for this message id and peer already exists we don't update the expiry\n    if (!expireByPeer.has(from)) {\n      expireByPeer.set(from, now + this.gossipsubIWantFollowupMs)\n\n      if (this.metrics) {\n        this.metrics.iwantPromiseStarted.inc(1)\n        if (!this.requestMsByMsg.has(msgIdStr)) {\n          this.requestMsByMsg.set(msgIdStr, now)\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.\n   *\n   * This should be called not too often relative to the expire times, since it iterates over the whole data.\n   */\n  getBrokenPromises(): Map<PeerIdStr, number> {\n    const now = Date.now()\n    const result = new Map<PeerIdStr, number>()\n\n    let brokenPromises = 0\n\n    this.promises.forEach((expireByPeer, msgId) => {\n      expireByPeer.forEach((expire, p) => {\n        // the promise has been broken\n        if (expire < now) {\n          // add 1 to result\n          result.set(p, (result.get(p) ?? 0) + 1)\n          // delete from tracked promises\n          expireByPeer.delete(p)\n          // for metrics\n          brokenPromises++\n        }\n      })\n      // clean up empty promises for a msgId\n      if (!expireByPeer.size) {\n        this.promises.delete(msgId)\n      }\n    })\n\n    this.metrics?.iwantPromiseBroken.inc(brokenPromises)\n\n    return result\n  }\n\n  /**\n   * Someone delivered a message, stop tracking promises for it\n   */\n  deliverMessage(msgIdStr: MsgIdStr, isDuplicate = false): void {\n    this.trackMessage(msgIdStr)\n\n    const expireByPeer = this.promises.get(msgIdStr)\n\n    // Expired promise, check requestMsByMsg\n    if (expireByPeer) {\n      this.promises.delete(msgIdStr)\n\n      if (this.metrics) {\n        this.metrics.iwantPromiseResolved.inc(1)\n        if (isDuplicate) this.metrics.iwantPromiseResolvedFromDuplicate.inc(1)\n        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size)\n      }\n    }\n  }\n\n  /**\n   * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,\n   * unless its an obviously invalid message.\n   */\n  rejectMessage(msgIdStr: MsgIdStr, reason: RejectReason): void {\n    this.trackMessage(msgIdStr)\n\n    // A message got rejected, so we can stop tracking promises and let the score penalty apply.\n    // With the expection of obvious invalid messages\n    switch (reason) {\n      case RejectReason.Error:\n        return\n    }\n\n    this.promises.delete(msgIdStr)\n  }\n\n  clear(): void {\n    this.promises.clear()\n  }\n\n  prune(): void {\n    const maxMs = Date.now() - this.requestMsByMsgExpire\n    let count = 0\n\n    for (const [k, v] of this.requestMsByMsg.entries()) {\n      if (v < maxMs) {\n        // messages that stay too long in the requestMsByMsg map, delete\n        this.requestMsByMsg.delete(k)\n        count++\n      } else {\n        // recent messages, keep them\n        // sort by insertion order\n        break\n      }\n    }\n\n    this.metrics?.iwantMessagePruned.inc(count)\n  }\n\n  private trackMessage(msgIdStr: MsgIdStr): void {\n    if (this.metrics) {\n      const requestMs = this.requestMsByMsg.get(msgIdStr)\n      if (requestMs !== undefined) {\n        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1000)\n        this.requestMsByMsg.delete(msgIdStr)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}