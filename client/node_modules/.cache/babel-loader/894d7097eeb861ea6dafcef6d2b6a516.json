{"ast":null,"code":"import 'node-forge/lib/pkcs7.js';\nimport 'node-forge/lib/pbe.js'; // @ts-expect-error types are missing\n\nimport forge from 'node-forge/lib/forge.js';\nimport { certificateForKey, findAsync } from './util.js';\nimport errCode from 'err-code';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { codes } from '../errors.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:keychain:cms');\nconst privates = new WeakMap();\n/**\n * Cryptographic Message Syntax (aka PKCS #7)\n *\n * CMS describes an encapsulation syntax for data protection. It\n * is used to digitally sign, digest, authenticate, or encrypt\n * arbitrary message content.\n *\n * See RFC 5652 for all the details.\n */\n\nexport class CMS {\n  /**\n   * Creates a new instance with a keychain\n   */\n  constructor(keychain, dek) {\n    if (keychain == null) {\n      throw errCode(new Error('keychain is required'), codes.ERR_KEYCHAIN_REQUIRED);\n    }\n\n    this.keychain = keychain;\n    privates.set(this, {\n      dek\n    });\n  }\n  /**\n   * Creates some protected data.\n   *\n   * The output Uint8Array contains the PKCS #7 message in DER.\n   */\n\n\n  async encrypt(name, plain) {\n    if (!(plain instanceof Uint8Array)) {\n      throw errCode(new Error('Plain data must be a Uint8Array'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    const key = await this.keychain.findKeyByName(name);\n    const pem = await this.keychain.getPrivateKey(name);\n    const cached = privates.get(this);\n\n    if (cached == null) {\n      throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    const dek = cached.dek;\n    const privateKey = forge.pki.decryptRsaPrivateKey(pem, dek);\n    const certificate = await certificateForKey(key, privateKey); // create a p7 enveloped message\n\n    const p7 = forge.pkcs7.createEnvelopedData();\n    p7.addRecipient(certificate);\n    p7.content = forge.util.createBuffer(plain);\n    p7.encrypt(); // convert message to DER\n\n    const der = forge.asn1.toDer(p7.toAsn1()).getBytes();\n    return uint8ArrayFromString(der, 'ascii');\n  }\n  /**\n   * Reads some protected data.\n   *\n   * The keychain must contain one of the keys used to encrypt the data.  If none of the keys\n   * exists, an Error is returned with the property 'missingKeys'.  It is array of key ids.\n   */\n\n\n  async decrypt(cmsData) {\n    if (!(cmsData instanceof Uint8Array)) {\n      throw errCode(new Error('CMS data is required'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    let cms;\n\n    try {\n      const buf = forge.util.createBuffer(uint8ArrayToString(cmsData, 'ascii'));\n      const obj = forge.asn1.fromDer(buf);\n      cms = forge.pkcs7.messageFromAsn1(obj);\n    } catch (err) {\n      log.error(err);\n      throw errCode(new Error('Invalid CMS'), codes.ERR_INVALID_CMS);\n    } // Find a recipient whose key we hold. We only deal with recipient certs\n    // issued by ipfs (O=ipfs).\n\n\n    const recipients = cms.recipients // @ts-expect-error cms types not defined\n    .filter(r => r.issuer.find(a => a.shortName === 'O' && a.value === 'ipfs')) // @ts-expect-error cms types not defined\n    .filter(r => r.issuer.find(a => a.shortName === 'CN')) // @ts-expect-error cms types not defined\n    .map(r => {\n      return {\n        recipient: r,\n        // @ts-expect-error cms types not defined\n        keyId: r.issuer.find(a => a.shortName === 'CN').value\n      };\n    });\n    const r = await findAsync(recipients, async recipient => {\n      try {\n        const key = await this.keychain.findKeyById(recipient.keyId);\n\n        if (key != null) {\n          return true;\n        }\n      } catch (err) {\n        return false;\n      }\n\n      return false;\n    });\n\n    if (r == null) {\n      // @ts-expect-error cms types not defined\n      const missingKeys = recipients.map(r => r.keyId);\n      throw errCode(new Error(`Decryption needs one of the key(s): ${missingKeys.join(', ')}`), codes.ERR_MISSING_KEYS, {\n        missingKeys\n      });\n    }\n\n    const key = await this.keychain.findKeyById(r.keyId);\n\n    if (key == null) {\n      throw errCode(new Error('No key available to decrypto'), codes.ERR_NO_KEY);\n    }\n\n    const pem = await this.keychain.getPrivateKey(key.name);\n    const cached = privates.get(this);\n\n    if (cached == null) {\n      throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    const dek = cached.dek;\n    const privateKey = forge.pki.decryptRsaPrivateKey(pem, dek);\n    cms.decrypt(r.recipient, privateKey);\n    return uint8ArrayFromString(cms.content.getBytes(), 'ascii');\n  }\n\n}","map":{"version":3,"mappings":"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","names":["forge","certificateForKey","findAsync","errCode","fromString","uint8ArrayFromString","toString","uint8ArrayToString","codes","logger","log","privates","WeakMap","CMS","constructor","keychain","dek","Error","ERR_KEYCHAIN_REQUIRED","set","encrypt","name","plain","Uint8Array","ERR_INVALID_PARAMETERS","key","findKeyByName","pem","getPrivateKey","cached","get","privateKey","pki","decryptRsaPrivateKey","certificate","p7","pkcs7","createEnvelopedData","addRecipient","content","util","createBuffer","der","asn1","toDer","toAsn1","getBytes","decrypt","cmsData","cms","buf","obj","fromDer","messageFromAsn1","err","error","ERR_INVALID_CMS","recipients","filter","r","issuer","find","a","shortName","value","map","recipient","keyId","findKeyById","missingKeys","join","ERR_MISSING_KEYS","ERR_NO_KEY"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\keychain\\cms.ts"],"sourcesContent":["import 'node-forge/lib/pkcs7.js'\nimport 'node-forge/lib/pbe.js'\n// @ts-expect-error types are missing\nimport forge from 'node-forge/lib/forge.js'\nimport { certificateForKey, findAsync } from './util.js'\nimport errCode from 'err-code'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { codes } from '../errors.js'\nimport { logger } from '@libp2p/logger'\nimport type { KeyChain } from './index.js'\n\nconst log = logger('libp2p:keychain:cms')\n\nconst privates = new WeakMap<object, { dek: string }>()\n\n/**\n * Cryptographic Message Syntax (aka PKCS #7)\n *\n * CMS describes an encapsulation syntax for data protection. It\n * is used to digitally sign, digest, authenticate, or encrypt\n * arbitrary message content.\n *\n * See RFC 5652 for all the details.\n */\nexport class CMS {\n  private readonly keychain: KeyChain\n\n  /**\n   * Creates a new instance with a keychain\n   */\n  constructor (keychain: KeyChain, dek: string) {\n    if (keychain == null) {\n      throw errCode(new Error('keychain is required'), codes.ERR_KEYCHAIN_REQUIRED)\n    }\n\n    this.keychain = keychain\n    privates.set(this, { dek })\n  }\n\n  /**\n   * Creates some protected data.\n   *\n   * The output Uint8Array contains the PKCS #7 message in DER.\n   */\n  async encrypt (name: string, plain: Uint8Array): Promise<Uint8Array> {\n    if (!(plain instanceof Uint8Array)) {\n      throw errCode(new Error('Plain data must be a Uint8Array'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    const key = await this.keychain.findKeyByName(name)\n    const pem = await this.keychain.getPrivateKey(name)\n    const cached = privates.get(this)\n\n    if (cached == null) {\n      throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    const dek = cached.dek\n    const privateKey = forge.pki.decryptRsaPrivateKey(pem, dek)\n    const certificate = await certificateForKey(key, privateKey)\n\n    // create a p7 enveloped message\n    const p7 = forge.pkcs7.createEnvelopedData()\n    p7.addRecipient(certificate)\n    p7.content = forge.util.createBuffer(plain)\n    p7.encrypt()\n\n    // convert message to DER\n    const der = forge.asn1.toDer(p7.toAsn1()).getBytes()\n    return uint8ArrayFromString(der, 'ascii')\n  }\n\n  /**\n   * Reads some protected data.\n   *\n   * The keychain must contain one of the keys used to encrypt the data.  If none of the keys\n   * exists, an Error is returned with the property 'missingKeys'.  It is array of key ids.\n   */\n  async decrypt (cmsData: Uint8Array): Promise<Uint8Array> {\n    if (!(cmsData instanceof Uint8Array)) {\n      throw errCode(new Error('CMS data is required'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    let cms: any\n    try {\n      const buf = forge.util.createBuffer(uint8ArrayToString(cmsData, 'ascii'))\n      const obj = forge.asn1.fromDer(buf)\n\n      cms = forge.pkcs7.messageFromAsn1(obj)\n    } catch (err: any) {\n      log.error(err)\n      throw errCode(new Error('Invalid CMS'), codes.ERR_INVALID_CMS)\n    }\n\n    // Find a recipient whose key we hold. We only deal with recipient certs\n    // issued by ipfs (O=ipfs).\n    const recipients: any = cms.recipients\n      // @ts-expect-error cms types not defined\n      .filter(r => r.issuer.find(a => a.shortName === 'O' && a.value === 'ipfs'))\n      // @ts-expect-error cms types not defined\n      .filter(r => r.issuer.find(a => a.shortName === 'CN'))\n      // @ts-expect-error cms types not defined\n      .map(r => {\n        return {\n          recipient: r,\n          // @ts-expect-error cms types not defined\n          keyId: r.issuer.find(a => a.shortName === 'CN').value\n        }\n      })\n\n    const r = await findAsync(recipients, async (recipient: any) => {\n      try {\n        const key = await this.keychain.findKeyById(recipient.keyId)\n        if (key != null) {\n          return true\n        }\n      } catch (err: any) {\n        return false\n      }\n      return false\n    })\n\n    if (r == null) {\n      // @ts-expect-error cms types not defined\n      const missingKeys: string[] = recipients.map(r => r.keyId)\n      throw errCode(new Error(`Decryption needs one of the key(s): ${missingKeys.join(', ')}`), codes.ERR_MISSING_KEYS, {\n        missingKeys\n      })\n    }\n\n    const key = await this.keychain.findKeyById(r.keyId)\n\n    if (key == null) {\n      throw errCode(new Error('No key available to decrypto'), codes.ERR_NO_KEY)\n    }\n\n    const pem = await this.keychain.getPrivateKey(key.name)\n    const cached = privates.get(this)\n\n    if (cached == null) {\n      throw errCode(new Error('dek missing'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    const dek = cached.dek\n    const privateKey = forge.pki.decryptRsaPrivateKey(pem, dek)\n    cms.decrypt(r.recipient, privateKey)\n    return uint8ArrayFromString(cms.content.getBytes(), 'ascii')\n  }\n}\n"]},"metadata":{},"sourceType":"module"}