{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errcode from 'err-code';\nimport mergeOpts from 'merge-options';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { base36 } from 'multiformats/bases/base36';\nimport { peerIdFromString } from '@libp2p/peer-id'; // @ts-expect-error no types\n\nimport isDomain from 'is-domain-name';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { OFFLINE_ERROR } from '../../utils.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nconst log = logger('ipfs:name:resolve');\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\n\nconst appendRemainder = (result, remainder) => remainder.length > 0 ? result + '/' + remainder.join('/') : result;\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {object} config\n * @param {import('ipfs-core-types/src/root').API<{}>[\"dns\"]} config.dns\n * @param {import('../ipns').IPNSAPI} config.ipns\n * @param {import('ipfs-core-types/src/root').API<{}>[\"isOnline\"]} config.isOnline\n * @param {import('../../types').Options} config.options\n */\n\n\nexport function createResolve(_ref) {\n  let {\n    dns,\n    ipns,\n    isOnline,\n    options: {\n      offline\n    }\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/name').API<{}>[\"resolve\"]}\n   */\n  async function* resolve(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options); // TODO: params related logic should be in the core implementation\n\n    if (offline && options && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');\n    } // IPNS resolve needs a online daemon\n\n\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n    }\n\n    let ipnsName = name.toString();\n\n    if (!ipnsName.startsWith('/ipns/')) {\n      ipnsName = `/ipns/${ipnsName}`;\n    }\n\n    let [namespace, hash, ...remainder] = ipnsName.slice(1).split('/');\n\n    try {\n      if (hash.substring(0, 1) === '1') {\n        const id = peerIdFromString(hash);\n        const digest = Digest.decode(id.toBytes());\n        const libp2pKey = CID.createV1(0x72, digest);\n        hash = libp2pKey.toString(base36);\n      } else {\n        const cid = CID.parse(hash);\n\n        if (cid.version === 1) {\n          hash = cid.toString(base36);\n        }\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder(await dns(hash, options), remainder);\n        return;\n      }\n\n      log.error(err);\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');\n    } // multihash is valid lets resolve with IPNS\n    // TODO: convert ipns.resolve to return an iterator\n\n\n    const value = await ipns.resolve(`/${namespace}/${hash}`, options);\n    yield appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder);\n  }\n\n  return withTimeoutOption(resolve);\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/name/resolve.js"],"names":["logger","errcode","mergeOpts","CID","Digest","base36","peerIdFromString","isDomain","toString","uint8ArrayToString","OFFLINE_ERROR","withTimeoutOption","mergeOptions","bind","ignoreUndefined","log","appendRemainder","result","remainder","length","join","createResolve","dns","ipns","isOnline","options","offline","resolve","name","nocache","recursive","Error","ipnsName","startsWith","namespace","hash","slice","split","substring","id","digest","decode","toBytes","libp2pKey","createV1","cid","parse","version","err","error","value","Uint8Array"],"mappings":"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","sourcesContent":["import { logger } from '@libp2p/logger'\nimport errcode from 'err-code'\nimport mergeOpts from 'merge-options'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { base36 } from 'multiformats/bases/base36'\nimport { peerIdFromString } from '@libp2p/peer-id'\n// @ts-expect-error no types\nimport isDomain from 'is-domain-name'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { OFFLINE_ERROR } from '../../utils.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\n\nconst log = logger('ipfs:name:resolve')\n\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\nconst appendRemainder = (result, remainder) =>\n  remainder.length > 0\n    ? result + '/' + remainder.join('/')\n    : result\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {object} config\n * @param {import('ipfs-core-types/src/root').API<{}>[\"dns\"]} config.dns\n * @param {import('../ipns').IPNSAPI} config.ipns\n * @param {import('ipfs-core-types/src/root').API<{}>[\"isOnline\"]} config.isOnline\n * @param {import('../../types').Options} config.options\n */\nexport function createResolve ({ dns, ipns, isOnline, options: { offline } }) {\n  /**\n   * @type {import('ipfs-core-types/src/name').API<{}>[\"resolve\"]}\n   */\n  async function * resolve (name, options = {}) { // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options)\n\n    // TODO: params related logic should be in the core implementation\n    if (offline && options && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE')\n    }\n\n    // IPNS resolve needs a online daemon\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    let ipnsName = name.toString()\n\n    if (!ipnsName.startsWith('/ipns/')) {\n      ipnsName = `/ipns/${ipnsName}`\n    }\n\n    let [namespace, hash, ...remainder] = ipnsName.slice(1).split('/')\n\n    try {\n      if (hash.substring(0, 1) === '1') {\n        const id = peerIdFromString(hash)\n        const digest = Digest.decode(id.toBytes())\n        const libp2pKey = CID.createV1(0x72, digest)\n        hash = libp2pKey.toString(base36)\n      } else {\n        const cid = CID.parse(hash)\n\n        if (cid.version === 1) {\n          hash = cid.toString(base36)\n        }\n      }\n    } catch (/** @type {any} */ err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder(await dns(hash, options), remainder)\n        return\n      }\n\n      log.error(err)\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME')\n    }\n\n    // multihash is valid lets resolve with IPNS\n    // TODO: convert ipns.resolve to return an iterator\n    const value = await ipns.resolve(`/${namespace}/${hash}`, options)\n    yield appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder)\n  }\n\n  return withTimeoutOption(resolve)\n}\n"]},"metadata":{},"sourceType":"module"}