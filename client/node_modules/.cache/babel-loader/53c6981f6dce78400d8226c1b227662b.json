{"ast":null,"code":"import mortice from 'mortice';\n/**\n * @typedef {object} Lock\n * @property {(fn: (...args: any) => any) => (...args: any) => any} readLock\n * @property {(fn: (...args: any) => any) => (...args: any) => any} writeLock\n */\n\n/** @type {Lock} */\n\nlet lock;\n/**\n * @param {boolean} [repoOwner]\n */\n\nexport function createLock() {\n  let repoOwner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n  if (lock) {\n    return lock;\n  }\n\n  const mutex = mortice({\n    // ordinarily the main thread would store the read/write lock but\n    // if we are the thread that owns the repo, we can store the lock\n    // on this process even if we are a worker thread\n    singleProcess: repoOwner\n  });\n  lock = {\n    readLock: func => {\n      return async function () {\n        const releaseLock = await mutex.readLock();\n\n        try {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return await func.apply(null, args);\n        } finally {\n          releaseLock();\n        }\n      };\n    },\n    writeLock: func => {\n      return async function () {\n        const releaseLock = await mutex.writeLock();\n\n        try {\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          return await func.apply(null, args);\n        } finally {\n          releaseLock();\n        }\n      };\n    }\n  };\n  return lock;\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/files/utils/create-lock.js"],"names":["mortice","lock","createLock","repoOwner","mutex","singleProcess","readLock","func","releaseLock","args","apply","writeLock"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,SAApB;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AACA,IAAIC,IAAJ;AAEA;AACA;AACA;;AACA,OAAO,SAASC,UAAT,GAAwC;AAAA,MAAnBC,SAAmB,uEAAP,KAAO;;AAC7C,MAAIF,IAAJ,EAAU;AACR,WAAOA,IAAP;AACD;;AAED,QAAMG,KAAK,GAAGJ,OAAO,CAAC;AACpB;AACA;AACA;AACAK,IAAAA,aAAa,EAAEF;AAJK,GAAD,CAArB;AAOAF,EAAAA,IAAI,GAAG;AACLK,IAAAA,QAAQ,EAAGC,IAAD,IAAU;AAClB,aAAO,kBAAmB;AACxB,cAAMC,WAAW,GAAG,MAAMJ,KAAK,CAACE,QAAN,EAA1B;;AAEA,YAAI;AAAA,4CAHWG,IAGX;AAHWA,YAAAA,IAGX;AAAA;;AACF,iBAAO,MAAMF,IAAI,CAACG,KAAL,CAAW,IAAX,EAAiBD,IAAjB,CAAb;AACD,SAFD,SAEU;AACRD,UAAAA,WAAW;AACZ;AACF,OARD;AASD,KAXI;AAaLG,IAAAA,SAAS,EAAGJ,IAAD,IAAU;AACnB,aAAO,kBAAmB;AACxB,cAAMC,WAAW,GAAG,MAAMJ,KAAK,CAACO,SAAN,EAA1B;;AAEA,YAAI;AAAA,6CAHWF,IAGX;AAHWA,YAAAA,IAGX;AAAA;;AACF,iBAAO,MAAMF,IAAI,CAACG,KAAL,CAAW,IAAX,EAAiBD,IAAjB,CAAb;AACD,SAFD,SAEU;AACRD,UAAAA,WAAW;AACZ;AACF,OARD;AASD;AAvBI,GAAP;AA0BA,SAAOP,IAAP;AACD","sourcesContent":["import mortice from 'mortice'\n\n/**\n * @typedef {object} Lock\n * @property {(fn: (...args: any) => any) => (...args: any) => any} readLock\n * @property {(fn: (...args: any) => any) => (...args: any) => any} writeLock\n */\n\n/** @type {Lock} */\nlet lock\n\n/**\n * @param {boolean} [repoOwner]\n */\nexport function createLock (repoOwner = false) {\n  if (lock) {\n    return lock\n  }\n\n  const mutex = mortice({\n    // ordinarily the main thread would store the read/write lock but\n    // if we are the thread that owns the repo, we can store the lock\n    // on this process even if we are a worker thread\n    singleProcess: repoOwner\n  })\n\n  lock = {\n    readLock: (func) => {\n      return async (...args) => {\n        const releaseLock = await mutex.readLock()\n\n        try {\n          return await func.apply(null, args)\n        } finally {\n          releaseLock()\n        }\n      }\n    },\n\n    writeLock: (func) => {\n      return async (...args) => {\n        const releaseLock = await mutex.writeLock()\n\n        try {\n          return await func.apply(null, args)\n        } finally {\n          releaseLock()\n        }\n      }\n    }\n  }\n\n  return lock\n}\n"]},"metadata":{},"sourceType":"module"}