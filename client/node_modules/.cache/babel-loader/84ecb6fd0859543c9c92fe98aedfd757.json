{"ast":null,"code":"import { pushable } from 'it-pushable';\nimport merge from 'it-merge';\nexport function pipe(first) {\n  if (first == null) {\n    throw new Error('Empty pipeline');\n  } // Duplex at start: wrap in function and return duplex source\n\n\n  if (isDuplex(first)) {\n    const duplex = first;\n\n    first = () => duplex.source; // Iterable at start: wrap in function\n\n  } else if (isIterable(first) || isAsyncIterable(first)) {\n    const source = first;\n\n    first = () => source;\n  }\n\n  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    rest[_key - 1] = arguments[_key];\n  }\n\n  const fns = [first, ...rest];\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink;\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i]);\n      }\n    }\n  }\n\n  return rawPipe(...fns);\n}\nexport const rawPipe = function () {\n  let res;\n\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  while (fns.length > 0) {\n    res = fns.shift()(res);\n  }\n\n  return res;\n};\n\nconst isAsyncIterable = obj => {\n  return obj?.[Symbol.asyncIterator] != null;\n};\n\nconst isIterable = obj => {\n  return obj?.[Symbol.iterator] != null;\n};\n\nconst isDuplex = obj => {\n  if (obj == null) {\n    return false;\n  }\n\n  return obj.sink != null && obj.source != null;\n};\n\nconst duplexPipelineFn = duplex => {\n  return source => {\n    const p = duplex.sink(source);\n\n    if (p?.then != null) {\n      const stream = pushable({\n        objectMode: true\n      });\n      p.then(() => {\n        stream.end();\n      }, err => {\n        stream.end(err);\n      });\n      let sourceWrap;\n      const source = duplex.source;\n\n      if (isAsyncIterable(source)) {\n        sourceWrap = async function* () {\n          yield* source;\n          stream.end();\n        };\n      } else if (isIterable(source)) {\n        sourceWrap = function* () {\n          yield* source;\n          stream.end();\n        };\n      } else {\n        throw new Error('Unknown duplex source type - must be Iterable or AsyncIterable');\n      }\n\n      return merge(stream, sourceWrap());\n    }\n\n    return duplex.source;\n  };\n};","map":{"version":3,"mappings":"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","names":["pushable","merge","pipe","first","Error","isDuplex","duplex","source","isIterable","isAsyncIterable","rest","fns","length","sink","i","duplexPipelineFn","rawPipe","res","shift","obj","Symbol","asyncIterator","iterator","p","then","stream","objectMode","end","err","sourceWrap"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\multistream-select\\node_modules\\it-pipe\\src\\index.ts"],"sourcesContent":["import { pushable } from 'it-pushable'\nimport merge from 'it-merge'\nimport type { Duplex, Transform, Sink } from 'it-stream-types'\n\ninterface SourceFn<A = any> { (): A }\n\ntype PipeSource<A = any> =\n  Iterable<A> |\n  AsyncIterable<A> |\n  SourceFn<A> |\n  Duplex<A, any, any>\n\ntype PipeTransform<A = any, B = any> =\n  Transform<A, B> |\n  Duplex<B, A>\n\ntype PipeSink<A = any, B = any> =\n  Sink<A, B> |\n  Duplex<any, A, B>\n\ntype PipeOutput<A> =\n  A extends Sink<any> ? ReturnType<A> :\n    A extends Duplex<any, any, any> ? ReturnType<A['sink']> :\n      never\n\n// single item pipe output includes pipe source types\ntype SingleItemPipeOutput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Duplex<any, any, any> ? A['source'] :\n          PipeOutput<A>\n\ntype PipeFnInput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Transform<any, any> ? ReturnType<A> :\n          A extends Duplex<any, any, any> ? A['source'] :\n            never\n\n// one item, just a pass-through\nexport function pipe<\n  A extends PipeSource\n> (\n  source: A\n): SingleItemPipeOutput<A>\n\n// two items, source to sink\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeSink<PipeFnInput<A>>\n> (\n  source: A,\n  sink: B\n): PipeOutput<B>\n\n// three items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeSink<PipeFnInput<B>>\n> (\n  source: A,\n  transform1: B,\n  sink: C\n): PipeOutput<C>\n\n// many items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeSink<PipeFnInput<C>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  sink: D\n): PipeOutput<D>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeSink<PipeFnInput<D>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  sink: E\n): PipeOutput<E>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeSink<PipeFnInput<E>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  sink: F\n): PipeOutput<F>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeSink<PipeFnInput<F>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  sink: G\n): PipeOutput<G>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeSink<PipeFnInput<G>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  sink: H\n): PipeOutput<H>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeSink<PipeFnInput<H>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  sink: I\n): PipeOutput<I>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeSink<PipeFnInput<I>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  sink: J\n): PipeOutput<J>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeSink<PipeFnInput<J>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  sink: K\n): PipeOutput<K>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeTransform<PipeFnInput<J>>,\n  L extends PipeSink<PipeFnInput<K>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  transform10: K,\n  sink: L\n): PipeOutput<L>\n\nexport function pipe (first: any, ...rest: any[]): any {\n  if (first == null) {\n    throw new Error('Empty pipeline')\n  }\n\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(first)) {\n    const duplex = first\n    first = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(first) || isAsyncIterable(first)) {\n    const source = first\n    first = () => source\n  }\n\n  const fns = [first, ...rest]\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n\nexport const rawPipe = (...fns: any): any => {\n  let res\n  while (fns.length > 0) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nconst isAsyncIterable = (obj: any): obj is AsyncIterable<unknown> => {\n  return obj?.[Symbol.asyncIterator] != null\n}\n\nconst isIterable = (obj: any): obj is Iterable<unknown> => {\n  return obj?.[Symbol.iterator] != null\n}\n\nconst isDuplex = (obj: any): obj is Duplex => {\n  if (obj == null) {\n    return false\n  }\n\n  return obj.sink != null && obj.source != null\n}\n\nconst duplexPipelineFn = (duplex: Duplex<any, any, any>) => {\n  return (source: any) => {\n    const p = duplex.sink(source)\n\n    if (p?.then != null) {\n      const stream = pushable<any>({\n        objectMode: true\n      })\n      p.then(() => {\n        stream.end()\n      }, (err: Error) => {\n        stream.end(err)\n      })\n\n      let sourceWrap: () => Iterable<any> | AsyncIterable<any>\n      const source = duplex.source\n\n      if (isAsyncIterable(source)) {\n        sourceWrap = async function * () {\n          yield * source\n          stream.end()\n        }\n      } else if (isIterable(source)) {\n        sourceWrap = function * () {\n          yield * source\n          stream.end()\n        }\n      } else {\n        throw new Error('Unknown duplex source type - must be Iterable or AsyncIterable')\n      }\n\n      return merge(stream, sourceWrap())\n    }\n\n    return duplex.source\n  }\n}\n"]},"metadata":{},"sourceType":"module"}