{"ast":null,"code":"import dirBuilder from './dir.js';\nimport fileBuilder from './file/index.js';\nimport errCode from 'err-code';\nimport rabin from '../chunker/rabin.js';\nimport fixedSize from '../chunker/fixed-size.js';\nimport validateChunks from './validate-chunks.js';\n/**\n * @typedef {import('../types').File} File\n * @typedef {import('../types').Directory} Directory\n * @typedef {import('../types').DAGBuilder} DAGBuilder\n * @typedef {import('../types').Chunker} Chunker\n * @typedef {import('../types').ChunkValidator} ChunkValidator\n */\n\n/**\n * @param {any} thing\n * @returns {thing is Iterable<any>}\n */\n\nfunction isIterable(thing) {\n  return Symbol.iterator in thing;\n}\n/**\n * @param {any} thing\n * @returns {thing is AsyncIterable<any>}\n */\n\n\nfunction isAsyncIterable(thing) {\n  return Symbol.asyncIterator in thing;\n}\n/**\n * @param {Uint8Array | AsyncIterable<Uint8Array> | Iterable<Uint8Array>} content\n * @returns {AsyncIterable<Uint8Array>}\n */\n\n\nfunction contentAsAsyncIterable(content) {\n  try {\n    if (content instanceof Uint8Array) {\n      return async function* () {\n        yield content;\n      }();\n    } else if (isIterable(content)) {\n      return async function* () {\n        yield* content;\n      }();\n    } else if (isAsyncIterable(content)) {\n      return content;\n    }\n  } catch {\n    throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n  }\n\n  throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n}\n/**\n * @type {DAGBuilder}\n */\n\n\nasync function* dagBuilder(source, blockstore, options) {\n  for await (const entry of source) {\n    if (entry.path) {\n      if (entry.path.substring(0, 2) === './') {\n        options.wrapWithDirectory = true;\n      }\n\n      entry.path = entry.path.split('/').filter(path => path && path !== '.').join('/');\n    }\n\n    if (entry.content) {\n      /**\n       * @type {Chunker}\n       */\n      let chunker;\n\n      if (typeof options.chunker === 'function') {\n        chunker = options.chunker;\n      } else if (options.chunker === 'rabin') {\n        chunker = rabin;\n      } else {\n        chunker = fixedSize;\n      }\n      /**\n       * @type {ChunkValidator}\n       */\n\n\n      let chunkValidator;\n\n      if (typeof options.chunkValidator === 'function') {\n        chunkValidator = options.chunkValidator;\n      } else {\n        chunkValidator = validateChunks;\n      }\n      /** @type {File} */\n\n\n      const file = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode,\n        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)\n      };\n      yield () => fileBuilder(file, blockstore, options);\n    } else if (entry.path) {\n      /** @type {Directory} */\n      const dir = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode\n      };\n      yield () => dirBuilder(dir, blockstore, options);\n    } else {\n      throw new Error('Import candidate must have content or path or both');\n    }\n  }\n}\n\nexport default dagBuilder;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-unixfs-importer/src/dag-builder/index.js"],"names":["dirBuilder","fileBuilder","errCode","rabin","fixedSize","validateChunks","isIterable","thing","Symbol","iterator","isAsyncIterable","asyncIterator","contentAsAsyncIterable","content","Uint8Array","Error","dagBuilder","source","blockstore","options","entry","path","substring","wrapWithDirectory","split","filter","join","chunker","chunkValidator","file","mtime","mode","dir"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,UAAvB;AACA,OAAOC,WAAP,MAAwB,iBAAxB;AACA,OAAOC,OAAP,MAAoB,UAApB;AACA,OAAOC,KAAP,MAAkB,qBAAlB;AACA,OAAOC,SAAP,MAAsB,0BAAtB;AACA,OAAOC,cAAP,MAA2B,sBAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA,SAASC,UAAT,CAAqBC,KAArB,EAA4B;AAC1B,SAAOC,MAAM,CAACC,QAAP,IAAmBF,KAA1B;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASG,eAAT,CAA0BH,KAA1B,EAAiC;AAC/B,SAAOC,MAAM,CAACG,aAAP,IAAwBJ,KAA/B;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASK,sBAAT,CAAiCC,OAAjC,EAA0C;AACxC,MAAI;AACF,QAAIA,OAAO,YAAYC,UAAvB,EAAmC;AACjC,aAAQ,mBAAoB;AAC1B,cAAMD,OAAN;AACD,OAFO,EAAR;AAGD,KAJD,MAIO,IAAIP,UAAU,CAACO,OAAD,CAAd,EAAyB;AAC9B,aAAQ,mBAAoB;AAC1B,eAAQA,OAAR;AACD,OAFO,EAAR;AAGD,KAJM,MAIA,IAAIH,eAAe,CAACG,OAAD,CAAnB,EAA8B;AACnC,aAAOA,OAAP;AACD;AACF,GAZD,CAYE,MAAM;AACN,UAAMX,OAAO,CAAC,IAAIa,KAAJ,CAAU,qBAAV,CAAD,EAAmC,qBAAnC,CAAb;AACD;;AAED,QAAMb,OAAO,CAAC,IAAIa,KAAJ,CAAU,qBAAV,CAAD,EAAmC,qBAAnC,CAAb;AACD;AAED;AACA;AACA;;;AACA,gBAAiBC,UAAjB,CAA6BC,MAA7B,EAAqCC,UAArC,EAAiDC,OAAjD,EAA0D;AACxD,aAAW,MAAMC,KAAjB,IAA0BH,MAA1B,EAAkC;AAChC,QAAIG,KAAK,CAACC,IAAV,EAAgB;AACd,UAAID,KAAK,CAACC,IAAN,CAAWC,SAAX,CAAqB,CAArB,EAAwB,CAAxB,MAA+B,IAAnC,EAAyC;AACvCH,QAAAA,OAAO,CAACI,iBAAR,GAA4B,IAA5B;AACD;;AAEDH,MAAAA,KAAK,CAACC,IAAN,GAAaD,KAAK,CAACC,IAAN,CACVG,KADU,CACJ,GADI,EAEVC,MAFU,CAEHJ,IAAI,IAAIA,IAAI,IAAIA,IAAI,KAAK,GAFtB,EAGVK,IAHU,CAGL,GAHK,CAAb;AAID;;AAED,QAAIN,KAAK,CAACP,OAAV,EAAmB;AACjB;AACN;AACA;AACM,UAAIc,OAAJ;;AAEA,UAAI,OAAOR,OAAO,CAACQ,OAAf,KAA2B,UAA/B,EAA2C;AACzCA,QAAAA,OAAO,GAAGR,OAAO,CAACQ,OAAlB;AACD,OAFD,MAEO,IAAIR,OAAO,CAACQ,OAAR,KAAoB,OAAxB,EAAiC;AACtCA,QAAAA,OAAO,GAAGxB,KAAV;AACD,OAFM,MAEA;AACLwB,QAAAA,OAAO,GAAGvB,SAAV;AACD;AAED;AACN;AACA;;;AACM,UAAIwB,cAAJ;;AAEA,UAAI,OAAOT,OAAO,CAACS,cAAf,KAAkC,UAAtC,EAAkD;AAChDA,QAAAA,cAAc,GAAGT,OAAO,CAACS,cAAzB;AACD,OAFD,MAEO;AACLA,QAAAA,cAAc,GAAGvB,cAAjB;AACD;AAED;;;AACA,YAAMwB,IAAI,GAAG;AACXR,QAAAA,IAAI,EAAED,KAAK,CAACC,IADD;AAEXS,QAAAA,KAAK,EAAEV,KAAK,CAACU,KAFF;AAGXC,QAAAA,IAAI,EAAEX,KAAK,CAACW,IAHD;AAIXlB,QAAAA,OAAO,EAAEc,OAAO,CAACC,cAAc,CAAChB,sBAAsB,CAACQ,KAAK,CAACP,OAAP,CAAvB,EAAwCM,OAAxC,CAAf,EAAiEA,OAAjE;AAJL,OAAb;AAOA,YAAM,MAAMlB,WAAW,CAAC4B,IAAD,EAAOX,UAAP,EAAmBC,OAAnB,CAAvB;AACD,KAlCD,MAkCO,IAAIC,KAAK,CAACC,IAAV,EAAgB;AACrB;AACA,YAAMW,GAAG,GAAG;AACVX,QAAAA,IAAI,EAAED,KAAK,CAACC,IADF;AAEVS,QAAAA,KAAK,EAAEV,KAAK,CAACU,KAFH;AAGVC,QAAAA,IAAI,EAAEX,KAAK,CAACW;AAHF,OAAZ;AAMA,YAAM,MAAM/B,UAAU,CAACgC,GAAD,EAAMd,UAAN,EAAkBC,OAAlB,CAAtB;AACD,KATM,MASA;AACL,YAAM,IAAIJ,KAAJ,CAAU,oDAAV,CAAN;AACD;AACF;AACF;;AAED,eAAeC,UAAf","sourcesContent":["import dirBuilder from './dir.js'\nimport fileBuilder from './file/index.js'\nimport errCode from 'err-code'\nimport rabin from '../chunker/rabin.js'\nimport fixedSize from '../chunker/fixed-size.js'\nimport validateChunks from './validate-chunks.js'\n\n/**\n * @typedef {import('../types').File} File\n * @typedef {import('../types').Directory} Directory\n * @typedef {import('../types').DAGBuilder} DAGBuilder\n * @typedef {import('../types').Chunker} Chunker\n * @typedef {import('../types').ChunkValidator} ChunkValidator\n */\n\n/**\n * @param {any} thing\n * @returns {thing is Iterable<any>}\n */\nfunction isIterable (thing) {\n  return Symbol.iterator in thing\n}\n\n/**\n * @param {any} thing\n * @returns {thing is AsyncIterable<any>}\n */\nfunction isAsyncIterable (thing) {\n  return Symbol.asyncIterator in thing\n}\n\n/**\n * @param {Uint8Array | AsyncIterable<Uint8Array> | Iterable<Uint8Array>} content\n * @returns {AsyncIterable<Uint8Array>}\n */\nfunction contentAsAsyncIterable (content) {\n  try {\n    if (content instanceof Uint8Array) {\n      return (async function * () {\n        yield content\n      }())\n    } else if (isIterable(content)) {\n      return (async function * () {\n        yield * content\n      }())\n    } else if (isAsyncIterable(content)) {\n      return content\n    }\n  } catch {\n    throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT')\n  }\n\n  throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT')\n}\n\n/**\n * @type {DAGBuilder}\n */\nasync function * dagBuilder (source, blockstore, options) {\n  for await (const entry of source) {\n    if (entry.path) {\n      if (entry.path.substring(0, 2) === './') {\n        options.wrapWithDirectory = true\n      }\n\n      entry.path = entry.path\n        .split('/')\n        .filter(path => path && path !== '.')\n        .join('/')\n    }\n\n    if (entry.content) {\n      /**\n       * @type {Chunker}\n       */\n      let chunker\n\n      if (typeof options.chunker === 'function') {\n        chunker = options.chunker\n      } else if (options.chunker === 'rabin') {\n        chunker = rabin\n      } else {\n        chunker = fixedSize\n      }\n\n      /**\n       * @type {ChunkValidator}\n       */\n      let chunkValidator\n\n      if (typeof options.chunkValidator === 'function') {\n        chunkValidator = options.chunkValidator\n      } else {\n        chunkValidator = validateChunks\n      }\n\n      /** @type {File} */\n      const file = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode,\n        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)\n      }\n\n      yield () => fileBuilder(file, blockstore, options)\n    } else if (entry.path) {\n      /** @type {Directory} */\n      const dir = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode\n      }\n\n      yield () => dirBuilder(dir, blockstore, options)\n    } else {\n      throw new Error('Import candidate must have content or path or both')\n    }\n  }\n}\n\nexport default dagBuilder\n"]},"metadata":{},"sourceType":"module"}