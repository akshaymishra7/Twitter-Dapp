{"ast":null,"code":"import { MessageTypeNames, MessageTypes } from './message-types.js';\nimport { Uint8ArrayList } from 'uint8arraylist';\nexport const MAX_MSG_SIZE = 1 << 20; // 1MB\n\nexport const MAX_MSG_QUEUE_SIZE = 4 << 20; // 4MB\n\nexport class Decoder {\n  constructor() {\n    let maxMessageSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MAX_MSG_SIZE;\n    let maxUnprocessedMessageQueueSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_MSG_QUEUE_SIZE;\n    this._buffer = new Uint8ArrayList();\n    this._headerInfo = null;\n    this._maxMessageSize = maxMessageSize;\n    this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;\n  }\n\n  write(chunk) {\n    if (chunk == null || chunk.length === 0) {\n      return [];\n    }\n\n    this._buffer.append(chunk);\n\n    if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {\n      throw Object.assign(new Error('unprocessed message queue size too large!'), {\n        code: 'ERR_MSG_QUEUE_TOO_BIG'\n      });\n    }\n\n    const msgs = [];\n\n    while (this._buffer.length !== 0) {\n      if (this._headerInfo == null) {\n        try {\n          this._headerInfo = this._decodeHeader(this._buffer);\n        } catch (err) {\n          if (err.code === 'ERR_MSG_TOO_BIG') {\n            throw err;\n          }\n\n          break; // We haven't received enough data yet\n        }\n      }\n\n      const {\n        id,\n        type,\n        length,\n        offset\n      } = this._headerInfo;\n      const bufferedDataLength = this._buffer.length - offset;\n\n      if (bufferedDataLength < length) {\n        break; // not enough data yet\n      }\n\n      const msg = {\n        id,\n        type\n      };\n\n      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {\n        msg.data = this._buffer.sublist(offset, offset + length);\n      }\n\n      msgs.push(msg);\n\n      this._buffer.consume(offset + length);\n\n      this._headerInfo = null;\n    }\n\n    return msgs;\n  }\n  /**\n   * Attempts to decode the message header from the buffer\n   */\n\n\n  _decodeHeader(data) {\n    const {\n      value: h,\n      offset\n    } = readVarInt(data);\n    const {\n      value: length,\n      offset: end\n    } = readVarInt(data, offset);\n    const type = h & 7; // @ts-expect-error h is a number not a CODE\n\n    if (MessageTypeNames[type] == null) {\n      throw new Error(`Invalid type received: ${type}`);\n    } // test message type varint + data length\n\n\n    if (length > this._maxMessageSize) {\n      throw Object.assign(new Error('message size too large!'), {\n        code: 'ERR_MSG_TOO_BIG'\n      });\n    } // @ts-expect-error h is a number not a CODE\n\n\n    return {\n      id: h >> 3,\n      type,\n      offset: offset + end,\n      length\n    };\n  }\n\n}\nconst MSB = 0x80;\nconst REST = 0x7F;\n\nfunction readVarInt(buf) {\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let res = 0;\n  let shift = 0;\n  let counter = offset;\n  let b;\n  const l = buf.length;\n\n  do {\n    if (counter >= l || shift > 49) {\n      offset = 0;\n      throw new RangeError('Could not decode varint');\n    }\n\n    b = buf.get(counter++);\n    res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB);\n\n  offset = counter - offset;\n  return {\n    value: res,\n    offset\n  };\n}","map":{"version":3,"mappings":"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","names":["MessageTypeNames","MessageTypes","Uint8ArrayList","MAX_MSG_SIZE","MAX_MSG_QUEUE_SIZE","Decoder","constructor","maxMessageSize","maxUnprocessedMessageQueueSize","_buffer","_headerInfo","_maxMessageSize","_maxUnprocessedMessageQueueSize","write","chunk","length","append","byteLength","Object","assign","Error","code","msgs","_decodeHeader","err","id","type","offset","bufferedDataLength","msg","NEW_STREAM","MESSAGE_INITIATOR","MESSAGE_RECEIVER","data","sublist","push","consume","value","h","readVarInt","end","MSB","REST","buf","res","shift","counter","b","l","RangeError","get","Math","pow"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\mplex\\src\\decode.ts"],"sourcesContent":["import { MessageTypeNames, MessageTypes } from './message-types.js'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport type { Message } from './message-types.js'\n\nexport const MAX_MSG_SIZE = 1 << 20 // 1MB\nexport const MAX_MSG_QUEUE_SIZE = 4 << 20 // 4MB\n\ninterface MessageHeader {\n  id: number\n  type: keyof typeof MessageTypeNames\n  offset: number\n  length: number\n}\n\nexport class Decoder {\n  private readonly _buffer: Uint8ArrayList\n  private _headerInfo: MessageHeader | null\n  private readonly _maxMessageSize: number\n  private readonly _maxUnprocessedMessageQueueSize: number\n\n  constructor (maxMessageSize: number = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize: number = MAX_MSG_QUEUE_SIZE) {\n    this._buffer = new Uint8ArrayList()\n    this._headerInfo = null\n    this._maxMessageSize = maxMessageSize\n    this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize\n  }\n\n  write (chunk: Uint8Array): Message[] {\n    if (chunk == null || chunk.length === 0) {\n      return []\n    }\n\n    this._buffer.append(chunk)\n\n    if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {\n      throw Object.assign(new Error('unprocessed message queue size too large!'), { code: 'ERR_MSG_QUEUE_TOO_BIG' })\n    }\n\n    const msgs: Message[] = []\n\n    while (this._buffer.length !== 0) {\n      if (this._headerInfo == null) {\n        try {\n          this._headerInfo = this._decodeHeader(this._buffer)\n        } catch (err: any) {\n          if (err.code === 'ERR_MSG_TOO_BIG') {\n            throw err\n          }\n\n          break // We haven't received enough data yet\n        }\n      }\n\n      const { id, type, length, offset } = this._headerInfo\n      const bufferedDataLength = this._buffer.length - offset\n\n      if (bufferedDataLength < length) {\n        break // not enough data yet\n      }\n\n      const msg: any = {\n        id,\n        type\n      }\n\n      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {\n        msg.data = this._buffer.sublist(offset, offset + length)\n      }\n\n      msgs.push(msg)\n\n      this._buffer.consume(offset + length)\n      this._headerInfo = null\n    }\n\n    return msgs\n  }\n\n  /**\n   * Attempts to decode the message header from the buffer\n   */\n  _decodeHeader (data: Uint8ArrayList): MessageHeader {\n    const {\n      value: h,\n      offset\n    } = readVarInt(data)\n    const {\n      value: length,\n      offset: end\n    } = readVarInt(data, offset)\n\n    const type = h & 7\n\n    // @ts-expect-error h is a number not a CODE\n    if (MessageTypeNames[type] == null) {\n      throw new Error(`Invalid type received: ${type}`)\n    }\n\n    // test message type varint + data length\n    if (length > this._maxMessageSize) {\n      throw Object.assign(new Error('message size too large!'), { code: 'ERR_MSG_TOO_BIG' })\n    }\n\n    // @ts-expect-error h is a number not a CODE\n    return { id: h >> 3, type, offset: offset + end, length }\n  }\n}\n\nconst MSB = 0x80\nconst REST = 0x7F\n\nexport interface ReadVarIntResult {\n  value: number\n  offset: number\n}\n\nfunction readVarInt (buf: Uint8ArrayList, offset: number = 0): ReadVarIntResult {\n  let res = 0\n  let shift = 0\n  let counter = offset\n  let b: number\n  const l = buf.length\n\n  do {\n    if (counter >= l || shift > 49) {\n      offset = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf.get(counter++)\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  offset = counter - offset\n\n  return {\n    value: res,\n    offset\n  }\n}\n"]},"metadata":{},"sourceType":"module"}