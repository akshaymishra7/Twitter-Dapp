{"ast":null,"code":"import { concat } from 'uint8arrays/concat';\nimport { equals } from 'uint8arrays/equals';\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc';\nconst symbol = Symbol.for('@achingbrain/uint8arraylist');\n\nfunction findBufAndOffset(bufs, index) {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds');\n  }\n\n  let offset = 0;\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength;\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      };\n    }\n\n    offset = bufEnd;\n  }\n\n  throw new RangeError('index is out of bounds');\n}\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\n\n\nexport function isUint8ArrayList(value) {\n  return Boolean(value?.[symbol]);\n}\nexport class Uint8ArrayList {\n  constructor() {\n    // Define symbol\n    Object.defineProperty(this, symbol, {\n      value: true\n    });\n    this.bufs = [];\n    this.length = 0;\n\n    for (var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++) {\n      data[_key] = arguments[_key];\n    }\n\n    if (data.length > 0) {\n      this.appendAll(data);\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.bufs;\n  }\n\n  get byteLength() {\n    return this.length;\n  }\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n\n\n  append() {\n    for (var _len2 = arguments.length, bufs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      bufs[_key2] = arguments[_key2];\n    }\n\n    this.appendAll(bufs);\n  }\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n\n\n  appendAll(bufs) {\n    let length = 0;\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength;\n        this.bufs.push(buf);\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength;\n        this.bufs.push(...buf.bufs);\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList');\n      }\n    }\n\n    this.length += length;\n  }\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n\n\n  prepend() {\n    for (var _len3 = arguments.length, bufs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      bufs[_key3] = arguments[_key3];\n    }\n\n    this.prependAll(bufs);\n  }\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n\n\n  prependAll(bufs) {\n    let length = 0;\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength;\n        this.bufs.unshift(buf);\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength;\n        this.bufs.unshift(...buf.bufs);\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList');\n      }\n    }\n\n    this.length += length;\n  }\n  /**\n   * Read the value at `index`\n   */\n\n\n  get(index) {\n    const res = findBufAndOffset(this.bufs, index);\n    return res.buf[res.index];\n  }\n  /**\n   * Set the value at `index` to `value`\n   */\n\n\n  set(index, value) {\n    const res = findBufAndOffset(this.bufs, index);\n    res.buf[res.index] = value;\n  }\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n\n\n  write(buf) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i]);\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i));\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList');\n    }\n  }\n  /**\n   * Remove bytes from the front of the pool\n   */\n\n\n  consume(bytes) {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes); // do nothing if not a positive number\n\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return;\n    } // if consuming all bytes, skip iterating\n\n\n    if (bytes === this.byteLength) {\n      this.bufs = [];\n      this.length = 0;\n      return;\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength;\n        this.length -= this.bufs[0].byteLength;\n        this.bufs.shift();\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes);\n        this.length -= bytes;\n        break;\n      }\n    }\n  }\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n\n\n  slice(beginInclusive, endExclusive) {\n    const {\n      bufs,\n      length\n    } = this._subList(beginInclusive, endExclusive);\n\n    return concat(bufs, length);\n  }\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n\n\n  subarray(beginInclusive, endExclusive) {\n    const {\n      bufs,\n      length\n    } = this._subList(beginInclusive, endExclusive);\n\n    if (bufs.length === 1) {\n      return bufs[0];\n    }\n\n    return concat(bufs, length);\n  }\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n\n\n  sublist(beginInclusive, endExclusive) {\n    const {\n      bufs,\n      length\n    } = this._subList(beginInclusive, endExclusive);\n\n    const list = new Uint8ArrayList();\n    list.length = length; // don't loop, just set the bufs\n\n    list.bufs = bufs;\n    return list;\n  }\n\n  _subList(beginInclusive, endExclusive) {\n    beginInclusive = beginInclusive ?? 0;\n    endExclusive = endExclusive ?? this.length;\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive;\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive;\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds');\n    }\n\n    if (beginInclusive === endExclusive) {\n      return {\n        bufs: [],\n        length: 0\n      };\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return {\n        bufs: [...this.bufs],\n        length: this.length\n      };\n    }\n\n    const bufs = [];\n    let offset = 0;\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i];\n      const bufStart = offset;\n      const bufEnd = bufStart + buf.byteLength; // for next loop\n\n      offset = bufEnd;\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue;\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf);\n          break;\n        } // requested part of buffer\n\n\n        const start = beginInclusive - bufStart;\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));\n        break;\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf);\n          continue;\n        } // requested part of buffer\n\n\n        bufs.push(buf.subarray(beginInclusive - bufStart));\n        continue;\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf);\n          break;\n        } // requested part of buffer\n\n\n        bufs.push(buf.subarray(0, endExclusive - bufStart));\n        break;\n      } // slice started before this buffer and ends after it\n\n\n      bufs.push(buf);\n    }\n\n    return {\n      bufs,\n      length: endExclusive - beginInclusive\n    };\n  }\n\n  indexOf(search) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array');\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray();\n    offset = Number(offset ?? 0);\n\n    if (isNaN(offset)) {\n      offset = 0;\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset;\n    }\n\n    if (offset < 0) {\n      offset = 0;\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset;\n    } // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n\n\n    const M = needle.byteLength;\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long');\n    } // radix\n\n\n    const radix = 256;\n    const rightmostPositions = new Int32Array(radix); // position of the rightmost occurrence of the byte c in the pattern\n\n    for (let c = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1;\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j;\n    } // Return offset of first match, -1 if no match\n\n\n    const right = rightmostPositions;\n    const lastIndex = this.byteLength - needle.byteLength;\n    const lastPatIndex = needle.byteLength - 1;\n    let skip;\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0;\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char = this.get(i + j);\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char]);\n          break;\n        }\n      }\n\n      if (skip === 0) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  getInt8(byteOffset) {\n    const buf = this.subarray(byteOffset, byteOffset + 1);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getInt8(0);\n  }\n\n  setInt8(byteOffset, value) {\n    const buf = allocUnsafe(1);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setInt8(0, value);\n    this.write(buf, byteOffset);\n  }\n\n  getInt16(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 2);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getInt16(0, littleEndian);\n  }\n\n  setInt16(byteOffset, value, littleEndian) {\n    const buf = alloc(2);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setInt16(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n\n  getInt32(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 4);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getInt32(0, littleEndian);\n  }\n\n  setInt32(byteOffset, value, littleEndian) {\n    const buf = alloc(4);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setInt32(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n\n  getBigInt64(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 8);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getBigInt64(0, littleEndian);\n  }\n\n  setBigInt64(byteOffset, value, littleEndian) {\n    const buf = alloc(8);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setBigInt64(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n\n  getUint8(byteOffset) {\n    const buf = this.subarray(byteOffset, byteOffset + 1);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getUint8(0);\n  }\n\n  setUint8(byteOffset, value) {\n    const buf = allocUnsafe(1);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setUint8(0, value);\n    this.write(buf, byteOffset);\n  }\n\n  getUint16(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 2);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getUint16(0, littleEndian);\n  }\n\n  setUint16(byteOffset, value, littleEndian) {\n    const buf = alloc(2);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setUint16(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n\n  getUint32(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 4);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getUint32(0, littleEndian);\n  }\n\n  setUint32(byteOffset, value, littleEndian) {\n    const buf = alloc(4);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setUint32(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n\n  getBigUint64(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 8);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getBigUint64(0, littleEndian);\n  }\n\n  setBigUint64(byteOffset, value, littleEndian) {\n    const buf = alloc(8);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setBigUint64(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n\n  getFloat32(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 4);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getFloat32(0, littleEndian);\n  }\n\n  setFloat32(byteOffset, value, littleEndian) {\n    const buf = alloc(4);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setFloat32(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n\n  getFloat64(byteOffset, littleEndian) {\n    const buf = this.subarray(byteOffset, byteOffset + 8);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    return view.getFloat64(0, littleEndian);\n  }\n\n  setFloat64(byteOffset, value, littleEndian) {\n    const buf = alloc(8);\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    view.setFloat64(0, value, littleEndian);\n    this.write(buf, byteOffset);\n  }\n\n  equals(other) {\n    if (other == null) {\n      return false;\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false;\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n\n\n  static fromUint8Arrays(bufs, length) {\n    const list = new Uint8ArrayList();\n    list.bufs = bufs;\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);\n    }\n\n    list.length = length;\n    return list;\n  }\n\n}\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/","map":{"version":3,"mappings":"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","names":["concat","equals","allocUnsafe","alloc","symbol","Symbol","for","findBufAndOffset","bufs","index","RangeError","offset","buf","bufEnd","byteLength","isUint8ArrayList","value","Boolean","Uint8ArrayList","constructor","Object","defineProperty","length","data","appendAll","iterator","append","Uint8Array","push","Error","prepend","prependAll","reverse","unshift","get","res","set","write","i","consume","bytes","Math","trunc","Number","isNaN","shift","subarray","slice","beginInclusive","endExclusive","_subList","sublist","list","bufStart","sliceStartInBuf","sliceEndsInBuf","start","indexOf","search","TypeError","needle","M","radix","rightmostPositions","Int32Array","c","j","right","lastIndex","lastPatIndex","skip","char","max","getInt8","byteOffset","view","DataView","buffer","setInt8","getInt16","littleEndian","setInt16","getInt32","setInt32","getBigInt64","setBigInt64","getUint8","setUint8","getUint16","setUint16","getUint32","setUint32","getBigUint64","setBigUint64","getFloat32","setFloat32","getFloat64","setFloat64","other","fromUint8Arrays","reduce","acc","curr"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\uint8arraylist\\src\\index.ts"],"sourcesContent":["import { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number) {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n\n  constructor (...data: Appendable[]) {\n    // Define symbol\n    Object.defineProperty(this, symbol, { value: true })\n\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] () {\n    yield * this.bufs\n  }\n\n  get byteLength () {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]) {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]) {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]) {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]) {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number) {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number) {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0) {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number) {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = bufs\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number) {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: [...this.bufs], length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n"]},"metadata":{},"sourceType":"module"}