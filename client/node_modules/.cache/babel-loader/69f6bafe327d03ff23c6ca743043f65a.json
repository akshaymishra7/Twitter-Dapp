{"ast":null,"code":"import pTimeout from 'p-timeout';\n\nconst normalizeEmitter = emitter => {\n  const addListener = emitter.on || emitter.addListener || emitter.addEventListener;\n  const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;\n\n  if (!addListener || !removeListener) {\n    throw new TypeError('Emitter is not compatible');\n  }\n\n  return {\n    addListener: addListener.bind(emitter),\n    removeListener: removeListener.bind(emitter)\n  };\n};\n\nexport function pEventMultiple(emitter, event, options) {\n  let cancel;\n  const returnValue = new Promise((resolve, reject) => {\n    options = {\n      rejectionEvents: ['error'],\n      multiArgs: false,\n      resolveImmediately: false,\n      ...options\n    };\n\n    if (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {\n      throw new TypeError('The `count` option should be at least 0 or more');\n    } // Allow multiple events\n\n\n    const events = [event].flat();\n    const items = [];\n    const {\n      addListener,\n      removeListener\n    } = normalizeEmitter(emitter);\n\n    const onItem = function () {\n      for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n        arguments_[_key] = arguments[_key];\n      }\n\n      const value = options.multiArgs ? arguments_ : arguments_[0]; // eslint-disable-next-line unicorn/no-array-callback-reference\n\n      if (options.filter && !options.filter(value)) {\n        return;\n      }\n\n      items.push(value);\n\n      if (options.count === items.length) {\n        cancel();\n        resolve(items);\n      }\n    };\n\n    const rejectHandler = error => {\n      cancel();\n      reject(error);\n    };\n\n    cancel = () => {\n      for (const event of events) {\n        removeListener(event, onItem);\n      }\n\n      for (const rejectionEvent of options.rejectionEvents) {\n        removeListener(rejectionEvent, rejectHandler);\n      }\n    };\n\n    for (const event of events) {\n      addListener(event, onItem);\n    }\n\n    for (const rejectionEvent of options.rejectionEvents) {\n      addListener(rejectionEvent, rejectHandler);\n    }\n\n    if (options.resolveImmediately) {\n      resolve(items);\n    }\n  });\n  returnValue.cancel = cancel;\n\n  if (typeof options.timeout === 'number') {\n    const timeout = pTimeout(returnValue, options.timeout);\n    timeout.cancel = cancel;\n    return timeout;\n  }\n\n  return returnValue;\n}\nexport function pEvent(emitter, event, options) {\n  if (typeof options === 'function') {\n    options = {\n      filter: options\n    };\n  }\n\n  options = { ...options,\n    count: 1,\n    resolveImmediately: false\n  };\n  const arrayPromise = pEventMultiple(emitter, event, options);\n  const promise = arrayPromise.then(array => array[0]); // eslint-disable-line promise/prefer-await-to-then\n\n  promise.cancel = arrayPromise.cancel;\n  return promise;\n}\nexport function pEventIterator(emitter, event, options) {\n  if (typeof options === 'function') {\n    options = {\n      filter: options\n    };\n  } // Allow multiple events\n\n\n  const events = [event].flat();\n  options = {\n    rejectionEvents: ['error'],\n    resolutionEvents: [],\n    limit: Number.POSITIVE_INFINITY,\n    multiArgs: false,\n    ...options\n  };\n  const {\n    limit\n  } = options;\n  const isValidLimit = limit >= 0 && (limit === Number.POSITIVE_INFINITY || Number.isInteger(limit));\n\n  if (!isValidLimit) {\n    throw new TypeError('The `limit` option should be a non-negative integer or Infinity');\n  }\n\n  if (limit === 0) {\n    // Return an empty async iterator to avoid any further cost\n    return {\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      async next() {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n\n    };\n  }\n\n  const {\n    addListener,\n    removeListener\n  } = normalizeEmitter(emitter);\n  let isDone = false;\n  let error;\n  let hasPendingError = false;\n  const nextQueue = [];\n  const valueQueue = [];\n  let eventCount = 0;\n  let isLimitReached = false;\n\n  const valueHandler = function () {\n    eventCount++;\n    isLimitReached = eventCount === limit;\n\n    for (var _len2 = arguments.length, arguments_ = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      arguments_[_key2] = arguments[_key2];\n    }\n\n    const value = options.multiArgs ? arguments_ : arguments_[0];\n\n    if (nextQueue.length > 0) {\n      const {\n        resolve\n      } = nextQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n\n      if (isLimitReached) {\n        cancel();\n      }\n\n      return;\n    }\n\n    valueQueue.push(value);\n\n    if (isLimitReached) {\n      cancel();\n    }\n  };\n\n  const cancel = () => {\n    isDone = true;\n\n    for (const event of events) {\n      removeListener(event, valueHandler);\n    }\n\n    for (const rejectionEvent of options.rejectionEvents) {\n      removeListener(rejectionEvent, rejectHandler);\n    }\n\n    for (const resolutionEvent of options.resolutionEvents) {\n      removeListener(resolutionEvent, resolveHandler);\n    }\n\n    while (nextQueue.length > 0) {\n      const {\n        resolve\n      } = nextQueue.shift();\n      resolve({\n        done: true,\n        value: undefined\n      });\n    }\n  };\n\n  const rejectHandler = function () {\n    for (var _len3 = arguments.length, arguments_ = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      arguments_[_key3] = arguments[_key3];\n    }\n\n    error = options.multiArgs ? arguments_ : arguments_[0];\n\n    if (nextQueue.length > 0) {\n      const {\n        reject\n      } = nextQueue.shift();\n      reject(error);\n    } else {\n      hasPendingError = true;\n    }\n\n    cancel();\n  };\n\n  const resolveHandler = function () {\n    for (var _len4 = arguments.length, arguments_ = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      arguments_[_key4] = arguments[_key4];\n    }\n\n    const value = options.multiArgs ? arguments_ : arguments_[0]; // eslint-disable-next-line unicorn/no-array-callback-reference\n\n    if (options.filter && !options.filter(value)) {\n      return;\n    }\n\n    if (nextQueue.length > 0) {\n      const {\n        resolve\n      } = nextQueue.shift();\n      resolve({\n        done: true,\n        value\n      });\n    } else {\n      valueQueue.push(value);\n    }\n\n    cancel();\n  };\n\n  for (const event of events) {\n    addListener(event, valueHandler);\n  }\n\n  for (const rejectionEvent of options.rejectionEvents) {\n    addListener(rejectionEvent, rejectHandler);\n  }\n\n  for (const resolutionEvent of options.resolutionEvents) {\n    addListener(resolutionEvent, resolveHandler);\n  }\n\n  return {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    async next() {\n      if (valueQueue.length > 0) {\n        const value = valueQueue.shift();\n        return {\n          done: isDone && valueQueue.length === 0 && !isLimitReached,\n          value\n        };\n      }\n\n      if (hasPendingError) {\n        hasPendingError = false;\n        throw error;\n      }\n\n      if (isDone) {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n\n      return new Promise((resolve, reject) => {\n        nextQueue.push({\n          resolve,\n          reject\n        });\n      });\n    },\n\n    async return(value) {\n      cancel();\n      return {\n        done: isDone,\n        value\n      };\n    }\n\n  };\n}\nexport { TimeoutError } from 'p-timeout';","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/p-event/index.js"],"names":["pTimeout","normalizeEmitter","emitter","addListener","on","addEventListener","removeListener","off","removeEventListener","TypeError","bind","pEventMultiple","event","options","cancel","returnValue","Promise","resolve","reject","rejectionEvents","multiArgs","resolveImmediately","count","Number","POSITIVE_INFINITY","isInteger","events","flat","items","onItem","arguments_","value","filter","push","length","rejectHandler","error","rejectionEvent","timeout","pEvent","arrayPromise","promise","then","array","pEventIterator","resolutionEvents","limit","isValidLimit","Symbol","asyncIterator","next","done","undefined","isDone","hasPendingError","nextQueue","valueQueue","eventCount","isLimitReached","valueHandler","shift","resolutionEvent","resolveHandler","return","TimeoutError"],"mappings":"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","sourcesContent":["import pTimeout from 'p-timeout';\n\nconst normalizeEmitter = emitter => {\n\tconst addListener = emitter.on || emitter.addListener || emitter.addEventListener;\n\tconst removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;\n\n\tif (!addListener || !removeListener) {\n\t\tthrow new TypeError('Emitter is not compatible');\n\t}\n\n\treturn {\n\t\taddListener: addListener.bind(emitter),\n\t\tremoveListener: removeListener.bind(emitter),\n\t};\n};\n\nexport function pEventMultiple(emitter, event, options) {\n\tlet cancel;\n\tconst returnValue = new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\trejectionEvents: ['error'],\n\t\t\tmultiArgs: false,\n\t\t\tresolveImmediately: false,\n\t\t\t...options,\n\t\t};\n\n\t\tif (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {\n\t\t\tthrow new TypeError('The `count` option should be at least 0 or more');\n\t\t}\n\n\t\t// Allow multiple events\n\t\tconst events = [event].flat();\n\n\t\tconst items = [];\n\t\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\t\tconst onItem = (...arguments_) => {\n\t\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\t\t// eslint-disable-next-line unicorn/no-array-callback-reference\n\t\t\tif (options.filter && !options.filter(value)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titems.push(value);\n\n\t\t\tif (options.count === items.length) {\n\t\t\t\tcancel();\n\t\t\t\tresolve(items);\n\t\t\t}\n\t\t};\n\n\t\tconst rejectHandler = error => {\n\t\t\tcancel();\n\t\t\treject(error);\n\t\t};\n\n\t\tcancel = () => {\n\t\t\tfor (const event of events) {\n\t\t\t\tremoveListener(event, onItem);\n\t\t\t}\n\n\t\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t\t}\n\t\t};\n\n\t\tfor (const event of events) {\n\t\t\taddListener(event, onItem);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\taddListener(rejectionEvent, rejectHandler);\n\t\t}\n\n\t\tif (options.resolveImmediately) {\n\t\t\tresolve(items);\n\t\t}\n\t});\n\n\treturnValue.cancel = cancel;\n\n\tif (typeof options.timeout === 'number') {\n\t\tconst timeout = pTimeout(returnValue, options.timeout);\n\t\ttimeout.cancel = cancel;\n\t\treturn timeout;\n\t}\n\n\treturn returnValue;\n}\n\nexport function pEvent(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\toptions = {\n\t\t...options,\n\t\tcount: 1,\n\t\tresolveImmediately: false,\n\t};\n\n\tconst arrayPromise = pEventMultiple(emitter, event, options);\n\tconst promise = arrayPromise.then(array => array[0]); // eslint-disable-line promise/prefer-await-to-then\n\tpromise.cancel = arrayPromise.cancel;\n\n\treturn promise;\n}\n\nexport function pEventIterator(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\t// Allow multiple events\n\tconst events = [event].flat();\n\n\toptions = {\n\t\trejectionEvents: ['error'],\n\t\tresolutionEvents: [],\n\t\tlimit: Number.POSITIVE_INFINITY,\n\t\tmultiArgs: false,\n\t\t...options,\n\t};\n\n\tconst {limit} = options;\n\tconst isValidLimit = limit >= 0 && (limit === Number.POSITIVE_INFINITY || Number.isInteger(limit));\n\tif (!isValidLimit) {\n\t\tthrow new TypeError('The `limit` option should be a non-negative integer or Infinity');\n\t}\n\n\tif (limit === 0) {\n\t\t// Return an empty async iterator to avoid any further cost\n\t\treturn {\n\t\t\t[Symbol.asyncIterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tasync next() {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t},\n\t\t};\n\t}\n\n\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\tlet isDone = false;\n\tlet error;\n\tlet hasPendingError = false;\n\tconst nextQueue = [];\n\tconst valueQueue = [];\n\tlet eventCount = 0;\n\tlet isLimitReached = false;\n\n\tconst valueHandler = (...arguments_) => {\n\t\teventCount++;\n\t\tisLimitReached = eventCount === limit;\n\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\n\t\t\tresolve({done: false, value});\n\n\t\t\tif (isLimitReached) {\n\t\t\t\tcancel();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueQueue.push(value);\n\n\t\tif (isLimitReached) {\n\t\t\tcancel();\n\t\t}\n\t};\n\n\tconst cancel = () => {\n\t\tisDone = true;\n\n\t\tfor (const event of events) {\n\t\t\tremoveListener(event, valueHandler);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t}\n\n\t\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\t\tremoveListener(resolutionEvent, resolveHandler);\n\t\t}\n\n\t\twhile (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value: undefined});\n\t\t}\n\t};\n\n\tconst rejectHandler = (...arguments_) => {\n\t\terror = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {reject} = nextQueue.shift();\n\t\t\treject(error);\n\t\t} else {\n\t\t\thasPendingError = true;\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tconst resolveHandler = (...arguments_) => {\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\t// eslint-disable-next-line unicorn/no-array-callback-reference\n\t\tif (options.filter && !options.filter(value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value});\n\t\t} else {\n\t\t\tvalueQueue.push(value);\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tfor (const event of events) {\n\t\taddListener(event, valueHandler);\n\t}\n\n\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\taddListener(rejectionEvent, rejectHandler);\n\t}\n\n\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\taddListener(resolutionEvent, resolveHandler);\n\t}\n\n\treturn {\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\t\tasync next() {\n\t\t\tif (valueQueue.length > 0) {\n\t\t\t\tconst value = valueQueue.shift();\n\t\t\t\treturn {\n\t\t\t\t\tdone: isDone && valueQueue.length === 0 && !isLimitReached,\n\t\t\t\t\tvalue,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (hasPendingError) {\n\t\t\t\thasPendingError = false;\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tif (isDone) {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tnextQueue.push({resolve, reject});\n\t\t\t});\n\t\t},\n\t\tasync return(value) {\n\t\t\tcancel();\n\t\t\treturn {\n\t\t\t\tdone: isDone,\n\t\t\t\tvalue,\n\t\t\t};\n\t\t},\n\t};\n}\n\nexport {TimeoutError} from 'p-timeout';\n"]},"metadata":{},"sourceType":"module"}