{"ast":null,"code":"import { pbStream } from 'it-pb-stream';\nimport { duplexPair } from 'it-pair/duplex';\nimport { pipe } from 'it-pipe';\nimport { decode } from 'it-length-prefixed';\nimport { NOISE_MSG_MAX_LENGTH_BYTES } from './constants.js';\nimport { stablelib } from './crypto/stablelib.js';\nimport { decryptStream, encryptStream } from './crypto/streaming.js';\nimport { uint16BEDecode, uint16BEEncode } from './encoder.js';\nimport { XXHandshake } from './handshake-xx.js';\nimport { getPayload } from './utils.js';\nimport { registerMetrics } from './metrics.js';\nexport class Noise {\n  constructor() {\n    let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.protocol = '/noise';\n    const {\n      staticNoiseKey,\n      extensions,\n      crypto,\n      prologueBytes,\n      metrics\n    } = init;\n    this.crypto = crypto ?? stablelib;\n    this.extensions = extensions;\n    this.metrics = metrics ? registerMetrics(metrics) : undefined;\n\n    if (staticNoiseKey) {\n      // accepts x25519 private key of length 32\n      this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(staticNoiseKey);\n    } else {\n      this.staticKeys = this.crypto.generateX25519KeyPair();\n    }\n\n    this.prologue = prologueBytes ?? new Uint8Array(0);\n  }\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param {Duplex<Uint8Array>} connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecuredConnection>}\n   */\n\n\n  async secureOutbound(localPeer, connection, remotePeer) {\n    const wrappedConnection = pbStream(connection, {\n      lengthEncoder: uint16BEEncode,\n      lengthDecoder: uint16BEDecode,\n      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n    });\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: true,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n    return {\n      conn,\n      remoteExtensions: handshake.remoteExtensions,\n      remotePeer: handshake.remotePeer\n    };\n  }\n  /**\n   * Decrypt incoming data (handshake as responder).\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param {Duplex<Uint8Array>} connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecuredConnection>}\n   */\n\n\n  async secureInbound(localPeer, connection, remotePeer) {\n    const wrappedConnection = pbStream(connection, {\n      lengthEncoder: uint16BEEncode,\n      lengthDecoder: uint16BEDecode,\n      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n    });\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: false,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n    return {\n      conn,\n      remotePeer: handshake.remotePeer,\n      remoteExtensions: handshake.remoteExtensions\n    };\n  }\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   *\n   * @param {HandshakeParams} params\n   */\n\n\n  async performHandshake(params) {\n    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.extensions); // run XX handshake\n\n    return await this.performXXHandshake(params, payload);\n  }\n\n  async performXXHandshake(params, payload) {\n    const {\n      isInitiator,\n      remotePeer,\n      connection\n    } = params;\n    const handshake = new XXHandshake(isInitiator, payload, this.prologue, this.crypto, this.staticKeys, connection, remotePeer);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n      this.metrics?.xxHandshakeSuccesses.increment();\n    } catch (e) {\n      this.metrics?.xxHandshakeErrors.increment();\n\n      if (e instanceof Error) {\n        e.message = `Error occurred during XX handshake: ${e.message}`;\n        throw e;\n      }\n    }\n\n    return handshake;\n  }\n\n  async createSecureConnection(connection, handshake) {\n    // Create encryption box/unbox wrapper\n    const [secure, user] = duplexPair();\n    const network = connection.unwrap();\n    await pipe(secure, // write to wrapper\n    encryptStream(handshake, this.metrics), // encrypt data + prefix with message length\n    network, // send to the remote peer\n    decode({\n      lengthDecoder: uint16BEDecode\n    }), // read message length prefix\n    decryptStream(handshake, this.metrics), // decrypt the incoming data\n    secure // pipe to the wrapper\n    );\n    return user;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["pbStream","duplexPair","pipe","decode","NOISE_MSG_MAX_LENGTH_BYTES","stablelib","decryptStream","encryptStream","uint16BEDecode","uint16BEEncode","XXHandshake","getPayload","registerMetrics","Noise","constructor","init","staticNoiseKey","extensions","crypto","prologueBytes","metrics","undefined","staticKeys","generateX25519KeyPairFromSeed","generateX25519KeyPair","prologue","Uint8Array","secureOutbound","localPeer","connection","remotePeer","wrappedConnection","lengthEncoder","lengthDecoder","maxDataLength","handshake","performHandshake","isInitiator","conn","createSecureConnection","remoteExtensions","secureInbound","params","payload","publicKey","performXXHandshake","propose","exchange","finish","xxHandshakeSuccesses","increment","e","xxHandshakeErrors","Error","message","secure","user","network","unwrap"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-noise\\src\\noise.ts"],"sourcesContent":["import type { PeerId } from '@libp2p/interface-peer-id'\nimport type { SecuredConnection } from '@libp2p/interface-connection-encrypter'\nimport { pbStream, ProtobufStream } from 'it-pb-stream'\nimport { duplexPair } from 'it-pair/duplex'\nimport { pipe } from 'it-pipe'\nimport { decode } from 'it-length-prefixed'\nimport type { Duplex } from 'it-stream-types'\nimport type { bytes } from './@types/basic.js'\nimport type { IHandshake } from './@types/handshake-interface.js'\nimport type { INoiseConnection, KeyPair } from './@types/libp2p.js'\nimport { NOISE_MSG_MAX_LENGTH_BYTES } from './constants.js'\nimport type { ICryptoInterface } from './crypto.js'\nimport { stablelib } from './crypto/stablelib.js'\nimport { decryptStream, encryptStream } from './crypto/streaming.js'\nimport { uint16BEDecode, uint16BEEncode } from './encoder.js'\nimport { XXHandshake } from './handshake-xx.js'\nimport { getPayload } from './utils.js'\nimport type { NoiseExtensions } from './proto/payload.js'\nimport type { Metrics } from '@libp2p/interface-metrics'\nimport { MetricsRegistry, registerMetrics } from './metrics.js'\n\ninterface HandshakeParams {\n  connection: ProtobufStream\n  isInitiator: boolean\n  localPeer: PeerId\n  remotePeer?: PeerId\n}\n\nexport interface NoiseInit {\n  /**\n   * x25519 private key, reuse for faster handshakes\n   */\n  staticNoiseKey?: bytes\n  extensions?: NoiseExtensions\n  crypto?: ICryptoInterface\n  prologueBytes?: Uint8Array\n  metrics?: Metrics\n}\n\nexport class Noise implements INoiseConnection {\n  public protocol = '/noise'\n  public crypto: ICryptoInterface\n\n  private readonly prologue: Uint8Array\n  private readonly staticKeys: KeyPair\n  private readonly extensions?: NoiseExtensions\n  private readonly metrics?: MetricsRegistry\n\n  constructor (init: NoiseInit = {}) {\n    const { staticNoiseKey, extensions, crypto, prologueBytes, metrics } = init\n\n    this.crypto = crypto ?? stablelib\n    this.extensions = extensions\n    this.metrics = metrics ? registerMetrics(metrics) : undefined\n\n    if (staticNoiseKey) {\n      // accepts x25519 private key of length 32\n      this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(staticNoiseKey)\n    } else {\n      this.staticKeys = this.crypto.generateX25519KeyPair()\n    }\n    this.prologue = prologueBytes ?? new Uint8Array(0)\n  }\n\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param {Duplex<Uint8Array>} connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecuredConnection>}\n   */\n  public async secureOutbound (localPeer: PeerId, connection: Duplex<Uint8Array>, remotePeer?: PeerId): Promise<SecuredConnection<NoiseExtensions>> {\n    const wrappedConnection = pbStream(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    )\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: true,\n      localPeer,\n      remotePeer\n    })\n    const conn = await this.createSecureConnection(wrappedConnection, handshake)\n\n    return {\n      conn,\n      remoteExtensions: handshake.remoteExtensions,\n      remotePeer: handshake.remotePeer\n    }\n  }\n\n  /**\n   * Decrypt incoming data (handshake as responder).\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param {Duplex<Uint8Array>} connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecuredConnection>}\n   */\n  public async secureInbound (localPeer: PeerId, connection: Duplex<Uint8Array>, remotePeer?: PeerId): Promise<SecuredConnection<NoiseExtensions>> {\n    const wrappedConnection = pbStream(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    )\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: false,\n      localPeer,\n      remotePeer\n    })\n    const conn = await this.createSecureConnection(wrappedConnection, handshake)\n\n    return {\n      conn,\n      remotePeer: handshake.remotePeer,\n      remoteExtensions: handshake.remoteExtensions\n    }\n  }\n\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   *\n   * @param {HandshakeParams} params\n   */\n  private async performHandshake (params: HandshakeParams): Promise<IHandshake> {\n    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.extensions)\n\n    // run XX handshake\n    return await this.performXXHandshake(params, payload)\n  }\n\n  private async performXXHandshake (\n    params: HandshakeParams,\n    payload: bytes\n  ): Promise<XXHandshake> {\n    const { isInitiator, remotePeer, connection } = params\n    const handshake = new XXHandshake(\n      isInitiator,\n      payload,\n      this.prologue,\n      this.crypto,\n      this.staticKeys,\n      connection,\n      remotePeer\n    )\n\n    try {\n      await handshake.propose()\n      await handshake.exchange()\n      await handshake.finish()\n      this.metrics?.xxHandshakeSuccesses.increment()\n    } catch (e: unknown) {\n      this.metrics?.xxHandshakeErrors.increment()\n      if (e instanceof Error) {\n        e.message = `Error occurred during XX handshake: ${e.message}`\n        throw e\n      }\n    }\n\n    return handshake\n  }\n\n  private async createSecureConnection (\n    connection: ProtobufStream,\n    handshake: IHandshake\n  ): Promise<Duplex<Uint8Array>> {\n    // Create encryption box/unbox wrapper\n    const [secure, user] = duplexPair<Uint8Array>()\n    const network = connection.unwrap()\n\n    await pipe(\n      secure, // write to wrapper\n      encryptStream(handshake, this.metrics), // encrypt data + prefix with message length\n      network, // send to the remote peer\n      decode({ lengthDecoder: uint16BEDecode }), // read message length prefix\n      decryptStream(handshake, this.metrics), // decrypt the incoming data\n      secure // pipe to the wrapper\n    )\n\n    return user\n  }\n}\n"]},"metadata":{},"sourceType":"module"}