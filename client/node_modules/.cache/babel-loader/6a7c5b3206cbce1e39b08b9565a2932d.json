{"ast":null,"code":"import { RecordEnvelope, PeerRecord } from '@libp2p/peer-record';\nimport { logger } from '@libp2p/logger';\nimport { protocols } from '@multiformats/multiaddr';\nconst log = logger('libp2p:peer-record-updater');\nexport class PeerRecordUpdater {\n  constructor(components) {\n    this.components = components;\n    this.started = false;\n    this.update = this.update.bind(this);\n  }\n\n  isStarted() {\n    return this.started;\n  }\n\n  async start() {\n    this.started = true;\n    this.components.transportManager.addEventListener('listener:listening', this.update);\n    this.components.transportManager.addEventListener('listener:close', this.update);\n    this.components.addressManager.addEventListener('change:addresses', this.update);\n  }\n\n  async stop() {\n    this.started = false;\n    this.components.transportManager.removeEventListener('listener:listening', this.update);\n    this.components.transportManager.removeEventListener('listener:close', this.update);\n    this.components.addressManager.removeEventListener('change:addresses', this.update);\n  }\n  /**\n   * Create (or update if existing) self peer record and store it in the AddressBook.\n   */\n\n\n  update() {\n    Promise.resolve().then(async () => {\n      const peerRecord = new PeerRecord({\n        peerId: this.components.peerId,\n        multiaddrs: this.components.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n      });\n      const envelope = await RecordEnvelope.seal(peerRecord, this.components.peerId);\n      await this.components.peerStore.addressBook.consumePeerRecord(envelope);\n    }).catch(err => {\n      log.error('Could not update self peer record: %o', err);\n    });\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,cAAT,EAAyBC,UAAzB,QAA2C,qBAA3C;AAEA,SAASC,MAAT,QAAuB,gBAAvB;AACA,SAASC,SAAT,QAA0B,yBAA1B;AAMA,MAAMC,GAAG,GAAGF,MAAM,CAAC,4BAAD,CAAlB;AASA,OAAM,MAAOG,iBAAP,CAAwB;AAI5BC,cAAaC,UAAb,EAAoD;AAClD,SAAKA,UAAL,GAAkBA,UAAlB;AACA,SAAKC,OAAL,GAAe,KAAf;AACA,SAAKC,MAAL,GAAc,KAAKA,MAAL,CAAYC,IAAZ,CAAiB,IAAjB,CAAd;AACD;;AAEDC,WAAS;AACP,WAAO,KAAKH,OAAZ;AACD;;AAEU,QAALI,KAAK;AACT,SAAKJ,OAAL,GAAe,IAAf;AACA,SAAKD,UAAL,CAAgBM,gBAAhB,CAAiCC,gBAAjC,CAAkD,oBAAlD,EAAwE,KAAKL,MAA7E;AACA,SAAKF,UAAL,CAAgBM,gBAAhB,CAAiCC,gBAAjC,CAAkD,gBAAlD,EAAoE,KAAKL,MAAzE;AACA,SAAKF,UAAL,CAAgBQ,cAAhB,CAA+BD,gBAA/B,CAAgD,kBAAhD,EAAoE,KAAKL,MAAzE;AACD;;AAES,QAAJO,IAAI;AACR,SAAKR,OAAL,GAAe,KAAf;AACA,SAAKD,UAAL,CAAgBM,gBAAhB,CAAiCI,mBAAjC,CAAqD,oBAArD,EAA2E,KAAKR,MAAhF;AACA,SAAKF,UAAL,CAAgBM,gBAAhB,CAAiCI,mBAAjC,CAAqD,gBAArD,EAAuE,KAAKR,MAA5E;AACA,SAAKF,UAAL,CAAgBQ,cAAhB,CAA+BE,mBAA/B,CAAmD,kBAAnD,EAAuE,KAAKR,MAA5E;AACD;AAED;;;;;AAGAA,QAAM;AACJS,WAAO,CAACC,OAAR,GACGC,IADH,CACQ,YAAW;AACf,YAAMC,UAAU,GAAG,IAAIpB,UAAJ,CAAe;AAChCqB,cAAM,EAAE,KAAKf,UAAL,CAAgBe,MADQ;AAEhCC,kBAAU,EAAE,KAAKhB,UAAL,CAAgBQ,cAAhB,CAA+BS,YAA/B,GAA8CC,GAA9C,CAAkDC,EAAE,IAAIA,EAAE,CAACC,eAAH,CAAmBxB,SAAS,CAAC,KAAD,CAAT,CAAiByB,IAApC,CAAxD;AAFoB,OAAf,CAAnB;AAKA,YAAMC,QAAQ,GAAG,MAAM7B,cAAc,CAAC8B,IAAf,CAAoBT,UAApB,EAAgC,KAAKd,UAAL,CAAgBe,MAAhD,CAAvB;AACA,YAAM,KAAKf,UAAL,CAAgBwB,SAAhB,CAA0BC,WAA1B,CAAsCC,iBAAtC,CAAwDJ,QAAxD,CAAN;AACD,KATH,EAUGK,KAVH,CAUSC,GAAG,IAAG;AACX/B,SAAG,CAACgC,KAAJ,CAAU,uCAAV,EAAmDD,GAAnD;AACD,KAZH;AAaD;;AA7C2B","names":["RecordEnvelope","PeerRecord","logger","protocols","log","PeerRecordUpdater","constructor","components","started","update","bind","isStarted","start","transportManager","addEventListener","addressManager","stop","removeEventListener","Promise","resolve","then","peerRecord","peerId","multiaddrs","getAddresses","map","ma","decapsulateCode","code","envelope","seal","peerStore","addressBook","consumePeerRecord","catch","err","error"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\peer-record-updater.ts"],"sourcesContent":["import { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport { logger } from '@libp2p/logger'\nimport { protocols } from '@multiformats/multiaddr'\nimport type { TransportManager } from '@libp2p/interface-transport'\nimport type { AddressManager } from '@libp2p/interface-address-manager'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { PeerStore } from '@libp2p/interface-peer-store'\n\nconst log = logger('libp2p:peer-record-updater')\n\nexport interface PeerRecordUpdaterComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  transportManager: TransportManager\n  addressManager: AddressManager\n}\n\nexport class PeerRecordUpdater implements Startable {\n  private readonly components: PeerRecordUpdaterComponents\n  private started: boolean\n\n  constructor (components: PeerRecordUpdaterComponents) {\n    this.components = components\n    this.started = false\n    this.update = this.update.bind(this)\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  async start () {\n    this.started = true\n    this.components.transportManager.addEventListener('listener:listening', this.update)\n    this.components.transportManager.addEventListener('listener:close', this.update)\n    this.components.addressManager.addEventListener('change:addresses', this.update)\n  }\n\n  async stop () {\n    this.started = false\n    this.components.transportManager.removeEventListener('listener:listening', this.update)\n    this.components.transportManager.removeEventListener('listener:close', this.update)\n    this.components.addressManager.removeEventListener('change:addresses', this.update)\n  }\n\n  /**\n   * Create (or update if existing) self peer record and store it in the AddressBook.\n   */\n  update () {\n    Promise.resolve()\n      .then(async () => {\n        const peerRecord = new PeerRecord({\n          peerId: this.components.peerId,\n          multiaddrs: this.components.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n        })\n\n        const envelope = await RecordEnvelope.seal(peerRecord, this.components.peerId)\n        await this.components.peerStore.addressBook.consumePeerRecord(envelope)\n      })\n      .catch(err => {\n        log.error('Could not update self peer record: %o', err)\n      })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}