{"ast":null,"code":"import { RoutingTable } from './routing-table/index.js';\nimport { RoutingTableRefresh } from './routing-table/refresh.js';\nimport { Network } from './network.js';\nimport { ContentFetching } from './content-fetching/index.js';\nimport { ContentRouting } from './content-routing/index.js';\nimport { PeerRouting } from './peer-routing/index.js';\nimport { Providers } from './providers.js';\nimport { QueryManager } from './query/manager.js';\nimport { RPC } from './rpc/index.js';\nimport { TopologyListener } from './topology-listener.js';\nimport { QuerySelf } from './query-self.js';\nimport { removePrivateAddresses, removePublicAddresses } from './utils.js';\nimport { logger } from '@libp2p/logger';\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { validators as recordValidators } from '@libp2p/record/validators';\nimport { selectors as recordSelectors } from '@libp2p/record/selectors';\nimport { symbol } from '@libp2p/interface-peer-discovery';\nimport { PROTOCOL_DHT, PROTOCOL_PREFIX, LAN_PREFIX } from './constants.js';\nexport const DEFAULT_MAX_INBOUND_STREAMS = 32;\nexport const DEFAULT_MAX_OUTBOUND_STREAMS = 64;\n/**\n * A DHT implementation modelled after Kademlia with S/Kademlia modifications.\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\n\nexport class KadDHT extends EventEmitter {\n  /**\n   * Create a new KadDHT\n   */\n  constructor(components, init) {\n    super();\n    const {\n      kBucketSize,\n      clientMode,\n      validators,\n      selectors,\n      querySelfInterval,\n      lan,\n      protocolPrefix,\n      pingTimeout,\n      pingConcurrency,\n      maxInboundStreams,\n      maxOutboundStreams,\n      providers: providersInit\n    } = init;\n    this.running = false;\n    this.components = components;\n    this.lan = Boolean(lan);\n    this.log = logger(`libp2p:kad-dht:${lan === true ? 'lan' : 'wan'}`);\n    this.protocol = `${protocolPrefix ?? PROTOCOL_PREFIX}${lan === true ? LAN_PREFIX : ''}${PROTOCOL_DHT}`;\n    this.kBucketSize = kBucketSize ?? 20;\n    this.clientMode = clientMode ?? true;\n    this.maxInboundStreams = maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS;\n    this.maxOutboundStreams = maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;\n    this.routingTable = new RoutingTable(components, {\n      kBucketSize,\n      lan: this.lan,\n      pingTimeout,\n      pingConcurrency,\n      protocol: this.protocol\n    });\n    this.providers = new Providers(components, providersInit ?? {});\n    this.validators = { ...recordValidators,\n      ...validators\n    };\n    this.selectors = { ...recordSelectors,\n      ...selectors\n    };\n    this.network = new Network(components, {\n      protocol: this.protocol,\n      lan: this.lan\n    });\n    this.queryManager = new QueryManager(components, {\n      // Number of disjoint query paths to use - This is set to `kBucketSize/2` per the S/Kademlia paper\n      disjointPaths: Math.ceil(this.kBucketSize / 2),\n      lan\n    }); // DHT components\n\n    this.peerRouting = new PeerRouting(components, {\n      routingTable: this.routingTable,\n      network: this.network,\n      validators: this.validators,\n      queryManager: this.queryManager,\n      lan: this.lan\n    });\n    this.contentFetching = new ContentFetching(components, {\n      validators: this.validators,\n      selectors: this.selectors,\n      peerRouting: this.peerRouting,\n      queryManager: this.queryManager,\n      routingTable: this.routingTable,\n      network: this.network,\n      lan: this.lan\n    });\n    this.contentRouting = new ContentRouting(components, {\n      network: this.network,\n      peerRouting: this.peerRouting,\n      queryManager: this.queryManager,\n      routingTable: this.routingTable,\n      providers: this.providers,\n      lan: this.lan\n    });\n    this.routingTableRefresh = new RoutingTableRefresh({\n      peerRouting: this.peerRouting,\n      routingTable: this.routingTable,\n      lan: this.lan\n    });\n    this.rpc = new RPC(components, {\n      routingTable: this.routingTable,\n      providers: this.providers,\n      peerRouting: this.peerRouting,\n      validators: this.validators,\n      lan: this.lan\n    });\n    this.topologyListener = new TopologyListener(components, {\n      protocol: this.protocol,\n      lan: this.lan\n    });\n    this.querySelf = new QuerySelf(components, {\n      peerRouting: this.peerRouting,\n      interval: querySelfInterval,\n      lan: this.lan\n    }); // handle peers being discovered during processing of DHT messages\n\n    this.network.addEventListener('peer', evt => {\n      const peerData = evt.detail;\n      this.onPeerConnect(peerData).catch(err => {\n        this.log.error('could not add %p to routing table', peerData.id, err);\n      });\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: peerData\n      }));\n    }); // handle peers being discovered via other peer discovery mechanisms\n\n    this.topologyListener.addEventListener('peer', evt => {\n      const peerId = evt.detail;\n      Promise.resolve().then(async () => {\n        const multiaddrs = await this.components.peerStore.addressBook.get(peerId);\n        const peerData = {\n          id: peerId,\n          multiaddrs: multiaddrs.map(addr => addr.multiaddr),\n          protocols: []\n        };\n        await this.onPeerConnect(peerData);\n      }).catch(err => {\n        this.log.error('could not add %p to routing table', peerId, err);\n      });\n    });\n  }\n\n  get [symbol]() {\n    return true;\n  }\n\n  get [Symbol.toStringTag]() {\n    return '@libp2p/kad-dht';\n  }\n\n  async onPeerConnect(peerData) {\n    this.log('peer %p connected with protocols %s', peerData.id, peerData.protocols);\n\n    if (this.lan) {\n      peerData = removePublicAddresses(peerData);\n    } else {\n      peerData = removePrivateAddresses(peerData);\n    }\n\n    if (peerData.multiaddrs.length === 0) {\n      this.log('ignoring %p as they do not have any %s addresses in %s', peerData.id, this.lan ? 'private' : 'public', peerData.multiaddrs.map(addr => addr.toString()));\n      return;\n    }\n\n    try {\n      await this.routingTable.add(peerData.id);\n    } catch (err) {\n      this.log.error('could not add %p to routing table', peerData.id, err);\n    }\n  }\n  /**\n   * Is this DHT running.\n   */\n\n\n  isStarted() {\n    return this.running;\n  }\n  /**\n   * If 'server' this node will respond to DHT queries, if 'client' this node will not\n   */\n\n\n  async getMode() {\n    return this.clientMode ? 'client' : 'server';\n  }\n  /**\n   * If 'server' this node will respond to DHT queries, if 'client' this node will not\n   */\n\n\n  async setMode(mode) {\n    await this.components.registrar.unhandle(this.protocol);\n\n    if (mode === 'client') {\n      this.log('enabling client mode');\n      this.clientMode = true;\n    } else {\n      this.log('enabling server mode');\n      this.clientMode = false;\n      await this.components.registrar.handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {\n        maxInboundStreams: this.maxInboundStreams,\n        maxOutboundStreams: this.maxOutboundStreams\n      });\n    }\n  }\n  /**\n   * Start listening to incoming connections.\n   */\n\n\n  async start() {\n    this.running = true; // Only respond to queries when not in client mode\n\n    await this.setMode(this.clientMode ? 'client' : 'server');\n    await Promise.all([this.providers.start(), this.queryManager.start(), this.network.start(), this.routingTable.start(), this.topologyListener.start(), this.querySelf.start()]);\n    await this.routingTableRefresh.start();\n  }\n  /**\n   * Stop accepting incoming connections and sending outgoing\n   * messages.\n   */\n\n\n  async stop() {\n    this.running = false;\n    await Promise.all([this.providers.stop(), this.queryManager.stop(), this.network.stop(), this.routingTable.stop(), this.routingTableRefresh.stop(), this.topologyListener.stop(), this.querySelf.stop()]);\n  }\n  /**\n   * Store the given key/value pair in the DHT\n   */\n\n\n  async *put(key, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    yield* this.contentFetching.put(key, value, options);\n  }\n  /**\n   * Get the value that corresponds to the passed key\n   */\n\n\n  async *get(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.contentFetching.get(key, options);\n  } // ----------- Content Routing\n\n  /**\n   * Announce to the network that we can provide given key's value\n   */\n\n\n  async *provide(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.contentRouting.provide(key, this.components.addressManager.getAddresses(), options);\n  }\n  /**\n   * Search the dht for providers of the given CID\n   */\n\n\n  async *findProviders(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.contentRouting.findProviders(key, options);\n  } // ----------- Peer Routing -----------\n\n  /**\n   * Search for a peer with the given ID\n   */\n\n\n  async *findPeer(id) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.peerRouting.findPeer(id, options);\n  }\n  /**\n   * Kademlia 'node lookup' operation\n   */\n\n\n  async *getClosestPeers(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.peerRouting.getClosestPeers(key, options);\n  }\n\n  async refreshRoutingTable() {\n    this.routingTableRefresh.refreshTable(true);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["RoutingTable","RoutingTableRefresh","Network","ContentFetching","ContentRouting","PeerRouting","Providers","QueryManager","RPC","TopologyListener","QuerySelf","removePrivateAddresses","removePublicAddresses","logger","CustomEvent","EventEmitter","validators","recordValidators","selectors","recordSelectors","symbol","PROTOCOL_DHT","PROTOCOL_PREFIX","LAN_PREFIX","DEFAULT_MAX_INBOUND_STREAMS","DEFAULT_MAX_OUTBOUND_STREAMS","KadDHT","constructor","components","init","kBucketSize","clientMode","querySelfInterval","lan","protocolPrefix","pingTimeout","pingConcurrency","maxInboundStreams","maxOutboundStreams","providers","providersInit","running","Boolean","log","protocol","routingTable","network","queryManager","disjointPaths","Math","ceil","peerRouting","contentFetching","contentRouting","routingTableRefresh","rpc","topologyListener","querySelf","interval","addEventListener","evt","peerData","detail","onPeerConnect","catch","err","error","id","dispatchEvent","peerId","Promise","resolve","then","multiaddrs","peerStore","addressBook","get","map","addr","multiaddr","protocols","Symbol","toStringTag","length","toString","add","isStarted","getMode","setMode","mode","registrar","unhandle","handle","onIncomingStream","bind","start","all","stop","put","key","value","options","provide","addressManager","getAddresses","findProviders","findPeer","getClosestPeers","refreshRoutingTable","refreshTable"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\kad-dht.ts"],"sourcesContent":["import { RoutingTable } from './routing-table/index.js'\nimport { RoutingTableRefresh } from './routing-table/refresh.js'\nimport { Network } from './network.js'\nimport { ContentFetching } from './content-fetching/index.js'\nimport { ContentRouting } from './content-routing/index.js'\nimport { PeerRouting } from './peer-routing/index.js'\nimport { Providers } from './providers.js'\nimport { QueryManager } from './query/manager.js'\nimport { RPC } from './rpc/index.js'\nimport { TopologyListener } from './topology-listener.js'\nimport { QuerySelf } from './query-self.js'\nimport {\n  removePrivateAddresses,\n  removePublicAddresses\n} from './utils.js'\nimport { Logger, logger } from '@libp2p/logger'\nimport type { QueryOptions, Validators, Selectors, DHT, QueryEvent } from '@libp2p/interface-dht'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { CID } from 'multiformats/cid'\nimport type { PeerDiscoveryEvents } from '@libp2p/interface-peer-discovery'\nimport type { KadDHTComponents, KadDHTInit } from './index.js'\nimport { validators as recordValidators } from '@libp2p/record/validators'\nimport { selectors as recordSelectors } from '@libp2p/record/selectors'\nimport { symbol } from '@libp2p/interface-peer-discovery'\nimport { PROTOCOL_DHT, PROTOCOL_PREFIX, LAN_PREFIX } from './constants.js'\n\nexport const DEFAULT_MAX_INBOUND_STREAMS = 32\nexport const DEFAULT_MAX_OUTBOUND_STREAMS = 64\n\nexport interface SingleKadDHTInit extends KadDHTInit {\n  /**\n   * Whether to start up in lan or wan mode\n   */\n  lan?: boolean\n}\n\n/**\n * A DHT implementation modelled after Kademlia with S/Kademlia modifications.\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\nexport class KadDHT extends EventEmitter<PeerDiscoveryEvents> implements DHT {\n  public protocol: string\n  public routingTable: RoutingTable\n  public providers: Providers\n  public network: Network\n  public peerRouting: PeerRouting\n\n  public readonly components: KadDHTComponents\n  private readonly log: Logger\n  private running: boolean\n  private readonly kBucketSize: number\n  private clientMode: boolean\n  private readonly lan: boolean\n  private readonly validators: Validators\n  private readonly selectors: Selectors\n  private readonly queryManager: QueryManager\n  private readonly contentFetching: ContentFetching\n  private readonly contentRouting: ContentRouting\n  private readonly routingTableRefresh: RoutingTableRefresh\n  private readonly rpc: RPC\n  private readonly topologyListener: TopologyListener\n  private readonly querySelf: QuerySelf\n  private readonly maxInboundStreams: number\n  private readonly maxOutboundStreams: number\n\n  /**\n   * Create a new KadDHT\n   */\n  constructor (components: KadDHTComponents, init: SingleKadDHTInit) {\n    super()\n\n    const {\n      kBucketSize,\n      clientMode,\n      validators,\n      selectors,\n      querySelfInterval,\n      lan,\n      protocolPrefix,\n      pingTimeout,\n      pingConcurrency,\n      maxInboundStreams,\n      maxOutboundStreams,\n      providers: providersInit\n    } = init\n\n    this.running = false\n    this.components = components\n    this.lan = Boolean(lan)\n    this.log = logger(`libp2p:kad-dht:${lan === true ? 'lan' : 'wan'}`)\n    this.protocol = `${protocolPrefix ?? PROTOCOL_PREFIX}${lan === true ? LAN_PREFIX : ''}${PROTOCOL_DHT}`\n    this.kBucketSize = kBucketSize ?? 20\n    this.clientMode = clientMode ?? true\n    this.maxInboundStreams = maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS\n    this.maxOutboundStreams = maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS\n    this.routingTable = new RoutingTable(components, {\n      kBucketSize,\n      lan: this.lan,\n      pingTimeout,\n      pingConcurrency,\n      protocol: this.protocol\n    })\n\n    this.providers = new Providers(components, providersInit ?? {})\n\n    this.validators = {\n      ...recordValidators,\n      ...validators\n    }\n    this.selectors = {\n      ...recordSelectors,\n      ...selectors\n    }\n    this.network = new Network(components, {\n      protocol: this.protocol,\n      lan: this.lan\n    })\n    this.queryManager = new QueryManager(components, {\n      // Number of disjoint query paths to use - This is set to `kBucketSize/2` per the S/Kademlia paper\n      disjointPaths: Math.ceil(this.kBucketSize / 2),\n      lan\n    })\n\n    // DHT components\n    this.peerRouting = new PeerRouting(components, {\n      routingTable: this.routingTable,\n      network: this.network,\n      validators: this.validators,\n      queryManager: this.queryManager,\n      lan: this.lan\n    })\n    this.contentFetching = new ContentFetching(components, {\n      validators: this.validators,\n      selectors: this.selectors,\n      peerRouting: this.peerRouting,\n      queryManager: this.queryManager,\n      routingTable: this.routingTable,\n      network: this.network,\n      lan: this.lan\n    })\n    this.contentRouting = new ContentRouting(components, {\n      network: this.network,\n      peerRouting: this.peerRouting,\n      queryManager: this.queryManager,\n      routingTable: this.routingTable,\n      providers: this.providers,\n      lan: this.lan\n    })\n    this.routingTableRefresh = new RoutingTableRefresh({\n      peerRouting: this.peerRouting,\n      routingTable: this.routingTable,\n      lan: this.lan\n    })\n    this.rpc = new RPC(components, {\n      routingTable: this.routingTable,\n      providers: this.providers,\n      peerRouting: this.peerRouting,\n      validators: this.validators,\n      lan: this.lan\n    })\n    this.topologyListener = new TopologyListener(components, {\n      protocol: this.protocol,\n      lan: this.lan\n    })\n    this.querySelf = new QuerySelf(components, {\n      peerRouting: this.peerRouting,\n      interval: querySelfInterval,\n      lan: this.lan\n    })\n\n    // handle peers being discovered during processing of DHT messages\n    this.network.addEventListener('peer', (evt) => {\n      const peerData = evt.detail\n\n      this.onPeerConnect(peerData).catch(err => {\n        this.log.error('could not add %p to routing table', peerData.id, err)\n      })\n\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: peerData\n      }))\n    })\n\n    // handle peers being discovered via other peer discovery mechanisms\n    this.topologyListener.addEventListener('peer', (evt) => {\n      const peerId = evt.detail\n\n      Promise.resolve().then(async () => {\n        const multiaddrs = await this.components.peerStore.addressBook.get(peerId)\n\n        const peerData = {\n          id: peerId,\n          multiaddrs: multiaddrs.map(addr => addr.multiaddr),\n          protocols: []\n        }\n\n        await this.onPeerConnect(peerData)\n      }).catch(err => {\n        this.log.error('could not add %p to routing table', peerId, err)\n      })\n    })\n  }\n\n  get [symbol] (): true {\n    return true\n  }\n\n  get [Symbol.toStringTag] (): '@libp2p/kad-dht' {\n    return '@libp2p/kad-dht'\n  }\n\n  async onPeerConnect (peerData: PeerInfo): Promise<void> {\n    this.log('peer %p connected with protocols %s', peerData.id, peerData.protocols)\n\n    if (this.lan) {\n      peerData = removePublicAddresses(peerData)\n    } else {\n      peerData = removePrivateAddresses(peerData)\n    }\n\n    if (peerData.multiaddrs.length === 0) {\n      this.log('ignoring %p as they do not have any %s addresses in %s', peerData.id, this.lan ? 'private' : 'public', peerData.multiaddrs.map(addr => addr.toString()))\n      return\n    }\n\n    try {\n      await this.routingTable.add(peerData.id)\n    } catch (err: any) {\n      this.log.error('could not add %p to routing table', peerData.id, err)\n    }\n  }\n\n  /**\n   * Is this DHT running.\n   */\n  isStarted (): boolean {\n    return this.running\n  }\n\n  /**\n   * If 'server' this node will respond to DHT queries, if 'client' this node will not\n   */\n  async getMode (): Promise<'client' | 'server'> {\n    return this.clientMode ? 'client' : 'server'\n  }\n\n  /**\n   * If 'server' this node will respond to DHT queries, if 'client' this node will not\n   */\n  async setMode (mode: 'client' | 'server'): Promise<void> {\n    await this.components.registrar.unhandle(this.protocol)\n\n    if (mode === 'client') {\n      this.log('enabling client mode')\n      this.clientMode = true\n    } else {\n      this.log('enabling server mode')\n      this.clientMode = false\n      await this.components.registrar.handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {\n        maxInboundStreams: this.maxInboundStreams,\n        maxOutboundStreams: this.maxOutboundStreams\n      })\n    }\n  }\n\n  /**\n   * Start listening to incoming connections.\n   */\n  async start (): Promise<void> {\n    this.running = true\n\n    // Only respond to queries when not in client mode\n    await this.setMode(this.clientMode ? 'client' : 'server')\n\n    await Promise.all([\n      this.providers.start(),\n      this.queryManager.start(),\n      this.network.start(),\n      this.routingTable.start(),\n      this.topologyListener.start(),\n      this.querySelf.start()\n    ])\n\n    await this.routingTableRefresh.start()\n  }\n\n  /**\n   * Stop accepting incoming connections and sending outgoing\n   * messages.\n   */\n  async stop (): Promise<void> {\n    this.running = false\n\n    await Promise.all([\n      this.providers.stop(),\n      this.queryManager.stop(),\n      this.network.stop(),\n      this.routingTable.stop(),\n      this.routingTableRefresh.stop(),\n      this.topologyListener.stop(),\n      this.querySelf.stop()\n    ])\n  }\n\n  /**\n   * Store the given key/value pair in the DHT\n   */\n  async * put (key: Uint8Array, value: Uint8Array, options: QueryOptions = {}): AsyncGenerator<any, void, undefined> {\n    yield * this.contentFetching.put(key, value, options)\n  }\n\n  /**\n   * Get the value that corresponds to the passed key\n   */\n  async * get (key: Uint8Array, options: QueryOptions = {}): AsyncGenerator<QueryEvent, void, undefined> {\n    yield * this.contentFetching.get(key, options)\n  }\n\n  // ----------- Content Routing\n\n  /**\n   * Announce to the network that we can provide given key's value\n   */\n  async * provide (key: CID, options: QueryOptions = {}): AsyncGenerator<QueryEvent, void, undefined> {\n    yield * this.contentRouting.provide(key, this.components.addressManager.getAddresses(), options)\n  }\n\n  /**\n   * Search the dht for providers of the given CID\n   */\n  async * findProviders (key: CID, options: QueryOptions = {}): AsyncGenerator<QueryEvent, any, unknown> {\n    yield * this.contentRouting.findProviders(key, options)\n  }\n\n  // ----------- Peer Routing -----------\n\n  /**\n   * Search for a peer with the given ID\n   */\n  async * findPeer (id: PeerId, options: QueryOptions = {}): AsyncGenerator<QueryEvent, any, unknown> {\n    yield * this.peerRouting.findPeer(id, options)\n  }\n\n  /**\n   * Kademlia 'node lookup' operation\n   */\n  async * getClosestPeers (key: Uint8Array, options: QueryOptions = {}): AsyncGenerator<QueryEvent, any, unknown> {\n    yield * this.peerRouting.getClosestPeers(key, options)\n  }\n\n  async refreshRoutingTable (): Promise<void> {\n    this.routingTableRefresh.refreshTable(true)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}