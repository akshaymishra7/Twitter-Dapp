{"ast":null,"code":"/* eslint-disable import/export */\n\n/* eslint-disable complexity */\n\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\nimport { encodeMessage, decodeMessage, message, enumeration } from 'protons-runtime';\nexport var FetchRequest;\n\n(function (FetchRequest) {\n  let _codec;\n\n  FetchRequest.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (opts.writeDefaults === true || obj.identifier !== '') {\n          w.uint32(10);\n          w.string(obj.identifier);\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {\n          identifier: ''\n        };\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.identifier = reader.string();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  FetchRequest.encode = obj => {\n    return encodeMessage(obj, FetchRequest.codec());\n  };\n\n  FetchRequest.decode = buf => {\n    return decodeMessage(buf, FetchRequest.codec());\n  };\n})(FetchRequest || (FetchRequest = {}));\n\nexport var FetchResponse;\n\n(function (FetchResponse) {\n  let StatusCode;\n\n  (function (StatusCode) {\n    StatusCode[\"OK\"] = \"OK\";\n    StatusCode[\"NOT_FOUND\"] = \"NOT_FOUND\";\n    StatusCode[\"ERROR\"] = \"ERROR\";\n  })(StatusCode = FetchResponse.StatusCode || (FetchResponse.StatusCode = {}));\n\n  let __StatusCodeValues;\n\n  (function (__StatusCodeValues) {\n    __StatusCodeValues[__StatusCodeValues[\"OK\"] = 0] = \"OK\";\n    __StatusCodeValues[__StatusCodeValues[\"NOT_FOUND\"] = 1] = \"NOT_FOUND\";\n    __StatusCodeValues[__StatusCodeValues[\"ERROR\"] = 2] = \"ERROR\";\n  })(__StatusCodeValues || (__StatusCodeValues = {}));\n\n  (function (StatusCode) {\n    StatusCode.codec = () => {\n      return enumeration(__StatusCodeValues);\n    };\n  })(StatusCode = FetchResponse.StatusCode || (FetchResponse.StatusCode = {}));\n\n  let _codec;\n\n  FetchResponse.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (opts.writeDefaults === true || obj.status != null && __StatusCodeValues[obj.status] !== 0) {\n          w.uint32(8);\n          FetchResponse.StatusCode.codec().encode(obj.status, w);\n        }\n\n        if (opts.writeDefaults === true || obj.data != null && obj.data.byteLength > 0) {\n          w.uint32(18);\n          w.bytes(obj.data);\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {\n          status: StatusCode.OK,\n          data: new Uint8Array(0)\n        };\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.status = FetchResponse.StatusCode.codec().decode(reader);\n              break;\n\n            case 2:\n              obj.data = reader.bytes();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  FetchResponse.encode = obj => {\n    return encodeMessage(obj, FetchResponse.codec());\n  };\n\n  FetchResponse.decode = buf => {\n    return decodeMessage(buf, FetchResponse.codec());\n  };\n})(FetchResponse || (FetchResponse = {}));","map":{"version":3,"mappings":"AAAA;;AACA;;AACA;;AACA;AAEA,SAASA,aAAT,EAAwBC,aAAxB,EAAuCC,OAAvC,EAAgDC,WAAhD,QAAmE,iBAAnE;AAQA,OAAM,IAAWC,YAAX;;AAAN,WAAiBA,YAAjB,EAA6B;AAC3B,MAAIC,MAAJ;;AAEaD,uBAAQ,MAA0B;AAC7C,QAAIC,MAAM,IAAI,IAAd,EAAoB;AAClBA,YAAM,GAAGH,OAAO,CAAe,UAACI,GAAD,EAAMC,CAAN,EAAsB;AAAA,YAAbC,IAAa,uEAAN,EAAM;;AACnD,YAAIA,IAAI,CAACC,eAAL,KAAyB,KAA7B,EAAoC;AAClCF,WAAC,CAACG,IAAF;AACD;;AAED,YAAIF,IAAI,CAACG,aAAL,KAAuB,IAAvB,IAA+BL,GAAG,CAACM,UAAJ,KAAmB,EAAtD,EAA0D;AACxDL,WAAC,CAACM,MAAF,CAAS,EAAT;AACAN,WAAC,CAACO,MAAF,CAASR,GAAG,CAACM,UAAb;AACD;;AAED,YAAIJ,IAAI,CAACC,eAAL,KAAyB,KAA7B,EAAoC;AAClCF,WAAC,CAACQ,MAAF;AACD;AACF,OAbe,EAab,CAACC,MAAD,EAASC,MAAT,KAAmB;AACpB,cAAMX,GAAG,GAAQ;AACfM,oBAAU,EAAE;AADG,SAAjB;AAIA,cAAMM,GAAG,GAAGD,MAAM,IAAI,IAAV,GAAiBD,MAAM,CAACG,GAAxB,GAA8BH,MAAM,CAACI,GAAP,GAAaH,MAAvD;;AAEA,eAAOD,MAAM,CAACI,GAAP,GAAaF,GAApB,EAAyB;AACvB,gBAAMG,GAAG,GAAGL,MAAM,CAACH,MAAP,EAAZ;;AAEA,kBAAQQ,GAAG,KAAK,CAAhB;AACE,iBAAK,CAAL;AACEf,iBAAG,CAACM,UAAJ,GAAiBI,MAAM,CAACF,MAAP,EAAjB;AACA;;AACF;AACEE,oBAAM,CAACM,QAAP,CAAgBD,GAAG,GAAG,CAAtB;AACA;AANJ;AAQD;;AAED,eAAOf,GAAP;AACD,OAlCe,CAAhB;AAmCD;;AAED,WAAOD,MAAP;AACD,GAxCY;;AA0CAD,wBAAUE,GAAD,IAAkC;AACtD,WAAON,aAAa,CAACM,GAAD,EAAMF,YAAY,CAACmB,KAAb,EAAN,CAApB;AACD,GAFY;;AAIAnB,wBAAUoB,GAAD,IAAmD;AACvE,WAAOvB,aAAa,CAACuB,GAAD,EAAMpB,YAAY,CAACmB,KAAb,EAAN,CAApB;AACD,GAFY;AAGd,CApDD,EAAiBnB,YAAY,KAAZA,YAAY,MAA7B;;AA2DA,OAAM,IAAWqB,aAAX;;AAAN,WAAiBA,aAAjB,EAA8B;AAC5B,MAAYC,UAAZ;;AAAA,aAAYA,UAAZ,EAAsB;AACpBA;AACAA;AACAA;AACD,GAJD,EAAYA,UAAU,GAAVD,wDAAU,EAAV,CAAZ;;AAMA,MAAKE,kBAAL;;AAAA,aAAKA,kBAAL,EAAuB;AACrBA;AACAA;AACAA;AACD,GAJD,EAAKA,kBAAkB,KAAlBA,kBAAkB,MAAvB;;AAMA,aAAiBD,UAAjB,EAA2B;AACZA,uBAAQ,MAAK;AACxB,aAAOvB,WAAW,CAAawB,kBAAb,CAAlB;AACD,KAFY;AAGd,GAJD,EAAiBD,UAAU,GAAVD,wDAAU,EAAV,CAAjB;;AAMA,MAAIpB,MAAJ;;AAEaoB,wBAAQ,MAA2B;AAC9C,QAAIpB,MAAM,IAAI,IAAd,EAAoB;AAClBA,YAAM,GAAGH,OAAO,CAAgB,UAACI,GAAD,EAAMC,CAAN,EAAsB;AAAA,YAAbC,IAAa,uEAAN,EAAM;;AACpD,YAAIA,IAAI,CAACC,eAAL,KAAyB,KAA7B,EAAoC;AAClCF,WAAC,CAACG,IAAF;AACD;;AAED,YAAIF,IAAI,CAACG,aAAL,KAAuB,IAAvB,IAAgCL,GAAG,CAACsB,MAAJ,IAAc,IAAd,IAAsBD,kBAAkB,CAACrB,GAAG,CAACsB,MAAL,CAAlB,KAAmC,CAA7F,EAAiG;AAC/FrB,WAAC,CAACM,MAAF,CAAS,CAAT;AACAY,uBAAa,CAACC,UAAd,CAAyBH,KAAzB,GAAiCM,MAAjC,CAAwCvB,GAAG,CAACsB,MAA5C,EAAoDrB,CAApD;AACD;;AAED,YAAIC,IAAI,CAACG,aAAL,KAAuB,IAAvB,IAAgCL,GAAG,CAACwB,IAAJ,IAAY,IAAZ,IAAoBxB,GAAG,CAACwB,IAAJ,CAASC,UAAT,GAAsB,CAA9E,EAAkF;AAChFxB,WAAC,CAACM,MAAF,CAAS,EAAT;AACAN,WAAC,CAACyB,KAAF,CAAQ1B,GAAG,CAACwB,IAAZ;AACD;;AAED,YAAItB,IAAI,CAACC,eAAL,KAAyB,KAA7B,EAAoC;AAClCF,WAAC,CAACQ,MAAF;AACD;AACF,OAlBe,EAkBb,CAACC,MAAD,EAASC,MAAT,KAAmB;AACpB,cAAMX,GAAG,GAAQ;AACfsB,gBAAM,EAAEF,UAAU,CAACO,EADJ;AAEfH,cAAI,EAAE,IAAII,UAAJ,CAAe,CAAf;AAFS,SAAjB;AAKA,cAAMhB,GAAG,GAAGD,MAAM,IAAI,IAAV,GAAiBD,MAAM,CAACG,GAAxB,GAA8BH,MAAM,CAACI,GAAP,GAAaH,MAAvD;;AAEA,eAAOD,MAAM,CAACI,GAAP,GAAaF,GAApB,EAAyB;AACvB,gBAAMG,GAAG,GAAGL,MAAM,CAACH,MAAP,EAAZ;;AAEA,kBAAQQ,GAAG,KAAK,CAAhB;AACE,iBAAK,CAAL;AACEf,iBAAG,CAACsB,MAAJ,GAAaH,aAAa,CAACC,UAAd,CAAyBH,KAAzB,GAAiCY,MAAjC,CAAwCnB,MAAxC,CAAb;AACA;;AACF,iBAAK,CAAL;AACEV,iBAAG,CAACwB,IAAJ,GAAWd,MAAM,CAACgB,KAAP,EAAX;AACA;;AACF;AACEhB,oBAAM,CAACM,QAAP,CAAgBD,GAAG,GAAG,CAAtB;AACA;AATJ;AAWD;;AAED,eAAOf,GAAP;AACD,OA3Ce,CAAhB;AA4CD;;AAED,WAAOD,MAAP;AACD,GAjDY;;AAmDAoB,yBAAUnB,GAAD,IAAmC;AACvD,WAAON,aAAa,CAACM,GAAD,EAAMmB,aAAa,CAACF,KAAd,EAAN,CAApB;AACD,GAFY;;AAIAE,yBAAUD,GAAD,IAAoD;AACxE,WAAOvB,aAAa,CAACuB,GAAD,EAAMC,aAAa,CAACF,KAAd,EAAN,CAApB;AACD,GAFY;AAGd,CA/ED,EAAiBE,aAAa,KAAbA,aAAa,MAA9B","names":["encodeMessage","decodeMessage","message","enumeration","FetchRequest","_codec","obj","w","opts","lengthDelimited","fork","writeDefaults","identifier","uint32","string","ldelim","reader","length","end","len","pos","tag","skipType","codec","buf","FetchResponse","StatusCode","__StatusCodeValues","status","encode","data","byteLength","bytes","OK","Uint8Array","decode"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\fetch\\pb\\proto.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n\nimport { encodeMessage, decodeMessage, message, enumeration } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { Codec } from 'protons-runtime'\n\nexport interface FetchRequest {\n  identifier: string\n}\n\nexport namespace FetchRequest {\n  let _codec: Codec<FetchRequest>\n\n  export const codec = (): Codec<FetchRequest> => {\n    if (_codec == null) {\n      _codec = message<FetchRequest>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (opts.writeDefaults === true || obj.identifier !== '') {\n          w.uint32(10)\n          w.string(obj.identifier)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          identifier: ''\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.identifier = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: FetchRequest): Uint8Array => {\n    return encodeMessage(obj, FetchRequest.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): FetchRequest => {\n    return decodeMessage(buf, FetchRequest.codec())\n  }\n}\n\nexport interface FetchResponse {\n  status: FetchResponse.StatusCode\n  data: Uint8Array\n}\n\nexport namespace FetchResponse {\n  export enum StatusCode {\n    OK = 'OK',\n    NOT_FOUND = 'NOT_FOUND',\n    ERROR = 'ERROR'\n  }\n\n  enum __StatusCodeValues {\n    OK = 0,\n    NOT_FOUND = 1,\n    ERROR = 2\n  }\n\n  export namespace StatusCode {\n    export const codec = () => {\n      return enumeration<StatusCode>(__StatusCodeValues)\n    }\n  }\n\n  let _codec: Codec<FetchResponse>\n\n  export const codec = (): Codec<FetchResponse> => {\n    if (_codec == null) {\n      _codec = message<FetchResponse>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (opts.writeDefaults === true || (obj.status != null && __StatusCodeValues[obj.status] !== 0)) {\n          w.uint32(8)\n          FetchResponse.StatusCode.codec().encode(obj.status, w)\n        }\n\n        if (opts.writeDefaults === true || (obj.data != null && obj.data.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          status: StatusCode.OK,\n          data: new Uint8Array(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.status = FetchResponse.StatusCode.codec().decode(reader)\n              break\n            case 2:\n              obj.data = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: FetchResponse): Uint8Array => {\n    return encodeMessage(obj, FetchResponse.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): FetchResponse => {\n    return decodeMessage(buf, FetchResponse.codec())\n  }\n}\n"]},"metadata":{},"sourceType":"module"}