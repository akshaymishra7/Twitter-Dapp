{"ast":null,"code":"import { multiaddrToUri } from '@multiformats/multiaddr-to-uri';\nimport { logger } from '@libp2p/logger';\nimport shuffle from 'array-shuffle';\nimport { preload } from 'ipfs-core-config/preload';\nimport hashlru from 'hashlru';\nconst log = logger('ipfs:preload');\n/**\n * @param {import('./types').PreloadOptions} [options]\n */\n\nexport function createPreloader() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  options.enabled = Boolean(options.enabled);\n  options.addresses = options.addresses || [];\n  options.cache = options.cache || 1000;\n\n  if (!options.enabled || !options.addresses.length) {\n    log('preload disabled');\n\n    const api = () => {};\n\n    return Object.assign(api, {\n      start: () => {},\n      stop: () => {}\n    });\n  }\n\n  let stopped = true;\n  /** @type {AbortController[]} */\n\n  let requests = [];\n  const apiUris = options.addresses.map(str => multiaddrToUri(str)); // Avoid preloading the same CID over and over again\n\n  const cache = hashlru(options.cache);\n  /**\n   * @type {import('./types').Preload}\n   */\n\n  const api = async cid => {\n    try {\n      if (stopped) {\n        throw new Error(`preload ${cid} but preloader is not started`);\n      }\n\n      const path = cid.toString();\n\n      if (cache.has(path)) {\n        // we've preloaded this recently, don't preload it again\n        return;\n      } // make sure we don't preload this again any time soon\n\n\n      cache.set(path, true);\n      const fallbackApiUris = shuffle(apiUris);\n      let success = false;\n      const now = Date.now();\n\n      for (const uri of fallbackApiUris) {\n        if (stopped) throw new Error(`preload aborted for ${path}`);\n        /** @type {AbortController} */\n\n        let controller;\n\n        try {\n          controller = new AbortController();\n          requests = requests.concat(controller);\n          await preload(`${uri}/api/v0/refs?r=true&arg=${encodeURIComponent(path)}`, {\n            signal: controller.signal\n          });\n          success = true;\n        } catch (\n        /** @type {any} */\n        err) {\n          if (err.type !== 'aborted') log.error(err);\n        } finally {\n          requests = requests.filter(r => r !== controller);\n        }\n\n        if (success) break;\n      }\n\n      log(`${success ? '' : 'un'}successfully preloaded ${path} in ${Date.now() - now}ms`);\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n    }\n  };\n  /**\n   * @returns {void}\n   */\n\n\n  api.start = () => {\n    stopped = false;\n  };\n  /**\n   * @returns {void}\n   */\n\n\n  api.stop = () => {\n    stopped = true;\n    log(`aborting ${requests.length} pending preload request(s)`);\n    requests.forEach(r => r.abort());\n    requests = [];\n  };\n\n  return api;\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/preload.js"],"names":["multiaddrToUri","logger","shuffle","preload","hashlru","log","createPreloader","options","enabled","Boolean","addresses","cache","length","api","Object","assign","start","stop","stopped","requests","apiUris","map","str","cid","Error","path","toString","has","set","fallbackApiUris","success","now","Date","uri","controller","AbortController","concat","encodeURIComponent","signal","err","type","error","filter","r","forEach","abort"],"mappings":"AAAA,SAASA,cAAT,QAA+B,gCAA/B;AACA,SAASC,MAAT,QAAuB,gBAAvB;AACA,OAAOC,OAAP,MAAoB,eAApB;AACA,SAASC,OAAT,QAAwB,0BAAxB;AACA,OAAOC,OAAP,MAAoB,SAApB;AAEA,MAAMC,GAAG,GAAGJ,MAAM,CAAC,cAAD,CAAlB;AAEA;AACA;AACA;;AACA,OAAO,SAASK,eAAT,GAAwC;AAAA,MAAdC,OAAc,uEAAJ,EAAI;AAC7CA,EAAAA,OAAO,CAACC,OAAR,GAAkBC,OAAO,CAACF,OAAO,CAACC,OAAT,CAAzB;AACAD,EAAAA,OAAO,CAACG,SAAR,GAAoBH,OAAO,CAACG,SAAR,IAAqB,EAAzC;AACAH,EAAAA,OAAO,CAACI,KAAR,GAAgBJ,OAAO,CAACI,KAAR,IAAiB,IAAjC;;AAEA,MAAI,CAACJ,OAAO,CAACC,OAAT,IAAoB,CAACD,OAAO,CAACG,SAAR,CAAkBE,MAA3C,EAAmD;AACjDP,IAAAA,GAAG,CAAC,kBAAD,CAAH;;AACA,UAAMQ,GAAG,GAAG,MAAM,CAAE,CAApB;;AACA,WAAOC,MAAM,CAACC,MAAP,CAAcF,GAAd,EAAmB;AACxBG,MAAAA,KAAK,EAAE,MAAM,CAAE,CADS;AAExBC,MAAAA,IAAI,EAAE,MAAM,CAAE;AAFU,KAAnB,CAAP;AAID;;AAED,MAAIC,OAAO,GAAG,IAAd;AACA;;AACA,MAAIC,QAAQ,GAAG,EAAf;AACA,QAAMC,OAAO,GAAGb,OAAO,CAACG,SAAR,CAAkBW,GAAlB,CAAuBC,GAAD,IAAStB,cAAc,CAACsB,GAAD,CAA7C,CAAhB,CAjB6C,CAmB7C;;AACA,QAAMX,KAAK,GAAGP,OAAO,CAACG,OAAO,CAACI,KAAT,CAArB;AAEA;AACF;AACA;;AACE,QAAME,GAAG,GAAG,MAAMU,GAAN,IAAa;AACvB,QAAI;AACF,UAAIL,OAAJ,EAAa;AACX,cAAM,IAAIM,KAAJ,CAAW,WAAUD,GAAI,+BAAzB,CAAN;AACD;;AAED,YAAME,IAAI,GAAGF,GAAG,CAACG,QAAJ,EAAb;;AAEA,UAAIf,KAAK,CAACgB,GAAN,CAAUF,IAAV,CAAJ,EAAqB;AACnB;AACA;AACD,OAVC,CAYF;;;AACAd,MAAAA,KAAK,CAACiB,GAAN,CAAUH,IAAV,EAAgB,IAAhB;AAEA,YAAMI,eAAe,GAAG3B,OAAO,CAACkB,OAAD,CAA/B;AACA,UAAIU,OAAO,GAAG,KAAd;AACA,YAAMC,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAZ;;AAEA,WAAK,MAAME,GAAX,IAAkBJ,eAAlB,EAAmC;AACjC,YAAIX,OAAJ,EAAa,MAAM,IAAIM,KAAJ,CAAW,uBAAsBC,IAAK,EAAtC,CAAN;AACb;;AACA,YAAIS,UAAJ;;AAEA,YAAI;AACFA,UAAAA,UAAU,GAAG,IAAIC,eAAJ,EAAb;AACAhB,UAAAA,QAAQ,GAAGA,QAAQ,CAACiB,MAAT,CAAgBF,UAAhB,CAAX;AACA,gBAAM/B,OAAO,CAAE,GAAE8B,GAAI,2BAA0BI,kBAAkB,CAACZ,IAAD,CAAO,EAA3D,EAA8D;AAAEa,YAAAA,MAAM,EAAEJ,UAAU,CAACI;AAArB,WAA9D,CAAb;AACAR,UAAAA,OAAO,GAAG,IAAV;AACD,SALD,CAKE;AAAO;AAAmBS,QAAAA,GAA1B,EAA+B;AAC/B,cAAIA,GAAG,CAACC,IAAJ,KAAa,SAAjB,EAA4BnC,GAAG,CAACoC,KAAJ,CAAUF,GAAV;AAC7B,SAPD,SAOU;AACRpB,UAAAA,QAAQ,GAAGA,QAAQ,CAACuB,MAAT,CAAgBC,CAAC,IAAIA,CAAC,KAAKT,UAA3B,CAAX;AACD;;AAED,YAAIJ,OAAJ,EAAa;AACd;;AAEDzB,MAAAA,GAAG,CAAE,GAAEyB,OAAO,GAAG,EAAH,GAAQ,IAAK,0BAAyBL,IAAK,OAAMO,IAAI,CAACD,GAAL,KAAaA,GAAI,IAA7E,CAAH;AACD,KAvCD,CAuCE;AAAO;AAAmBQ,IAAAA,GAA1B,EAA+B;AAC/BlC,MAAAA,GAAG,CAACoC,KAAJ,CAAUF,GAAV;AACD;AACF,GA3CD;AA6CA;AACF;AACA;;;AACE1B,EAAAA,GAAG,CAACG,KAAJ,GAAY,MAAM;AAChBE,IAAAA,OAAO,GAAG,KAAV;AACD,GAFD;AAIA;AACF;AACA;;;AACEL,EAAAA,GAAG,CAACI,IAAJ,GAAW,MAAM;AACfC,IAAAA,OAAO,GAAG,IAAV;AACAb,IAAAA,GAAG,CAAE,YAAWc,QAAQ,CAACP,MAAO,6BAA7B,CAAH;AACAO,IAAAA,QAAQ,CAACyB,OAAT,CAAiBD,CAAC,IAAIA,CAAC,CAACE,KAAF,EAAtB;AACA1B,IAAAA,QAAQ,GAAG,EAAX;AACD,GALD;;AAOA,SAAON,GAAP;AACD","sourcesContent":["import { multiaddrToUri } from '@multiformats/multiaddr-to-uri'\nimport { logger } from '@libp2p/logger'\nimport shuffle from 'array-shuffle'\nimport { preload } from 'ipfs-core-config/preload'\nimport hashlru from 'hashlru'\n\nconst log = logger('ipfs:preload')\n\n/**\n * @param {import('./types').PreloadOptions} [options]\n */\nexport function createPreloader (options = {}) {\n  options.enabled = Boolean(options.enabled)\n  options.addresses = options.addresses || []\n  options.cache = options.cache || 1000\n\n  if (!options.enabled || !options.addresses.length) {\n    log('preload disabled')\n    const api = () => {}\n    return Object.assign(api, {\n      start: () => {},\n      stop: () => {}\n    })\n  }\n\n  let stopped = true\n  /** @type {AbortController[]} */\n  let requests = []\n  const apiUris = options.addresses.map((str) => multiaddrToUri(str))\n\n  // Avoid preloading the same CID over and over again\n  const cache = hashlru(options.cache)\n\n  /**\n   * @type {import('./types').Preload}\n   */\n  const api = async cid => {\n    try {\n      if (stopped) {\n        throw new Error(`preload ${cid} but preloader is not started`)\n      }\n\n      const path = cid.toString()\n\n      if (cache.has(path)) {\n        // we've preloaded this recently, don't preload it again\n        return\n      }\n\n      // make sure we don't preload this again any time soon\n      cache.set(path, true)\n\n      const fallbackApiUris = shuffle(apiUris)\n      let success = false\n      const now = Date.now()\n\n      for (const uri of fallbackApiUris) {\n        if (stopped) throw new Error(`preload aborted for ${path}`)\n        /** @type {AbortController} */\n        let controller\n\n        try {\n          controller = new AbortController()\n          requests = requests.concat(controller)\n          await preload(`${uri}/api/v0/refs?r=true&arg=${encodeURIComponent(path)}`, { signal: controller.signal })\n          success = true\n        } catch (/** @type {any} */ err) {\n          if (err.type !== 'aborted') log.error(err)\n        } finally {\n          requests = requests.filter(r => r !== controller)\n        }\n\n        if (success) break\n      }\n\n      log(`${success ? '' : 'un'}successfully preloaded ${path} in ${Date.now() - now}ms`)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  api.start = () => {\n    stopped = false\n  }\n\n  /**\n   * @returns {void}\n   */\n  api.stop = () => {\n    stopped = true\n    log(`aborting ${requests.length} pending preload request(s)`)\n    requests.forEach(r => r.abort())\n    requests = []\n  }\n\n  return api\n}\n"]},"metadata":{},"sourceType":"module"}