{"ast":null,"code":"const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\n\nconst RateLimiterRes = require('./RateLimiterRes');\n\nconst incrTtlLuaScript = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') \\\nlocal consumed = redis.call('incrby', KEYS[1], ARGV[1]) \\\nlocal ttl = redis.call('pttl', KEYS[1]) \\\nif ttl == -1 then \\\n  redis.call('expire', KEYS[1], ARGV[2]) \\\n  ttl = 1000 * ARGV[2] \\\nend \\\nreturn {consumed, ttl} \\\n`;\n\nclass RateLimiterRedis extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   redis: RedisClient\n   *   rejectIfRedisNotReady: boolean = false - reject / invoke insuranceLimiter immediately when redis connection is not \"ready\"\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n\n    if (opts.redis) {\n      this.client = opts.redis;\n    } else {\n      this.client = opts.storeClient;\n    }\n\n    this._rejectIfRedisNotReady = !!opts.rejectIfRedisNotReady;\n\n    if (typeof this.client.defineCommand === 'function') {\n      this.client.defineCommand(\"rlflxIncr\", {\n        numberOfKeys: 1,\n        lua: incrTtlLuaScript\n      });\n    }\n  }\n  /**\n   * Prevent actual redis call if redis connection is not ready\n   * Because of different connection state checks for ioredis and node-redis, only this clients would be actually checked.\n   * For any other clients all the requests would be passed directly to redis client\n   * @return {boolean}\n   * @private\n   */\n\n\n  _isRedisReady() {\n    if (!this._rejectIfRedisNotReady) {\n      return true;\n    } // ioredis client\n\n\n    if (this.client.status && this.client.status !== 'ready') {\n      return false;\n    } // node-redis client\n\n\n    if (typeof this.client.isReady === 'function' && !this.client.isReady()) {\n      return false;\n    }\n\n    return true;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    let [consumed, resTtlMs] = result; // Support ioredis results format\n\n    if (Array.isArray(consumed)) {\n      [, consumed] = consumed;\n      [, resTtlMs] = resTtlMs;\n    }\n\n    const res = new RateLimiterRes();\n    res.consumedPoints = parseInt(consumed);\n    res.isFirstInDuration = res.consumedPoints === changedPoints;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = resTtlMs;\n    return res;\n  }\n\n  _upsert(rlKey, points, msDuration) {\n    let forceExpire = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    return new Promise((resolve, reject) => {\n      if (!this._isRedisReady()) {\n        return reject(new Error('Redis connection is not ready'));\n      }\n\n      const secDuration = Math.floor(msDuration / 1000);\n      const multi = this.client.multi();\n\n      if (forceExpire) {\n        if (secDuration > 0) {\n          multi.set(rlKey, points, 'EX', secDuration);\n        } else {\n          multi.set(rlKey, points);\n        }\n\n        multi.pttl(rlKey).exec((err, res) => {\n          if (err) {\n            return reject(err);\n          }\n\n          return resolve(res);\n        });\n      } else {\n        if (secDuration > 0) {\n          const incrCallback = function (err, result) {\n            if (err) {\n              return reject(err);\n            }\n\n            return resolve(result);\n          };\n\n          if (typeof this.client.rlflxIncr === 'function') {\n            this.client.rlflxIncr(rlKey, points, secDuration, incrCallback);\n          } else {\n            this.client.eval(incrTtlLuaScript, 1, rlKey, points, secDuration, incrCallback);\n          }\n        } else {\n          multi.incrby(rlKey, points).pttl(rlKey).exec((err, res) => {\n            if (err) {\n              return reject(err);\n            }\n\n            return resolve(res);\n          });\n        }\n      }\n    });\n  }\n\n  _get(rlKey) {\n    return new Promise((resolve, reject) => {\n      if (!this._isRedisReady()) {\n        return reject(new Error('Redis connection is not ready'));\n      }\n\n      this.client.multi().get(rlKey).pttl(rlKey).exec((err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          const [points] = res;\n\n          if (points === null) {\n            return resolve(null);\n          }\n\n          resolve(res);\n        }\n      });\n    });\n  }\n\n  _delete(rlKey) {\n    return new Promise((resolve, reject) => {\n      this.client.del(rlKey, (err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res > 0);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = RateLimiterRedis;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/rate-limiter-flexible/lib/RateLimiterRedis.js"],"names":["RateLimiterStoreAbstract","require","RateLimiterRes","incrTtlLuaScript","RateLimiterRedis","constructor","opts","redis","client","storeClient","_rejectIfRedisNotReady","rejectIfRedisNotReady","defineCommand","numberOfKeys","lua","_isRedisReady","status","isReady","_getRateLimiterRes","rlKey","changedPoints","result","consumed","resTtlMs","Array","isArray","res","consumedPoints","parseInt","isFirstInDuration","remainingPoints","Math","max","points","msBeforeNext","_upsert","msDuration","forceExpire","Promise","resolve","reject","Error","secDuration","floor","multi","set","pttl","exec","err","incrCallback","rlflxIncr","eval","incrby","_get","get","_delete","del","module","exports"],"mappings":"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","sourcesContent":["const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nconst incrTtlLuaScript = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') \\\nlocal consumed = redis.call('incrby', KEYS[1], ARGV[1]) \\\nlocal ttl = redis.call('pttl', KEYS[1]) \\\nif ttl == -1 then \\\n  redis.call('expire', KEYS[1], ARGV[2]) \\\n  ttl = 1000 * ARGV[2] \\\nend \\\nreturn {consumed, ttl} \\\n`;\n\nclass RateLimiterRedis extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   redis: RedisClient\n   *   rejectIfRedisNotReady: boolean = false - reject / invoke insuranceLimiter immediately when redis connection is not \"ready\"\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n    if (opts.redis) {\n      this.client = opts.redis;\n    } else {\n      this.client = opts.storeClient;\n    }\n\n    this._rejectIfRedisNotReady = !!opts.rejectIfRedisNotReady;\n\n    if (typeof this.client.defineCommand === 'function') {\n      this.client.defineCommand(\"rlflxIncr\", {\n        numberOfKeys: 1,\n        lua: incrTtlLuaScript,\n      });\n    }\n  }\n\n  /**\n   * Prevent actual redis call if redis connection is not ready\n   * Because of different connection state checks for ioredis and node-redis, only this clients would be actually checked.\n   * For any other clients all the requests would be passed directly to redis client\n   * @return {boolean}\n   * @private\n   */\n  _isRedisReady() {\n    if (!this._rejectIfRedisNotReady) {\n      return true;\n    }\n    // ioredis client\n    if (this.client.status && this.client.status !== 'ready') {\n      return false;\n    }\n    // node-redis client\n    if (typeof this.client.isReady === 'function' && !this.client.isReady()) {\n      return false;\n    }\n    return true;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    let [consumed, resTtlMs] = result;\n    // Support ioredis results format\n    if (Array.isArray(consumed)) {\n      [, consumed] = consumed;\n      [, resTtlMs] = resTtlMs;\n    }\n\n    const res = new RateLimiterRes();\n    res.consumedPoints = parseInt(consumed);\n    res.isFirstInDuration = res.consumedPoints === changedPoints;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = resTtlMs;\n\n    return res;\n  }\n\n  _upsert(rlKey, points, msDuration, forceExpire = false) {\n    return new Promise((resolve, reject) => {\n      if (!this._isRedisReady()) {\n        return reject(new Error('Redis connection is not ready'));\n      }\n\n      const secDuration = Math.floor(msDuration / 1000);\n      const multi = this.client.multi();\n      if (forceExpire) {\n        if (secDuration > 0) {\n          multi.set(rlKey, points, 'EX', secDuration);\n        } else {\n          multi.set(rlKey, points);\n        }\n\n        multi.pttl(rlKey)\n          .exec((err, res) => {\n            if (err) {\n              return reject(err);\n            }\n\n            return resolve(res);\n          });\n      } else {\n        if (secDuration > 0) {\n          const incrCallback = function(err, result) {\n            if (err) {\n              return reject(err);\n            }\n\n            return resolve(result);\n          };\n\n          if (typeof this.client.rlflxIncr === 'function') {\n            this.client.rlflxIncr(rlKey, points, secDuration, incrCallback);\n          } else {\n            this.client.eval(incrTtlLuaScript, 1, rlKey, points, secDuration, incrCallback);\n          }\n        } else {\n          multi.incrby(rlKey, points)\n            .pttl(rlKey)\n            .exec((err, res) => {\n              if (err) {\n                return reject(err);\n              }\n\n              return resolve(res);\n            });\n        }\n      }\n    });\n  }\n\n  _get(rlKey) {\n    return new Promise((resolve, reject) => {\n      if (!this._isRedisReady()) {\n        return reject(new Error('Redis connection is not ready'));\n      }\n\n      this.client\n        .multi()\n        .get(rlKey)\n        .pttl(rlKey)\n        .exec((err, res) => {\n          if (err) {\n            reject(err);\n          } else {\n            const [points] = res;\n            if (points === null) {\n              return resolve(null)\n            }\n\n            resolve(res);\n          }\n        });\n    });\n  }\n\n  _delete(rlKey) {\n    return new Promise((resolve, reject) => {\n      this.client.del(rlKey, (err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res > 0);\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = RateLimiterRedis;\n"]},"metadata":{},"sourceType":"script"}