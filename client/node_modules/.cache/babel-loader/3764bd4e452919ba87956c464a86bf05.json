{"ast":null,"code":"import { CID } from 'multiformats/cid';\nimport debug from 'debug';\nimport { notFoundError } from 'datastore-core/errors';\nimport parallelBatch from 'it-parallel-batch';\nimport { pipe } from 'it-pipe';\nimport merge from 'it-merge';\nimport map from 'it-map';\nimport filter from 'it-filter';\nimport { Key } from 'interface-datastore/key';\nimport { base32 } from 'multiformats/bases/base32';\nimport { walkDag } from './utils/walk-dag.js';\nconst log = debug('ipfs:repo:gc');\nconst ERR_NOT_FOUND = notFoundError().code; // Limit on the number of parallel block remove operations\n\nconst BLOCK_RM_CONCURRENCY = 256;\nconst MFS_ROOT_KEY = new Key('/local/filesroot');\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./types').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\n\nexport function gc(_ref) {\n  let {\n    gcLock,\n    pins,\n    blockstore,\n    root,\n    loadCodec\n  } = _ref;\n\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  async function* gc() {\n    const start = Date.now();\n    log('Creating set of marked blocks');\n    const release = await gcLock.writeLock();\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({\n        pins,\n        blockstore,\n        root,\n        loadCodec\n      }); // Get all blocks keys from the blockstore\n\n      const blockKeys = blockstore.queryKeys({}); // Delete blocks that are not being used\n      // @ts-ignore ts cannot tell that we filter out null results\n\n      yield* deleteUnmarkedBlocks({\n        blockstore\n      }, markedSet, blockKeys);\n      log(`Complete (${Date.now() - start}ms)`);\n    } finally {\n      release();\n    }\n  }\n\n  return gc;\n}\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pin-manager').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\n\nasync function createMarkedSet(_ref2) {\n  let {\n    pins,\n    blockstore,\n    loadCodec,\n    root\n  } = _ref2;\n\n  const mfsSource = async function* () {\n    let mh;\n\n    try {\n      mh = await root.get(MFS_ROOT_KEY);\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS');\n        return;\n      }\n\n      throw err;\n    }\n\n    const rootCid = CID.decode(mh);\n    yield rootCid;\n    yield* walkDag(rootCid, blockstore, loadCodec);\n  }();\n\n  const pinsSource = merge(map(pins.recursiveKeys(), _ref3 => {\n    let {\n      cid\n    } = _ref3;\n    return cid;\n  }), pins.indirectKeys(), map(pins.directKeys(), _ref4 => {\n    let {\n      cid\n    } = _ref4;\n    return cid;\n  }), mfsSource);\n  const output = new Set();\n\n  for await (const cid of merge(pinsSource, mfsSource)) {\n    output.add(base32.encode(cid.multihash.bytes));\n  }\n\n  return output;\n}\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\n\n\nasync function* deleteUnmarkedBlocks(_ref5, markedSet, blockKeys) {\n  let {\n    blockstore\n  } = _ref5;\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0;\n  let removedBlocksCount = 0;\n  /**\n   * @param {CID} cid\n   */\n\n  const removeBlock = async cid => {\n    return async function remove() {\n      blocksCount++;\n\n      try {\n        const b32 = base32.encode(cid.multihash.bytes);\n\n        if (markedSet.has(b32)) {\n          return null;\n        }\n\n        try {\n          await blockstore.delete(cid);\n          removedBlocksCount++;\n        } catch (\n        /** @type {any} */\n        err) {\n          return {\n            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n          };\n        }\n\n        return {\n          cid\n        };\n      } catch (\n      /** @type {any} */\n      err) {\n        const msg = `Could delete block with CID ${cid}`;\n        log(msg, err);\n        return {\n          err: new Error(msg + `: ${err.message}`)\n        };\n      }\n    };\n  };\n\n  yield* pipe(parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY), // filter nulls (blocks that were retained)\n  source => filter(source, Boolean));\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` + `Deleted ${removedBlocksCount} blocks.`);\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-repo/src/gc.js"],"names":["CID","debug","notFoundError","parallelBatch","pipe","merge","map","filter","Key","base32","walkDag","log","ERR_NOT_FOUND","code","BLOCK_RM_CONCURRENCY","MFS_ROOT_KEY","gc","gcLock","pins","blockstore","root","loadCodec","start","Date","now","release","writeLock","markedSet","createMarkedSet","blockKeys","queryKeys","deleteUnmarkedBlocks","mfsSource","mh","get","err","rootCid","decode","pinsSource","recursiveKeys","cid","indirectKeys","directKeys","output","Set","add","encode","multihash","bytes","blocksCount","removedBlocksCount","removeBlock","remove","b32","has","delete","Error","message","msg","source","Boolean","size"],"mappings":"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","sourcesContent":["\nimport { CID } from 'multiformats/cid'\nimport debug from 'debug'\nimport { notFoundError } from 'datastore-core/errors'\nimport parallelBatch from 'it-parallel-batch'\nimport { pipe } from 'it-pipe'\nimport merge from 'it-merge'\nimport map from 'it-map'\nimport filter from 'it-filter'\nimport { Key } from 'interface-datastore/key'\nimport { base32 } from 'multiformats/bases/base32'\nimport { walkDag } from './utils/walk-dag.js'\n\nconst log = debug('ipfs:repo:gc')\nconst ERR_NOT_FOUND = notFoundError().code\n\n// Limit on the number of parallel block remove operations\nconst BLOCK_RM_CONCURRENCY = 256\n\nconst MFS_ROOT_KEY = new Key('/local/filesroot')\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./types').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nexport function gc ({ gcLock, pins, blockstore, root, loadCodec }) {\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  async function * gc () {\n    const start = Date.now()\n    log('Creating set of marked blocks')\n\n    const release = await gcLock.writeLock()\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({ pins, blockstore, root, loadCodec })\n      // Get all blocks keys from the blockstore\n      const blockKeys = blockstore.queryKeys({})\n\n      // Delete blocks that are not being used\n      // @ts-ignore ts cannot tell that we filter out null results\n      yield * deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys)\n\n      log(`Complete (${Date.now() - start}ms)`)\n    } finally {\n      release()\n    }\n  }\n\n  return gc\n}\n\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pin-manager').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nasync function createMarkedSet ({ pins, blockstore, loadCodec, root }) {\n  const mfsSource = (async function * () {\n    let mh\n    try {\n      mh = await root.get(MFS_ROOT_KEY)\n    } catch (/** @type {any} */ err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS')\n        return\n      }\n\n      throw err\n    }\n\n    const rootCid = CID.decode(mh)\n    yield rootCid\n    yield * walkDag(rootCid, blockstore, loadCodec)\n  })()\n\n  const pinsSource = merge(\n    map(pins.recursiveKeys(), ({ cid }) => cid),\n    pins.indirectKeys(),\n    map(pins.directKeys(), ({ cid }) => cid),\n    mfsSource\n  )\n\n  const output = new Set()\n\n  for await (const cid of merge(pinsSource, mfsSource)) {\n    output.add(base32.encode(cid.multihash.bytes))\n  }\n\n  return output\n}\n\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\nasync function * deleteUnmarkedBlocks ({ blockstore }, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0\n  let removedBlocksCount = 0\n\n  /**\n   * @param {CID} cid\n   */\n  const removeBlock = async (cid) => {\n    return async function remove () {\n      blocksCount++\n\n      try {\n        const b32 = base32.encode(cid.multihash.bytes)\n\n        if (markedSet.has(b32)) {\n          return null\n        }\n\n        try {\n          await blockstore.delete(cid)\n          removedBlocksCount++\n        } catch (/** @type {any} */ err) {\n          return {\n            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n          }\n        }\n\n        return { cid }\n      } catch (/** @type {any} */ err) {\n        const msg = `Could delete block with CID ${cid}`\n        log(msg, err)\n        return { err: new Error(msg + `: ${err.message}`) }\n      }\n    }\n  }\n\n  yield * pipe(\n    parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY),\n    // filter nulls (blocks that were retained)\n    source => filter(source, Boolean)\n  )\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` +\n  `Deleted ${removedBlocksCount} blocks.`)\n}\n"]},"metadata":{},"sourceType":"module"}