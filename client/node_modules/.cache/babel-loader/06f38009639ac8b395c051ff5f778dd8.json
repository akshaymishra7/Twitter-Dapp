{"ast":null,"code":"import { Bucket, createHAMT } from 'hamt-sharding';\nimport { decode } from '@ipld/dag-pb';\nimport { murmur3128 } from '@multiformats/murmur3';\n\nconst hashFn = async function (buf) {\n  return (await murmur3128.encode(buf)).slice(0, 8).reverse();\n};\n\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(links.map(link => {\n    if (link.Name == null) {\n      throw new Error('Unexpected Link without a Name');\n    }\n\n    if (link.Name.length === 2) {\n      const pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new Bucket({\n        hash: rootBucket._options.hash,\n        bits: rootBucket._options.bits\n      }, bucket, pos));\n    }\n\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\n\nconst toPrefix = position => {\n  return position.toString(16).toUpperCase().padStart(2, '0').substring(0, 2);\n};\n\nconst toBucketPath = position => {\n  let bucket = position.bucket;\n  const path = [];\n\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n\n  path.push(bucket);\n  return path.reverse();\n};\n\nconst findShardCid = async (node, name, blockstore, context, options) => {\n  if (!context) {\n    const rootBucket = createHAMT({\n      hashFn\n    });\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    };\n  }\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n  const position = await context.rootBucket._findNewBucketAndPos(name);\n  let prefix = toPrefix(position.pos);\n  const bucketPath = toBucketPath(position);\n\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth];\n    prefix = toPrefix(context.lastBucket._posAtParent);\n  }\n\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false;\n    }\n\n    const entryPrefix = link.Name.substring(0, 2);\n    const entryName = link.Name.substring(2);\n\n    if (entryPrefix !== prefix) {\n      return false;\n    }\n\n    if (entryName && entryName !== name) {\n      return false;\n    }\n\n    return true;\n  });\n\n  if (!link) {\n    return null;\n  }\n\n  if (link.Name != null && link.Name.substring(2) === name) {\n    return link.Hash;\n  }\n\n  context.hamtDepth++;\n  const block = await blockstore.get(link.Hash, options);\n  node = decode(block);\n  return findShardCid(node, name, blockstore, context, options);\n};\n\nexport default findShardCid;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/client/node_modules/ipfs-unixfs-exporter/esm/src/utils/find-cid-in-shard.js"],"names":["Bucket","createHAMT","decode","murmur3128","hashFn","buf","encode","slice","reverse","addLinksToHamtBucket","links","bucket","rootBucket","Promise","all","map","link","Name","Error","length","pos","parseInt","_putObjectAt","hash","_options","bits","put","substring","toPrefix","position","toString","toUpperCase","padStart","toBucketPath","path","_parent","push","findShardCid","node","name","blockstore","context","options","hamtDepth","lastBucket","Links","_findNewBucketAndPos","prefix","bucketPath","_posAtParent","find","entryPrefix","entryName","Hash","block","get"],"mappings":"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","sourcesContent":["import {\n  Bucket,\n  createHAMT\n} from 'hamt-sharding';\nimport { decode } from '@ipld/dag-pb';\nimport { murmur3128 } from '@multiformats/murmur3';\nconst hashFn = async function (buf) {\n  return (await murmur3128.encode(buf)).slice(0, 8).reverse();\n};\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(links.map(link => {\n    if (link.Name == null) {\n      throw new Error('Unexpected Link without a Name');\n    }\n    if (link.Name.length === 2) {\n      const pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new Bucket({\n        hash: rootBucket._options.hash,\n        bits: rootBucket._options.bits\n      }, bucket, pos));\n    }\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\nconst toPrefix = position => {\n  return position.toString(16).toUpperCase().padStart(2, '0').substring(0, 2);\n};\nconst toBucketPath = position => {\n  let bucket = position.bucket;\n  const path = [];\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n  path.push(bucket);\n  return path.reverse();\n};\nconst findShardCid = async (node, name, blockstore, context, options) => {\n  if (!context) {\n    const rootBucket = createHAMT({ hashFn });\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    };\n  }\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n  const position = await context.rootBucket._findNewBucketAndPos(name);\n  let prefix = toPrefix(position.pos);\n  const bucketPath = toBucketPath(position);\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth];\n    prefix = toPrefix(context.lastBucket._posAtParent);\n  }\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false;\n    }\n    const entryPrefix = link.Name.substring(0, 2);\n    const entryName = link.Name.substring(2);\n    if (entryPrefix !== prefix) {\n      return false;\n    }\n    if (entryName && entryName !== name) {\n      return false;\n    }\n    return true;\n  });\n  if (!link) {\n    return null;\n  }\n  if (link.Name != null && link.Name.substring(2) === name) {\n    return link.Hash;\n  }\n  context.hamtDepth++;\n  const block = await blockstore.get(link.Hash, options);\n  node = decode(block);\n  return findShardCid(node, name, blockstore, context, options);\n};\nexport default findShardCid;"]},"metadata":{},"sourceType":"module"}