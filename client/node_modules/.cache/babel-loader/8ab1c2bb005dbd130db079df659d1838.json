{"ast":null,"code":"import * as dagPB from '@ipld/dag-pb';\nimport { notFoundError } from 'datastore-core/errors';\nimport { toCidAndPath } from 'ipfs-core-utils/to-cid-and-path';\nimport { CID } from 'multiformats/cid';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { anySignal } from 'any-signal';\nconst ERR_NOT_FOUND = notFoundError().code;\nexport const Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\n\nexport function createRefs(_ref) {\n  let {\n    repo,\n    codecs,\n    resolve,\n    preload\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/refs').API<{}>[\"refs\"]}\n   */\n  async function* refs(ipfsPath) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.maxDepth === 0) {\n      return;\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format');\n    }\n\n    options.format = options.edges ? Format.edges : options.format;\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1;\n    }\n\n    if (options.timeout) {\n      const controller = new TimeoutController(options.timeout);\n      const signals = [controller.signal];\n\n      if (options.signal) {\n        signals.push(options.signal);\n      }\n\n      options.signal = anySignal(signals);\n    }\n    /** @type {(string|CID)[]} */\n\n\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n    const paths = rawPaths.map(p => getFullPath(preload, p, options));\n\n    for (const path of paths) {\n      try {\n        yield* refsStream(resolve, repo, codecs, path, options);\n      } catch (\n      /** @type {any} */\n      err) {\n        yield {\n          ref: '',\n          err: err.message\n        };\n      }\n    }\n  }\n\n  return refs;\n}\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\nfunction getFullPath(preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath);\n\n  if (options.preload !== false) {\n    preload(cid);\n  }\n\n  return `/ipfs/${cid}${path || ''}`;\n}\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\n\nasync function* refsStream(resolve, repo, codecs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path, options);\n  const {\n    cid\n  } = toCidAndPath(resPath);\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;\n  const unique = options.unique || false; // Traverse the DAG, converting it into a stream\n\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique, options)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue;\n    } // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n\n\n    if (obj.isDuplicate) {\n      continue;\n    } // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n\n\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    };\n  }\n}\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\n\n\nfunction formatLink(srcCid, dstCid) {\n  let linkName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  let format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Format.default;\n  let out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n}\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n * @param {AbortOptions} options\n */\n\n\nasync function* objectStream(repo, codecs, rootCid, maxDepth, uniqueOnly, options) {\n  // eslint-disable-line require-await\n  const seen = new Set();\n  /**\n   * @param {Node} parent\n   * @param {number} depth\n   * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n   */\n\n  async function* traverseLevel(parent, depth) {\n    const nextLevelDepth = depth + 1; // Check the depth\n\n    if (nextLevelDepth > maxDepth) {\n      return;\n    } // Get this object's links\n\n\n    try {\n      // Look at each link, parent and the new depth\n      for await (const link of getLinks(repo, codecs, parent.cid, options)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        };\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString());\n        }\n\n        yield* traverseLevel(link, nextLevelDepth);\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`;\n      }\n\n      throw err;\n    }\n  }\n\n  yield* traverseLevel({\n    cid: rootCid\n  }, 0);\n}\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID} cid\n * @param {AbortOptions} options\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\n\n\nasync function* getLinks(repo, codecs, cid, options) {\n  const block = await repo.blocks.get(cid, options);\n  const codec = await codecs.getCodec(cid.code);\n  const value = codec.decode(block);\n  const isDagPb = cid.code === dagPB.code;\n  /** @type {Array<string|number>} */\n\n  const base = [];\n\n  for (const [name, cid] of links(value, base)) {\n    // special case for dag-pb - use the name of the link\n    // instead of the path within the object\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/);\n\n      if (match) {\n        const index = Number(match[1]);\n\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          };\n          continue;\n        }\n      }\n    }\n\n    yield {\n      name,\n      cid\n    };\n  }\n}\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\n\n\nconst links = function* (source, base) {\n  if (source == null) {\n    return;\n  }\n\n  if (source instanceof Uint8Array) {\n    return;\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key];\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index];\n          const cid = CID.asCID(element); // eslint-disable-next-line max-depth\n\n          if (cid) {\n            yield [elementPath.join('/'), cid];\n          } else if (typeof element === 'object') {\n            yield* links(element, elementPath);\n          }\n        }\n      } else {\n        const cid = CID.asCID(value);\n\n        if (cid) {\n          yield [path.join('/'), cid];\n        } else {\n          yield* links(value, path);\n        }\n      }\n    }\n  } // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n\n\n  return [];\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/refs/index.js"],"names":["dagPB","notFoundError","toCidAndPath","CID","TimeoutController","anySignal","ERR_NOT_FOUND","code","Format","default","edges","createRefs","repo","codecs","resolve","preload","refs","ipfsPath","options","maxDepth","format","Error","recursive","Infinity","timeout","controller","signals","signal","push","rawPaths","Array","isArray","paths","map","p","getFullPath","path","refsStream","err","ref","message","cid","resPath","unique","obj","objectStream","parent","isDuplicate","formatLink","node","name","srcCid","dstCid","linkName","out","replace","toString","rootCid","uniqueOnly","seen","Set","traverseLevel","depth","nextLevelDepth","link","getLinks","has","add","block","blocks","get","codec","getCodec","value","decode","isDagPb","base","links","match","index","Number","Links","length","Name","source","Uint8Array","key","Object","entries","element","elementPath","asCID","join"],"mappings":"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","sourcesContent":["import * as dagPB from '@ipld/dag-pb'\nimport { notFoundError } from 'datastore-core/errors'\nimport { toCidAndPath } from 'ipfs-core-utils/to-cid-and-path'\nimport { CID } from 'multiformats/cid'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { anySignal } from 'any-signal'\n\nconst ERR_NOT_FOUND = notFoundError().code\n\nexport const Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n}\n\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\nexport function createRefs ({ repo, codecs, resolve, preload }) {\n  /**\n   * @type {import('ipfs-core-types/src/refs').API<{}>[\"refs\"]}\n   */\n  async function * refs (ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format')\n    }\n\n    options.format = options.edges ? Format.edges : options.format\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1\n    }\n\n    if (options.timeout) {\n      const controller = new TimeoutController(options.timeout)\n      const signals = [controller.signal]\n\n      if (options.signal) {\n        signals.push(options.signal)\n      }\n\n      options.signal = anySignal(signals)\n    }\n\n    /** @type {(string|CID)[]} */\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath]\n\n    const paths = rawPaths.map(p => getFullPath(preload, p, options))\n\n    for (const path of paths) {\n      try {\n        yield * refsStream(resolve, repo, codecs, path, options)\n      } catch (/** @type {any} */ err) {\n        yield {\n          ref: '',\n          err: err.message\n        }\n      }\n    }\n  }\n\n  return refs\n}\n\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nfunction getFullPath (preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath)\n\n  if (options.preload !== false) {\n    preload(cid)\n  }\n\n  return `/ipfs/${cid}${path || ''}`\n}\n\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nasync function * refsStream (resolve, repo, codecs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path, options)\n  const {\n    cid\n  } = toCidAndPath(resPath)\n\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity\n  const unique = options.unique || false\n\n  // Traverse the DAG, converting it into a stream\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique, options)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue\n    }\n\n    // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n    if (obj.isDuplicate) {\n      continue\n    }\n\n    // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    }\n  }\n}\n\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\nfunction formatLink (srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString())\n  out = out.replace(/<dst>/g, dstCid.toString())\n  out = out.replace(/<linkname>/g, linkName)\n  return out\n}\n\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n * @param {AbortOptions} options\n */\nasync function * objectStream (repo, codecs, rootCid, maxDepth, uniqueOnly, options) { // eslint-disable-line require-await\n  const seen = new Set()\n\n  /**\n   * @param {Node} parent\n   * @param {number} depth\n   * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n   */\n  async function * traverseLevel (parent, depth) {\n    const nextLevelDepth = depth + 1\n\n    // Check the depth\n    if (nextLevelDepth > maxDepth) {\n      return\n    }\n\n    // Get this object's links\n    try {\n      // Look at each link, parent and the new depth\n      for await (const link of getLinks(repo, codecs, parent.cid, options)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        }\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString())\n        }\n\n        yield * traverseLevel(link, nextLevelDepth)\n      }\n    } catch (/** @type {any} */ err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`\n      }\n\n      throw err\n    }\n  }\n\n  yield * traverseLevel({ cid: rootCid }, 0)\n}\n\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID} cid\n * @param {AbortOptions} options\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\nasync function * getLinks (repo, codecs, cid, options) {\n  const block = await repo.blocks.get(cid, options)\n  const codec = await codecs.getCodec(cid.code)\n  const value = codec.decode(block)\n  const isDagPb = cid.code === dagPB.code\n  /** @type {Array<string|number>} */\n  const base = []\n\n  for (const [name, cid] of links(value, base)) {\n    // special case for dag-pb - use the name of the link\n    // instead of the path within the object\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/)\n\n      if (match) {\n        const index = Number(match[1])\n\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          }\n\n          continue\n        }\n      }\n    }\n\n    yield {\n      name,\n      cid\n    }\n  }\n}\n\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nconst links = function * (source, base) {\n  if (source == null) {\n    return\n  }\n\n  if (source instanceof Uint8Array) {\n    return\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key]\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index]\n          const cid = CID.asCID(element)\n\n          // eslint-disable-next-line max-depth\n          if (cid) {\n            yield [elementPath.join('/'), cid]\n          } else if (typeof element === 'object') {\n            yield * links(element, elementPath)\n          }\n        }\n      } else {\n        const cid = CID.asCID(value)\n\n        if (cid) {\n          yield [path.join('/'), cid]\n        } else {\n          yield * links(value, path)\n        }\n      }\n    }\n  }\n\n  // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n  return []\n}\n"]},"metadata":{},"sourceType":"module"}