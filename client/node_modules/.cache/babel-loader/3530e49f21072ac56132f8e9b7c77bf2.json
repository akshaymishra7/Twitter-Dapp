{"ast":null,"code":"import { peerIdFromString } from '@libp2p/peer-id';\nimport { mapIterable } from './util.js';\n/**\n * We can't use PeerIds as map keys because map keys are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```JavaScript\n * import { peerMap } from '@libp2p/peer-collections'\n *\n * const map = peerMap<string>()\n * map.set(peerId, 'value')\n * ```\n */\n\nexport class PeerMap {\n  constructor(map) {\n    this.map = new Map();\n\n    if (map != null) {\n      for (const [key, value] of map.entries()) {\n        this.map.set(key.toString(), value);\n      }\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  clear() {\n    this.map.clear();\n  }\n\n  delete(peer) {\n    this.map.delete(peer.toString());\n  }\n\n  entries() {\n    return mapIterable(this.map.entries(), val => {\n      return [peerIdFromString(val[0]), val[1]];\n    });\n  }\n\n  forEach(fn) {\n    this.map.forEach((value, key) => {\n      fn(value, peerIdFromString(key), this);\n    });\n  }\n\n  get(peer) {\n    return this.map.get(peer.toString());\n  }\n\n  has(peer) {\n    return this.map.has(peer.toString());\n  }\n\n  set(peer, value) {\n    this.map.set(peer.toString(), value);\n  }\n\n  keys() {\n    return mapIterable(this.map.keys(), val => {\n      return peerIdFromString(val);\n    });\n  }\n\n  values() {\n    return this.map.values();\n  }\n\n  get size() {\n    return this.map.size;\n  }\n\n}","map":{"version":3,"mappings":"AACA,SAASA,gBAAT,QAAiC,iBAAjC;AACA,SAASC,WAAT,QAA4B,WAA5B;AAEA;;;;;;;;;;;;;;;;;;AAiBA,OAAM,MAAOC,OAAP,CAAc;AAGlBC,cAAaC,GAAb,EAA6B;AAC3B,SAAKA,GAAL,GAAW,IAAIC,GAAJ,EAAX;;AAEA,QAAID,GAAG,IAAI,IAAX,EAAiB;AACf,WAAK,MAAM,CAACE,GAAD,EAAMC,KAAN,CAAX,IAA2BH,GAAG,CAACI,OAAJ,EAA3B,EAA0C;AACxC,aAAKJ,GAAL,CAASK,GAAT,CAAaH,GAAG,CAACI,QAAJ,EAAb,EAA6BH,KAA7B;AACD;AACF;AACF;;AAEe,GAAfI,MAAM,CAACC,QAAQ,IAAC;AACf,WAAO,KAAKJ,OAAL,EAAP;AACD;;AAEDK,OAAK;AACH,SAAKT,GAAL,CAASS,KAAT;AACD;;AAEDC,QAAM,CAAEC,IAAF,EAAc;AAClB,SAAKX,GAAL,CAASU,MAAT,CAAgBC,IAAI,CAACL,QAAL,EAAhB;AACD;;AAEDF,SAAO;AACL,WAAOP,WAAW,CAChB,KAAKG,GAAL,CAASI,OAAT,EADgB,EAEfQ,GAAD,IAAQ;AACN,aAAO,CAAChB,gBAAgB,CAACgB,GAAG,CAAC,CAAD,CAAJ,CAAjB,EAA2BA,GAAG,CAAC,CAAD,CAA9B,CAAP;AACD,KAJe,CAAlB;AAMD;;AAEDC,SAAO,CAAEC,EAAF,EAAsD;AAC3D,SAAKd,GAAL,CAASa,OAAT,CAAiB,CAACV,KAAD,EAAQD,GAAR,KAAe;AAC9BY,QAAE,CAACX,KAAD,EAAQP,gBAAgB,CAACM,GAAD,CAAxB,EAA+B,IAA/B,CAAF;AACD,KAFD;AAGD;;AAEDa,KAAG,CAAEJ,IAAF,EAAc;AACf,WAAO,KAAKX,GAAL,CAASe,GAAT,CAAaJ,IAAI,CAACL,QAAL,EAAb,CAAP;AACD;;AAEDU,KAAG,CAAEL,IAAF,EAAc;AACf,WAAO,KAAKX,GAAL,CAASgB,GAAT,CAAaL,IAAI,CAACL,QAAL,EAAb,CAAP;AACD;;AAEDD,KAAG,CAAEM,IAAF,EAAgBR,KAAhB,EAAwB;AACzB,SAAKH,GAAL,CAASK,GAAT,CAAaM,IAAI,CAACL,QAAL,EAAb,EAA8BH,KAA9B;AACD;;AAEDc,MAAI;AACF,WAAOpB,WAAW,CAChB,KAAKG,GAAL,CAASiB,IAAT,EADgB,EAEfL,GAAD,IAAQ;AACN,aAAOhB,gBAAgB,CAACgB,GAAD,CAAvB;AACD,KAJe,CAAlB;AAMD;;AAEDM,QAAM;AACJ,WAAO,KAAKlB,GAAL,CAASkB,MAAT,EAAP;AACD;;AAEO,MAAJC,IAAI;AACN,WAAO,KAAKnB,GAAL,CAASmB,IAAhB;AACD;;AAnEiB","names":["peerIdFromString","mapIterable","PeerMap","constructor","map","Map","key","value","entries","set","toString","Symbol","iterator","clear","delete","peer","val","forEach","fn","get","has","keys","values","size"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\peer-collections\\src\\map.ts"],"sourcesContent":["import type { PeerId } from '@libp2p/interface-peer-id'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { mapIterable } from './util.js'\n\n/**\n * We can't use PeerIds as map keys because map keys are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```JavaScript\n * import { peerMap } from '@libp2p/peer-collections'\n *\n * const map = peerMap<string>()\n * map.set(peerId, 'value')\n * ```\n */\nexport class PeerMap <T> {\n  private readonly map: Map<string, T>\n\n  constructor (map?: PeerMap<T>) {\n    this.map = new Map()\n\n    if (map != null) {\n      for (const [key, value] of map.entries()) {\n        this.map.set(key.toString(), value)\n      }\n    }\n  }\n\n  [Symbol.iterator] (): IterableIterator<[PeerId, T]> {\n    return this.entries()\n  }\n\n  clear (): void {\n    this.map.clear()\n  }\n\n  delete (peer: PeerId): void {\n    this.map.delete(peer.toString())\n  }\n\n  entries (): IterableIterator<[PeerId, T]> {\n    return mapIterable<[string, T], [PeerId, T]>(\n      this.map.entries(),\n      (val) => {\n        return [peerIdFromString(val[0]), val[1]]\n      }\n    )\n  }\n\n  forEach (fn: (value: T, key: PeerId, map: PeerMap<T>) => void): void {\n    this.map.forEach((value, key) => {\n      fn(value, peerIdFromString(key), this)\n    })\n  }\n\n  get (peer: PeerId): T | undefined {\n    return this.map.get(peer.toString())\n  }\n\n  has (peer: PeerId): boolean {\n    return this.map.has(peer.toString())\n  }\n\n  set (peer: PeerId, value: T): void {\n    this.map.set(peer.toString(), value)\n  }\n\n  keys (): IterableIterator<PeerId> {\n    return mapIterable<string, PeerId>(\n      this.map.keys(),\n      (val) => {\n        return peerIdFromString(val)\n      }\n    )\n  }\n\n  values (): IterableIterator<T> {\n    return this.map.values()\n  }\n\n  get size (): number {\n    return this.map.size\n  }\n}\n"]},"metadata":{},"sourceType":"module"}