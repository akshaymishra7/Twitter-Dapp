{"ast":null,"code":"import { CarBlockIterator } from '@ipld/car/iterator';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport itPeekable from 'it-peekable';\nimport drain from 'it-drain';\nimport map from 'it-map';\nimport { logger } from '@libp2p/logger';\nconst log = logger('ipfs:components:dag:import');\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/dag/').ImportRootStatus} RootStatus\n */\n\n/**\n * @param {object} config\n * @param {IPFSRepo} config.repo\n */\n\nexport function createImport(_ref) {\n  let {\n    repo\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/dag').API<{}>[\"import\"]}\n   */\n  async function* dagImport(sources) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const release = await repo.gcLock.readLock();\n\n    try {\n      const abortOptions = {\n        signal: options.signal,\n        timeout: options.timeout\n      };\n      const peekable = itPeekable(sources);\n      const {\n        value,\n        done\n      } = await peekable.peek();\n\n      if (done) {\n        return;\n      }\n\n      if (value) {\n        // @ts-expect-error\n        peekable.push(value);\n      }\n      /**\n       * @type {AsyncIterable<AsyncIterable<Uint8Array>> | Iterable<AsyncIterable<Uint8Array>>}\n       */\n\n\n      let cars;\n\n      if (value instanceof Uint8Array) {\n        // @ts-expect-error\n        cars = [peekable];\n      } else {\n        // @ts-expect-error\n        cars = peekable;\n      }\n\n      for await (const car of cars) {\n        const roots = await importCar(repo, abortOptions, car);\n\n        if (options.pinRoots !== false) {\n          // default=true\n          for (const cid of roots) {\n            let pinErrorMsg = '';\n\n            try {\n              // eslint-disable-line max-depth\n              if (await repo.blocks.has(cid)) {\n                // eslint-disable-line max-depth\n                log(`Pinning root ${cid}`);\n                await repo.pins.pinRecursively(cid);\n              } else {\n                pinErrorMsg = 'blockstore: block not found';\n              }\n            } catch (\n            /** @type {any} */\n            err) {\n              pinErrorMsg = err.message;\n            }\n\n            yield {\n              root: {\n                cid,\n                pinErrorMsg\n              }\n            };\n          }\n        }\n      }\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption(dagImport);\n}\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {Promise<CID[]>}\n */\n\nasync function importCar(repo, options, source) {\n  const reader = await CarBlockIterator.fromIterable(source);\n  const roots = await reader.getRoots();\n  await drain(repo.blocks.putMany(map(reader, _ref2 => {\n    let {\n      cid: key,\n      bytes: value\n    } = _ref2;\n    log(`Import block ${key}`);\n    return {\n      key,\n      value\n    };\n  }), {\n    signal: options.signal\n  }));\n  return roots;\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/dag/import.js"],"names":["CarBlockIterator","withTimeoutOption","itPeekable","drain","map","logger","log","createImport","repo","dagImport","sources","options","release","gcLock","readLock","abortOptions","signal","timeout","peekable","value","done","peek","push","cars","Uint8Array","car","roots","importCar","pinRoots","cid","pinErrorMsg","blocks","has","pins","pinRecursively","err","message","root","source","reader","fromIterable","getRoots","putMany","key","bytes"],"mappings":"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","sourcesContent":["import { CarBlockIterator } from '@ipld/car/iterator'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport itPeekable from 'it-peekable'\nimport drain from 'it-drain'\nimport map from 'it-map'\nimport { logger } from '@libp2p/logger'\nconst log = logger('ipfs:components:dag:import')\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/dag/').ImportRootStatus} RootStatus\n */\n\n/**\n * @param {object} config\n * @param {IPFSRepo} config.repo\n */\nexport function createImport ({ repo }) {\n  /**\n   * @type {import('ipfs-core-types/src/dag').API<{}>[\"import\"]}\n   */\n  async function * dagImport (sources, options = {}) {\n    const release = await repo.gcLock.readLock()\n\n    try {\n      const abortOptions = { signal: options.signal, timeout: options.timeout }\n      const peekable = itPeekable(sources)\n\n      const { value, done } = await peekable.peek()\n\n      if (done) {\n        return\n      }\n\n      if (value) {\n        // @ts-expect-error\n        peekable.push(value)\n      }\n\n      /**\n       * @type {AsyncIterable<AsyncIterable<Uint8Array>> | Iterable<AsyncIterable<Uint8Array>>}\n       */\n      let cars\n\n      if (value instanceof Uint8Array) {\n        // @ts-expect-error\n        cars = [peekable]\n      } else {\n        // @ts-expect-error\n        cars = peekable\n      }\n\n      for await (const car of cars) {\n        const roots = await importCar(repo, abortOptions, car)\n\n        if (options.pinRoots !== false) { // default=true\n          for (const cid of roots) {\n            let pinErrorMsg = ''\n\n            try { // eslint-disable-line max-depth\n              if (await repo.blocks.has(cid)) { // eslint-disable-line max-depth\n                log(`Pinning root ${cid}`)\n                await repo.pins.pinRecursively(cid)\n              } else {\n                pinErrorMsg = 'blockstore: block not found'\n              }\n            } catch (/** @type {any} */ err) {\n              pinErrorMsg = err.message\n            }\n\n            yield { root: { cid, pinErrorMsg } }\n          }\n        }\n      }\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(dagImport)\n}\n\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {Promise<CID[]>}\n */\nasync function importCar (repo, options, source) {\n  const reader = await CarBlockIterator.fromIterable(source)\n  const roots = await reader.getRoots()\n\n  await drain(\n    repo.blocks.putMany(\n      map(reader, ({ cid: key, bytes: value }) => {\n        log(`Import block ${key}`)\n\n        return { key, value }\n      }),\n      { signal: options.signal }\n    )\n  )\n\n  return roots\n}\n"]},"metadata":{},"sourceType":"module"}