{"ast":null,"code":"export function isStartable(obj) {\n  return obj != null && typeof obj.start === 'function' && typeof obj.stop === 'function';\n}\nexport async function start() {\n  const startables = [];\n\n  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {\n    objs[_key] = arguments[_key];\n  }\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj);\n    }\n  }\n\n  await Promise.all(startables.map(async s => {\n    if (s.beforeStart != null) {\n      await s.beforeStart();\n    }\n  }));\n  await Promise.all(startables.map(async s => {\n    await s.start();\n  }));\n  await Promise.all(startables.map(async s => {\n    if (s.afterStart != null) {\n      await s.afterStart();\n    }\n  }));\n}\nexport async function stop() {\n  const startables = [];\n\n  for (var _len2 = arguments.length, objs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    objs[_key2] = arguments[_key2];\n  }\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj);\n    }\n  }\n\n  await Promise.all(startables.map(async s => {\n    if (s.beforeStop != null) {\n      await s.beforeStop();\n    }\n  }));\n  await Promise.all(startables.map(async s => {\n    await s.stop();\n  }));\n  await Promise.all(startables.map(async s => {\n    if (s.afterStop != null) {\n      await s.afterStop();\n    }\n  }));\n}","map":{"version":3,"mappings":"AAkDA,OAAM,SAAUA,WAAV,CAAuBC,GAAvB,EAA+B;AACnC,SAAOA,GAAG,IAAI,IAAP,IAAe,OAAOA,GAAG,CAACC,KAAX,KAAqB,UAApC,IAAkD,OAAOD,GAAG,CAACE,IAAX,KAAoB,UAA7E;AACD;AAED,OAAO,eAAeD,KAAf,GAAoC;AACzC,QAAME,UAAU,GAAgB,EAAhC;;AADyC,oCAAXC,IAAW;AAAXA,QAAW;AAAA;;AAGzC,OAAK,MAAMJ,GAAX,IAAkBI,IAAlB,EAAwB;AACtB,QAAIL,WAAW,CAACC,GAAD,CAAf,EAAsB;AACpBG,gBAAU,CAACE,IAAX,CAAgBL,GAAhB;AACD;AACF;;AAED,QAAMM,OAAO,CAACC,GAAR,CACJJ,UAAU,CAACK,GAAX,CAAe,MAAMC,CAAN,IAAU;AACvB,QAAIA,CAAC,CAACC,WAAF,IAAiB,IAArB,EAA2B;AACzB,YAAMD,CAAC,CAACC,WAAF,EAAN;AACD;AACF,GAJD,CADI,CAAN;AAQA,QAAMJ,OAAO,CAACC,GAAR,CACJJ,UAAU,CAACK,GAAX,CAAe,MAAMC,CAAN,IAAU;AACvB,UAAMA,CAAC,CAACR,KAAF,EAAN;AACD,GAFD,CADI,CAAN;AAMA,QAAMK,OAAO,CAACC,GAAR,CACJJ,UAAU,CAACK,GAAX,CAAe,MAAMC,CAAN,IAAU;AACvB,QAAIA,CAAC,CAACE,UAAF,IAAgB,IAApB,EAA0B;AACxB,YAAMF,CAAC,CAACE,UAAF,EAAN;AACD;AACF,GAJD,CADI,CAAN;AAOD;AAED,OAAO,eAAeT,IAAf,GAAmC;AACxC,QAAMC,UAAU,GAAgB,EAAhC;;AADwC,qCAAXC,IAAW;AAAXA,QAAW;AAAA;;AAGxC,OAAK,MAAMJ,GAAX,IAAkBI,IAAlB,EAAwB;AACtB,QAAIL,WAAW,CAACC,GAAD,CAAf,EAAsB;AACpBG,gBAAU,CAACE,IAAX,CAAgBL,GAAhB;AACD;AACF;;AAED,QAAMM,OAAO,CAACC,GAAR,CACJJ,UAAU,CAACK,GAAX,CAAe,MAAMC,CAAN,IAAU;AACvB,QAAIA,CAAC,CAACG,UAAF,IAAgB,IAApB,EAA0B;AACxB,YAAMH,CAAC,CAACG,UAAF,EAAN;AACD;AACF,GAJD,CADI,CAAN;AAQA,QAAMN,OAAO,CAACC,GAAR,CACJJ,UAAU,CAACK,GAAX,CAAe,MAAMC,CAAN,IAAU;AACvB,UAAMA,CAAC,CAACP,IAAF,EAAN;AACD,GAFD,CADI,CAAN;AAMA,QAAMI,OAAO,CAACC,GAAR,CACJJ,UAAU,CAACK,GAAX,CAAe,MAAMC,CAAN,IAAU;AACvB,QAAIA,CAAC,CAACI,SAAF,IAAe,IAAnB,EAAyB;AACvB,YAAMJ,CAAC,CAACI,SAAF,EAAN;AACD;AACF,GAJD,CADI,CAAN;AAOD","names":["isStartable","obj","start","stop","startables","objs","push","Promise","all","map","s","beforeStart","afterStart","beforeStop","afterStop"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\interfaces\\src\\startable.ts"],"sourcesContent":["\n/**\n * Implemented by components that have a lifecycle\n */\nexport interface Startable {\n  isStarted: () => boolean\n\n  /**\n   * If implemented, this method will be invoked before the start method.\n   *\n   * It should not assume any other components have been started.\n   */\n  beforeStart?: () => void | Promise<void>\n\n  /**\n   * This method will be invoked to start the component.\n   *\n   * It should not assume that any other components have been started.\n   */\n  start: () => void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the start method.\n   *\n   * All other components will have had their start method invoked before this method is called.\n   */\n  afterStart?: () => void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked before the stop method.\n   *\n   * Any other components will still be running when this method is called.\n   */\n  beforeStop?: () => void | Promise<void>\n\n  /**\n   * This method will be invoked to stop the component.\n   *\n   * It should not assume any other components are running when it is called.\n   */\n  stop: () => void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the stop method.\n   *\n   * All other components will have had their stop method invoked before this method is called.\n   */\n  afterStop?: () => void | Promise<void>\n}\n\nexport function isStartable (obj: any): obj is Startable {\n  return obj != null && typeof obj.start === 'function' && typeof obj.stop === 'function'\n}\n\nexport async function start (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStart != null) {\n        await s.beforeStart()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.start()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStart != null) {\n        await s.afterStart()\n      }\n    })\n  )\n}\n\nexport async function stop (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStop != null) {\n        await s.beforeStop()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.stop()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStop != null) {\n        await s.afterStop()\n      }\n    })\n  )\n}\n"]},"metadata":{},"sourceType":"module"}