{"ast":null,"code":"/* eslint-disable import/export */\n\n/* eslint-disable complexity */\n\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Tags;\n\n(function (Tags) {\n  let _codec;\n\n  Tags.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.tags != null) {\n          for (const value of obj.tags) {\n            w.uint32(10);\n            Tag.codec().encode(value, w);\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {\n          tags: []\n        };\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.tags.push(Tag.codec().decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  Tags.encode = obj => {\n    return encodeMessage(obj, Tags.codec());\n  };\n\n  Tags.decode = buf => {\n    return decodeMessage(buf, Tags.codec());\n  };\n})(Tags || (Tags = {}));\n\nexport var Tag;\n\n(function (Tag) {\n  let _codec;\n\n  Tag.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.name != null && obj.name !== '') {\n          w.uint32(10);\n          w.string(obj.name);\n        }\n\n        if (obj.value != null) {\n          w.uint32(16);\n          w.uint32(obj.value);\n        }\n\n        if (obj.expiry != null) {\n          w.uint32(24);\n          w.uint64(obj.expiry);\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {\n          name: ''\n        };\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.name = reader.string();\n              break;\n\n            case 2:\n              obj.value = reader.uint32();\n              break;\n\n            case 3:\n              obj.expiry = reader.uint64();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  Tag.encode = obj => {\n    return encodeMessage(obj, Tag.codec());\n  };\n\n  Tag.decode = buf => {\n    return decodeMessage(buf, Tag.codec());\n  };\n})(Tag || (Tag = {}));","map":{"version":3,"mappings":"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","names":["encodeMessage","decodeMessage","message","Tags","_codec","obj","w","opts","lengthDelimited","fork","tags","value","uint32","Tag","codec","encode","ldelim","reader","length","end","len","pos","tag","push","decode","skipType","buf","name","string","expiry","uint64"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\peer-store\\src\\pb\\tags.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Tags {\n  tags: Tag[]\n}\n\nexport namespace Tags {\n  let _codec: Codec<Tags>\n\n  export const codec = (): Codec<Tags> => {\n    if (_codec == null) {\n      _codec = message<Tags>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.tags != null) {\n          for (const value of obj.tags) {\n            w.uint32(10)\n            Tag.codec().encode(value, w)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          tags: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.tags.push(Tag.codec().decode(reader, reader.uint32()))\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Tags>): Uint8Array => {\n    return encodeMessage(obj, Tags.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Tags => {\n    return decodeMessage(buf, Tags.codec())\n  }\n}\n\nexport interface Tag {\n  name: string\n  value?: number\n  expiry?: bigint\n}\n\nexport namespace Tag {\n  let _codec: Codec<Tag>\n\n  export const codec = (): Codec<Tag> => {\n    if (_codec == null) {\n      _codec = message<Tag>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.name != null && obj.name !== '')) {\n          w.uint32(10)\n          w.string(obj.name)\n        }\n\n        if (obj.value != null) {\n          w.uint32(16)\n          w.uint32(obj.value)\n        }\n\n        if (obj.expiry != null) {\n          w.uint32(24)\n          w.uint64(obj.expiry)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          name: ''\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.name = reader.string()\n              break\n            case 2:\n              obj.value = reader.uint32()\n              break\n            case 3:\n              obj.expiry = reader.uint64()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Tag>): Uint8Array => {\n    return encodeMessage(obj, Tag.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Tag => {\n    return decodeMessage(buf, Tag.codec())\n  }\n}\n"]},"metadata":{},"sourceType":"module"}