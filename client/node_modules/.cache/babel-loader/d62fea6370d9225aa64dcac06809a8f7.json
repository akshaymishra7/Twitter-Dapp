{"ast":null,"code":"import $protobuf from 'protobufjs/minimal.js';\nimport { Key } from 'interface-datastore/key';\nimport { Protocols } from './pb/proto-book.js';\nimport { Addresses } from './pb/address-book.js';\nimport { Peer } from './pb/peer.js';\nimport { Envelope } from './pb/envelope.js';\nimport { PeerRecord } from './pb/peer-record.js';\nimport { multiaddr } from '@multiformats/multiaddr'; // @ts-expect-error Explicitly disable long.js support\n\n$protobuf.util.Long = undefined;\n$protobuf.configure();\n/**\n * @param {import('../../types').Backends} backends\n * @param {import('../../types').MigrationProgressCallback} onProgress\n */\n\nasync function storePeerUnderSingleDatastoreKey(backends) {\n  let onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n  onProgress(0, 'Storing each peerstore key under a single datastore key');\n  await backends.datastore.open();\n  /** @type {Record<string, any>} */\n\n  const peers = {};\n  /** @type {Key[]} */\n\n  const keys = [];\n\n  for await (const {\n    key,\n    value\n  } of backends.datastore.query({\n    prefix: '/peers'\n  })) {\n    keys.push(key);\n    const keyStr = key.toString();\n    const [, prefix, type, peerId, metadataKey] = keyStr.split('/');\n\n    if (prefix !== 'peers') {\n      continue;\n    }\n\n    if (!['protos', 'addrs', 'metadata', 'keys'].includes(type)) {\n      continue;\n    }\n\n    if (!peerId) {\n      continue;\n    }\n\n    peers[peerId] = peers[peerId] || {\n      addresses: [],\n      protocols: [],\n      metadata: []\n    };\n\n    if (type === 'protos') {\n      const protos = Protocols.decode(value);\n      peers[peerId].protocols = protos.protocols.sort();\n    } else if (type === 'addrs') {\n      const addrs = Addresses.decode(value);\n      peers[peerId].addresses = addrs.addrs.sort((a, b) => {\n        return multiaddr(a.multiaddr).toString().localeCompare(multiaddr(b.multiaddr).toString());\n      });\n\n      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {\n        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw;\n      }\n    } else if (type === 'metadata') {\n      peers[peerId].metadata.push({\n        key: metadataKey,\n        value\n      });\n    } else if (type === 'keys') {\n      peers[peerId].pubKey = value;\n    }\n  }\n\n  onProgress(33, 'Read peer data from store');\n\n  for (const key of keys) {\n    await backends.datastore.delete(key);\n  }\n\n  onProgress(66, 'Removed existing peer data from store');\n\n  for (const peerId of Object.keys(peers)) {\n    const peer = peers[peerId];\n    peer.metadata = peer.metadata.sort((\n    /** @type {{ key: string }} */\n    a,\n    /** @type {{ key: string }} */\n    b) => a.key.localeCompare(b.key));\n    const data = Peer.encode(peer).finish();\n    await backends.datastore.put(new Key(`/peers/${peerId}`), data);\n  }\n\n  await backends.datastore.close();\n  onProgress(100, 'Stored each peerstore key under a single datastore key');\n}\n/**\n * @param {import('../../types').Backends} backends\n * @param {import('../../types').MigrationProgressCallback} onProgress\n */\n\n\nasync function storePeerUnderMultipleDatastoreKeys(backends) {\n  let onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n  onProgress(0, 'Storing each peerstore key under a multiple datastore keys');\n  await backends.datastore.open();\n  /** @type {Record<string, any>} */\n\n  const peers = {};\n  /** @type {Key[]} */\n\n  const keys = [];\n\n  for await (const {\n    key,\n    value\n  } of backends.datastore.query({\n    prefix: '/peers'\n  })) {\n    keys.push(key);\n    const keyStr = key.toString();\n    const [,, peerId] = keyStr.split('/');\n    peers[peerId] = Peer.decode(value);\n  }\n\n  onProgress(33, 'Read peer data from store');\n\n  for (const key of keys) {\n    await backends.datastore.delete(key);\n  }\n\n  onProgress(66, 'Removed existing peer data from store');\n\n  for (const [peerId, peer] of Object.entries(peers)) {\n    if (peer.protocols && peer.protocols.length > 0) {\n      await backends.datastore.put(new Key(`/peers/protos/${peerId}`), Protocols.encode({\n        protocols: peer.protocols\n      }).finish());\n    }\n\n    if (peer.addresses && peer.addresses.length > 0) {\n      const peerRecordEnvelope = peer.peerRecordEnvelope;\n      let certifiedRecord;\n\n      if (peerRecordEnvelope) {\n        const envelope = Envelope.decode(peerRecordEnvelope);\n        const record = PeerRecord.decode(envelope.payload);\n        certifiedRecord = {\n          raw: peerRecordEnvelope,\n          seq: record.seq\n        };\n      }\n\n      await backends.datastore.put(new Key(`/peers/addrs/${peerId}`), Addresses.encode({\n        addrs: peer.addresses,\n        certifiedRecord\n      }).finish());\n    }\n\n    if (peer.metadata && peer.metadata.length > 0) {\n      for (const {\n        key,\n        value\n      } of peer.metadata) {\n        await backends.datastore.put(new Key(`/peers/metadata/${peerId}/${key}`), value);\n      }\n    }\n\n    if (peer.pubKey) {\n      await backends.datastore.put(new Key(`/peers/keys/${peerId}`), peer.pubKey);\n    }\n  }\n\n  await backends.datastore.close();\n  onProgress(100, 'Stored each peerstore key under multiple datastore keys');\n}\n/** @type {import('../../types').Migration} */\n\n\nexport const migration = {\n  version: 12,\n  description: 'Store each peerstore peer under a single datastore key',\n  migrate: storePeerUnderSingleDatastoreKey,\n  revert: storePeerUnderMultipleDatastoreKeys\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-repo-migrations/src/migrations/migration-12/index.js"],"names":["$protobuf","Key","Protocols","Addresses","Peer","Envelope","PeerRecord","multiaddr","util","Long","undefined","configure","storePeerUnderSingleDatastoreKey","backends","onProgress","datastore","open","peers","keys","key","value","query","prefix","push","keyStr","toString","type","peerId","metadataKey","split","includes","addresses","protocols","metadata","protos","decode","sort","addrs","a","b","localeCompare","certifiedRecord","raw","peerRecordEnvelope","pubKey","delete","Object","peer","data","encode","finish","put","close","storePeerUnderMultipleDatastoreKeys","entries","length","envelope","record","payload","seq","migration","version","description","migrate","revert"],"mappings":"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","sourcesContent":["import $protobuf from 'protobufjs/minimal.js'\nimport { Key } from 'interface-datastore/key'\nimport { Protocols } from './pb/proto-book.js'\nimport { Addresses } from './pb/address-book.js'\nimport { Peer } from './pb/peer.js'\nimport { Envelope } from './pb/envelope.js'\nimport { PeerRecord } from './pb/peer-record.js'\nimport { multiaddr } from '@multiformats/multiaddr'\n\n// @ts-expect-error Explicitly disable long.js support\n$protobuf.util.Long = undefined\n$protobuf.configure()\n\n/**\n * @param {import('../../types').Backends} backends\n * @param {import('../../types').MigrationProgressCallback} onProgress\n */\nasync function storePeerUnderSingleDatastoreKey (backends, onProgress = () => {}) {\n  onProgress(0, 'Storing each peerstore key under a single datastore key')\n\n  await backends.datastore.open()\n\n  /** @type {Record<string, any>} */\n  const peers = {}\n  /** @type {Key[]} */\n  const keys = []\n\n  for await (const { key, value } of backends.datastore.query({\n    prefix: '/peers'\n  })) {\n    keys.push(key)\n    const keyStr = key.toString()\n    const [, prefix, type, peerId, metadataKey] = keyStr.split('/')\n\n    if (prefix !== 'peers') {\n      continue\n    }\n\n    if (!['protos', 'addrs', 'metadata', 'keys'].includes(type)) {\n      continue\n    }\n\n    if (!peerId) {\n      continue\n    }\n\n    peers[peerId] = peers[peerId] || {\n      addresses: [],\n      protocols: [],\n      metadata: []\n    }\n\n    if (type === 'protos') {\n      const protos = Protocols.decode(value)\n\n      peers[peerId].protocols = protos.protocols.sort()\n    } else if (type === 'addrs') {\n      const addrs = Addresses.decode(value)\n\n      peers[peerId].addresses = addrs.addrs.sort((a, b) => {\n        return multiaddr(a.multiaddr).toString().localeCompare(multiaddr(b.multiaddr).toString())\n      })\n\n      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {\n        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw\n      }\n    } else if (type === 'metadata') {\n      peers[peerId].metadata.push({ key: metadataKey, value })\n    } else if (type === 'keys') {\n      peers[peerId].pubKey = value\n    }\n  }\n\n  onProgress(33, 'Read peer data from store')\n\n  for (const key of keys) {\n    await backends.datastore.delete(key)\n  }\n\n  onProgress(66, 'Removed existing peer data from store')\n\n  for (const peerId of Object.keys(peers)) {\n    const peer = peers[peerId]\n    peer.metadata = peer.metadata.sort((/** @type {{ key: string }} */ a, /** @type {{ key: string }} */ b) => a.key.localeCompare(b.key))\n\n    const data = Peer.encode(peer).finish()\n\n    await backends.datastore.put(new Key(`/peers/${peerId}`), data)\n  }\n\n  await backends.datastore.close()\n\n  onProgress(100, 'Stored each peerstore key under a single datastore key')\n}\n\n/**\n * @param {import('../../types').Backends} backends\n * @param {import('../../types').MigrationProgressCallback} onProgress\n */\nasync function storePeerUnderMultipleDatastoreKeys (backends, onProgress = () => {}) {\n  onProgress(0, 'Storing each peerstore key under a multiple datastore keys')\n\n  await backends.datastore.open()\n\n  /** @type {Record<string, any>} */\n  const peers = {}\n  /** @type {Key[]} */\n  const keys = []\n\n  for await (const { key, value } of backends.datastore.query({\n    prefix: '/peers'\n  })) {\n    keys.push(key)\n    const keyStr = key.toString()\n\n    const [, , peerId] = keyStr.split('/')\n\n    peers[peerId] = Peer.decode(value)\n  }\n\n  onProgress(33, 'Read peer data from store')\n\n  for (const key of keys) {\n    await backends.datastore.delete(key)\n  }\n\n  onProgress(66, 'Removed existing peer data from store')\n\n  for (const [peerId, peer] of Object.entries(peers)) {\n    if (peer.protocols && peer.protocols.length > 0) {\n      await backends.datastore.put(new Key(`/peers/protos/${peerId}`), Protocols.encode({\n        protocols: peer.protocols\n      }).finish())\n    }\n\n    if (peer.addresses && peer.addresses.length > 0) {\n      const peerRecordEnvelope = peer.peerRecordEnvelope\n      let certifiedRecord\n\n      if (peerRecordEnvelope) {\n        const envelope = Envelope.decode(peerRecordEnvelope)\n        const record = PeerRecord.decode(envelope.payload)\n\n        certifiedRecord = {\n          raw: peerRecordEnvelope,\n          seq: record.seq\n        }\n      }\n\n      await backends.datastore.put(new Key(`/peers/addrs/${peerId}`), Addresses.encode({\n        addrs: peer.addresses,\n        certifiedRecord\n      }).finish())\n    }\n\n    if (peer.metadata && peer.metadata.length > 0) {\n      for (const { key, value } of peer.metadata) {\n        await backends.datastore.put(new Key(`/peers/metadata/${peerId}/${key}`), value)\n      }\n    }\n\n    if (peer.pubKey) {\n      await backends.datastore.put(new Key(`/peers/keys/${peerId}`), peer.pubKey)\n    }\n  }\n\n  await backends.datastore.close()\n\n  onProgress(100, 'Stored each peerstore key under multiple datastore keys')\n}\n\n/** @type {import('../../types').Migration} */\nexport const migration = {\n  version: 12,\n  description: 'Store each peerstore peer under a single datastore key',\n  migrate: storePeerUnderSingleDatastoreKey,\n  revert: storePeerUnderMultipleDatastoreKeys\n}\n"]},"metadata":{},"sourceType":"module"}