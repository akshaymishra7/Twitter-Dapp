{"ast":null,"code":"import { RejectReason } from './types.js';\nexport var MessageSource;\n\n(function (MessageSource) {\n  MessageSource[\"forward\"] = \"forward\";\n  MessageSource[\"publish\"] = \"publish\";\n})(MessageSource || (MessageSource = {}));\n\nexport var InclusionReason;\n\n(function (InclusionReason) {\n  /** Peer was a fanaout peer. */\n  InclusionReason[\"Fanout\"] = \"fanout\";\n  /** Included from random selection. */\n\n  InclusionReason[\"Random\"] = \"random\";\n  /** Peer subscribed. */\n\n  InclusionReason[\"Subscribed\"] = \"subscribed\";\n  /** On heartbeat, peer was included to fill the outbound quota. */\n\n  InclusionReason[\"Outbound\"] = \"outbound\";\n  /** On heartbeat, not enough peers in mesh */\n\n  InclusionReason[\"NotEnough\"] = \"not_enough\";\n  /** On heartbeat opportunistic grafting due to low mesh score */\n\n  InclusionReason[\"Opportunistic\"] = \"opportunistic\";\n})(InclusionReason || (InclusionReason = {})); /// Reasons why a peer was removed from the mesh.\n\n\nexport var ChurnReason;\n\n(function (ChurnReason) {\n  /// Peer disconnected.\n  ChurnReason[\"Dc\"] = \"disconnected\"; /// Peer had a bad score.\n\n  ChurnReason[\"BadScore\"] = \"bad_score\"; /// Peer sent a PRUNE.\n\n  ChurnReason[\"Prune\"] = \"prune\"; /// Peer unsubscribed.\n\n  ChurnReason[\"Unsub\"] = \"unsubscribed\"; /// Too many peers.\n\n  ChurnReason[\"Excess\"] = \"excess\";\n})(ChurnReason || (ChurnReason = {})); /// Kinds of reasons a peer's score has been penalized\n\n\nexport var ScorePenalty;\n\n(function (ScorePenalty) {\n  /// A peer grafted before waiting the back-off time.\n  ScorePenalty[\"GraftBackoff\"] = \"graft_backoff\"; /// A Peer did not respond to an IWANT request in time.\n\n  ScorePenalty[\"BrokenPromise\"] = \"broken_promise\"; /// A Peer did not send enough messages as expected.\n\n  ScorePenalty[\"MessageDeficit\"] = \"message_deficit\"; /// Too many peers under one IP address.\n\n  ScorePenalty[\"IPColocation\"] = \"IP_colocation\";\n})(ScorePenalty || (ScorePenalty = {}));\n\nexport var IHaveIgnoreReason;\n\n(function (IHaveIgnoreReason) {\n  IHaveIgnoreReason[\"LowScore\"] = \"low_score\";\n  IHaveIgnoreReason[\"MaxIhave\"] = \"max_ihave\";\n  IHaveIgnoreReason[\"MaxIasked\"] = \"max_iasked\";\n})(IHaveIgnoreReason || (IHaveIgnoreReason = {}));\n\nexport var ScoreThreshold;\n\n(function (ScoreThreshold) {\n  ScoreThreshold[\"graylist\"] = \"graylist\";\n  ScoreThreshold[\"publish\"] = \"publish\";\n  ScoreThreshold[\"gossip\"] = \"gossip\";\n  ScoreThreshold[\"mesh\"] = \"mesh\";\n})(ScoreThreshold || (ScoreThreshold = {}));\n/**\n * A collection of metrics used throughout the Gossipsub behaviour.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\n\nexport function getMetrics(register, topicStrToLabel, opts) {\n  // Using function style instead of class to prevent having to re-declare all MetricsPrometheus types.\n  return {\n    /* Metrics for static config */\n    protocolsEnabled: register.gauge({\n      name: 'gossipsub_protocol',\n      help: 'Status of enabled protocols',\n      labelNames: ['protocol']\n    }),\n\n    /* Metrics per known topic */\n\n    /** Status of our subscription to this topic. This metric allows analyzing other topic metrics\n     *  filtered by our current subscription status.\n     *  = rust-libp2p `topic_subscription_status` */\n    topicSubscriptionStatus: register.gauge({\n      name: 'gossipsub_topic_subscription_status',\n      help: 'Status of our subscription to this topic',\n      labelNames: ['topicStr']\n    }),\n\n    /** Number of peers subscribed to each topic. This allows us to analyze a topic's behaviour\n     * regardless of our subscription status. */\n    topicPeersCount: register.gauge({\n      name: 'gossipsub_topic_peer_count',\n      help: 'Number of peers subscribed to each topic',\n      labelNames: ['topicStr']\n    }),\n\n    /* Metrics regarding mesh state */\n\n    /** Number of peers in our mesh. This metric should be updated with the count of peers for a\n     *  topic in the mesh regardless of inclusion and churn events.\n     *  = rust-libp2p `mesh_peer_counts` */\n    meshPeerCounts: register.gauge({\n      name: 'gossipsub_mesh_peer_count',\n      help: 'Number of peers in our mesh',\n      labelNames: ['topicStr']\n    }),\n\n    /** Number of times we include peers in a topic mesh for different reasons.\n     *  = rust-libp2p `mesh_peer_inclusion_events` */\n    meshPeerInclusionEvents: register.gauge({\n      name: 'gossipsub_mesh_peer_inclusion_events_total',\n      help: 'Number of times we include peers in a topic mesh for different reasons',\n      labelNames: ['topic', 'reason']\n    }),\n\n    /** Number of times we remove peers in a topic mesh for different reasons.\n     *  = rust-libp2p `mesh_peer_churn_events` */\n    meshPeerChurnEvents: register.gauge({\n      name: 'gossipsub_peer_churn_events_total',\n      help: 'Number of times we remove peers in a topic mesh for different reasons',\n      labelNames: ['topic', 'reason']\n    }),\n\n    /* General Metrics */\n\n    /** Gossipsub supports floodsub, gossipsub v1.0 and gossipsub v1.1. Peers are classified based\n     *  on which protocol they support. This metric keeps track of the number of peers that are\n     *  connected of each type. */\n    peersPerProtocol: register.gauge({\n      name: 'gossipsub_peers_per_protocol_count',\n      help: 'Peers connected for each topic',\n      labelNames: ['protocol']\n    }),\n\n    /** The time it takes to complete one iteration of the heartbeat. */\n    heartbeatDuration: register.histogram({\n      name: 'gossipsub_heartbeat_duration_seconds',\n      help: 'The time it takes to complete one iteration of the heartbeat',\n      // Should take <10ms, over 1s it's a huge issue that needs debugging, since a heartbeat will be cancelled\n      buckets: [0.01, 0.1, 1]\n    }),\n\n    /** Heartbeat run took longer than heartbeat interval so next is skipped */\n    heartbeatSkipped: register.gauge({\n      name: 'gossipsub_heartbeat_skipped',\n      help: 'Heartbeat run took longer than heartbeat interval so next is skipped'\n    }),\n\n    /** Message validation results for each topic.\n     *  Invalid == Reject?\n     *  = rust-libp2p `invalid_messages`, `accepted_messages`, `ignored_messages`, `rejected_messages` */\n    asyncValidationResult: register.gauge({\n      name: 'gossipsub_async_validation_result_total',\n      help: 'Message validation result for each topic',\n      labelNames: ['topic', 'acceptance']\n    }),\n\n    /** When the user validates a message, it tries to re propagate it to its mesh peers. If the\n     *  message expires from the memcache before it can be validated, we count this a cache miss\n     *  and it is an indicator that the memcache size should be increased.\n     *  = rust-libp2p `mcache_misses` */\n    asyncValidationMcacheHit: register.gauge({\n      name: 'gossipsub_async_validation_mcache_hit_total',\n      help: 'Async validation result reported by the user layer',\n      labelNames: ['hit']\n    }),\n    // peer stream\n    peerReadStreamError: register.gauge({\n      name: 'gossipsub_peer_read_stream_err_count_total',\n      help: 'Peer read stream error'\n    }),\n    // RPC outgoing. Track byte length + data structure sizes\n    rpcRecvBytes: register.gauge({\n      name: 'gossipsub_rpc_recv_bytes_total',\n      help: 'RPC recv'\n    }),\n    rpcRecvCount: register.gauge({\n      name: 'gossipsub_rpc_recv_count_total',\n      help: 'RPC recv'\n    }),\n    rpcRecvSubscription: register.gauge({\n      name: 'gossipsub_rpc_recv_subscription_total',\n      help: 'RPC recv'\n    }),\n    rpcRecvMessage: register.gauge({\n      name: 'gossipsub_rpc_recv_message_total',\n      help: 'RPC recv'\n    }),\n    rpcRecvControl: register.gauge({\n      name: 'gossipsub_rpc_recv_control_total',\n      help: 'RPC recv'\n    }),\n    rpcRecvIHave: register.gauge({\n      name: 'gossipsub_rpc_recv_ihave_total',\n      help: 'RPC recv'\n    }),\n    rpcRecvIWant: register.gauge({\n      name: 'gossipsub_rpc_recv_iwant_total',\n      help: 'RPC recv'\n    }),\n    rpcRecvGraft: register.gauge({\n      name: 'gossipsub_rpc_recv_graft_total',\n      help: 'RPC recv'\n    }),\n    rpcRecvPrune: register.gauge({\n      name: 'gossipsub_rpc_recv_prune_total',\n      help: 'RPC recv'\n    }),\n    rpcDataError: register.gauge({\n      name: 'gossipsub_rpc_data_err_count_total',\n      help: 'RPC data error'\n    }),\n    rpcRecvError: register.gauge({\n      name: 'gossipsub_rpc_recv_err_count_total',\n      help: 'RPC recv error'\n    }),\n\n    /** Total count of RPC dropped because acceptFrom() == false */\n    rpcRecvNotAccepted: register.gauge({\n      name: 'gossipsub_rpc_rcv_not_accepted_total',\n      help: 'Total count of RPC dropped because acceptFrom() == false'\n    }),\n    // RPC incoming. Track byte length + data structure sizes\n    rpcSentBytes: register.gauge({\n      name: 'gossipsub_rpc_sent_bytes_total',\n      help: 'RPC sent'\n    }),\n    rpcSentCount: register.gauge({\n      name: 'gossipsub_rpc_sent_count_total',\n      help: 'RPC sent'\n    }),\n    rpcSentSubscription: register.gauge({\n      name: 'gossipsub_rpc_sent_subscription_total',\n      help: 'RPC sent'\n    }),\n    rpcSentMessage: register.gauge({\n      name: 'gossipsub_rpc_sent_message_total',\n      help: 'RPC sent'\n    }),\n    rpcSentControl: register.gauge({\n      name: 'gossipsub_rpc_sent_control_total',\n      help: 'RPC sent'\n    }),\n    rpcSentIHave: register.gauge({\n      name: 'gossipsub_rpc_sent_ihave_total',\n      help: 'RPC sent'\n    }),\n    rpcSentIWant: register.gauge({\n      name: 'gossipsub_rpc_sent_iwant_total',\n      help: 'RPC sent'\n    }),\n    rpcSentGraft: register.gauge({\n      name: 'gossipsub_rpc_sent_graft_total',\n      help: 'RPC sent'\n    }),\n    rpcSentPrune: register.gauge({\n      name: 'gossipsub_rpc_sent_prune_total',\n      help: 'RPC sent'\n    }),\n    // publish message. Track peers sent to and bytes\n\n    /** Total count of msg published by topic */\n    msgPublishCount: register.gauge({\n      name: 'gossipsub_msg_publish_count_total',\n      help: 'Total count of msg published by topic',\n      labelNames: ['topic']\n    }),\n\n    /** Total count of peers that we publish a msg to */\n    msgPublishPeers: register.gauge({\n      name: 'gossipsub_msg_publish_peers_total',\n      help: 'Total count of peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n\n    /** Total count of peers (by group) that we publish a msg to */\n    // NOTE: Do not use 'group' label since it's a generic already used by Prometheus to group instances\n    msgPublishPeersByGroup: register.gauge({\n      name: 'gossipsub_msg_publish_peers_by_group',\n      help: 'Total count of peers (by group) that we publish a msg to',\n      labelNames: ['topic', 'peerGroup']\n    }),\n\n    /** Total count of msg publish data.length bytes */\n    msgPublishBytes: register.gauge({\n      name: 'gossipsub_msg_publish_bytes_total',\n      help: 'Total count of msg publish data.length bytes',\n      labelNames: ['topic']\n    }),\n\n    /** Total count of msg forwarded by topic */\n    msgForwardCount: register.gauge({\n      name: 'gossipsub_msg_forward_count_total',\n      help: 'Total count of msg forwarded by topic',\n      labelNames: ['topic']\n    }),\n\n    /** Total count of peers that we forward a msg to */\n    msgForwardPeers: register.gauge({\n      name: 'gossipsub_msg_forward_peers_total',\n      help: 'Total count of peers that we forward a msg to',\n      labelNames: ['topic']\n    }),\n\n    /** Total count of recv msgs before any validation */\n    msgReceivedPreValidation: register.gauge({\n      name: 'gossipsub_msg_received_prevalidation_total',\n      help: 'Total count of recv msgs before any validation',\n      labelNames: ['topic']\n    }),\n\n    /** Total count of recv msgs error */\n    msgReceivedError: register.gauge({\n      name: 'gossipsub_msg_received_error_total',\n      help: 'Total count of recv msgs error',\n      labelNames: ['topic']\n    }),\n\n    /** Tracks distribution of recv msgs by duplicate, invalid, valid */\n    msgReceivedStatus: register.gauge({\n      name: 'gossipsub_msg_received_status_total',\n      help: 'Tracks distribution of recv msgs by duplicate, invalid, valid',\n      labelNames: ['topic', 'status']\n    }),\n\n    /** Tracks specific reason of invalid */\n    msgReceivedInvalid: register.gauge({\n      name: 'gossipsub_msg_received_invalid_total',\n      help: 'Tracks specific reason of invalid',\n      labelNames: ['topic', 'error']\n    }),\n\n    /** Track duplicate message delivery time */\n    duplicateMsgDeliveryDelay: register.histogram({\n      name: 'gossisub_duplicate_msg_delivery_delay_seconds',\n      help: 'Time since the 1st duplicated message validated',\n      labelNames: ['topic'],\n      buckets: [0.25 * opts.maxMeshMessageDeliveriesWindowSec, 0.5 * opts.maxMeshMessageDeliveriesWindowSec, 1 * opts.maxMeshMessageDeliveriesWindowSec, 2 * opts.maxMeshMessageDeliveriesWindowSec, 4 * opts.maxMeshMessageDeliveriesWindowSec]\n    }),\n\n    /** Total count of late msg delivery total by topic */\n    duplicateMsgLateDelivery: register.gauge({\n      name: 'gossisub_duplicate_msg_late_delivery_total',\n      help: 'Total count of late duplicate message delivery by topic, which triggers P3 penalty',\n      labelNames: ['topic']\n    }),\n    duplicateMsgIgnored: register.gauge({\n      name: 'gossisub_ignored_published_duplicate_msgs_total',\n      help: 'Total count of published duplicate message ignored by topic',\n      labelNames: ['topic']\n    }),\n\n    /* Metrics related to scoring */\n\n    /** Total times score() is called */\n    scoreFnCalls: register.gauge({\n      name: 'gossipsub_score_fn_calls_total',\n      help: 'Total times score() is called'\n    }),\n\n    /** Total times score() call actually computed computeScore(), no cache */\n    scoreFnRuns: register.gauge({\n      name: 'gossipsub_score_fn_runs_total',\n      help: 'Total times score() call actually computed computeScore(), no cache'\n    }),\n    scoreCachedDelta: register.histogram({\n      name: 'gossipsub_score_cache_delta',\n      help: 'Delta of score between cached values that expired',\n      buckets: [10, 100, 1000]\n    }),\n\n    /** Current count of peers by score threshold */\n    peersByScoreThreshold: register.gauge({\n      name: 'gossipsub_peers_by_score_threshold_count',\n      help: 'Current count of peers by score threshold',\n      labelNames: ['threshold']\n    }),\n    score: register.avgMinMax({\n      name: 'gossipsub_score',\n      help: 'Avg min max of gossip scores',\n      labelNames: ['topic', 'p']\n    }),\n\n    /** Separate score weights */\n    scoreWeights: register.avgMinMax({\n      name: 'gossipsub_score_weights',\n      help: 'Separate score weights',\n      labelNames: ['topic', 'p']\n    }),\n\n    /** Histogram of the scores for each mesh topic. */\n    // TODO: Not implemented\n    scorePerMesh: register.avgMinMax({\n      name: 'gossipsub_score_per_mesh',\n      help: 'Histogram of the scores for each mesh topic',\n      labelNames: ['topic']\n    }),\n\n    /** A counter of the kind of penalties being applied to peers. */\n    // TODO: Not fully implemented\n    scoringPenalties: register.gauge({\n      name: 'gossipsub_scoring_penalties_total',\n      help: 'A counter of the kind of penalties being applied to peers',\n      labelNames: ['penalty']\n    }),\n    behaviourPenalty: register.histogram({\n      name: 'gossipsub_peer_stat_behaviour_penalty',\n      help: 'Current peer stat behaviour_penalty at each scrape',\n      buckets: [0.25 * opts.behaviourPenaltyThreshold, 0.5 * opts.behaviourPenaltyThreshold, 1 * opts.behaviourPenaltyThreshold, 2 * opts.behaviourPenaltyThreshold, 4 * opts.behaviourPenaltyThreshold]\n    }),\n    // TODO:\n    // - iasked per peer (on heartbeat)\n    // - when promise is resolved, track messages from promises\n\n    /** Total received IHAVE messages that we ignore for some reason */\n    ihaveRcvIgnored: register.gauge({\n      name: 'gossipsub_ihave_rcv_ignored_total',\n      help: 'Total received IHAVE messages that we ignore for some reason',\n      labelNames: ['reason']\n    }),\n\n    /** Total received IHAVE messages by topic */\n    ihaveRcvMsgids: register.gauge({\n      name: 'gossipsub_ihave_rcv_msgids_total',\n      help: 'Total received IHAVE messages by topic',\n      labelNames: ['topic']\n    }),\n\n    /** Total messages per topic we don't have. Not actual requests.\n     *  The number of times we have decided that an IWANT control message is required for this\n     *  topic. A very high metric might indicate an underperforming network.\n     *  = rust-libp2p `topic_iwant_msgs` */\n    ihaveRcvNotSeenMsgids: register.gauge({\n      name: 'gossipsub_ihave_rcv_not_seen_msgids_total',\n      help: 'Total messages per topic we do not have, not actual requests',\n      labelNames: ['topic']\n    }),\n\n    /** Total received IWANT messages by topic */\n    iwantRcvMsgids: register.gauge({\n      name: 'gossipsub_iwant_rcv_msgids_total',\n      help: 'Total received IWANT messages by topic',\n      labelNames: ['topic']\n    }),\n\n    /** Total requested messageIDs that we don't have */\n    iwantRcvDonthaveMsgids: register.gauge({\n      name: 'gossipsub_iwant_rcv_dont_have_msgids_total',\n      help: 'Total requested messageIDs that we do not have'\n    }),\n    iwantPromiseStarted: register.gauge({\n      name: 'gossipsub_iwant_promise_sent_total',\n      help: 'Total count of started IWANT promises'\n    }),\n\n    /** Total count of resolved IWANT promises */\n    iwantPromiseResolved: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_total',\n      help: 'Total count of resolved IWANT promises'\n    }),\n\n    /** Total count of resolved IWANT promises from duplicate messages */\n    iwantPromiseResolvedFromDuplicate: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_from_duplicate_total',\n      help: 'Total count of resolved IWANT promises from duplicate messages'\n    }),\n\n    /** Total count of peers we have asked IWANT promises that are resolved */\n    iwantPromiseResolvedPeers: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_peers',\n      help: 'Total count of peers we have asked IWANT promises that are resolved'\n    }),\n    iwantPromiseBroken: register.gauge({\n      name: 'gossipsub_iwant_promise_broken',\n      help: 'Total count of broken IWANT promises'\n    }),\n    iwantMessagePruned: register.gauge({\n      name: 'gossipsub_iwant_message_pruned',\n      help: 'Total count of pruned IWANT messages'\n    }),\n\n    /** Histogram of delivery time of resolved IWANT promises */\n    iwantPromiseDeliveryTime: register.histogram({\n      name: 'gossipsub_iwant_promise_delivery_seconds',\n      help: 'Histogram of delivery time of resolved IWANT promises',\n      buckets: [0.5 * opts.gossipPromiseExpireSec, 1 * opts.gossipPromiseExpireSec, 2 * opts.gossipPromiseExpireSec, 4 * opts.gossipPromiseExpireSec]\n    }),\n    iwantPromiseUntracked: register.gauge({\n      name: 'gossip_iwant_promise_untracked',\n      help: 'Total count of untracked IWANT promise'\n    }),\n\n    /* Data structure sizes */\n\n    /** Unbounded cache sizes */\n    cacheSize: register.gauge({\n      name: 'gossipsub_cache_size',\n      help: 'Unbounded cache sizes',\n      labelNames: ['cache']\n    }),\n\n    /** Current mcache msg count */\n    mcacheSize: register.gauge({\n      name: 'gossipsub_mcache_size',\n      help: 'Current mcache msg count'\n    }),\n    mcacheNotValidatedCount: register.gauge({\n      name: 'gossipsub_mcache_not_validated_count',\n      help: 'Current mcache msg count not validated'\n    }),\n    fastMsgIdCacheCollision: register.gauge({\n      name: 'gossipsub_fastmsgid_cache_collision_total',\n      help: 'Total count of key collisions on fastmsgid cache put'\n    }),\n    newConnectionCount: register.gauge({\n      name: 'gossipsub_new_connection_total',\n      help: 'Total new connection by status',\n      labelNames: ['status']\n    }),\n    topicStrToLabel: topicStrToLabel,\n\n    toTopic(topicStr) {\n      return this.topicStrToLabel.get(topicStr) ?? topicStr;\n    },\n\n    /** We joined a topic */\n    onJoin(topicStr) {\n      this.topicSubscriptionStatus.set({\n        topicStr\n      }, 1);\n      this.meshPeerCounts.set({\n        topicStr\n      }, 0); // Reset count\n    },\n\n    /** We left a topic */\n    onLeave(topicStr) {\n      this.topicSubscriptionStatus.set({\n        topicStr\n      }, 0);\n      this.meshPeerCounts.set({\n        topicStr\n      }, 0); // Reset count\n    },\n\n    /** Register the inclusion of peers in our mesh due to some reason. */\n    onAddToMesh(topicStr, reason, count) {\n      const topic = this.toTopic(topicStr);\n      this.meshPeerInclusionEvents.inc({\n        topic,\n        reason\n      }, count);\n    },\n\n    /** Register the removal of peers in our mesh due to some reason */\n    // - remove_peer_from_mesh()\n    // - heartbeat() Churn::BadScore\n    // - heartbeat() Churn::Excess\n    // - on_disconnect() Churn::Ds\n    onRemoveFromMesh(topicStr, reason, count) {\n      const topic = this.toTopic(topicStr);\n      this.meshPeerChurnEvents.inc({\n        topic,\n        reason\n      }, count);\n    },\n\n    onReportValidationMcacheHit(hit) {\n      this.asyncValidationMcacheHit.inc({\n        hit: hit ? 'hit' : 'miss'\n      });\n    },\n\n    onReportValidation(topicStr, acceptance) {\n      const topic = this.toTopic(topicStr);\n      this.asyncValidationResult.inc({\n        topic: topic,\n        acceptance\n      });\n    },\n\n    /**\n     * - in handle_graft() Penalty::GraftBackoff\n     * - in apply_iwant_penalties() Penalty::BrokenPromise\n     * - in metric_score() P3 Penalty::MessageDeficit\n     * - in metric_score() P6 Penalty::IPColocation\n     */\n    onScorePenalty(penalty) {\n      // Can this be labeled by topic too?\n      this.scoringPenalties.inc({\n        penalty\n      }, 1);\n    },\n\n    onIhaveRcv(topicStr, ihave, idonthave) {\n      const topic = this.toTopic(topicStr);\n      this.ihaveRcvMsgids.inc({\n        topic\n      }, ihave);\n      this.ihaveRcvNotSeenMsgids.inc({\n        topic\n      }, idonthave);\n    },\n\n    onIwantRcv(iwantByTopic, iwantDonthave) {\n      for (const [topicStr, iwant] of iwantByTopic) {\n        const topic = this.toTopic(topicStr);\n        this.iwantRcvMsgids.inc({\n          topic\n        }, iwant);\n      }\n\n      this.iwantRcvDonthaveMsgids.inc(iwantDonthave);\n    },\n\n    onForwardMsg(topicStr, tosendCount) {\n      const topic = this.toTopic(topicStr);\n      this.msgForwardCount.inc({\n        topic\n      }, 1);\n      this.msgForwardPeers.inc({\n        topic\n      }, tosendCount);\n    },\n\n    onPublishMsg(topicStr, tosendGroupCount, tosendCount, dataLen) {\n      const topic = this.toTopic(topicStr);\n      this.msgPublishCount.inc({\n        topic\n      }, 1);\n      this.msgPublishBytes.inc({\n        topic\n      }, tosendCount * dataLen);\n      this.msgPublishPeers.inc({\n        topic\n      }, tosendCount);\n      this.msgPublishPeersByGroup.inc({\n        topic,\n        peerGroup: 'direct'\n      }, tosendGroupCount.direct);\n      this.msgPublishPeersByGroup.inc({\n        topic,\n        peerGroup: 'floodsub'\n      }, tosendGroupCount.floodsub);\n      this.msgPublishPeersByGroup.inc({\n        topic,\n        peerGroup: 'mesh'\n      }, tosendGroupCount.mesh);\n      this.msgPublishPeersByGroup.inc({\n        topic,\n        peerGroup: 'fanout'\n      }, tosendGroupCount.fanout);\n    },\n\n    onMsgRecvPreValidation(topicStr) {\n      const topic = this.toTopic(topicStr);\n      this.msgReceivedPreValidation.inc({\n        topic\n      }, 1);\n    },\n\n    onMsgRecvError(topicStr) {\n      const topic = this.toTopic(topicStr);\n      this.msgReceivedError.inc({\n        topic\n      }, 1);\n    },\n\n    onMsgRecvResult(topicStr, status) {\n      const topic = this.toTopic(topicStr);\n      this.msgReceivedStatus.inc({\n        topic,\n        status\n      });\n    },\n\n    onMsgRecvInvalid(topicStr, reason) {\n      const topic = this.toTopic(topicStr);\n      const error = reason.reason === RejectReason.Error ? reason.error : reason.reason;\n      this.msgReceivedInvalid.inc({\n        topic,\n        error\n      }, 1);\n    },\n\n    onDuplicateMsgDelivery(topicStr, deliveryDelayMs, isLateDelivery) {\n      this.duplicateMsgDeliveryDelay.observe(deliveryDelayMs / 1000);\n\n      if (isLateDelivery) {\n        const topic = this.toTopic(topicStr);\n        this.duplicateMsgLateDelivery.inc({\n          topic\n        }, 1);\n      }\n    },\n\n    onPublishDuplicateMsg(topicStr) {\n      const topic = this.toTopic(topicStr);\n      this.duplicateMsgIgnored.inc({\n        topic\n      }, 1);\n    },\n\n    onPeerReadStreamError() {\n      this.peerReadStreamError.inc(1);\n    },\n\n    onRpcRecvError() {\n      this.rpcRecvError.inc(1);\n    },\n\n    onRpcDataError() {\n      this.rpcDataError.inc(1);\n    },\n\n    onRpcRecv(rpc, rpcBytes) {\n      this.rpcRecvBytes.inc(rpcBytes);\n      this.rpcRecvCount.inc(1);\n      if (rpc.subscriptions) this.rpcRecvSubscription.inc(rpc.subscriptions.length);\n      if (rpc.messages) this.rpcRecvMessage.inc(rpc.messages.length);\n\n      if (rpc.control) {\n        this.rpcRecvControl.inc(1);\n        if (rpc.control.ihave) this.rpcRecvIHave.inc(rpc.control.ihave.length);\n        if (rpc.control.iwant) this.rpcRecvIWant.inc(rpc.control.iwant.length);\n        if (rpc.control.graft) this.rpcRecvGraft.inc(rpc.control.graft.length);\n        if (rpc.control.prune) this.rpcRecvPrune.inc(rpc.control.prune.length);\n      }\n    },\n\n    onRpcSent(rpc, rpcBytes) {\n      this.rpcSentBytes.inc(rpcBytes);\n      this.rpcSentCount.inc(1);\n      if (rpc.subscriptions) this.rpcSentSubscription.inc(rpc.subscriptions.length);\n      if (rpc.messages) this.rpcSentMessage.inc(rpc.messages.length);\n\n      if (rpc.control) {\n        const ihave = rpc.control.ihave?.length ?? 0;\n        const iwant = rpc.control.iwant?.length ?? 0;\n        const graft = rpc.control.graft?.length ?? 0;\n        const prune = rpc.control.prune?.length ?? 0;\n        if (ihave > 0) this.rpcSentIHave.inc(ihave);\n        if (iwant > 0) this.rpcSentIWant.inc(iwant);\n        if (graft > 0) this.rpcSentGraft.inc(graft);\n        if (prune > 0) this.rpcSentPrune.inc(prune);\n        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0) this.rpcSentControl.inc(1);\n      }\n    },\n\n    registerScores(scores, scoreThresholds) {\n      let graylist = 0;\n      let publish = 0;\n      let gossip = 0;\n      let mesh = 0;\n\n      for (const score of scores) {\n        if (score >= scoreThresholds.graylistThreshold) graylist++;\n        if (score >= scoreThresholds.publishThreshold) publish++;\n        if (score >= scoreThresholds.gossipThreshold) gossip++;\n        if (score >= 0) mesh++;\n      }\n\n      this.peersByScoreThreshold.set({\n        threshold: ScoreThreshold.graylist\n      }, graylist);\n      this.peersByScoreThreshold.set({\n        threshold: ScoreThreshold.publish\n      }, publish);\n      this.peersByScoreThreshold.set({\n        threshold: ScoreThreshold.gossip\n      }, gossip);\n      this.peersByScoreThreshold.set({\n        threshold: ScoreThreshold.mesh\n      }, mesh); // Register full score too\n\n      this.score.set(scores);\n    },\n\n    registerScoreWeights(sw) {\n      for (const [topic, wsTopic] of sw.byTopic) {\n        this.scoreWeights.set({\n          topic,\n          p: 'p1'\n        }, wsTopic.p1w);\n        this.scoreWeights.set({\n          topic,\n          p: 'p2'\n        }, wsTopic.p2w);\n        this.scoreWeights.set({\n          topic,\n          p: 'p3'\n        }, wsTopic.p3w);\n        this.scoreWeights.set({\n          topic,\n          p: 'p3b'\n        }, wsTopic.p3bw);\n        this.scoreWeights.set({\n          topic,\n          p: 'p4'\n        }, wsTopic.p4w);\n      }\n\n      this.scoreWeights.set({\n        p: 'p5'\n      }, sw.p5w);\n      this.scoreWeights.set({\n        p: 'p6'\n      }, sw.p6w);\n      this.scoreWeights.set({\n        p: 'p7'\n      }, sw.p7w);\n    },\n\n    registerScorePerMesh(mesh, scoreByPeer) {\n      const peersPerTopicLabel = new Map();\n      mesh.forEach((peers, topicStr) => {\n        // Aggregate by known topicLabel or throw to 'unknown'. This prevent too high cardinality\n        const topicLabel = this.topicStrToLabel.get(topicStr) ?? 'unknown';\n        let peersInMesh = peersPerTopicLabel.get(topicLabel);\n\n        if (!peersInMesh) {\n          peersInMesh = new Set();\n          peersPerTopicLabel.set(topicLabel, peersInMesh);\n        }\n\n        peers.forEach(p => peersInMesh?.add(p));\n      });\n\n      for (const [topic, peers] of peersPerTopicLabel) {\n        const meshScores = [];\n        peers.forEach(peer => {\n          meshScores.push(scoreByPeer.get(peer) ?? 0);\n        });\n        this.scorePerMesh.set({\n          topic\n        }, meshScores);\n      }\n    }\n\n  };\n}","map":{"version":3,"mappings":"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","names":["RejectReason","MessageSource","InclusionReason","ChurnReason","ScorePenalty","IHaveIgnoreReason","ScoreThreshold","getMetrics","register","topicStrToLabel","opts","protocolsEnabled","gauge","name","help","labelNames","topicSubscriptionStatus","topicPeersCount","meshPeerCounts","meshPeerInclusionEvents","meshPeerChurnEvents","peersPerProtocol","heartbeatDuration","histogram","buckets","heartbeatSkipped","asyncValidationResult","asyncValidationMcacheHit","peerReadStreamError","rpcRecvBytes","rpcRecvCount","rpcRecvSubscription","rpcRecvMessage","rpcRecvControl","rpcRecvIHave","rpcRecvIWant","rpcRecvGraft","rpcRecvPrune","rpcDataError","rpcRecvError","rpcRecvNotAccepted","rpcSentBytes","rpcSentCount","rpcSentSubscription","rpcSentMessage","rpcSentControl","rpcSentIHave","rpcSentIWant","rpcSentGraft","rpcSentPrune","msgPublishCount","msgPublishPeers","msgPublishPeersByGroup","msgPublishBytes","msgForwardCount","msgForwardPeers","msgReceivedPreValidation","msgReceivedError","msgReceivedStatus","msgReceivedInvalid","duplicateMsgDeliveryDelay","maxMeshMessageDeliveriesWindowSec","duplicateMsgLateDelivery","duplicateMsgIgnored","scoreFnCalls","scoreFnRuns","scoreCachedDelta","peersByScoreThreshold","score","avgMinMax","scoreWeights","scorePerMesh","scoringPenalties","behaviourPenalty","behaviourPenaltyThreshold","ihaveRcvIgnored","ihaveRcvMsgids","ihaveRcvNotSeenMsgids","iwantRcvMsgids","iwantRcvDonthaveMsgids","iwantPromiseStarted","iwantPromiseResolved","iwantPromiseResolvedFromDuplicate","iwantPromiseResolvedPeers","iwantPromiseBroken","iwantMessagePruned","iwantPromiseDeliveryTime","gossipPromiseExpireSec","iwantPromiseUntracked","cacheSize","mcacheSize","mcacheNotValidatedCount","fastMsgIdCacheCollision","newConnectionCount","toTopic","topicStr","get","onJoin","set","onLeave","onAddToMesh","reason","count","topic","inc","onRemoveFromMesh","onReportValidationMcacheHit","hit","onReportValidation","acceptance","onScorePenalty","penalty","onIhaveRcv","ihave","idonthave","onIwantRcv","iwantByTopic","iwantDonthave","iwant","onForwardMsg","tosendCount","onPublishMsg","tosendGroupCount","dataLen","peerGroup","direct","floodsub","mesh","fanout","onMsgRecvPreValidation","onMsgRecvError","onMsgRecvResult","status","onMsgRecvInvalid","error","Error","onDuplicateMsgDelivery","deliveryDelayMs","isLateDelivery","observe","onPublishDuplicateMsg","onPeerReadStreamError","onRpcRecvError","onRpcDataError","onRpcRecv","rpc","rpcBytes","subscriptions","length","messages","control","graft","prune","onRpcSent","registerScores","scores","scoreThresholds","graylist","publish","gossip","graylistThreshold","publishThreshold","gossipThreshold","threshold","registerScoreWeights","sw","wsTopic","byTopic","p","p1w","p2w","p3w","p3bw","p4w","p5w","p6w","p7w","registerScorePerMesh","scoreByPeer","peersPerTopicLabel","Map","forEach","peers","topicLabel","peersInMesh","Set","add","meshScores","peer","push"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\metrics.ts"],"sourcesContent":["import { TopicValidatorResult } from '@libp2p/interface-pubsub'\nimport type { IRPC } from './message/rpc.js'\nimport type { PeerScoreThresholds } from './score/peer-score-thresholds.js'\nimport { MessageStatus, PeerIdStr, RejectReason, RejectReasonObj, TopicStr, ValidateError } from './types.js'\n\n/** Topic label as provided in `topicStrToLabel` */\nexport type TopicLabel = string\nexport type TopicStrToLabel = Map<TopicStr, TopicLabel>\n\nexport enum MessageSource {\n  forward = 'forward',\n  publish = 'publish'\n}\n\ntype LabelsGeneric = Record<string, string | undefined>\ntype CollectFn<Labels extends LabelsGeneric> = (metric: Gauge<Labels>) => void\n\ninterface Gauge<Labels extends LabelsGeneric = never> {\n  // Sorry for this mess, `prom-client` API choices are not great\n  // If the function signature was `inc(value: number, labels?: Labels)`, this would be simpler\n  inc(value?: number): void\n  inc(labels: Labels, value?: number): void\n  inc(arg1?: Labels | number, arg2?: number): void\n\n  set(value: number): void\n  set(labels: Labels, value: number): void\n  set(arg1?: Labels | number, arg2?: number): void\n\n  addCollect(collectFn: CollectFn<Labels>): void\n}\n\ninterface Histogram<Labels extends LabelsGeneric = never> {\n  startTimer(): () => void\n\n  observe(value: number): void\n  observe(labels: Labels, values: number): void\n  observe(arg1: Labels | number, arg2?: number): void\n\n  reset(): void\n}\n\ninterface AvgMinMax<Labels extends LabelsGeneric = never> {\n  set(values: number[]): void\n  set(labels: Labels, values: number[]): void\n  set(arg1?: Labels | number[], arg2?: number[]): void\n}\n\ntype GaugeConfig<Labels extends LabelsGeneric> = {\n  name: string\n  help: string\n  labelNames?: keyof Labels extends string ? (keyof Labels)[] : undefined\n}\n\ntype HistogramConfig<Labels extends LabelsGeneric> = {\n  name: string\n  help: string\n  labelNames?: (keyof Labels)[]\n  buckets?: number[]\n}\n\ntype AvgMinMaxConfig<Labels extends LabelsGeneric> = GaugeConfig<Labels>\n\nexport interface MetricsRegister {\n  gauge<T extends LabelsGeneric>(config: GaugeConfig<T>): Gauge<T>\n  histogram<T extends LabelsGeneric>(config: HistogramConfig<T>): Histogram<T>\n  avgMinMax<T extends LabelsGeneric>(config: AvgMinMaxConfig<T>): AvgMinMax<T>\n}\n\nexport enum InclusionReason {\n  /** Peer was a fanaout peer. */\n  Fanout = 'fanout',\n  /** Included from random selection. */\n  Random = 'random',\n  /** Peer subscribed. */\n  Subscribed = 'subscribed',\n  /** On heartbeat, peer was included to fill the outbound quota. */\n  Outbound = 'outbound',\n  /** On heartbeat, not enough peers in mesh */\n  NotEnough = 'not_enough',\n  /** On heartbeat opportunistic grafting due to low mesh score */\n  Opportunistic = 'opportunistic'\n}\n\n/// Reasons why a peer was removed from the mesh.\nexport enum ChurnReason {\n  /// Peer disconnected.\n  Dc = 'disconnected',\n  /// Peer had a bad score.\n  BadScore = 'bad_score',\n  /// Peer sent a PRUNE.\n  Prune = 'prune',\n  /// Peer unsubscribed.\n  Unsub = 'unsubscribed',\n  /// Too many peers.\n  Excess = 'excess'\n}\n\n/// Kinds of reasons a peer's score has been penalized\nexport enum ScorePenalty {\n  /// A peer grafted before waiting the back-off time.\n  GraftBackoff = 'graft_backoff',\n  /// A Peer did not respond to an IWANT request in time.\n  BrokenPromise = 'broken_promise',\n  /// A Peer did not send enough messages as expected.\n  MessageDeficit = 'message_deficit',\n  /// Too many peers under one IP address.\n  IPColocation = 'IP_colocation'\n}\n\nexport enum IHaveIgnoreReason {\n  LowScore = 'low_score',\n  MaxIhave = 'max_ihave',\n  MaxIasked = 'max_iasked'\n}\n\nexport enum ScoreThreshold {\n  graylist = 'graylist',\n  publish = 'publish',\n  gossip = 'gossip',\n  mesh = 'mesh'\n}\n\nexport type PeersByScoreThreshold = Record<ScoreThreshold, number>\n\nexport type ToSendGroupCount = {\n  direct: number\n  floodsub: number\n  mesh: number\n  fanout: number\n}\n\nexport type ToAddGroupCount = {\n  fanout: number\n  random: number\n}\n\nexport type PromiseDeliveredStats =\n  | { expired: false; requestedCount: number; maxDeliverMs: number }\n  | { expired: true; maxDeliverMs: number }\n\nexport type TopicScoreWeights<T> = { p1w: T; p2w: T; p3w: T; p3bw: T; p4w: T }\nexport type ScoreWeights<T> = {\n  byTopic: Map<TopicLabel, TopicScoreWeights<T>>\n  p5w: T\n  p6w: T\n  p7w: T\n  score: T\n}\n\nexport type Metrics = ReturnType<typeof getMetrics>\n\n/**\n * A collection of metrics used throughout the Gossipsub behaviour.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getMetrics(\n  register: MetricsRegister,\n  topicStrToLabel: TopicStrToLabel,\n  opts: { gossipPromiseExpireSec: number; behaviourPenaltyThreshold: number; maxMeshMessageDeliveriesWindowSec: number }\n) {\n  // Using function style instead of class to prevent having to re-declare all MetricsPrometheus types.\n\n  return {\n    /* Metrics for static config */\n    protocolsEnabled: register.gauge<{ protocol: string }>({\n      name: 'gossipsub_protocol',\n      help: 'Status of enabled protocols',\n      labelNames: ['protocol']\n    }),\n\n    /* Metrics per known topic */\n    /** Status of our subscription to this topic. This metric allows analyzing other topic metrics\n     *  filtered by our current subscription status.\n     *  = rust-libp2p `topic_subscription_status` */\n    topicSubscriptionStatus: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_topic_subscription_status',\n      help: 'Status of our subscription to this topic',\n      labelNames: ['topicStr']\n    }),\n    /** Number of peers subscribed to each topic. This allows us to analyze a topic's behaviour\n     * regardless of our subscription status. */\n    topicPeersCount: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_topic_peer_count',\n      help: 'Number of peers subscribed to each topic',\n      labelNames: ['topicStr']\n    }),\n\n    /* Metrics regarding mesh state */\n    /** Number of peers in our mesh. This metric should be updated with the count of peers for a\n     *  topic in the mesh regardless of inclusion and churn events.\n     *  = rust-libp2p `mesh_peer_counts` */\n    meshPeerCounts: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_mesh_peer_count',\n      help: 'Number of peers in our mesh',\n      labelNames: ['topicStr']\n    }),\n    /** Number of times we include peers in a topic mesh for different reasons.\n     *  = rust-libp2p `mesh_peer_inclusion_events` */\n    meshPeerInclusionEvents: register.gauge<{ topic: TopicLabel; reason: InclusionReason }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_total',\n      help: 'Number of times we include peers in a topic mesh for different reasons',\n      labelNames: ['topic', 'reason']\n    }),\n    /** Number of times we remove peers in a topic mesh for different reasons.\n     *  = rust-libp2p `mesh_peer_churn_events` */\n    meshPeerChurnEvents: register.gauge<{ topic: TopicLabel; reason: ChurnReason }>({\n      name: 'gossipsub_peer_churn_events_total',\n      help: 'Number of times we remove peers in a topic mesh for different reasons',\n      labelNames: ['topic', 'reason']\n    }),\n\n    /* General Metrics */\n    /** Gossipsub supports floodsub, gossipsub v1.0 and gossipsub v1.1. Peers are classified based\n     *  on which protocol they support. This metric keeps track of the number of peers that are\n     *  connected of each type. */\n    peersPerProtocol: register.gauge<{ protocol: string }>({\n      name: 'gossipsub_peers_per_protocol_count',\n      help: 'Peers connected for each topic',\n      labelNames: ['protocol']\n    }),\n    /** The time it takes to complete one iteration of the heartbeat. */\n    heartbeatDuration: register.histogram({\n      name: 'gossipsub_heartbeat_duration_seconds',\n      help: 'The time it takes to complete one iteration of the heartbeat',\n      // Should take <10ms, over 1s it's a huge issue that needs debugging, since a heartbeat will be cancelled\n      buckets: [0.01, 0.1, 1]\n    }),\n    /** Heartbeat run took longer than heartbeat interval so next is skipped */\n    heartbeatSkipped: register.gauge({\n      name: 'gossipsub_heartbeat_skipped',\n      help: 'Heartbeat run took longer than heartbeat interval so next is skipped'\n    }),\n\n    /** Message validation results for each topic.\n     *  Invalid == Reject?\n     *  = rust-libp2p `invalid_messages`, `accepted_messages`, `ignored_messages`, `rejected_messages` */\n    asyncValidationResult: register.gauge<{ topic: TopicLabel; acceptance: TopicValidatorResult }>({\n      name: 'gossipsub_async_validation_result_total',\n      help: 'Message validation result for each topic',\n      labelNames: ['topic', 'acceptance']\n    }),\n    /** When the user validates a message, it tries to re propagate it to its mesh peers. If the\n     *  message expires from the memcache before it can be validated, we count this a cache miss\n     *  and it is an indicator that the memcache size should be increased.\n     *  = rust-libp2p `mcache_misses` */\n    asyncValidationMcacheHit: register.gauge<{ hit: 'hit' | 'miss' }>({\n      name: 'gossipsub_async_validation_mcache_hit_total',\n      help: 'Async validation result reported by the user layer',\n      labelNames: ['hit']\n    }),\n\n    // peer stream\n    peerReadStreamError: register.gauge({\n      name: 'gossipsub_peer_read_stream_err_count_total',\n      help: 'Peer read stream error'\n    }),\n\n    // RPC outgoing. Track byte length + data structure sizes\n    rpcRecvBytes: register.gauge({ name: 'gossipsub_rpc_recv_bytes_total', help: 'RPC recv' }),\n    rpcRecvCount: register.gauge({ name: 'gossipsub_rpc_recv_count_total', help: 'RPC recv' }),\n    rpcRecvSubscription: register.gauge({ name: 'gossipsub_rpc_recv_subscription_total', help: 'RPC recv' }),\n    rpcRecvMessage: register.gauge({ name: 'gossipsub_rpc_recv_message_total', help: 'RPC recv' }),\n    rpcRecvControl: register.gauge({ name: 'gossipsub_rpc_recv_control_total', help: 'RPC recv' }),\n    rpcRecvIHave: register.gauge({ name: 'gossipsub_rpc_recv_ihave_total', help: 'RPC recv' }),\n    rpcRecvIWant: register.gauge({ name: 'gossipsub_rpc_recv_iwant_total', help: 'RPC recv' }),\n    rpcRecvGraft: register.gauge({ name: 'gossipsub_rpc_recv_graft_total', help: 'RPC recv' }),\n    rpcRecvPrune: register.gauge({ name: 'gossipsub_rpc_recv_prune_total', help: 'RPC recv' }),\n    rpcDataError: register.gauge({ name: 'gossipsub_rpc_data_err_count_total', help: 'RPC data error' }),\n    rpcRecvError: register.gauge({ name: 'gossipsub_rpc_recv_err_count_total', help: 'RPC recv error' }),\n\n    /** Total count of RPC dropped because acceptFrom() == false */\n    rpcRecvNotAccepted: register.gauge({\n      name: 'gossipsub_rpc_rcv_not_accepted_total',\n      help: 'Total count of RPC dropped because acceptFrom() == false'\n    }),\n\n    // RPC incoming. Track byte length + data structure sizes\n    rpcSentBytes: register.gauge({ name: 'gossipsub_rpc_sent_bytes_total', help: 'RPC sent' }),\n    rpcSentCount: register.gauge({ name: 'gossipsub_rpc_sent_count_total', help: 'RPC sent' }),\n    rpcSentSubscription: register.gauge({ name: 'gossipsub_rpc_sent_subscription_total', help: 'RPC sent' }),\n    rpcSentMessage: register.gauge({ name: 'gossipsub_rpc_sent_message_total', help: 'RPC sent' }),\n    rpcSentControl: register.gauge({ name: 'gossipsub_rpc_sent_control_total', help: 'RPC sent' }),\n    rpcSentIHave: register.gauge({ name: 'gossipsub_rpc_sent_ihave_total', help: 'RPC sent' }),\n    rpcSentIWant: register.gauge({ name: 'gossipsub_rpc_sent_iwant_total', help: 'RPC sent' }),\n    rpcSentGraft: register.gauge({ name: 'gossipsub_rpc_sent_graft_total', help: 'RPC sent' }),\n    rpcSentPrune: register.gauge({ name: 'gossipsub_rpc_sent_prune_total', help: 'RPC sent' }),\n\n    // publish message. Track peers sent to and bytes\n    /** Total count of msg published by topic */\n    msgPublishCount: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_count_total',\n      help: 'Total count of msg published by topic',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers that we publish a msg to */\n    msgPublishPeers: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_peers_total',\n      help: 'Total count of peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers (by group) that we publish a msg to */\n    // NOTE: Do not use 'group' label since it's a generic already used by Prometheus to group instances\n    msgPublishPeersByGroup: register.gauge<{ topic: TopicLabel; peerGroup: keyof ToSendGroupCount }>({\n      name: 'gossipsub_msg_publish_peers_by_group',\n      help: 'Total count of peers (by group) that we publish a msg to',\n      labelNames: ['topic', 'peerGroup']\n    }),\n    /** Total count of msg publish data.length bytes */\n    msgPublishBytes: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_bytes_total',\n      help: 'Total count of msg publish data.length bytes',\n      labelNames: ['topic']\n    }),\n\n    /** Total count of msg forwarded by topic */\n    msgForwardCount: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_forward_count_total',\n      help: 'Total count of msg forwarded by topic',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers that we forward a msg to */\n    msgForwardPeers: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_forward_peers_total',\n      help: 'Total count of peers that we forward a msg to',\n      labelNames: ['topic']\n    }),\n\n    /** Total count of recv msgs before any validation */\n    msgReceivedPreValidation: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_prevalidation_total',\n      help: 'Total count of recv msgs before any validation',\n      labelNames: ['topic']\n    }),\n    /** Total count of recv msgs error */\n    msgReceivedError: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_error_total',\n      help: 'Total count of recv msgs error',\n      labelNames: ['topic']\n    }),\n    /** Tracks distribution of recv msgs by duplicate, invalid, valid */\n    msgReceivedStatus: register.gauge<{ topic: TopicLabel; status: MessageStatus }>({\n      name: 'gossipsub_msg_received_status_total',\n      help: 'Tracks distribution of recv msgs by duplicate, invalid, valid',\n      labelNames: ['topic', 'status']\n    }),\n    /** Tracks specific reason of invalid */\n    msgReceivedInvalid: register.gauge<{ topic: TopicLabel; error: RejectReason | ValidateError }>({\n      name: 'gossipsub_msg_received_invalid_total',\n      help: 'Tracks specific reason of invalid',\n      labelNames: ['topic', 'error']\n    }),\n    /** Track duplicate message delivery time */\n    duplicateMsgDeliveryDelay: register.histogram({\n      name: 'gossisub_duplicate_msg_delivery_delay_seconds',\n      help: 'Time since the 1st duplicated message validated',\n      labelNames: ['topic'],\n      buckets: [\n        0.25 * opts.maxMeshMessageDeliveriesWindowSec,\n        0.5 * opts.maxMeshMessageDeliveriesWindowSec,\n        1 * opts.maxMeshMessageDeliveriesWindowSec,\n        2 * opts.maxMeshMessageDeliveriesWindowSec,\n        4 * opts.maxMeshMessageDeliveriesWindowSec\n      ]\n    }),\n    /** Total count of late msg delivery total by topic */\n    duplicateMsgLateDelivery: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossisub_duplicate_msg_late_delivery_total',\n      help: 'Total count of late duplicate message delivery by topic, which triggers P3 penalty',\n      labelNames: ['topic']\n    }),\n\n    duplicateMsgIgnored: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossisub_ignored_published_duplicate_msgs_total',\n      help: 'Total count of published duplicate message ignored by topic',\n      labelNames: ['topic']\n    }),\n\n    /* Metrics related to scoring */\n    /** Total times score() is called */\n    scoreFnCalls: register.gauge({\n      name: 'gossipsub_score_fn_calls_total',\n      help: 'Total times score() is called'\n    }),\n    /** Total times score() call actually computed computeScore(), no cache */\n    scoreFnRuns: register.gauge({\n      name: 'gossipsub_score_fn_runs_total',\n      help: 'Total times score() call actually computed computeScore(), no cache'\n    }),\n    scoreCachedDelta: register.histogram({\n      name: 'gossipsub_score_cache_delta',\n      help: 'Delta of score between cached values that expired',\n      buckets: [10, 100, 1000]\n    }),\n    /** Current count of peers by score threshold */\n    peersByScoreThreshold: register.gauge<{ threshold: ScoreThreshold }>({\n      name: 'gossipsub_peers_by_score_threshold_count',\n      help: 'Current count of peers by score threshold',\n      labelNames: ['threshold']\n    }),\n    score: register.avgMinMax({\n      name: 'gossipsub_score',\n      help: 'Avg min max of gossip scores',\n      labelNames: ['topic', 'p']\n    }),\n    /** Separate score weights */\n    scoreWeights: register.avgMinMax<{ topic?: TopicLabel; p: string }>({\n      name: 'gossipsub_score_weights',\n      help: 'Separate score weights',\n      labelNames: ['topic', 'p']\n    }),\n    /** Histogram of the scores for each mesh topic. */\n    // TODO: Not implemented\n    scorePerMesh: register.avgMinMax<{ topic: TopicLabel }>({\n      name: 'gossipsub_score_per_mesh',\n      help: 'Histogram of the scores for each mesh topic',\n      labelNames: ['topic']\n    }),\n    /** A counter of the kind of penalties being applied to peers. */\n    // TODO: Not fully implemented\n    scoringPenalties: register.gauge<{ penalty: ScorePenalty }>({\n      name: 'gossipsub_scoring_penalties_total',\n      help: 'A counter of the kind of penalties being applied to peers',\n      labelNames: ['penalty']\n    }),\n    behaviourPenalty: register.histogram({\n      name: 'gossipsub_peer_stat_behaviour_penalty',\n      help: 'Current peer stat behaviour_penalty at each scrape',\n      buckets: [\n        0.25 * opts.behaviourPenaltyThreshold,\n        0.5 * opts.behaviourPenaltyThreshold,\n        1 * opts.behaviourPenaltyThreshold,\n        2 * opts.behaviourPenaltyThreshold,\n        4 * opts.behaviourPenaltyThreshold\n      ]\n    }),\n\n    // TODO:\n    // - iasked per peer (on heartbeat)\n    // - when promise is resolved, track messages from promises\n\n    /** Total received IHAVE messages that we ignore for some reason */\n    ihaveRcvIgnored: register.gauge<{ reason: IHaveIgnoreReason }>({\n      name: 'gossipsub_ihave_rcv_ignored_total',\n      help: 'Total received IHAVE messages that we ignore for some reason',\n      labelNames: ['reason']\n    }),\n    /** Total received IHAVE messages by topic */\n    ihaveRcvMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ihave_rcv_msgids_total',\n      help: 'Total received IHAVE messages by topic',\n      labelNames: ['topic']\n    }),\n    /** Total messages per topic we don't have. Not actual requests.\n     *  The number of times we have decided that an IWANT control message is required for this\n     *  topic. A very high metric might indicate an underperforming network.\n     *  = rust-libp2p `topic_iwant_msgs` */\n    ihaveRcvNotSeenMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ihave_rcv_not_seen_msgids_total',\n      help: 'Total messages per topic we do not have, not actual requests',\n      labelNames: ['topic']\n    }),\n\n    /** Total received IWANT messages by topic */\n    iwantRcvMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_iwant_rcv_msgids_total',\n      help: 'Total received IWANT messages by topic',\n      labelNames: ['topic']\n    }),\n    /** Total requested messageIDs that we don't have */\n    iwantRcvDonthaveMsgids: register.gauge({\n      name: 'gossipsub_iwant_rcv_dont_have_msgids_total',\n      help: 'Total requested messageIDs that we do not have'\n    }),\n    iwantPromiseStarted: register.gauge({\n      name: 'gossipsub_iwant_promise_sent_total',\n      help: 'Total count of started IWANT promises'\n    }),\n    /** Total count of resolved IWANT promises */\n    iwantPromiseResolved: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_total',\n      help: 'Total count of resolved IWANT promises'\n    }),\n    /** Total count of resolved IWANT promises from duplicate messages */\n    iwantPromiseResolvedFromDuplicate: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_from_duplicate_total',\n      help: 'Total count of resolved IWANT promises from duplicate messages'\n    }),\n    /** Total count of peers we have asked IWANT promises that are resolved */\n    iwantPromiseResolvedPeers: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_peers',\n      help: 'Total count of peers we have asked IWANT promises that are resolved'\n    }),\n    iwantPromiseBroken: register.gauge({\n      name: 'gossipsub_iwant_promise_broken',\n      help: 'Total count of broken IWANT promises'\n    }),\n    iwantMessagePruned: register.gauge({\n      name: 'gossipsub_iwant_message_pruned',\n      help: 'Total count of pruned IWANT messages'\n    }),\n    /** Histogram of delivery time of resolved IWANT promises */\n    iwantPromiseDeliveryTime: register.histogram({\n      name: 'gossipsub_iwant_promise_delivery_seconds',\n      help: 'Histogram of delivery time of resolved IWANT promises',\n      buckets: [\n        0.5 * opts.gossipPromiseExpireSec,\n        1 * opts.gossipPromiseExpireSec,\n        2 * opts.gossipPromiseExpireSec,\n        4 * opts.gossipPromiseExpireSec\n      ]\n    }),\n    iwantPromiseUntracked: register.gauge({\n      name: 'gossip_iwant_promise_untracked',\n      help: 'Total count of untracked IWANT promise'\n    }),\n\n    /* Data structure sizes */\n    /** Unbounded cache sizes */\n    cacheSize: register.gauge<{ cache: string }>({\n      name: 'gossipsub_cache_size',\n      help: 'Unbounded cache sizes',\n      labelNames: ['cache']\n    }),\n    /** Current mcache msg count */\n    mcacheSize: register.gauge({\n      name: 'gossipsub_mcache_size',\n      help: 'Current mcache msg count'\n    }),\n    mcacheNotValidatedCount: register.gauge({\n      name: 'gossipsub_mcache_not_validated_count',\n      help: 'Current mcache msg count not validated'\n    }),\n\n    fastMsgIdCacheCollision: register.gauge({\n      name: 'gossipsub_fastmsgid_cache_collision_total',\n      help: 'Total count of key collisions on fastmsgid cache put'\n    }),\n\n    newConnectionCount: register.gauge<{ status: string }>({\n      name: 'gossipsub_new_connection_total',\n      help: 'Total new connection by status',\n      labelNames: ['status']\n    }),\n\n    topicStrToLabel: topicStrToLabel,\n\n    toTopic(topicStr: TopicStr): TopicLabel {\n      return this.topicStrToLabel.get(topicStr) ?? topicStr\n    },\n\n    /** We joined a topic */\n    onJoin(topicStr: TopicStr): void {\n      this.topicSubscriptionStatus.set({ topicStr }, 1)\n      this.meshPeerCounts.set({ topicStr }, 0) // Reset count\n    },\n\n    /** We left a topic */\n    onLeave(topicStr: TopicStr): void {\n      this.topicSubscriptionStatus.set({ topicStr }, 0)\n      this.meshPeerCounts.set({ topicStr }, 0) // Reset count\n    },\n\n    /** Register the inclusion of peers in our mesh due to some reason. */\n    onAddToMesh(topicStr: TopicStr, reason: InclusionReason, count: number): void {\n      const topic = this.toTopic(topicStr)\n      this.meshPeerInclusionEvents.inc({ topic, reason }, count)\n    },\n\n    /** Register the removal of peers in our mesh due to some reason */\n    // - remove_peer_from_mesh()\n    // - heartbeat() Churn::BadScore\n    // - heartbeat() Churn::Excess\n    // - on_disconnect() Churn::Ds\n    onRemoveFromMesh(topicStr: TopicStr, reason: ChurnReason, count: number): void {\n      const topic = this.toTopic(topicStr)\n      this.meshPeerChurnEvents.inc({ topic, reason }, count)\n    },\n\n    onReportValidationMcacheHit(hit: boolean): void {\n      this.asyncValidationMcacheHit.inc({ hit: hit ? 'hit' : 'miss' })\n    },\n\n    onReportValidation(topicStr: TopicStr, acceptance: TopicValidatorResult): void {\n      const topic = this.toTopic(topicStr)\n      this.asyncValidationResult.inc({ topic: topic, acceptance })\n    },\n\n    /**\n     * - in handle_graft() Penalty::GraftBackoff\n     * - in apply_iwant_penalties() Penalty::BrokenPromise\n     * - in metric_score() P3 Penalty::MessageDeficit\n     * - in metric_score() P6 Penalty::IPColocation\n     */\n    onScorePenalty(penalty: ScorePenalty): void {\n      // Can this be labeled by topic too?\n      this.scoringPenalties.inc({ penalty }, 1)\n    },\n\n    onIhaveRcv(topicStr: TopicStr, ihave: number, idonthave: number): void {\n      const topic = this.toTopic(topicStr)\n      this.ihaveRcvMsgids.inc({ topic }, ihave)\n      this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave)\n    },\n\n    onIwantRcv(iwantByTopic: Map<TopicStr, number>, iwantDonthave: number): void {\n      for (const [topicStr, iwant] of iwantByTopic) {\n        const topic = this.toTopic(topicStr)\n        this.iwantRcvMsgids.inc({ topic }, iwant)\n      }\n\n      this.iwantRcvDonthaveMsgids.inc(iwantDonthave)\n    },\n\n    onForwardMsg(topicStr: TopicStr, tosendCount: number): void {\n      const topic = this.toTopic(topicStr)\n      this.msgForwardCount.inc({ topic }, 1)\n      this.msgForwardPeers.inc({ topic }, tosendCount)\n    },\n\n    onPublishMsg(topicStr: TopicStr, tosendGroupCount: ToSendGroupCount, tosendCount: number, dataLen: number): void {\n      const topic = this.toTopic(topicStr)\n      this.msgPublishCount.inc({ topic }, 1)\n      this.msgPublishBytes.inc({ topic }, tosendCount * dataLen)\n      this.msgPublishPeers.inc({ topic }, tosendCount)\n      this.msgPublishPeersByGroup.inc({ topic, peerGroup: 'direct' }, tosendGroupCount.direct)\n      this.msgPublishPeersByGroup.inc({ topic, peerGroup: 'floodsub' }, tosendGroupCount.floodsub)\n      this.msgPublishPeersByGroup.inc({ topic, peerGroup: 'mesh' }, tosendGroupCount.mesh)\n      this.msgPublishPeersByGroup.inc({ topic, peerGroup: 'fanout' }, tosendGroupCount.fanout)\n    },\n\n    onMsgRecvPreValidation(topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.msgReceivedPreValidation.inc({ topic }, 1)\n    },\n\n    onMsgRecvError(topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.msgReceivedError.inc({ topic }, 1)\n    },\n\n    onMsgRecvResult(topicStr: TopicStr, status: MessageStatus): void {\n      const topic = this.toTopic(topicStr)\n      this.msgReceivedStatus.inc({ topic, status })\n    },\n\n    onMsgRecvInvalid(topicStr: TopicStr, reason: RejectReasonObj): void {\n      const topic = this.toTopic(topicStr)\n\n      const error = reason.reason === RejectReason.Error ? reason.error : reason.reason\n      this.msgReceivedInvalid.inc({ topic, error }, 1)\n    },\n\n    onDuplicateMsgDelivery(topicStr: TopicStr, deliveryDelayMs: number, isLateDelivery: boolean): void {\n      this.duplicateMsgDeliveryDelay.observe(deliveryDelayMs / 1000)\n      if (isLateDelivery) {\n        const topic = this.toTopic(topicStr)\n        this.duplicateMsgLateDelivery.inc({ topic }, 1)\n      }\n    },\n\n    onPublishDuplicateMsg(topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.duplicateMsgIgnored.inc({ topic }, 1)\n    },\n\n    onPeerReadStreamError(): void {\n      this.peerReadStreamError.inc(1)\n    },\n\n    onRpcRecvError(): void {\n      this.rpcRecvError.inc(1)\n    },\n\n    onRpcDataError(): void {\n      this.rpcDataError.inc(1)\n    },\n\n    onRpcRecv(rpc: IRPC, rpcBytes: number): void {\n      this.rpcRecvBytes.inc(rpcBytes)\n      this.rpcRecvCount.inc(1)\n      if (rpc.subscriptions) this.rpcRecvSubscription.inc(rpc.subscriptions.length)\n      if (rpc.messages) this.rpcRecvMessage.inc(rpc.messages.length)\n      if (rpc.control) {\n        this.rpcRecvControl.inc(1)\n        if (rpc.control.ihave) this.rpcRecvIHave.inc(rpc.control.ihave.length)\n        if (rpc.control.iwant) this.rpcRecvIWant.inc(rpc.control.iwant.length)\n        if (rpc.control.graft) this.rpcRecvGraft.inc(rpc.control.graft.length)\n        if (rpc.control.prune) this.rpcRecvPrune.inc(rpc.control.prune.length)\n      }\n    },\n\n    onRpcSent(rpc: IRPC, rpcBytes: number): void {\n      this.rpcSentBytes.inc(rpcBytes)\n      this.rpcSentCount.inc(1)\n      if (rpc.subscriptions) this.rpcSentSubscription.inc(rpc.subscriptions.length)\n      if (rpc.messages) this.rpcSentMessage.inc(rpc.messages.length)\n      if (rpc.control) {\n        const ihave = rpc.control.ihave?.length ?? 0\n        const iwant = rpc.control.iwant?.length ?? 0\n        const graft = rpc.control.graft?.length ?? 0\n        const prune = rpc.control.prune?.length ?? 0\n        if (ihave > 0) this.rpcSentIHave.inc(ihave)\n        if (iwant > 0) this.rpcSentIWant.inc(iwant)\n        if (graft > 0) this.rpcSentGraft.inc(graft)\n        if (prune > 0) this.rpcSentPrune.inc(prune)\n        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0) this.rpcSentControl.inc(1)\n      }\n    },\n\n    registerScores(scores: number[], scoreThresholds: PeerScoreThresholds): void {\n      let graylist = 0\n      let publish = 0\n      let gossip = 0\n      let mesh = 0\n\n      for (const score of scores) {\n        if (score >= scoreThresholds.graylistThreshold) graylist++\n        if (score >= scoreThresholds.publishThreshold) publish++\n        if (score >= scoreThresholds.gossipThreshold) gossip++\n        if (score >= 0) mesh++\n      }\n\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh)\n\n      // Register full score too\n      this.score.set(scores)\n    },\n\n    registerScoreWeights(sw: ScoreWeights<number[]>): void {\n      for (const [topic, wsTopic] of sw.byTopic) {\n        this.scoreWeights.set({ topic, p: 'p1' }, wsTopic.p1w)\n        this.scoreWeights.set({ topic, p: 'p2' }, wsTopic.p2w)\n        this.scoreWeights.set({ topic, p: 'p3' }, wsTopic.p3w)\n        this.scoreWeights.set({ topic, p: 'p3b' }, wsTopic.p3bw)\n        this.scoreWeights.set({ topic, p: 'p4' }, wsTopic.p4w)\n      }\n\n      this.scoreWeights.set({ p: 'p5' }, sw.p5w)\n      this.scoreWeights.set({ p: 'p6' }, sw.p6w)\n      this.scoreWeights.set({ p: 'p7' }, sw.p7w)\n    },\n\n    registerScorePerMesh(mesh: Map<TopicStr, Set<PeerIdStr>>, scoreByPeer: Map<PeerIdStr, number>): void {\n      const peersPerTopicLabel = new Map<TopicLabel, Set<PeerIdStr>>()\n\n      mesh.forEach((peers, topicStr) => {\n        // Aggregate by known topicLabel or throw to 'unknown'. This prevent too high cardinality\n        const topicLabel = this.topicStrToLabel.get(topicStr) ?? 'unknown'\n        let peersInMesh = peersPerTopicLabel.get(topicLabel)\n        if (!peersInMesh) {\n          peersInMesh = new Set()\n          peersPerTopicLabel.set(topicLabel, peersInMesh)\n        }\n        peers.forEach((p) => peersInMesh?.add(p))\n      })\n\n      for (const [topic, peers] of peersPerTopicLabel) {\n        const meshScores: number[] = []\n        peers.forEach((peer) => {\n          meshScores.push(scoreByPeer.get(peer) ?? 0)\n        })\n        this.scorePerMesh.set({ topic }, meshScores)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}