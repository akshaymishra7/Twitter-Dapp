{"ast":null,"code":"import varint from 'varint';\nexport const CIDV0_BYTES = {\n  SHA2_256: 0x12,\n  LENGTH: 0x20,\n  DAG_PB: 0x70\n};\nexport const V2_HEADER_LENGTH =\n/* characteristics */\n16\n/* v1 offset */\n+ 8\n/* v1 size */\n+ 8\n/* index offset */\n+ 8;\n/**\n * Decodes varint and seeks the buffer\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @param {import('./coding').Seekable} seeker\n * @returns {number}\n */\n\nexport function decodeVarint(bytes, seeker) {\n  if (!bytes.length) {\n    throw new Error('Unexpected end of data');\n  }\n\n  const i = varint.decode(bytes);\n  seeker.seek(\n  /** @type {number} */\n  varint.decode.bytes);\n  return i;\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n/**\n * Decode v2 header\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.exactly(V2_HEADER_LENGTH, true) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @returns {import('./coding').CarV2FixedHeader}\n */\n\nexport function decodeV2Header(bytes) {\n  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  let offset = 0;\n  const header = {\n    version: 2,\n\n    /** @type {[bigint, bigint]} */\n    characteristics: [dv.getBigUint64(offset, true), dv.getBigUint64(offset += 8, true)],\n    dataOffset: Number(dv.getBigUint64(offset += 8, true)),\n    dataSize: Number(dv.getBigUint64(offset += 8, true)),\n    indexOffset: Number(dv.getBigUint64(offset += 8, true))\n  };\n  return header;\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n/**\n * Checks the length of the multihash to be read afterwards\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n */\n\nexport function getMultihashLength(bytes) {\n  // | code | length | .... |\n  // where both code and length are varints, so we have to decode\n  // them first before we can know total length\n  varint.decode(bytes); // code\n\n  const codeLength =\n  /** @type {number} */\n  varint.decode.bytes;\n  const length = varint.decode(bytes.subarray(varint.decode.bytes));\n  const lengthLength =\n  /** @type {number} */\n  varint.decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  return mhLength;\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/@ipld/car/src/decoder-common.js"],"names":["varint","CIDV0_BYTES","SHA2_256","LENGTH","DAG_PB","V2_HEADER_LENGTH","decodeVarint","bytes","seeker","length","Error","i","decode","seek","decodeV2Header","dv","DataView","buffer","byteOffset","byteLength","offset","header","version","characteristics","getBigUint64","dataOffset","Number","dataSize","indexOffset","getMultihashLength","codeLength","subarray","lengthLength","mhLength"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AAEA,OAAO,MAAMC,WAAW,GAAG;AACzBC,EAAAA,QAAQ,EAAE,IADe;AAEzBC,EAAAA,MAAM,EAAE,IAFiB;AAGzBC,EAAAA,MAAM,EAAE;AAHiB,CAApB;AAMP,OAAO,MAAMC,gBAAgB;AAAG;AAAsB;AAAG;AAAH,EAAqB;AAAE;AAAvB,EAAuC;AAAE;AAAzC,EAA8D,CAA7G;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,YAAT,CAAuBC,KAAvB,EAA8BC,MAA9B,EAAsC;AAC3C,MAAI,CAACD,KAAK,CAACE,MAAX,EAAmB;AACjB,UAAM,IAAIC,KAAJ,CAAU,wBAAV,CAAN;AACD;;AACD,QAAMC,CAAC,GAAGX,MAAM,CAACY,MAAP,CAAcL,KAAd,CAAV;AACAC,EAAAA,MAAM,CAACK,IAAP;AAAY;AAAsBb,EAAAA,MAAM,CAACY,MAAP,CAAcL,KAAhD;AACA,SAAOI,CAAP;AACA;AACA;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,cAAT,CAAyBP,KAAzB,EAAgC;AACrC,QAAMQ,EAAE,GAAG,IAAIC,QAAJ,CAAaT,KAAK,CAACU,MAAnB,EAA2BV,KAAK,CAACW,UAAjC,EAA6CX,KAAK,CAACY,UAAnD,CAAX;AACA,MAAIC,MAAM,GAAG,CAAb;AACA,QAAMC,MAAM,GAAG;AACbC,IAAAA,OAAO,EAAE,CADI;;AAEb;AACAC,IAAAA,eAAe,EAAE,CACfR,EAAE,CAACS,YAAH,CAAgBJ,MAAhB,EAAwB,IAAxB,CADe,EAEfL,EAAE,CAACS,YAAH,CAAgBJ,MAAM,IAAI,CAA1B,EAA6B,IAA7B,CAFe,CAHJ;AAObK,IAAAA,UAAU,EAAEC,MAAM,CAACX,EAAE,CAACS,YAAH,CAAgBJ,MAAM,IAAI,CAA1B,EAA6B,IAA7B,CAAD,CAPL;AAQbO,IAAAA,QAAQ,EAAED,MAAM,CAACX,EAAE,CAACS,YAAH,CAAgBJ,MAAM,IAAI,CAA1B,EAA6B,IAA7B,CAAD,CARH;AASbQ,IAAAA,WAAW,EAAEF,MAAM,CAACX,EAAE,CAACS,YAAH,CAAgBJ,MAAM,IAAI,CAA1B,EAA6B,IAA7B,CAAD;AATN,GAAf;AAWA,SAAOC,MAAP;AACA;AACA;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASQ,kBAAT,CAA6BtB,KAA7B,EAAoC;AACzC;AACA;AACA;AAEAP,EAAAA,MAAM,CAACY,MAAP,CAAcL,KAAd,EALyC,CAKpB;;AACrB,QAAMuB,UAAU;AAAG;AAAsB9B,EAAAA,MAAM,CAACY,MAAP,CAAcL,KAAvD;AACA,QAAME,MAAM,GAAGT,MAAM,CAACY,MAAP,CAAcL,KAAK,CAACwB,QAAN,CAAe/B,MAAM,CAACY,MAAP,CAAcL,KAA7B,CAAd,CAAf;AACA,QAAMyB,YAAY;AAAG;AAAsBhC,EAAAA,MAAM,CAACY,MAAP,CAAcL,KAAzD;AACA,QAAM0B,QAAQ,GAAGH,UAAU,GAAGE,YAAb,GAA4BvB,MAA7C;AAEA,SAAOwB,QAAP;AACD","sourcesContent":["import varint from 'varint'\n\nexport const CIDV0_BYTES = {\n  SHA2_256: 0x12,\n  LENGTH: 0x20,\n  DAG_PB: 0x70\n}\n\nexport const V2_HEADER_LENGTH = /* characteristics */ 16 /* v1 offset */ + 8 /* v1 size */ + 8 /* index offset */ + 8\n\n/**\n * Decodes varint and seeks the buffer\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @param {import('./coding').Seekable} seeker\n * @returns {number}\n */\nexport function decodeVarint (bytes, seeker) {\n  if (!bytes.length) {\n    throw new Error('Unexpected end of data')\n  }\n  const i = varint.decode(bytes)\n  seeker.seek(/** @type {number} */(varint.decode.bytes))\n  return i\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * Decode v2 header\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.exactly(V2_HEADER_LENGTH, true) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @returns {import('./coding').CarV2FixedHeader}\n */\nexport function decodeV2Header (bytes) {\n  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  let offset = 0\n  const header = {\n    version: 2,\n    /** @type {[bigint, bigint]} */\n    characteristics: [\n      dv.getBigUint64(offset, true),\n      dv.getBigUint64(offset += 8, true)\n    ],\n    dataOffset: Number(dv.getBigUint64(offset += 8, true)),\n    dataSize: Number(dv.getBigUint64(offset += 8, true)),\n    indexOffset: Number(dv.getBigUint64(offset += 8, true))\n  }\n  return header\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * Checks the length of the multihash to be read afterwards\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n */\nexport function getMultihashLength (bytes) {\n  // | code | length | .... |\n  // where both code and length are varints, so we have to decode\n  // them first before we can know total length\n\n  varint.decode(bytes) // code\n  const codeLength = /** @type {number} */(varint.decode.bytes)\n  const length = varint.decode(bytes.subarray(varint.decode.bytes))\n  const lengthLength = /** @type {number} */(varint.decode.bytes)\n  const mhLength = codeLength + lengthLength + length\n\n  return mhLength\n}\n"]},"metadata":{},"sourceType":"module"}