{"ast":null,"code":"import * as isIpfs from 'is-ipfs';\nimport { CID } from 'multiformats/cid';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { resolve as res } from '../utils.js';\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-core-utils/src/multibases').Multibases} config.bases\n * @param {import('ipfs-core-types/src/name').API} config.name\n */\n\nexport function createResolve(_ref) {\n  let {\n    repo,\n    codecs,\n    bases,\n    name\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]}\n   */\n  async function resolve(path) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!isIpfs.path(path)) {\n      throw new Error('invalid argument ' + path);\n    }\n\n    if (isIpfs.ipnsPath(path)) {\n      for await (const resolvedPath of name.resolve(path, opts)) {\n        path = resolvedPath;\n      }\n    }\n\n    const [, schema, hash, ...rest] = path.split('/'); // ['', 'ipfs', 'hash', ...path]\n\n    const base = opts.cidBase ? await bases.getBase(opts.cidBase) : undefined;\n    const bytes = parseBytes(hash); // nothing to resolve return the input\n\n    if (rest.length === 0) {\n      const str = base ? base.encoder.encode(bytes) : hash;\n      return `/${schema}/${str}`;\n    }\n\n    const cid = CID.decode(bytes);\n    path = rest.join('/');\n    const results = res(cid, path, codecs, repo, opts);\n    let value = cid;\n    let remainderPath = path;\n\n    for await (const result of results) {\n      if (CID.asCID(result.value)) {\n        value = result.value;\n        remainderPath = result.remainderPath;\n      }\n    }\n\n    return `/ipfs/${value.toString(base && base.encoder)}${remainderPath ? '/' + remainderPath : ''}`;\n  }\n\n  return withTimeoutOption(resolve);\n}\n/**\n * Parse the input as a PeerID or a CID or throw an error\n *\n * @param {string} str\n */\n\nfunction parseBytes(str) {\n  try {\n    return peerIdFromString(str).toBytes();\n  } catch {\n    return CID.parse(str).bytes;\n  }\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/resolve.js"],"names":["isIpfs","CID","peerIdFromString","withTimeoutOption","resolve","res","createResolve","repo","codecs","bases","name","path","opts","Error","ipnsPath","resolvedPath","schema","hash","rest","split","base","cidBase","getBase","undefined","bytes","parseBytes","length","str","encoder","encode","cid","decode","join","results","value","remainderPath","result","asCID","toString","toBytes","parse"],"mappings":"AAAA,OAAO,KAAKA,MAAZ,MAAwB,SAAxB;AACA,SAASC,GAAT,QAAoB,kBAApB;AACA,SAASC,gBAAT,QAAiC,iBAAjC;AACA,SAASC,iBAAT,QAAkC,qCAAlC;AACA,SAASC,OAAO,IAAIC,GAApB,QAA+B,aAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,aAAT,OAAuD;AAAA,MAA/B;AAAEC,IAAAA,IAAF;AAAQC,IAAAA,MAAR;AAAgBC,IAAAA,KAAhB;AAAuBC,IAAAA;AAAvB,GAA+B;;AAC5D;AACF;AACA;AACE,iBAAeN,OAAf,CAAwBO,IAAxB,EAAyC;AAAA,QAAXC,IAAW,uEAAJ,EAAI;;AACvC,QAAI,CAACZ,MAAM,CAACW,IAAP,CAAYA,IAAZ,CAAL,EAAwB;AACtB,YAAM,IAAIE,KAAJ,CAAU,sBAAsBF,IAAhC,CAAN;AACD;;AAED,QAAIX,MAAM,CAACc,QAAP,CAAgBH,IAAhB,CAAJ,EAA2B;AACzB,iBAAW,MAAMI,YAAjB,IAAiCL,IAAI,CAACN,OAAL,CAAaO,IAAb,EAAmBC,IAAnB,CAAjC,EAA2D;AACzDD,QAAAA,IAAI,GAAGI,YAAP;AACD;AACF;;AAED,UAAM,GAAGC,MAAH,EAAWC,IAAX,EAAiB,GAAGC,IAApB,IAA4BP,IAAI,CAACQ,KAAL,CAAW,GAAX,CAAlC,CAXuC,CAWW;;AAClD,UAAMC,IAAI,GAAGR,IAAI,CAACS,OAAL,GAAe,MAAMZ,KAAK,CAACa,OAAN,CAAcV,IAAI,CAACS,OAAnB,CAArB,GAAmDE,SAAhE;AACA,UAAMC,KAAK,GAAGC,UAAU,CAACR,IAAD,CAAxB,CAbuC,CAevC;;AACA,QAAIC,IAAI,CAACQ,MAAL,KAAgB,CAApB,EAAuB;AACrB,YAAMC,GAAG,GAAGP,IAAI,GAAGA,IAAI,CAACQ,OAAL,CAAaC,MAAb,CAAoBL,KAApB,CAAH,GAAgCP,IAAhD;AAEA,aAAQ,IAAGD,MAAO,IAAGW,GAAI,EAAzB;AACD;;AAED,UAAMG,GAAG,GAAG7B,GAAG,CAAC8B,MAAJ,CAAWP,KAAX,CAAZ;AAEAb,IAAAA,IAAI,GAAGO,IAAI,CAACc,IAAL,CAAU,GAAV,CAAP;AAEA,UAAMC,OAAO,GAAG5B,GAAG,CAACyB,GAAD,EAAMnB,IAAN,EAAYH,MAAZ,EAAoBD,IAApB,EAA0BK,IAA1B,CAAnB;AACA,QAAIsB,KAAK,GAAGJ,GAAZ;AACA,QAAIK,aAAa,GAAGxB,IAApB;;AAEA,eAAW,MAAMyB,MAAjB,IAA2BH,OAA3B,EAAoC;AAClC,UAAIhC,GAAG,CAACoC,KAAJ,CAAUD,MAAM,CAACF,KAAjB,CAAJ,EAA6B;AAC3BA,QAAAA,KAAK,GAAGE,MAAM,CAACF,KAAf;AACAC,QAAAA,aAAa,GAAGC,MAAM,CAACD,aAAvB;AACD;AACF;;AAED,WAAQ,SAAQD,KAAK,CAACI,QAAN,CAAelB,IAAI,IAAIA,IAAI,CAACQ,OAA5B,CAAqC,GAAEO,aAAa,GAAG,MAAMA,aAAT,GAAyB,EAAG,EAAhG;AACD;;AAED,SAAOhC,iBAAiB,CAACC,OAAD,CAAxB;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,SAASqB,UAAT,CAAqBE,GAArB,EAA0B;AACxB,MAAI;AACF,WAAOzB,gBAAgB,CAACyB,GAAD,CAAhB,CAAsBY,OAAtB,EAAP;AACD,GAFD,CAEE,MAAM;AACN,WAAOtC,GAAG,CAACuC,KAAJ,CAAUb,GAAV,EAAeH,KAAtB;AACD;AACF","sourcesContent":["import * as isIpfs from 'is-ipfs'\nimport { CID } from 'multiformats/cid'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { resolve as res } from '../utils.js'\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-core-utils/src/multibases').Multibases} config.bases\n * @param {import('ipfs-core-types/src/name').API} config.name\n */\nexport function createResolve ({ repo, codecs, bases, name }) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]}\n   */\n  async function resolve (path, opts = {}) {\n    if (!isIpfs.path(path)) {\n      throw new Error('invalid argument ' + path)\n    }\n\n    if (isIpfs.ipnsPath(path)) {\n      for await (const resolvedPath of name.resolve(path, opts)) {\n        path = resolvedPath\n      }\n    }\n\n    const [, schema, hash, ...rest] = path.split('/') // ['', 'ipfs', 'hash', ...path]\n    const base = opts.cidBase ? await bases.getBase(opts.cidBase) : undefined\n    const bytes = parseBytes(hash)\n\n    // nothing to resolve return the input\n    if (rest.length === 0) {\n      const str = base ? base.encoder.encode(bytes) : hash\n\n      return `/${schema}/${str}`\n    }\n\n    const cid = CID.decode(bytes)\n\n    path = rest.join('/')\n\n    const results = res(cid, path, codecs, repo, opts)\n    let value = cid\n    let remainderPath = path\n\n    for await (const result of results) {\n      if (CID.asCID(result.value)) {\n        value = result.value\n        remainderPath = result.remainderPath\n      }\n    }\n\n    return `/ipfs/${value.toString(base && base.encoder)}${remainderPath ? '/' + remainderPath : ''}`\n  }\n\n  return withTimeoutOption(resolve)\n}\n\n/**\n * Parse the input as a PeerID or a CID or throw an error\n *\n * @param {string} str\n */\nfunction parseBytes (str) {\n  try {\n    return peerIdFromString(str).toBytes()\n  } catch {\n    return CID.parse(str).bytes\n  }\n}\n"]},"metadata":{},"sourceType":"module"}