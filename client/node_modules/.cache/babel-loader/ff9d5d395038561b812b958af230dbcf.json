{"ast":null,"code":"/**\n * This code is based on `latency-monitor` (https://github.com/mlucool/latency-monitor) by `mlucool` (https://github.com/mlucool), available under Apache License 2.0 (https://github.com/mlucool/latency-monitor/blob/master/LICENSE)\n */\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { VisibilityChangeEmitter } from './visibility-change-emitter.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:connection-manager:latency-monitor');\n/**\n * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling\n * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.\n * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.\n *\n * @extends {EventEmitter}\n *\n * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop\n * and timing how long it takes to get back.\n *\n * @example\n * const monitor = new LatencyMonitor();\n * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));\n *\n * @example\n * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});\n * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));\n */\n\nexport class LatencyMonitor extends EventEmitter {\n  constructor() {\n    let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    const {\n      latencyCheckIntervalMs,\n      dataEmitIntervalMs,\n      asyncTestFn,\n      latencyRandomPercentage\n    } = init; // 0 isn't valid here, so its ok to use ||\n\n    this.latencyCheckIntervalMs = latencyCheckIntervalMs ?? 500; // 0.5s\n\n    this.latencyRandomPercentage = latencyRandomPercentage ?? 10;\n    this.latencyCheckMultiply = 2 * (this.latencyRandomPercentage / 100.0) * this.latencyCheckIntervalMs;\n    this.latencyCheckSubtract = this.latencyCheckMultiply / 2;\n    this.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? undefined : dataEmitIntervalMs ?? 5 * 1000; // 5s\n\n    log('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s', this.latencyCheckIntervalMs, this.dataEmitIntervalMs);\n\n    if (this.dataEmitIntervalMs != null) {\n      log('Expecting ~%s events per summary', this.latencyCheckIntervalMs / this.dataEmitIntervalMs);\n    } else {\n      log('Not emitting summaries');\n    }\n\n    this.asyncTestFn = asyncTestFn; // If there is no asyncFn, we measure latency\n    // If process: use high resolution timer\n\n    if (globalThis.process?.hrtime != null) {\n      log('Using process.hrtime for timing');\n      this.now = globalThis.process.hrtime; // eslint-disable-line no-undef\n\n      this.getDeltaMS = startTime => {\n        const hrtime = this.now(startTime);\n        return hrtime[0] * 1000 + hrtime[1] / 1000000;\n      }; // Let's try for a timer that only monotonically increases\n\n    } else if (typeof window !== 'undefined' && window.performance?.now != null) {\n      log('Using performance.now for timing');\n      this.now = window.performance.now.bind(window.performance);\n\n      this.getDeltaMS = startTime => Math.round(this.now() - startTime);\n    } else {\n      log('Using Date.now for timing');\n      this.now = Date.now;\n\n      this.getDeltaMS = startTime => this.now() - startTime;\n    }\n\n    this.latencyData = this.initLatencyData();\n  }\n\n  start() {\n    // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,\n    // so we fall back to another library\n    // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs\n    if (isBrowser()) {\n      this.visibilityChangeEmitter = new VisibilityChangeEmitter();\n      this.visibilityChangeEmitter.addEventListener('visibilityChange', evt => {\n        const {\n          detail: pageInFocus\n        } = evt;\n\n        if (pageInFocus) {\n          this._startTimers();\n        } else {\n          this._emitSummary();\n\n          this._stopTimers();\n        }\n      });\n    }\n\n    if (this.visibilityChangeEmitter?.isVisible() === true) {\n      this._startTimers();\n    }\n  }\n\n  stop() {\n    this._stopTimers();\n  }\n  /**\n   * Start internal timers\n   *\n   * @private\n   */\n\n\n  _startTimers() {\n    // Timer already started, ignore this\n    if (this.checkLatencyID != null) {\n      return;\n    }\n\n    this.checkLatency();\n\n    if (this.dataEmitIntervalMs != null) {\n      this.emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);\n\n      if (typeof this.emitIntervalID.unref === 'function') {\n        this.emitIntervalID.unref(); // Doesn't block exit\n      }\n    }\n  }\n  /**\n   * Stop internal timers\n   *\n   * @private\n   */\n\n\n  _stopTimers() {\n    if (this.checkLatencyID != null) {\n      clearTimeout(this.checkLatencyID);\n      this.checkLatencyID = undefined;\n    }\n\n    if (this.emitIntervalID != null) {\n      clearInterval(this.emitIntervalID);\n      this.emitIntervalID = undefined;\n    }\n  }\n  /**\n   * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show\n   *\n   * @private\n   */\n\n\n  _emitSummary() {\n    const summary = this.getSummary();\n\n    if (summary.events > 0) {\n      this.dispatchEvent(new CustomEvent('data', {\n        detail: summary\n      }));\n    }\n  }\n  /**\n   * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,\n   * it will not count for this time period\n   */\n\n\n  getSummary() {\n    // We might want to adjust for the number of expected events\n    // Example: first 1 event it comes back, then such a long blocker that the next emit check comes\n    // Then this fires - looks like no latency!!\n    const latency = {\n      events: this.latencyData.events,\n      minMs: this.latencyData.minMs,\n      maxMs: this.latencyData.maxMs,\n      avgMs: this.latencyData.events > 0 ? this.latencyData.totalMs / this.latencyData.events : Number.POSITIVE_INFINITY,\n      lengthMs: this.getDeltaMS(this.latencyData.startTime)\n    };\n    this.latencyData = this.initLatencyData(); // Clear\n\n    log.trace('Summary: %O', latency);\n    return latency;\n  }\n  /**\n   * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,\n   * it will simply report on event loop latency.\n   */\n\n\n  checkLatency() {\n    // Randomness is needed to avoid alignment by accident to regular things in the event loop\n    const randomness = Math.random() * this.latencyCheckMultiply - this.latencyCheckSubtract; // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset\n\n    const localData = {\n      deltaOffset: Math.ceil(this.latencyCheckIntervalMs + randomness),\n      startTime: this.now()\n    };\n\n    const cb = () => {\n      // We are already stopped, ignore this datapoint\n      if (this.checkLatencyID == null) {\n        return;\n      }\n\n      const deltaMS = this.getDeltaMS(localData.startTime) - localData.deltaOffset;\n      this.checkLatency(); // Start again ASAP\n      // Add the data point. If this gets complex, refactor it\n\n      this.latencyData.events++;\n      this.latencyData.minMs = Math.min(this.latencyData.minMs, deltaMS);\n      this.latencyData.maxMs = Math.max(this.latencyData.maxMs, deltaMS);\n      this.latencyData.totalMs += deltaMS;\n      log.trace('MS: %s Data: %O', deltaMS, this.latencyData);\n    };\n\n    log.trace('localData: %O', localData);\n    this.checkLatencyID = setTimeout(() => {\n      // This gets rid of including event loop\n      if (this.asyncTestFn != null) {\n        // Clear timing related things\n        localData.deltaOffset = 0;\n        localData.startTime = this.now();\n        this.asyncTestFn(cb);\n      } else {\n        // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.\n        // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.\n        localData.deltaOffset -= 1; // If there is no function to test, we mean check latency which is a special case that is really cb => cb()\n        // We avoid that for the few extra function all overheads. Also, we want to keep the timers different\n\n        cb();\n      }\n    }, localData.deltaOffset);\n\n    if (typeof this.checkLatencyID.unref === 'function') {\n      this.checkLatencyID.unref(); // Doesn't block exit\n    }\n  }\n\n  initLatencyData() {\n    return {\n      startTime: this.now(),\n      minMs: Number.POSITIVE_INFINITY,\n      maxMs: Number.NEGATIVE_INFINITY,\n      events: 0,\n      totalMs: 0\n    };\n  }\n\n}\n\nfunction isBrowser() {\n  return typeof globalThis.window !== 'undefined';\n}","map":{"version":3,"mappings":"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","names":["CustomEvent","EventEmitter","VisibilityChangeEmitter","logger","log","LatencyMonitor","constructor","init","latencyCheckIntervalMs","dataEmitIntervalMs","asyncTestFn","latencyRandomPercentage","latencyCheckMultiply","latencyCheckSubtract","undefined","globalThis","process","hrtime","now","getDeltaMS","startTime","window","performance","bind","Math","round","Date","latencyData","initLatencyData","start","isBrowser","visibilityChangeEmitter","addEventListener","evt","detail","pageInFocus","_startTimers","_emitSummary","_stopTimers","isVisible","stop","checkLatencyID","checkLatency","emitIntervalID","setInterval","unref","clearTimeout","clearInterval","summary","getSummary","events","dispatchEvent","latency","minMs","maxMs","avgMs","totalMs","Number","POSITIVE_INFINITY","lengthMs","trace","randomness","random","localData","deltaOffset","ceil","cb","deltaMS","min","max","setTimeout","NEGATIVE_INFINITY"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\connection-manager\\latency-monitor.ts"],"sourcesContent":["/**\n * This code is based on `latency-monitor` (https://github.com/mlucool/latency-monitor) by `mlucool` (https://github.com/mlucool), available under Apache License 2.0 (https://github.com/mlucool/latency-monitor/blob/master/LICENSE)\n */\n\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events'\nimport { VisibilityChangeEmitter } from './visibility-change-emitter.js'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('libp2p:connection-manager:latency-monitor')\n\nexport interface LatencyMonitorEvents {\n  'data': CustomEvent<SummaryObject>\n}\n\nexport interface LatencyMonitorInit {\n  /**\n   * How often to add a latency check event (ms)\n   */\n  latencyCheckIntervalMs?: number\n\n  /**\n   * How often to summarize latency check events. null or 0 disables event firing\n   */\n  dataEmitIntervalMs?: number\n\n  /**\n   * What cb-style async function to use\n   */\n  asyncTestFn?: (cb: () => void) => void\n\n  /**\n   * What percent (+/-) of latencyCheckIntervalMs should we randomly use? This helps avoid alignment to other events.\n   */\n  latencyRandomPercentage?: number\n}\n\nexport interface SummaryObject {\n  /**\n   * How many events were called\n   */\n  events: number\n\n  /**\n   * What was the min time for a cb to be called\n   */\n  minMs: number\n\n  /**\n   * What was the max time for a cb to be called\n   */\n  maxMs: number\n\n  /**\n   * What was the average time for a cb to be called\n   */\n  avgMs: number\n\n  /**\n   * How long this interval was in ms\n   */\n  lengthMs: number\n}\n\ninterface LatencyData {\n  startTime: number\n  events: number\n  minMs: number\n  maxMs: number\n  totalMs: number\n}\n\n/**\n * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling\n * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.\n * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.\n *\n * @extends {EventEmitter}\n *\n * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop\n * and timing how long it takes to get back.\n *\n * @example\n * const monitor = new LatencyMonitor();\n * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));\n *\n * @example\n * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});\n * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));\n */\nexport class LatencyMonitor extends EventEmitter<LatencyMonitorEvents> {\n  private readonly latencyCheckIntervalMs: number\n  private readonly latencyRandomPercentage: number\n  private readonly latencyCheckMultiply: number\n  private readonly latencyCheckSubtract: number\n  private readonly dataEmitIntervalMs?: number\n  private readonly asyncTestFn?: (cb: () => void) => void\n\n  private readonly now: (num?: any) => any\n  private readonly getDeltaMS: (num: number) => number\n  private visibilityChangeEmitter?: VisibilityChangeEmitter\n  private latencyData: LatencyData\n  private checkLatencyID?: NodeJS.Timeout\n  private emitIntervalID?: NodeJS.Timeout\n\n  constructor (init: LatencyMonitorInit = {}) {\n    super()\n\n    const { latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage } = init\n\n    // 0 isn't valid here, so its ok to use ||\n    this.latencyCheckIntervalMs = latencyCheckIntervalMs ?? 500 // 0.5s\n    this.latencyRandomPercentage = latencyRandomPercentage ?? 10\n    this.latencyCheckMultiply = 2 * (this.latencyRandomPercentage / 100.0) * this.latencyCheckIntervalMs\n    this.latencyCheckSubtract = this.latencyCheckMultiply / 2\n\n    this.dataEmitIntervalMs = (dataEmitIntervalMs === null || dataEmitIntervalMs === 0)\n      ? undefined\n      : dataEmitIntervalMs ?? 5 * 1000 // 5s\n    log('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s',\n      this.latencyCheckIntervalMs, this.dataEmitIntervalMs)\n    if (this.dataEmitIntervalMs != null) {\n      log('Expecting ~%s events per summary', this.latencyCheckIntervalMs / this.dataEmitIntervalMs)\n    } else {\n      log('Not emitting summaries')\n    }\n\n    this.asyncTestFn = asyncTestFn // If there is no asyncFn, we measure latency\n\n    // If process: use high resolution timer\n    if (globalThis.process?.hrtime != null) {\n      log('Using process.hrtime for timing')\n      this.now = globalThis.process.hrtime // eslint-disable-line no-undef\n      this.getDeltaMS = (startTime) => {\n        const hrtime = this.now(startTime)\n        return (hrtime[0] * 1000) + (hrtime[1] / 1000000)\n      }\n      // Let's try for a timer that only monotonically increases\n    } else if (typeof window !== 'undefined' && window.performance?.now != null) {\n      log('Using performance.now for timing')\n      this.now = window.performance.now.bind(window.performance)\n      this.getDeltaMS = (startTime) => Math.round(this.now() - startTime)\n    } else {\n      log('Using Date.now for timing')\n      this.now = Date.now\n      this.getDeltaMS = (startTime) => this.now() - startTime\n    }\n\n    this.latencyData = this.initLatencyData()\n  }\n\n  start () {\n    // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,\n    // so we fall back to another library\n    // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs\n    if (isBrowser()) {\n      this.visibilityChangeEmitter = new VisibilityChangeEmitter()\n\n      this.visibilityChangeEmitter.addEventListener('visibilityChange', (evt) => {\n        const { detail: pageInFocus } = evt\n\n        if (pageInFocus) {\n          this._startTimers()\n        } else {\n          this._emitSummary()\n          this._stopTimers()\n        }\n      })\n    }\n\n    if (this.visibilityChangeEmitter?.isVisible() === true) {\n      this._startTimers()\n    }\n  }\n\n  stop () {\n    this._stopTimers()\n  }\n\n  /**\n   * Start internal timers\n   *\n   * @private\n   */\n  _startTimers () {\n    // Timer already started, ignore this\n    if (this.checkLatencyID != null) {\n      return\n    }\n\n    this.checkLatency()\n\n    if (this.dataEmitIntervalMs != null) {\n      this.emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs)\n      if (typeof this.emitIntervalID.unref === 'function') {\n        this.emitIntervalID.unref() // Doesn't block exit\n      }\n    }\n  }\n\n  /**\n   * Stop internal timers\n   *\n   * @private\n   */\n  _stopTimers () {\n    if (this.checkLatencyID != null) {\n      clearTimeout(this.checkLatencyID)\n      this.checkLatencyID = undefined\n    }\n    if (this.emitIntervalID != null) {\n      clearInterval(this.emitIntervalID)\n      this.emitIntervalID = undefined\n    }\n  }\n\n  /**\n   * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show\n   *\n   * @private\n   */\n  _emitSummary () {\n    const summary = this.getSummary()\n    if (summary.events > 0) {\n      this.dispatchEvent(new CustomEvent<SummaryObject>('data', {\n        detail: summary\n      }))\n    }\n  }\n\n  /**\n   * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,\n   * it will not count for this time period\n   */\n  getSummary (): SummaryObject {\n    // We might want to adjust for the number of expected events\n    // Example: first 1 event it comes back, then such a long blocker that the next emit check comes\n    // Then this fires - looks like no latency!!\n    const latency = {\n      events: this.latencyData.events,\n      minMs: this.latencyData.minMs,\n      maxMs: this.latencyData.maxMs,\n      avgMs: this.latencyData.events > 0\n        ? this.latencyData.totalMs / this.latencyData.events\n        : Number.POSITIVE_INFINITY,\n      lengthMs: this.getDeltaMS(this.latencyData.startTime)\n    }\n    this.latencyData = this.initLatencyData() // Clear\n\n    log.trace('Summary: %O', latency)\n    return latency\n  }\n\n  /**\n   * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,\n   * it will simply report on event loop latency.\n   */\n  checkLatency () {\n    // Randomness is needed to avoid alignment by accident to regular things in the event loop\n    const randomness = (Math.random() * this.latencyCheckMultiply) - this.latencyCheckSubtract\n\n    // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset\n    const localData = {\n      deltaOffset: Math.ceil(this.latencyCheckIntervalMs + randomness),\n      startTime: this.now()\n    }\n\n    const cb = () => {\n      // We are already stopped, ignore this datapoint\n      if (this.checkLatencyID == null) {\n        return\n      }\n      const deltaMS = this.getDeltaMS(localData.startTime) - localData.deltaOffset\n      this.checkLatency() // Start again ASAP\n\n      // Add the data point. If this gets complex, refactor it\n      this.latencyData.events++\n      this.latencyData.minMs = Math.min(this.latencyData.minMs, deltaMS)\n      this.latencyData.maxMs = Math.max(this.latencyData.maxMs, deltaMS)\n      this.latencyData.totalMs += deltaMS\n      log.trace('MS: %s Data: %O', deltaMS, this.latencyData)\n    }\n    log.trace('localData: %O', localData)\n\n    this.checkLatencyID = setTimeout(() => {\n      // This gets rid of including event loop\n      if (this.asyncTestFn != null) {\n        // Clear timing related things\n        localData.deltaOffset = 0\n        localData.startTime = this.now()\n        this.asyncTestFn(cb)\n      } else {\n        // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.\n        // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.\n        localData.deltaOffset -= 1\n        // If there is no function to test, we mean check latency which is a special case that is really cb => cb()\n        // We avoid that for the few extra function all overheads. Also, we want to keep the timers different\n        cb()\n      }\n    }, localData.deltaOffset)\n\n    if (typeof this.checkLatencyID.unref === 'function') {\n      this.checkLatencyID.unref() // Doesn't block exit\n    }\n  }\n\n  initLatencyData (): LatencyData {\n    return {\n      startTime: this.now(),\n      minMs: Number.POSITIVE_INFINITY,\n      maxMs: Number.NEGATIVE_INFINITY,\n      events: 0,\n      totalMs: 0\n    }\n  }\n}\n\nfunction isBrowser () {\n  return typeof globalThis.window !== 'undefined'\n}\n"]},"metadata":{},"sourceType":"module"}