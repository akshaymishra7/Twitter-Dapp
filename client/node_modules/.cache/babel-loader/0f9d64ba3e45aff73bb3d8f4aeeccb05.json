{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\nimport { normaliseInput } from 'ipfs-core-utils/pins/normalise-input';\nimport { resolvePath } from '../../utils.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport errCode from 'err-code';\nimport { PinTypes } from 'ipfs-repo/pin-types';\n/**\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @param {string} type\n * @param {CID} cid\n * @param {Record<string, any>} [metadata]\n */\n\nfunction toPin(type, cid, metadata) {\n  /** @type {import('ipfs-core-types/src/pin').LsResult} */\n  const output = {\n    type,\n    cid\n  };\n\n  if (metadata) {\n    output.metadata = metadata;\n  }\n\n  return output;\n}\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n */\n\n\nexport function createLs(_ref) {\n  let {\n    repo,\n    codecs\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/pin').API<{}>[\"ls\"]}\n   */\n  async function* ls() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /** @type {import('ipfs-core-types/src/pin').PinQueryType} */\n    let type = PinTypes.all;\n\n    if (options.type) {\n      type = options.type;\n\n      if (!Object.keys(PinTypes).includes(type)) {\n        throw errCode(new Error('Invalid pin type'), 'ERR_INVALID_PIN_TYPE');\n      }\n    }\n\n    if (options.paths) {\n      // check the pinned state of specific hashes\n      let matched = false;\n\n      for await (const {\n        path\n      } of normaliseInput(options.paths)) {\n        const {\n          cid\n        } = await resolvePath(repo, codecs, path);\n        const {\n          reason,\n          pinned,\n          parent,\n          metadata\n        } = await repo.pins.isPinnedWithType(cid, type);\n\n        if (!pinned) {\n          throw errCode(new Error(`path '${path}' is not pinned`), 'ERR_NOT_PINNED');\n        }\n\n        switch (reason) {\n          case PinTypes.direct:\n          case PinTypes.recursive:\n            matched = true;\n            yield toPin(reason, cid, metadata);\n            break;\n\n          default:\n            matched = true;\n            yield toPin(`${PinTypes.indirect} through ${parent}`, cid, metadata);\n        }\n      }\n\n      if (!matched) {\n        throw new Error('No match found');\n      }\n\n      return;\n    }\n\n    if (type === PinTypes.recursive || type === PinTypes.all) {\n      for await (const {\n        cid,\n        metadata\n      } of repo.pins.recursiveKeys()) {\n        yield toPin(PinTypes.recursive, cid, metadata);\n      }\n    }\n\n    if (type === PinTypes.indirect || type === PinTypes.all) {\n      for await (const cid of repo.pins.indirectKeys(options)) {\n        yield toPin(PinTypes.indirect, cid);\n      }\n    }\n\n    if (type === PinTypes.direct || type === PinTypes.all) {\n      for await (const {\n        cid,\n        metadata\n      } of repo.pins.directKeys()) {\n        yield toPin(PinTypes.direct, cid, metadata);\n      }\n    }\n  }\n\n  return withTimeoutOption(ls);\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/pin/ls.js"],"names":["normaliseInput","resolvePath","withTimeoutOption","errCode","PinTypes","toPin","type","cid","metadata","output","createLs","repo","codecs","ls","options","all","Object","keys","includes","Error","paths","matched","path","reason","pinned","parent","pins","isPinnedWithType","direct","recursive","indirect","recursiveKeys","indirectKeys","directKeys"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n\nimport { normaliseInput } from 'ipfs-core-utils/pins/normalise-input'\nimport { resolvePath } from '../../utils.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport errCode from 'err-code'\nimport { PinTypes } from 'ipfs-repo/pin-types'\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @param {string} type\n * @param {CID} cid\n * @param {Record<string, any>} [metadata]\n */\nfunction toPin (type, cid, metadata) {\n  /** @type {import('ipfs-core-types/src/pin').LsResult} */\n  const output = {\n    type,\n    cid\n  }\n\n  if (metadata) {\n    output.metadata = metadata\n  }\n\n  return output\n}\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n */\nexport function createLs ({ repo, codecs }) {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API<{}>[\"ls\"]}\n   */\n  async function * ls (options = {}) {\n    /** @type {import('ipfs-core-types/src/pin').PinQueryType} */\n    let type = PinTypes.all\n\n    if (options.type) {\n      type = options.type\n\n      if (!Object.keys(PinTypes).includes(type)) {\n        throw errCode(new Error('Invalid pin type'), 'ERR_INVALID_PIN_TYPE')\n      }\n    }\n\n    if (options.paths) {\n      // check the pinned state of specific hashes\n      let matched = false\n\n      for await (const { path } of normaliseInput(options.paths)) {\n        const { cid } = await resolvePath(repo, codecs, path)\n        const { reason, pinned, parent, metadata } = await repo.pins.isPinnedWithType(cid, type)\n\n        if (!pinned) {\n          throw errCode(new Error(`path '${path}' is not pinned`), 'ERR_NOT_PINNED')\n        }\n\n        switch (reason) {\n          case PinTypes.direct:\n          case PinTypes.recursive:\n            matched = true\n            yield toPin(reason, cid, metadata)\n            break\n          default:\n            matched = true\n            yield toPin(`${PinTypes.indirect} through ${parent}`, cid, metadata)\n        }\n      }\n\n      if (!matched) {\n        throw new Error('No match found')\n      }\n\n      return\n    }\n\n    if (type === PinTypes.recursive || type === PinTypes.all) {\n      for await (const { cid, metadata } of repo.pins.recursiveKeys()) {\n        yield toPin(PinTypes.recursive, cid, metadata)\n      }\n    }\n\n    if (type === PinTypes.indirect || type === PinTypes.all) {\n      for await (const cid of repo.pins.indirectKeys(options)) {\n        yield toPin(PinTypes.indirect, cid)\n      }\n    }\n\n    if (type === PinTypes.direct || type === PinTypes.all) {\n      for await (const { cid, metadata } of repo.pins.directKeys()) {\n        yield toPin(PinTypes.direct, cid, metadata)\n      }\n    }\n  }\n\n  return withTimeoutOption(ls)\n}\n"]},"metadata":{},"sourceType":"module"}