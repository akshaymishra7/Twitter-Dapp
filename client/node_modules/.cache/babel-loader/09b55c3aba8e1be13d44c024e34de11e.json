{"ast":null,"code":"import { concat } from 'uint8arrays/concat';\nimport { fromString } from 'uint8arrays/from-string';\nimport webcrypto from '../webcrypto.js'; // WebKit on Linux does not support deriving a key from an empty PBKDF2 key.\n// So, as a workaround, we provide the generated key as a constant. We test that\n// this generated key is accurate in test/workaround.spec.ts\n// Generated via:\n// await crypto.subtle.exportKey('jwk',\n//   await crypto.subtle.deriveKey(\n//     { name: 'PBKDF2', salt: new Uint8Array(16), iterations: 32767, hash: { name: 'SHA-256' } },\n//     await crypto.subtle.importKey('raw', new Uint8Array(0), { name: 'PBKDF2' }, false, ['deriveKey']),\n//     { name: 'AES-GCM', length: 128 }, true, ['encrypt', 'decrypt'])\n// )\n\nexport const derivedEmptyPasswordKey = {\n  alg: 'A128GCM',\n  ext: true,\n  k: 'scm9jmO_4BJAgdwWGVulLg',\n  key_ops: ['encrypt', 'decrypt'],\n  kty: 'oct'\n}; // Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\n\nexport function create(opts) {\n  const algorithm = opts?.algorithm ?? 'AES-GCM';\n  let keyLength = opts?.keyLength ?? 16;\n  const nonceLength = opts?.nonceLength ?? 12;\n  const digest = opts?.digest ?? 'SHA-256';\n  const saltLength = opts?.saltLength ?? 16;\n  const iterations = opts?.iterations ?? 32767;\n  const crypto = webcrypto.get();\n  keyLength *= 8; // Browser crypto uses bits instead of bytes\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to encrypt the data.\n   */\n\n  async function encrypt(data, password) {\n    const salt = crypto.getRandomValues(new Uint8Array(saltLength));\n    const nonce = crypto.getRandomValues(new Uint8Array(nonceLength));\n    const aesGcm = {\n      name: algorithm,\n      iv: nonce\n    };\n\n    if (typeof password === 'string') {\n      password = fromString(password);\n    }\n\n    let cryptoKey;\n\n    if (password.length === 0) {\n      cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, {\n        name: 'AES-GCM'\n      }, true, ['encrypt']);\n\n      try {\n        const deriveParams = {\n          name: 'PBKDF2',\n          salt,\n          iterations,\n          hash: {\n            name: digest\n          }\n        };\n        const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, {\n          name: 'PBKDF2'\n        }, false, ['deriveKey']);\n        cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, {\n          name: algorithm,\n          length: keyLength\n        }, true, ['encrypt']);\n      } catch {\n        cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, {\n          name: 'AES-GCM'\n        }, true, ['encrypt']);\n      }\n    } else {\n      // Derive a key using PBKDF2.\n      const deriveParams = {\n        name: 'PBKDF2',\n        salt,\n        iterations,\n        hash: {\n          name: digest\n        }\n      };\n      const rawKey = await crypto.subtle.importKey('raw', password, {\n        name: 'PBKDF2'\n      }, false, ['deriveKey']);\n      cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, {\n        name: algorithm,\n        length: keyLength\n      }, true, ['encrypt']);\n    } // Encrypt the string.\n\n\n    const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data);\n    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);\n  }\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to decrypt the data. The options used to create\n   * this decryption cipher must be the same as those used to create\n   * the encryption cipher.\n   */\n\n\n  async function decrypt(data, password) {\n    const salt = data.subarray(0, saltLength);\n    const nonce = data.subarray(saltLength, saltLength + nonceLength);\n    const ciphertext = data.subarray(saltLength + nonceLength);\n    const aesGcm = {\n      name: algorithm,\n      iv: nonce\n    };\n\n    if (typeof password === 'string') {\n      password = fromString(password);\n    }\n\n    let cryptoKey;\n\n    if (password.length === 0) {\n      try {\n        const deriveParams = {\n          name: 'PBKDF2',\n          salt,\n          iterations,\n          hash: {\n            name: digest\n          }\n        };\n        const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, {\n          name: 'PBKDF2'\n        }, false, ['deriveKey']);\n        cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, {\n          name: algorithm,\n          length: keyLength\n        }, true, ['decrypt']);\n      } catch {\n        cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, {\n          name: 'AES-GCM'\n        }, true, ['decrypt']);\n      }\n    } else {\n      // Derive the key using PBKDF2.\n      const deriveParams = {\n        name: 'PBKDF2',\n        salt,\n        iterations,\n        hash: {\n          name: digest\n        }\n      };\n      const rawKey = await crypto.subtle.importKey('raw', password, {\n        name: 'PBKDF2'\n      }, false, ['deriveKey']);\n      cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, {\n        name: algorithm,\n        length: keyLength\n      }, true, ['decrypt']);\n    } // Decrypt the string.\n\n\n    const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext);\n    return new Uint8Array(plaintext);\n  }\n\n  const cipher = {\n    encrypt,\n    decrypt\n  };\n  return cipher;\n}","map":{"version":3,"mappings":"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","names":["concat","fromString","webcrypto","derivedEmptyPasswordKey","alg","ext","k","key_ops","kty","create","opts","algorithm","keyLength","nonceLength","digest","saltLength","iterations","crypto","get","encrypt","data","password","salt","getRandomValues","Uint8Array","nonce","aesGcm","name","iv","cryptoKey","length","subtle","importKey","deriveParams","hash","runtimeDerivedEmptyPassword","deriveKey","rawKey","ciphertext","decrypt","subarray","plaintext","cipher"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\crypto\\src\\ciphers\\aes-gcm.browser.ts"],"sourcesContent":["import { concat } from 'uint8arrays/concat'\nimport { fromString } from 'uint8arrays/from-string'\nimport webcrypto from '../webcrypto.js'\nimport type { CreateOptions, AESCipher } from './interface.js'\n\n// WebKit on Linux does not support deriving a key from an empty PBKDF2 key.\n// So, as a workaround, we provide the generated key as a constant. We test that\n// this generated key is accurate in test/workaround.spec.ts\n// Generated via:\n// await crypto.subtle.exportKey('jwk',\n//   await crypto.subtle.deriveKey(\n//     { name: 'PBKDF2', salt: new Uint8Array(16), iterations: 32767, hash: { name: 'SHA-256' } },\n//     await crypto.subtle.importKey('raw', new Uint8Array(0), { name: 'PBKDF2' }, false, ['deriveKey']),\n//     { name: 'AES-GCM', length: 128 }, true, ['encrypt', 'decrypt'])\n// )\nexport const derivedEmptyPasswordKey = { alg: 'A128GCM', ext: true, k: 'scm9jmO_4BJAgdwWGVulLg', key_ops: ['encrypt', 'decrypt'], kty: 'oct' }\n\n// Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\n\nexport function create (opts?: CreateOptions): AESCipher {\n  const algorithm = opts?.algorithm ?? 'AES-GCM'\n  let keyLength = opts?.keyLength ?? 16\n  const nonceLength = opts?.nonceLength ?? 12\n  const digest = opts?.digest ?? 'SHA-256'\n  const saltLength = opts?.saltLength ?? 16\n  const iterations = opts?.iterations ?? 32767\n\n  const crypto = webcrypto.get()\n  keyLength *= 8 // Browser crypto uses bits instead of bytes\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to encrypt the data.\n   */\n  async function encrypt (data: Uint8Array, password: string | Uint8Array): Promise<Uint8Array> { // eslint-disable-line require-await\n    const salt = crypto.getRandomValues(new Uint8Array(saltLength))\n    const nonce = crypto.getRandomValues(new Uint8Array(nonceLength))\n    const aesGcm = { name: algorithm, iv: nonce }\n\n    if (typeof password === 'string') {\n      password = fromString(password)\n    }\n\n    let cryptoKey: CryptoKey\n    if (password.length === 0) {\n      cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['encrypt'])\n      try {\n        const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n        const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey'])\n        cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ['encrypt'])\n      } catch {\n        cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['encrypt'])\n      }\n    } else {\n      // Derive a key using PBKDF2.\n      const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n      const rawKey = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey'])\n      cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['encrypt'])\n    }\n\n    // Encrypt the string.\n    const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data)\n    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)])\n  }\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to decrypt the data. The options used to create\n   * this decryption cipher must be the same as those used to create\n   * the encryption cipher.\n   */\n  async function decrypt (data: Uint8Array, password: string | Uint8Array): Promise<Uint8Array> {\n    const salt = data.subarray(0, saltLength)\n    const nonce = data.subarray(saltLength, saltLength + nonceLength)\n    const ciphertext = data.subarray(saltLength + nonceLength)\n    const aesGcm = { name: algorithm, iv: nonce }\n\n    if (typeof password === 'string') {\n      password = fromString(password)\n    }\n\n    let cryptoKey: CryptoKey\n    if (password.length === 0) {\n      try {\n        const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n        const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey'])\n        cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ['decrypt'])\n      } catch {\n        cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['decrypt'])\n      }\n    } else {\n      // Derive the key using PBKDF2.\n      const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n      const rawKey = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey'])\n      cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['decrypt'])\n    }\n\n    // Decrypt the string.\n    const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext)\n    return new Uint8Array(plaintext)\n  }\n\n  const cipher: AESCipher = {\n    encrypt,\n    decrypt\n  }\n\n  return cipher\n}\n"]},"metadata":{},"sourceType":"module"}