{"ast":null,"code":"import * as ipns from 'ipns';\nimport { importKey } from '@libp2p/crypto/keys';\nimport { isPeerId } from '@libp2p/interface-peer-id';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { TimeoutController } from 'timeout-abort-controller';\nconst log = logger('ipfs:ipns:republisher');\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst minute = 60 * 1000;\nconst hour = 60 * minute;\nconst defaultBroadcastInterval = 4 * hour;\nconst defaultRecordLifetime = 24 * hour;\nexport class IpnsRepublisher {\n  /**\n   * @param {import('./publisher').IpnsPublisher} publisher\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor(publisher, datastore, peerId, keychain) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      pass: ''\n    };\n    this._publisher = publisher;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._keychain = keychain;\n    this._options = options;\n    this._republishHandle = null;\n  }\n\n  async start() {\n    // eslint-disable-line require-await\n    if (this._republishHandle) {\n      throw errcode(new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING');\n    } // TODO: this handler should be isolated in another module\n\n\n    const republishHandle = {\n      /** @type {null|(() => Promise<void>)} */\n      _task: null,\n\n      /** @type {null|Promise<void>} */\n      _inflightTask: null,\n\n      /** @type {null|NodeJS.Timeout} */\n      _timeoutId: null,\n\n      /**\n       * @param {function(): number} period\n       */\n      runPeriodically: period => {\n        republishHandle._timeoutId = setTimeout(async () => {\n          republishHandle._timeoutId = null;\n\n          try {\n            // @ts-expect-error - _task could be null\n            republishHandle._inflightTask = republishHandle._task();\n            await republishHandle._inflightTask; // Schedule next\n\n            if (republishHandle._task) {\n              republishHandle.runPeriodically(period);\n            }\n          } catch (\n          /** @type {any} */\n          err) {\n            log.error(err);\n          }\n        }, period());\n      },\n      cancel: async () => {\n        // do not run again\n        if (republishHandle._timeoutId != null) {\n          clearTimeout(republishHandle._timeoutId);\n        }\n\n        republishHandle._task = null; // wait for the currently in flight task to complete\n\n        await republishHandle._inflightTask;\n      }\n    };\n    const {\n      pass\n    } = this._options;\n    let firstRun = true;\n\n    republishHandle._task = async () => {\n      const timeoutController = new TimeoutController(30000);\n\n      try {\n        await this._republishEntries(this._peerId, pass, {\n          signal: timeoutController.signal\n        });\n      } finally {\n        timeoutController.clear();\n      }\n    };\n\n    republishHandle.runPeriodically(() => {\n      if (firstRun) {\n        firstRun = false;\n        return this._options.initialBroadcastInterval || minute;\n      }\n\n      return this._options.broadcastInterval || defaultBroadcastInterval;\n    });\n    this._republishHandle = republishHandle;\n  }\n\n  async stop() {\n    const republishHandle = this._republishHandle;\n\n    if (!republishHandle) {\n      throw errcode(new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING');\n    }\n\n    this._republishHandle = null;\n    await republishHandle.cancel();\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {string} pass\n   * @param {AbortOptions} options\n   */\n\n\n  async _republishEntries(peerId, pass, options) {\n    // TODO: Should use list of published entries.\n    // We can't currently *do* that because go uses this method for now.\n    try {\n      await this._republishEntry(peerId, options);\n    } catch (\n    /** @type {any} */\n    err) {\n      const errMsg = 'cannot republish entry for the node\\'s private key';\n      log.error(errMsg);\n      return;\n    } // keychain needs pass to get the cryptographic keys\n\n\n    if (pass) {\n      try {\n        const keys = await this._keychain.listKeys();\n\n        for (const key of keys) {\n          if (key.name === 'self') {\n            continue;\n          }\n\n          const pem = await this._keychain.exportKey(key.name, pass);\n          const privKey = await importKey(pem, pass);\n          const peerIdKey = await peerIdFromKeys(privKey.public.bytes, privKey.bytes);\n          await this._republishEntry(peerIdKey, options);\n        }\n      } catch (\n      /** @type {any} */\n      err) {\n        log.error(err);\n      }\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {AbortOptions} options\n   */\n\n\n  async _republishEntry(peerId, options) {\n    try {\n      const value = await this._getPreviousValue(peerId);\n      await this._publisher.publishWithEOL(peerId, value, defaultRecordLifetime, options);\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code === 'ERR_NO_ENTRY_FOUND') {\n        return;\n      }\n\n      throw err;\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async _getPreviousValue(peerId) {\n    if (!isPeerId(peerId)) {\n      throw errcode(new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID');\n    }\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.toBytes()));\n\n      if (!(dsVal instanceof Uint8Array)) {\n        throw errcode(new Error(\"found ipns record that we couldn't process\"), 'ERR_INVALID_IPNS_RECORD');\n      } // unmarshal data\n\n\n      try {\n        const record = ipns.unmarshal(dsVal);\n        return record.value;\n      } catch (\n      /** @type {any} */\n      err) {\n        log.error(err);\n        throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD');\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      // error handling\n      // no need to republish\n      if (err && err.notFound) {\n        throw errcode(new Error(`no previous entry for record with id: ${peerId.toString()}`), 'ERR_NO_ENTRY_FOUND');\n      }\n\n      throw err;\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/ipns/republisher.js"],"names":["ipns","importKey","isPeerId","errcode","logger","peerIdFromKeys","TimeoutController","log","minute","hour","defaultBroadcastInterval","defaultRecordLifetime","IpnsRepublisher","constructor","publisher","datastore","peerId","keychain","options","pass","_publisher","_datastore","_peerId","_keychain","_options","_republishHandle","start","Error","republishHandle","_task","_inflightTask","_timeoutId","runPeriodically","period","setTimeout","err","error","cancel","clearTimeout","firstRun","timeoutController","_republishEntries","signal","clear","initialBroadcastInterval","broadcastInterval","stop","_republishEntry","errMsg","keys","listKeys","key","name","pem","exportKey","privKey","peerIdKey","public","bytes","value","_getPreviousValue","publishWithEOL","code","dsVal","get","getLocalKey","toBytes","Uint8Array","record","unmarshal","notFound","toString"],"mappings":"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","sourcesContent":["import * as ipns from 'ipns'\nimport { importKey } from '@libp2p/crypto/keys'\nimport { isPeerId } from '@libp2p/interface-peer-id'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { TimeoutController } from 'timeout-abort-controller'\n\nconst log = logger('ipfs:ipns:republisher')\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst minute = 60 * 1000\nconst hour = 60 * minute\n\nconst defaultBroadcastInterval = 4 * hour\nconst defaultRecordLifetime = 24 * hour\n\nexport class IpnsRepublisher {\n  /**\n   * @param {import('./publisher').IpnsPublisher} publisher\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor (publisher, datastore, peerId, keychain, options = { pass: '' }) {\n    this._publisher = publisher\n    this._datastore = datastore\n    this._peerId = peerId\n    this._keychain = keychain\n    this._options = options\n    this._republishHandle = null\n  }\n\n  async start () { // eslint-disable-line require-await\n    if (this._republishHandle) {\n      throw errcode(new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING')\n    }\n\n    // TODO: this handler should be isolated in another module\n    const republishHandle = {\n      /** @type {null|(() => Promise<void>)} */\n      _task: null,\n      /** @type {null|Promise<void>} */\n      _inflightTask: null,\n      /** @type {null|NodeJS.Timeout} */\n      _timeoutId: null,\n      /**\n       * @param {function(): number} period\n       */\n      runPeriodically: (period) => {\n        republishHandle._timeoutId = setTimeout(async () => {\n          republishHandle._timeoutId = null\n\n          try {\n            // @ts-expect-error - _task could be null\n            republishHandle._inflightTask = republishHandle._task()\n            await republishHandle._inflightTask\n\n            // Schedule next\n            if (republishHandle._task) {\n              republishHandle.runPeriodically(period)\n            }\n          } catch (/** @type {any} */ err) {\n            log.error(err)\n          }\n        }, period())\n      },\n      cancel: async () => {\n        // do not run again\n        if (republishHandle._timeoutId != null) {\n          clearTimeout(republishHandle._timeoutId)\n        }\n        republishHandle._task = null\n\n        // wait for the currently in flight task to complete\n        await republishHandle._inflightTask\n      }\n    }\n\n    const { pass } = this._options\n    let firstRun = true\n\n    republishHandle._task = async () => {\n      const timeoutController = new TimeoutController(30000)\n\n      try {\n        await this._republishEntries(this._peerId, pass, {\n          signal: timeoutController.signal\n        })\n      } finally {\n        timeoutController.clear()\n      }\n    }\n\n    republishHandle.runPeriodically(() => {\n      if (firstRun) {\n        firstRun = false\n        return this._options.initialBroadcastInterval || minute\n      }\n\n      return this._options.broadcastInterval || defaultBroadcastInterval\n    })\n\n    this._republishHandle = republishHandle\n  }\n\n  async stop () {\n    const republishHandle = this._republishHandle\n\n    if (!republishHandle) {\n      throw errcode(new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING')\n    }\n\n    this._republishHandle = null\n\n    await republishHandle.cancel()\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {string} pass\n   * @param {AbortOptions} options\n   */\n  async _republishEntries (peerId, pass, options) {\n    // TODO: Should use list of published entries.\n    // We can't currently *do* that because go uses this method for now.\n    try {\n      await this._republishEntry(peerId, options)\n    } catch (/** @type {any} */ err) {\n      const errMsg = 'cannot republish entry for the node\\'s private key'\n\n      log.error(errMsg)\n      return\n    }\n\n    // keychain needs pass to get the cryptographic keys\n    if (pass) {\n      try {\n        const keys = await this._keychain.listKeys()\n\n        for (const key of keys) {\n          if (key.name === 'self') {\n            continue\n          }\n\n          const pem = await this._keychain.exportKey(key.name, pass)\n          const privKey = await importKey(pem, pass)\n          const peerIdKey = await peerIdFromKeys(privKey.public.bytes, privKey.bytes)\n\n          await this._republishEntry(peerIdKey, options)\n        }\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n      }\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {AbortOptions} options\n   */\n  async _republishEntry (peerId, options) {\n    try {\n      const value = await this._getPreviousValue(peerId)\n      await this._publisher.publishWithEOL(peerId, value, defaultRecordLifetime, options)\n    } catch (/** @type {any} */ err) {\n      if (err.code === 'ERR_NO_ENTRY_FOUND') {\n        return\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async _getPreviousValue (peerId) {\n    if (!(isPeerId(peerId))) {\n      throw errcode(new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID')\n    }\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.toBytes()))\n\n      if (!(dsVal instanceof Uint8Array)) {\n        throw errcode(new Error(\"found ipns record that we couldn't process\"), 'ERR_INVALID_IPNS_RECORD')\n      }\n\n      // unmarshal data\n      try {\n        const record = ipns.unmarshal(dsVal)\n\n        return record.value\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n        throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD')\n      }\n    } catch (/** @type {any} */ err) {\n      // error handling\n      // no need to republish\n      if (err && err.notFound) {\n        throw errcode(new Error(`no previous entry for record with id: ${peerId.toString()}`), 'ERR_NO_ENTRY_FOUND')\n      }\n\n      throw err\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}