{"ast":null,"code":"import { concat as uint8ArrayConcat } from 'uint8arrays/concat';\n\nconst allocUnsafe = len => {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.allocUnsafe(len);\n  }\n\n  return new Uint8Array(len);\n};\n\nexport const uint16BEEncode = value => {\n  const target = allocUnsafe(2);\n  new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(0, value, false);\n  return target;\n};\nuint16BEEncode.bytes = 2;\nexport const uint16BEDecode = data => {\n  if (data.length < 2) throw RangeError('Could not decode int16BE');\n\n  if (data instanceof Uint8Array) {\n    return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false);\n  }\n\n  return data.getUint16(0);\n};\nuint16BEDecode.bytes = 2; // Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\n\nexport function encode0(message) {\n  return uint8ArrayConcat([message.ne, message.ciphertext], message.ne.length + message.ciphertext.length);\n}\nexport function encode1(message) {\n  return uint8ArrayConcat([message.ne, message.ns, message.ciphertext], message.ne.length + message.ns.length + message.ciphertext.length);\n}\nexport function encode2(message) {\n  return uint8ArrayConcat([message.ns, message.ciphertext], message.ns.length + message.ciphertext.length);\n}\nexport function decode0(input) {\n  if (input.length < 32) {\n    throw new Error('Cannot decode stage 0 MessageBuffer: length less than 32 bytes.');\n  }\n\n  return {\n    ne: input.subarray(0, 32),\n    ciphertext: input.subarray(32, input.length),\n    ns: new Uint8Array(0)\n  };\n}\nexport function decode1(input) {\n  if (input.length < 80) {\n    throw new Error('Cannot decode stage 1 MessageBuffer: length less than 80 bytes.');\n  }\n\n  return {\n    ne: input.subarray(0, 32),\n    ns: input.subarray(32, 80),\n    ciphertext: input.subarray(80, input.length)\n  };\n}\nexport function decode2(input) {\n  if (input.length < 48) {\n    throw new Error('Cannot decode stage 2 MessageBuffer: length less than 48 bytes.');\n  }\n\n  return {\n    ne: new Uint8Array(0),\n    ns: input.subarray(0, 48),\n    ciphertext: input.subarray(48, input.length)\n  };\n}","map":{"version":3,"mappings":"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","names":["concat","uint8ArrayConcat","allocUnsafe","len","globalThis","Buffer","Uint8Array","uint16BEEncode","value","target","DataView","buffer","byteOffset","byteLength","setUint16","bytes","uint16BEDecode","data","length","RangeError","getUint16","encode0","message","ne","ciphertext","encode1","ns","encode2","decode0","input","Error","subarray","decode1","decode2"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-noise\\src\\encoder.ts"],"sourcesContent":["import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { bytes } from './@types/basic.js'\nimport type { MessageBuffer } from './@types/handshake.js'\nimport type { LengthDecoderFunction } from 'it-length-prefixed'\n\nconst allocUnsafe = (len: number): Uint8Array => {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.allocUnsafe(len)\n  }\n\n  return new Uint8Array(len)\n}\n\nexport const uint16BEEncode = (value: number): Uint8Array => {\n  const target = allocUnsafe(2)\n  new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(0, value, false)\n  return target\n}\nuint16BEEncode.bytes = 2\n\nexport const uint16BEDecode: LengthDecoderFunction = (data: Uint8Array | Uint8ArrayList): number => {\n  if (data.length < 2) throw RangeError('Could not decode int16BE')\n\n  if (data instanceof Uint8Array) {\n    return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false)\n  }\n\n  return data.getUint16(0)\n}\nuint16BEDecode.bytes = 2\n\n// Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\n\nexport function encode0 (message: MessageBuffer): bytes {\n  return uint8ArrayConcat([message.ne, message.ciphertext], message.ne.length + message.ciphertext.length)\n}\n\nexport function encode1 (message: MessageBuffer): bytes {\n  return uint8ArrayConcat([message.ne, message.ns, message.ciphertext], message.ne.length + message.ns.length + message.ciphertext.length)\n}\n\nexport function encode2 (message: MessageBuffer): bytes {\n  return uint8ArrayConcat([message.ns, message.ciphertext], message.ns.length + message.ciphertext.length)\n}\n\nexport function decode0 (input: bytes): MessageBuffer {\n  if (input.length < 32) {\n    throw new Error('Cannot decode stage 0 MessageBuffer: length less than 32 bytes.')\n  }\n\n  return {\n    ne: input.subarray(0, 32),\n    ciphertext: input.subarray(32, input.length),\n    ns: new Uint8Array(0)\n  }\n}\n\nexport function decode1 (input: bytes): MessageBuffer {\n  if (input.length < 80) {\n    throw new Error('Cannot decode stage 1 MessageBuffer: length less than 80 bytes.')\n  }\n\n  return {\n    ne: input.subarray(0, 32),\n    ns: input.subarray(32, 80),\n    ciphertext: input.subarray(80, input.length)\n  }\n}\n\nexport function decode2 (input: bytes): MessageBuffer {\n  if (input.length < 48) {\n    throw new Error('Cannot decode stage 2 MessageBuffer: length less than 48 bytes.')\n  }\n\n  return {\n    ne: new Uint8Array(0),\n    ns: input.subarray(0, 48),\n    ciphertext: input.subarray(48, input.length)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}