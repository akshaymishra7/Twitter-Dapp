{"ast":null,"code":"/* eslint-disable import/export */\n\n/* eslint-disable complexity */\n\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message, enumeration } from 'protons-runtime';\nexport var Record;\n\n(function (Record) {\n  let _codec;\n\n  Record.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.key != null) {\n          w.uint32(10);\n          w.bytes(obj.key);\n        }\n\n        if (obj.value != null) {\n          w.uint32(18);\n          w.bytes(obj.value);\n        }\n\n        if (obj.author != null) {\n          w.uint32(26);\n          w.bytes(obj.author);\n        }\n\n        if (obj.signature != null) {\n          w.uint32(34);\n          w.bytes(obj.signature);\n        }\n\n        if (obj.timeReceived != null) {\n          w.uint32(42);\n          w.string(obj.timeReceived);\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {};\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.key = reader.bytes();\n              break;\n\n            case 2:\n              obj.value = reader.bytes();\n              break;\n\n            case 3:\n              obj.author = reader.bytes();\n              break;\n\n            case 4:\n              obj.signature = reader.bytes();\n              break;\n\n            case 5:\n              obj.timeReceived = reader.string();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  Record.encode = obj => {\n    return encodeMessage(obj, Record.codec());\n  };\n\n  Record.decode = buf => {\n    return decodeMessage(buf, Record.codec());\n  };\n})(Record || (Record = {}));\n\nexport var Message;\n\n(function (Message) {\n  let MessageType;\n\n  (function (MessageType) {\n    MessageType[\"PUT_VALUE\"] = \"PUT_VALUE\";\n    MessageType[\"GET_VALUE\"] = \"GET_VALUE\";\n    MessageType[\"ADD_PROVIDER\"] = \"ADD_PROVIDER\";\n    MessageType[\"GET_PROVIDERS\"] = \"GET_PROVIDERS\";\n    MessageType[\"FIND_NODE\"] = \"FIND_NODE\";\n    MessageType[\"PING\"] = \"PING\";\n  })(MessageType = Message.MessageType || (Message.MessageType = {}));\n\n  let __MessageTypeValues;\n\n  (function (__MessageTypeValues) {\n    __MessageTypeValues[__MessageTypeValues[\"PUT_VALUE\"] = 0] = \"PUT_VALUE\";\n    __MessageTypeValues[__MessageTypeValues[\"GET_VALUE\"] = 1] = \"GET_VALUE\";\n    __MessageTypeValues[__MessageTypeValues[\"ADD_PROVIDER\"] = 2] = \"ADD_PROVIDER\";\n    __MessageTypeValues[__MessageTypeValues[\"GET_PROVIDERS\"] = 3] = \"GET_PROVIDERS\";\n    __MessageTypeValues[__MessageTypeValues[\"FIND_NODE\"] = 4] = \"FIND_NODE\";\n    __MessageTypeValues[__MessageTypeValues[\"PING\"] = 5] = \"PING\";\n  })(__MessageTypeValues || (__MessageTypeValues = {}));\n\n  (function (MessageType) {\n    MessageType.codec = () => {\n      return enumeration(__MessageTypeValues);\n    };\n  })(MessageType = Message.MessageType || (Message.MessageType = {}));\n\n  let ConnectionType;\n\n  (function (ConnectionType) {\n    ConnectionType[\"NOT_CONNECTED\"] = \"NOT_CONNECTED\";\n    ConnectionType[\"CONNECTED\"] = \"CONNECTED\";\n    ConnectionType[\"CAN_CONNECT\"] = \"CAN_CONNECT\";\n    ConnectionType[\"CANNOT_CONNECT\"] = \"CANNOT_CONNECT\";\n  })(ConnectionType = Message.ConnectionType || (Message.ConnectionType = {}));\n\n  let __ConnectionTypeValues;\n\n  (function (__ConnectionTypeValues) {\n    __ConnectionTypeValues[__ConnectionTypeValues[\"NOT_CONNECTED\"] = 0] = \"NOT_CONNECTED\";\n    __ConnectionTypeValues[__ConnectionTypeValues[\"CONNECTED\"] = 1] = \"CONNECTED\";\n    __ConnectionTypeValues[__ConnectionTypeValues[\"CAN_CONNECT\"] = 2] = \"CAN_CONNECT\";\n    __ConnectionTypeValues[__ConnectionTypeValues[\"CANNOT_CONNECT\"] = 3] = \"CANNOT_CONNECT\";\n  })(__ConnectionTypeValues || (__ConnectionTypeValues = {}));\n\n  (function (ConnectionType) {\n    ConnectionType.codec = () => {\n      return enumeration(__ConnectionTypeValues);\n    };\n  })(ConnectionType = Message.ConnectionType || (Message.ConnectionType = {}));\n\n  let Peer;\n\n  (function (Peer) {\n    let _codec;\n\n    Peer.codec = () => {\n      if (_codec == null) {\n        _codec = message(function (obj, w) {\n          let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.id != null) {\n            w.uint32(10);\n            w.bytes(obj.id);\n          }\n\n          if (obj.addrs != null) {\n            for (const value of obj.addrs) {\n              w.uint32(18);\n              w.bytes(value);\n            }\n          }\n\n          if (obj.connection != null) {\n            w.uint32(24);\n            Message.ConnectionType.codec().encode(obj.connection, w);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        }, (reader, length) => {\n          const obj = {\n            addrs: []\n          };\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.id = reader.bytes();\n                break;\n\n              case 2:\n                obj.addrs.push(reader.bytes());\n                break;\n\n              case 3:\n                obj.connection = Message.ConnectionType.codec().decode(reader);\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        });\n      }\n\n      return _codec;\n    };\n\n    Peer.encode = obj => {\n      return encodeMessage(obj, Peer.codec());\n    };\n\n    Peer.decode = buf => {\n      return decodeMessage(buf, Peer.codec());\n    };\n  })(Peer = Message.Peer || (Message.Peer = {}));\n\n  let _codec;\n\n  Message.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.type != null) {\n          w.uint32(8);\n          Message.MessageType.codec().encode(obj.type, w);\n        }\n\n        if (obj.clusterLevelRaw != null) {\n          w.uint32(80);\n          w.int32(obj.clusterLevelRaw);\n        }\n\n        if (obj.key != null) {\n          w.uint32(18);\n          w.bytes(obj.key);\n        }\n\n        if (obj.record != null) {\n          w.uint32(26);\n          w.bytes(obj.record);\n        }\n\n        if (obj.closerPeers != null) {\n          for (const value of obj.closerPeers) {\n            w.uint32(66);\n            Message.Peer.codec().encode(value, w);\n          }\n        }\n\n        if (obj.providerPeers != null) {\n          for (const value of obj.providerPeers) {\n            w.uint32(74);\n            Message.Peer.codec().encode(value, w);\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {\n          closerPeers: [],\n          providerPeers: []\n        };\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.type = Message.MessageType.codec().decode(reader);\n              break;\n\n            case 10:\n              obj.clusterLevelRaw = reader.int32();\n              break;\n\n            case 2:\n              obj.key = reader.bytes();\n              break;\n\n            case 3:\n              obj.record = reader.bytes();\n              break;\n\n            case 8:\n              obj.closerPeers.push(Message.Peer.codec().decode(reader, reader.uint32()));\n              break;\n\n            case 9:\n              obj.providerPeers.push(Message.Peer.codec().decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  Message.encode = obj => {\n    return encodeMessage(obj, Message.codec());\n  };\n\n  Message.decode = buf => {\n    return decodeMessage(buf, Message.codec());\n  };\n})(Message || (Message = {}));","map":{"version":3,"mappings":"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","names":["encodeMessage","decodeMessage","message","enumeration","Record","_codec","obj","w","opts","lengthDelimited","fork","key","uint32","bytes","value","author","signature","timeReceived","string","ldelim","reader","length","end","len","pos","tag","skipType","codec","buf","Message","MessageType","__MessageTypeValues","ConnectionType","__ConnectionTypeValues","Peer","id","addrs","connection","encode","push","decode","type","clusterLevelRaw","int32","record","closerPeers","providerPeers"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\message\\dht.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message, enumeration } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Record {\n  key?: Uint8Array\n  value?: Uint8Array\n  author?: Uint8Array\n  signature?: Uint8Array\n  timeReceived?: string\n}\n\nexport namespace Record {\n  let _codec: Codec<Record>\n\n  export const codec = (): Codec<Record> => {\n    if (_codec == null) {\n      _codec = message<Record>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.key != null) {\n          w.uint32(10)\n          w.bytes(obj.key)\n        }\n\n        if (obj.value != null) {\n          w.uint32(18)\n          w.bytes(obj.value)\n        }\n\n        if (obj.author != null) {\n          w.uint32(26)\n          w.bytes(obj.author)\n        }\n\n        if (obj.signature != null) {\n          w.uint32(34)\n          w.bytes(obj.signature)\n        }\n\n        if (obj.timeReceived != null) {\n          w.uint32(42)\n          w.string(obj.timeReceived)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.key = reader.bytes()\n              break\n            case 2:\n              obj.value = reader.bytes()\n              break\n            case 3:\n              obj.author = reader.bytes()\n              break\n            case 4:\n              obj.signature = reader.bytes()\n              break\n            case 5:\n              obj.timeReceived = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Record>): Uint8Array => {\n    return encodeMessage(obj, Record.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Record => {\n    return decodeMessage(buf, Record.codec())\n  }\n}\n\nexport interface Message {\n  type?: Message.MessageType\n  clusterLevelRaw?: number\n  key?: Uint8Array\n  record?: Uint8Array\n  closerPeers: Message.Peer[]\n  providerPeers: Message.Peer[]\n}\n\nexport namespace Message {\n  export enum MessageType {\n    PUT_VALUE = 'PUT_VALUE',\n    GET_VALUE = 'GET_VALUE',\n    ADD_PROVIDER = 'ADD_PROVIDER',\n    GET_PROVIDERS = 'GET_PROVIDERS',\n    FIND_NODE = 'FIND_NODE',\n    PING = 'PING'\n  }\n\n  enum __MessageTypeValues {\n    PUT_VALUE = 0,\n    GET_VALUE = 1,\n    ADD_PROVIDER = 2,\n    GET_PROVIDERS = 3,\n    FIND_NODE = 4,\n    PING = 5\n  }\n\n  export namespace MessageType {\n    export const codec = (): Codec<MessageType> => {\n      return enumeration<MessageType>(__MessageTypeValues)\n    }\n  }\n\n  export enum ConnectionType {\n    NOT_CONNECTED = 'NOT_CONNECTED',\n    CONNECTED = 'CONNECTED',\n    CAN_CONNECT = 'CAN_CONNECT',\n    CANNOT_CONNECT = 'CANNOT_CONNECT'\n  }\n\n  enum __ConnectionTypeValues {\n    NOT_CONNECTED = 0,\n    CONNECTED = 1,\n    CAN_CONNECT = 2,\n    CANNOT_CONNECT = 3\n  }\n\n  export namespace ConnectionType {\n    export const codec = (): Codec<ConnectionType> => {\n      return enumeration<ConnectionType>(__ConnectionTypeValues)\n    }\n  }\n\n  export interface Peer {\n    id?: Uint8Array\n    addrs: Uint8Array[]\n    connection?: Message.ConnectionType\n  }\n\n  export namespace Peer {\n    let _codec: Codec<Peer>\n\n    export const codec = (): Codec<Peer> => {\n      if (_codec == null) {\n        _codec = message<Peer>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.id != null) {\n            w.uint32(10)\n            w.bytes(obj.id)\n          }\n\n          if (obj.addrs != null) {\n            for (const value of obj.addrs) {\n              w.uint32(18)\n              w.bytes(value)\n            }\n          }\n\n          if (obj.connection != null) {\n            w.uint32(24)\n            Message.ConnectionType.codec().encode(obj.connection, w)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length) => {\n          const obj: any = {\n            addrs: []\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.id = reader.bytes()\n                break\n              case 2:\n                obj.addrs.push(reader.bytes())\n                break\n              case 3:\n                obj.connection = Message.ConnectionType.codec().decode(reader)\n                break\n              default:\n                reader.skipType(tag & 7)\n                break\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Peer>): Uint8Array => {\n      return encodeMessage(obj, Peer.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList): Peer => {\n      return decodeMessage(buf, Peer.codec())\n    }\n  }\n\n  let _codec: Codec<Message>\n\n  export const codec = (): Codec<Message> => {\n    if (_codec == null) {\n      _codec = message<Message>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.type != null) {\n          w.uint32(8)\n          Message.MessageType.codec().encode(obj.type, w)\n        }\n\n        if (obj.clusterLevelRaw != null) {\n          w.uint32(80)\n          w.int32(obj.clusterLevelRaw)\n        }\n\n        if (obj.key != null) {\n          w.uint32(18)\n          w.bytes(obj.key)\n        }\n\n        if (obj.record != null) {\n          w.uint32(26)\n          w.bytes(obj.record)\n        }\n\n        if (obj.closerPeers != null) {\n          for (const value of obj.closerPeers) {\n            w.uint32(66)\n            Message.Peer.codec().encode(value, w)\n          }\n        }\n\n        if (obj.providerPeers != null) {\n          for (const value of obj.providerPeers) {\n            w.uint32(74)\n            Message.Peer.codec().encode(value, w)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          closerPeers: [],\n          providerPeers: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.type = Message.MessageType.codec().decode(reader)\n              break\n            case 10:\n              obj.clusterLevelRaw = reader.int32()\n              break\n            case 2:\n              obj.key = reader.bytes()\n              break\n            case 3:\n              obj.record = reader.bytes()\n              break\n            case 8:\n              obj.closerPeers.push(Message.Peer.codec().decode(reader, reader.uint32()))\n              break\n            case 9:\n              obj.providerPeers.push(Message.Peer.codec().decode(reader, reader.uint32()))\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Message>): Uint8Array => {\n    return encodeMessage(obj, Message.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Message => {\n    return decodeMessage(buf, Message.codec())\n  }\n}\n"]},"metadata":{},"sourceType":"module"}