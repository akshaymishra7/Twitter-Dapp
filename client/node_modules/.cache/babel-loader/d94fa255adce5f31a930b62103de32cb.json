{"ast":null,"code":"import errCode from 'err-code';\nimport { UnixFS } from 'ipfs-unixfs';\nimport findShardCid from '../../utils/find-cid-in-shard.js';\nimport { decode } from '@ipld/dag-pb';\nimport contentFile from './content/file.js';\nimport contentDirectory from './content/directory.js';\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js';\n/**\n * @typedef {import('../../types').Resolve} Resolve\n * @typedef {import('../../types').Resolver} Resolver\n * @typedef {import('../../types').UnixfsV1Resolver} UnixfsV1Resolver\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n */\n\n/**\n * @param {PBNode} node\n * @param {string} name\n */\n\nconst findLinkCid = (node, name) => {\n  const link = node.Links.find(link => link.Name === name);\n  return link && link.Hash;\n};\n/**\n * @type {{ [key: string]: UnixfsV1Resolver }}\n */\n\n\nconst contentExporters = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => [];\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => [];\n  }\n};\n/**\n * @type {Resolver}\n */\n\nconst unixFsResolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options);\n  const node = decode(block);\n  let unixfs;\n  let next;\n\n  if (!name) {\n    name = cid.toString();\n  }\n\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n  }\n\n  try {\n    unixfs = UnixFS.unmarshal(node.Data);\n  } catch (\n  /** @type {any} */\n  err) {\n    // non-UnixFS dag-pb node? It could happen.\n    throw errCode(err, 'ERR_NOT_UNIXFS');\n  }\n\n  if (!path) {\n    path = name;\n  }\n\n  if (toResolve.length) {\n    let linkCid;\n\n    if (unixfs && unixfs.type === 'hamt-sharded-directory') {\n      // special case - unixfs v1 hamt shards\n      linkCid = await findShardCid(node, toResolve[0], blockstore);\n    } else {\n      linkCid = findLinkCid(node, toResolve[0]);\n    }\n\n    if (!linkCid) {\n      throw errCode(new Error('file does not exist'), 'ERR_NOT_FOUND');\n    } // remove the path component we have resolved\n\n\n    const nextName = toResolve.shift();\n    const nextPath = `${path}/${nextName}`;\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName || '',\n      path: nextPath\n    };\n  }\n\n  return {\n    entry: {\n      type: unixfs.isDirectory() ? 'directory' : 'file',\n      name,\n      path,\n      cid,\n      // @ts-ignore\n      content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore),\n      unixfs,\n      depth,\n      node,\n      size: unixfs.fileSize()\n    },\n    next\n  };\n};\n\nexport default unixFsResolver;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.js"],"names":["errCode","UnixFS","findShardCid","decode","contentFile","contentDirectory","contentHamtShardedDirectory","findLinkCid","node","name","link","Links","find","Name","Hash","contentExporters","raw","file","directory","metadata","cid","unixfs","path","resolve","depth","blockstore","symlink","unixFsResolver","toResolve","options","block","get","next","toString","Data","Error","unmarshal","err","length","linkCid","type","nextName","shift","nextPath","entry","isDirectory","content","size","fileSize"],"mappings":"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","sourcesContent":["import errCode from 'err-code'\nimport { UnixFS } from 'ipfs-unixfs'\nimport findShardCid from '../../utils/find-cid-in-shard.js'\nimport { decode } from '@ipld/dag-pb'\n\nimport contentFile from './content/file.js'\nimport contentDirectory from './content/directory.js'\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js'\n\n/**\n * @typedef {import('../../types').Resolve} Resolve\n * @typedef {import('../../types').Resolver} Resolver\n * @typedef {import('../../types').UnixfsV1Resolver} UnixfsV1Resolver\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n */\n\n/**\n * @param {PBNode} node\n * @param {string} name\n */\nconst findLinkCid = (node, name) => {\n  const link = node.Links.find(link => link.Name === name)\n\n  return link && link.Hash\n}\n\n/**\n * @type {{ [key: string]: UnixfsV1Resolver }}\n */\nconst contentExporters = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  }\n}\n\n/**\n * @type {Resolver}\n */\nconst unixFsResolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const node = decode(block)\n  let unixfs\n  let next\n\n  if (!name) {\n    name = cid.toString()\n  }\n\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS')\n  }\n\n  try {\n    unixfs = UnixFS.unmarshal(node.Data)\n  } catch (/** @type {any} */ err) {\n    // non-UnixFS dag-pb node? It could happen.\n    throw errCode(err, 'ERR_NOT_UNIXFS')\n  }\n\n  if (!path) {\n    path = name\n  }\n\n  if (toResolve.length) {\n    let linkCid\n\n    if (unixfs && unixfs.type === 'hamt-sharded-directory') {\n      // special case - unixfs v1 hamt shards\n      linkCid = await findShardCid(node, toResolve[0], blockstore)\n    } else {\n      linkCid = findLinkCid(node, toResolve[0])\n    }\n\n    if (!linkCid) {\n      throw errCode(new Error('file does not exist'), 'ERR_NOT_FOUND')\n    }\n\n    // remove the path component we have resolved\n    const nextName = toResolve.shift()\n    const nextPath = `${path}/${nextName}`\n\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName || '',\n      path: nextPath\n    }\n  }\n\n  return {\n    entry: {\n      type: unixfs.isDirectory() ? 'directory' : 'file',\n      name,\n      path,\n      cid,\n      // @ts-ignore\n      content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore),\n      unixfs,\n      depth,\n      node,\n      size: unixfs.fileSize()\n    },\n    next\n  }\n}\n\nexport default unixFsResolver\n"]},"metadata":{},"sourceType":"module"}