{"ast":null,"code":"/**\n * Implements rate limiting in cluster using built-in IPC\n *\n * Two classes are described here: master and worker\n * Master have to be create in the master process without any options.\n * Any number of rate limiters can be created in workers, but each rate limiter must be with unique keyPrefix\n *\n * Workflow:\n * 1. master rate limiter created in master process\n * 2. worker rate limiter sends 'init' message with necessary options during creating\n * 3. master receives options and adds new rate limiter by keyPrefix if it isn't created yet\n * 4. master sends 'init' back to worker's rate limiter\n * 5. worker can process requests immediately,\n *    but they will be postponed by 'workerWaitInit' until master sends 'init' to worker\n * 6. every request to worker rate limiter creates a promise\n * 7. if master doesn't response for 'timeout', promise is rejected\n * 8. master sends 'resolve' or 'reject' command to worker\n * 9. worker resolves or rejects promise depending on message from master\n *\n */\nconst cluster = require('cluster');\n\nconst crypto = require('crypto');\n\nconst RateLimiterAbstract = require('./RateLimiterAbstract');\n\nconst RateLimiterMemory = require('./RateLimiterMemory');\n\nconst RateLimiterRes = require('./RateLimiterRes');\n\nconst channel = 'rate_limiter_flexible';\nlet masterInstance = null;\n\nconst masterSendToWorker = function (worker, msg, type, res) {\n  let data;\n\n  if (res === null || res === true || res === false) {\n    data = res;\n  } else {\n    data = {\n      remainingPoints: res.remainingPoints,\n      msBeforeNext: res.msBeforeNext,\n      consumedPoints: res.consumedPoints,\n      isFirstInDuration: res.isFirstInDuration\n    };\n  }\n\n  worker.send({\n    channel,\n    keyPrefix: msg.keyPrefix,\n    // which rate limiter exactly\n    promiseId: msg.promiseId,\n    type,\n    data\n  });\n};\n\nconst workerWaitInit = function (payload) {\n  setTimeout(() => {\n    if (this._initiated) {\n      process.send(payload); // Promise will be removed by timeout if too long\n    } else if (typeof this._promises[payload.promiseId] !== 'undefined') {\n      workerWaitInit.call(this, payload);\n    }\n  }, 30);\n};\n\nconst workerSendToMaster = function (func, promiseId, key, arg, opts) {\n  const payload = {\n    channel,\n    keyPrefix: this.keyPrefix,\n    func,\n    promiseId,\n    data: {\n      key,\n      arg,\n      opts\n    }\n  };\n\n  if (!this._initiated) {\n    // Wait init before sending messages to master\n    workerWaitInit.call(this, payload);\n  } else {\n    process.send(payload);\n  }\n};\n\nconst masterProcessMsg = function (worker, msg) {\n  if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === 'undefined') {\n    return false;\n  }\n\n  let promise;\n\n  switch (msg.func) {\n    case 'consume':\n      promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n\n    case 'penalty':\n      promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n\n    case 'reward':\n      promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n\n    case 'block':\n      promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n\n    case 'get':\n      promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);\n      break;\n\n    case 'delete':\n      promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);\n      break;\n\n    default:\n      return false;\n  }\n\n  if (promise) {\n    promise.then(res => {\n      masterSendToWorker(worker, msg, 'resolve', res);\n    }).catch(rejRes => {\n      masterSendToWorker(worker, msg, 'reject', rejRes);\n    });\n  }\n};\n\nconst workerProcessMsg = function (msg) {\n  if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {\n    return false;\n  }\n\n  if (this._promises[msg.promiseId]) {\n    clearTimeout(this._promises[msg.promiseId].timeoutId);\n    let res;\n\n    if (msg.data === null || msg.data === true || msg.data === false) {\n      res = msg.data;\n    } else {\n      res = new RateLimiterRes(msg.data.remainingPoints, msg.data.msBeforeNext, msg.data.consumedPoints, msg.data.isFirstInDuration // eslint-disable-line comma-dangle\n      );\n    }\n\n    switch (msg.type) {\n      case 'resolve':\n        this._promises[msg.promiseId].resolve(res);\n\n        break;\n\n      case 'reject':\n        this._promises[msg.promiseId].reject(res);\n\n        break;\n\n      default:\n        throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);\n    }\n\n    delete this._promises[msg.promiseId];\n  }\n};\n/**\n * Prepare options to send to master\n * Master will create rate limiter depending on options\n *\n * @returns {{points: *, duration: *, blockDuration: *, execEvenly: *, execEvenlyMinDelayMs: *, keyPrefix: *}}\n */\n\n\nconst getOpts = function () {\n  return {\n    points: this.points,\n    duration: this.duration,\n    blockDuration: this.blockDuration,\n    execEvenly: this.execEvenly,\n    execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,\n    keyPrefix: this.keyPrefix\n  };\n};\n\nconst savePromise = function (resolve, reject) {\n  const hrtime = process.hrtime();\n  let promiseId = hrtime[0].toString() + hrtime[1].toString();\n\n  if (typeof this._promises[promiseId] !== 'undefined') {\n    promiseId += crypto.randomBytes(12).toString('base64');\n  }\n\n  this._promises[promiseId] = {\n    resolve,\n    reject,\n    timeoutId: setTimeout(() => {\n      delete this._promises[promiseId];\n      reject(new Error('RateLimiterCluster timeout: no answer from master in time'));\n    }, this.timeoutMs)\n  };\n  return promiseId;\n};\n\nclass RateLimiterClusterMaster {\n  constructor() {\n    if (masterInstance) {\n      return masterInstance;\n    }\n\n    this._rateLimiters = {};\n    cluster.setMaxListeners(0);\n    cluster.on('message', (worker, msg) => {\n      if (msg && msg.channel === channel && msg.type === 'init') {\n        // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n        if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n          this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n        }\n\n        worker.send({\n          channel,\n          type: 'init',\n          keyPrefix: msg.opts.keyPrefix\n        });\n      } else {\n        masterProcessMsg.call(this, worker, msg);\n      }\n    });\n    masterInstance = this;\n  }\n\n}\n\nclass RateLimiterClusterMasterPM2 {\n  constructor(pm2) {\n    if (masterInstance) {\n      return masterInstance;\n    }\n\n    this._rateLimiters = {};\n    pm2.launchBus((err, pm2Bus) => {\n      pm2Bus.on('process:msg', packet => {\n        const msg = packet.raw;\n\n        if (msg && msg.channel === channel && msg.type === 'init') {\n          // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n          if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n            this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n          }\n\n          pm2.sendDataToProcessId(packet.process.pm_id, {\n            data: {},\n            topic: channel,\n            channel,\n            type: 'init',\n            keyPrefix: msg.opts.keyPrefix\n          }, (sendErr, res) => {\n            if (sendErr) {\n              console.log(sendErr, res);\n            }\n          });\n        } else {\n          const worker = {\n            send: msgData => {\n              const pm2Message = msgData;\n              pm2Message.topic = channel;\n\n              if (typeof pm2Message.data === 'undefined') {\n                pm2Message.data = {};\n              }\n\n              pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, (sendErr, res) => {\n                if (sendErr) {\n                  console.log(sendErr, res);\n                }\n              });\n            }\n          };\n          masterProcessMsg.call(this, worker, msg);\n        }\n      });\n    });\n    masterInstance = this;\n  }\n\n}\n\nclass RateLimiterClusterWorker extends RateLimiterAbstract {\n  get timeoutMs() {\n    return this._timeoutMs;\n  }\n\n  set timeoutMs(value) {\n    this._timeoutMs = typeof value === 'undefined' ? 5000 : Math.abs(parseInt(value));\n  }\n\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(opts);\n    process.setMaxListeners(0);\n    this.timeoutMs = opts.timeoutMs;\n    this._initiated = false;\n    process.on('message', msg => {\n      if (msg && msg.channel === channel && msg.type === 'init' && msg.keyPrefix === this.keyPrefix) {\n        this._initiated = true;\n      } else {\n        workerProcessMsg.call(this, msg);\n      }\n    }); // Create limiter on master with specific options\n\n    process.send({\n      channel,\n      type: 'init',\n      opts: getOpts.call(this)\n    });\n    this._promises = {};\n  }\n\n  consume(key) {\n    let pointsToConsume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n      workerSendToMaster.call(this, 'consume', promiseId, key, pointsToConsume, options);\n    });\n  }\n\n  penalty(key) {\n    let points = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n      workerSendToMaster.call(this, 'penalty', promiseId, key, points, options);\n    });\n  }\n\n  reward(key) {\n    let points = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n      workerSendToMaster.call(this, 'reward', promiseId, key, points, options);\n    });\n  }\n\n  block(key, secDuration) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n      workerSendToMaster.call(this, 'block', promiseId, key, secDuration, options);\n    });\n  }\n\n  get(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n      workerSendToMaster.call(this, 'get', promiseId, key, options);\n    });\n  }\n\n  delete(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n      workerSendToMaster.call(this, 'delete', promiseId, key, options);\n    });\n  }\n\n}\n\nmodule.exports = {\n  RateLimiterClusterMaster,\n  RateLimiterClusterMasterPM2,\n  RateLimiterCluster: RateLimiterClusterWorker\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/rate-limiter-flexible/lib/RateLimiterCluster.js"],"names":["cluster","require","crypto","RateLimiterAbstract","RateLimiterMemory","RateLimiterRes","channel","masterInstance","masterSendToWorker","worker","msg","type","res","data","remainingPoints","msBeforeNext","consumedPoints","isFirstInDuration","send","keyPrefix","promiseId","workerWaitInit","payload","setTimeout","_initiated","process","_promises","call","workerSendToMaster","func","key","arg","opts","masterProcessMsg","_rateLimiters","promise","consume","penalty","reward","block","get","delete","then","catch","rejRes","workerProcessMsg","clearTimeout","timeoutId","resolve","reject","Error","getOpts","points","duration","blockDuration","execEvenly","execEvenlyMinDelayMs","savePromise","hrtime","toString","randomBytes","timeoutMs","RateLimiterClusterMaster","constructor","setMaxListeners","on","RateLimiterClusterMasterPM2","pm2","launchBus","err","pm2Bus","packet","raw","sendDataToProcessId","pm_id","topic","sendErr","console","log","msgData","pm2Message","RateLimiterClusterWorker","_timeoutMs","value","Math","abs","parseInt","pointsToConsume","options","Promise","secDuration","module","exports","RateLimiterCluster"],"mappings":"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","sourcesContent":["/**\n * Implements rate limiting in cluster using built-in IPC\n *\n * Two classes are described here: master and worker\n * Master have to be create in the master process without any options.\n * Any number of rate limiters can be created in workers, but each rate limiter must be with unique keyPrefix\n *\n * Workflow:\n * 1. master rate limiter created in master process\n * 2. worker rate limiter sends 'init' message with necessary options during creating\n * 3. master receives options and adds new rate limiter by keyPrefix if it isn't created yet\n * 4. master sends 'init' back to worker's rate limiter\n * 5. worker can process requests immediately,\n *    but they will be postponed by 'workerWaitInit' until master sends 'init' to worker\n * 6. every request to worker rate limiter creates a promise\n * 7. if master doesn't response for 'timeout', promise is rejected\n * 8. master sends 'resolve' or 'reject' command to worker\n * 9. worker resolves or rejects promise depending on message from master\n *\n */\n\nconst cluster = require('cluster');\nconst crypto = require('crypto');\nconst RateLimiterAbstract = require('./RateLimiterAbstract');\nconst RateLimiterMemory = require('./RateLimiterMemory');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nconst channel = 'rate_limiter_flexible';\nlet masterInstance = null;\n\nconst masterSendToWorker = function (worker, msg, type, res) {\n  let data;\n  if (res === null || res === true || res === false) {\n    data = res;\n  } else {\n    data = {\n      remainingPoints: res.remainingPoints,\n      msBeforeNext: res.msBeforeNext,\n      consumedPoints: res.consumedPoints,\n      isFirstInDuration: res.isFirstInDuration,\n    };\n  }\n  worker.send({\n    channel,\n    keyPrefix: msg.keyPrefix, // which rate limiter exactly\n    promiseId: msg.promiseId,\n    type,\n    data,\n  });\n};\n\nconst workerWaitInit = function (payload) {\n  setTimeout(() => {\n    if (this._initiated) {\n      process.send(payload);\n      // Promise will be removed by timeout if too long\n    } else if (typeof this._promises[payload.promiseId] !== 'undefined') {\n      workerWaitInit.call(this, payload);\n    }\n  }, 30);\n};\n\nconst workerSendToMaster = function (func, promiseId, key, arg, opts) {\n  const payload = {\n    channel,\n    keyPrefix: this.keyPrefix,\n    func,\n    promiseId,\n    data: {\n      key,\n      arg,\n      opts,\n    },\n  };\n\n  if (!this._initiated) {\n    // Wait init before sending messages to master\n    workerWaitInit.call(this, payload);\n  } else {\n    process.send(payload);\n  }\n};\n\nconst masterProcessMsg = function (worker, msg) {\n  if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === 'undefined') {\n    return false;\n  }\n\n  let promise;\n\n  switch (msg.func) {\n    case 'consume':\n      promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'penalty':\n      promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'reward':\n      promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'block':\n      promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'get':\n      promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);\n      break;\n    case 'delete':\n      promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);\n      break;\n    default:\n      return false;\n  }\n\n  if (promise) {\n    promise\n      .then((res) => {\n        masterSendToWorker(worker, msg, 'resolve', res);\n      })\n      .catch((rejRes) => {\n        masterSendToWorker(worker, msg, 'reject', rejRes);\n      });\n  }\n};\n\nconst workerProcessMsg = function (msg) {\n  if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {\n    return false;\n  }\n\n  if (this._promises[msg.promiseId]) {\n    clearTimeout(this._promises[msg.promiseId].timeoutId);\n    let res;\n    if (msg.data === null || msg.data === true || msg.data === false) {\n      res = msg.data;\n    } else {\n      res = new RateLimiterRes(\n        msg.data.remainingPoints,\n        msg.data.msBeforeNext,\n        msg.data.consumedPoints,\n        msg.data.isFirstInDuration // eslint-disable-line comma-dangle\n      );\n    }\n\n    switch (msg.type) {\n      case 'resolve':\n        this._promises[msg.promiseId].resolve(res);\n        break;\n      case 'reject':\n        this._promises[msg.promiseId].reject(res);\n        break;\n      default:\n        throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);\n    }\n\n    delete this._promises[msg.promiseId];\n  }\n};\n/**\n * Prepare options to send to master\n * Master will create rate limiter depending on options\n *\n * @returns {{points: *, duration: *, blockDuration: *, execEvenly: *, execEvenlyMinDelayMs: *, keyPrefix: *}}\n */\nconst getOpts = function () {\n  return {\n    points: this.points,\n    duration: this.duration,\n    blockDuration: this.blockDuration,\n    execEvenly: this.execEvenly,\n    execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,\n    keyPrefix: this.keyPrefix,\n  };\n};\n\nconst savePromise = function (resolve, reject) {\n  const hrtime = process.hrtime();\n  let promiseId = hrtime[0].toString() + hrtime[1].toString();\n\n  if (typeof this._promises[promiseId] !== 'undefined') {\n    promiseId += crypto.randomBytes(12).toString('base64');\n  }\n\n  this._promises[promiseId] = {\n    resolve,\n    reject,\n    timeoutId: setTimeout(() => {\n      delete this._promises[promiseId];\n      reject(new Error('RateLimiterCluster timeout: no answer from master in time'));\n    }, this.timeoutMs),\n  };\n\n  return promiseId;\n};\n\nclass RateLimiterClusterMaster {\n  constructor() {\n    if (masterInstance) {\n      return masterInstance;\n    }\n\n    this._rateLimiters = {};\n\n    cluster.setMaxListeners(0);\n\n    cluster.on('message', (worker, msg) => {\n      if (msg && msg.channel === channel && msg.type === 'init') {\n        // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n        if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n          this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n        }\n\n        worker.send({\n          channel,\n          type: 'init',\n          keyPrefix: msg.opts.keyPrefix,\n        });\n      } else {\n        masterProcessMsg.call(this, worker, msg);\n      }\n    });\n\n    masterInstance = this;\n  }\n}\n\nclass RateLimiterClusterMasterPM2 {\n  constructor(pm2) {\n    if (masterInstance) {\n      return masterInstance;\n    }\n\n    this._rateLimiters = {};\n\n    pm2.launchBus((err, pm2Bus) => {\n      pm2Bus.on('process:msg', (packet) => {\n        const msg = packet.raw;\n        if (msg && msg.channel === channel && msg.type === 'init') {\n          // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n          if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n            this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n          }\n\n          pm2.sendDataToProcessId(packet.process.pm_id, {\n            data: {},\n            topic: channel,\n            channel,\n            type: 'init',\n            keyPrefix: msg.opts.keyPrefix,\n          }, (sendErr, res) => {\n            if (sendErr) {\n              console.log(sendErr, res);\n            }\n          });\n        } else {\n          const worker = {\n            send: (msgData) => {\n              const pm2Message = msgData;\n              pm2Message.topic = channel;\n              if (typeof pm2Message.data === 'undefined') {\n                pm2Message.data = {};\n              }\n              pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, (sendErr, res) => {\n                if (sendErr) {\n                  console.log(sendErr, res);\n                }\n              });\n            },\n          };\n          masterProcessMsg.call(this, worker, msg);\n        }\n      });\n    });\n\n    masterInstance = this;\n  }\n}\n\nclass RateLimiterClusterWorker extends RateLimiterAbstract {\n  get timeoutMs() {\n    return this._timeoutMs;\n  }\n\n  set timeoutMs(value) {\n    this._timeoutMs = typeof value === 'undefined' ? 5000 : Math.abs(parseInt(value));\n  }\n\n  constructor(opts = {}) {\n    super(opts);\n\n    process.setMaxListeners(0);\n\n    this.timeoutMs = opts.timeoutMs;\n\n    this._initiated = false;\n\n    process.on('message', (msg) => {\n      if (msg && msg.channel === channel && msg.type === 'init' && msg.keyPrefix === this.keyPrefix) {\n        this._initiated = true;\n      } else {\n        workerProcessMsg.call(this, msg);\n      }\n    });\n\n    // Create limiter on master with specific options\n    process.send({\n      channel,\n      type: 'init',\n      opts: getOpts.call(this),\n    });\n\n    this._promises = {};\n  }\n\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'consume', promiseId, key, pointsToConsume, options);\n    });\n  }\n\n  penalty(key, points = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'penalty', promiseId, key, points, options);\n    });\n  }\n\n  reward(key, points = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'reward', promiseId, key, points, options);\n    });\n  }\n\n  block(key, secDuration, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'block', promiseId, key, secDuration, options);\n    });\n  }\n\n  get(key, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'get', promiseId, key, options);\n    });\n  }\n\n  delete(key, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'delete', promiseId, key, options);\n    });\n  }\n}\n\nmodule.exports = {\n  RateLimiterClusterMaster,\n  RateLimiterClusterMasterPM2,\n  RateLimiterCluster: RateLimiterClusterWorker,\n};\n"]},"metadata":{},"sourceType":"script"}