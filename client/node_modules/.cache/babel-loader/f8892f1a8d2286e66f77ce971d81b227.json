{"ast":null,"code":"import { CodeError } from '@libp2p/interfaces/errors';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { Libp2pRecord } from '@libp2p/record';\nimport { verifyRecord } from '@libp2p/record/validators';\nimport { bestRecord } from '@libp2p/record/selectors';\nimport parallel from 'it-parallel';\nimport map from 'it-map';\nimport { valueEvent, queryErrorEvent } from '../query/events.js';\nimport { Message, MESSAGE_TYPE } from '../message/index.js';\nimport { pipe } from 'it-pipe';\nimport { ALPHA } from '../constants.js';\nimport { createPutRecord, convertBuffer, bufferToRecordKey } from '../utils.js';\nimport { logger } from '@libp2p/logger';\nexport class ContentFetching {\n  constructor(components, init) {\n    const {\n      validators,\n      selectors,\n      peerRouting,\n      queryManager,\n      routingTable,\n      network,\n      lan\n    } = init;\n    this.components = components;\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:content-fetching`);\n    this.validators = validators;\n    this.selectors = selectors;\n    this.peerRouting = peerRouting;\n    this.queryManager = queryManager;\n    this.routingTable = routingTable;\n    this.network = network;\n  }\n\n  async putLocal(key, rec) {\n    const dsKey = bufferToRecordKey(key);\n    await this.components.datastore.put(dsKey, rec);\n  }\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore\n   */\n\n\n  async getLocal(key) {\n    this.log('getLocal %b', key);\n    const dsKey = bufferToRecordKey(key);\n    this.log('fetching record for key %k', dsKey);\n    const raw = await this.components.datastore.get(dsKey);\n    this.log('found %k in local datastore', dsKey);\n    const rec = Libp2pRecord.deserialize(raw);\n    await verifyRecord(this.validators, rec);\n    return rec;\n  }\n  /**\n   * Send the best record found to any peers that have an out of date record\n   */\n\n\n  async *sendCorrectionRecord(key, vals, best) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this.log('sendCorrection for %b', key);\n    const fixupRec = createPutRecord(key, best);\n\n    for (const {\n      value,\n      from\n    } of vals) {\n      // no need to do anything\n      if (uint8ArrayEquals(value, best)) {\n        this.log('record was ok');\n        continue;\n      } // correct ourself\n\n\n      if (this.components.peerId.equals(from)) {\n        try {\n          const dsKey = bufferToRecordKey(key);\n          this.log(`Storing corrected record for key ${dsKey.toString()}`);\n          await this.components.datastore.put(dsKey, fixupRec.subarray());\n        } catch (err) {\n          this.log.error('Failed error correcting self', err);\n        }\n\n        continue;\n      } // send correction\n\n\n      let sentCorrection = false;\n      const request = new Message(MESSAGE_TYPE.PUT_VALUE, key, 0);\n      request.record = Libp2pRecord.deserialize(fixupRec);\n\n      for await (const event of this.network.sendRequest(from, request, options)) {\n        if (event.name === 'PEER_RESPONSE' && event.record != null && uint8ArrayEquals(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {\n          sentCorrection = true;\n        }\n\n        yield event;\n      }\n\n      if (!sentCorrection) {\n        yield queryErrorEvent({\n          from,\n          error: new CodeError('value not put correctly', 'ERR_PUT_VALUE_INVALID')\n        });\n      }\n\n      this.log.error('Failed error correcting entry');\n    }\n  }\n  /**\n   * Store the given key/value pair in the DHT\n   */\n\n\n  async *put(key, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.log('put key %b value %b', key, value); // create record in the dht format\n\n    const record = createPutRecord(key, value); // store the record locally\n\n    const dsKey = bufferToRecordKey(key);\n    this.log(`storing record for key ${dsKey.toString()}`);\n    await this.components.datastore.put(dsKey, record.subarray()); // put record to the closest peers\n\n    yield* pipe(this.peerRouting.getClosestPeers(key, {\n      signal: options.signal\n    }), source => map(source, event => {\n      return async () => {\n        if (event.name !== 'FINAL_PEER') {\n          return [event];\n        }\n\n        const events = [];\n        const msg = new Message(MESSAGE_TYPE.PUT_VALUE, key, 0);\n        msg.record = Libp2pRecord.deserialize(record);\n        this.log('send put to %p', event.peer.id);\n\n        for await (const putEvent of this.network.sendRequest(event.peer.id, msg, options)) {\n          events.push(putEvent);\n\n          if (putEvent.name !== 'PEER_RESPONSE') {\n            continue;\n          }\n\n          if (!(putEvent.record != null && uint8ArrayEquals(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {\n            events.push(queryErrorEvent({\n              from: event.peer.id,\n              error: new CodeError('value not put correctly', 'ERR_PUT_VALUE_INVALID')\n            }));\n          }\n        }\n\n        return events;\n      };\n    }), source => parallel(source, {\n      ordered: false,\n      concurrency: ALPHA\n    }), async function* (source) {\n      for await (const events of source) {\n        yield* events;\n      }\n    });\n  }\n  /**\n   * Get the value to the given key\n   */\n\n\n  async *get(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.log('get %b', key);\n    const vals = [];\n\n    for await (const event of this.getMany(key, options)) {\n      if (event.name === 'VALUE') {\n        vals.push(event);\n      }\n\n      yield event;\n    }\n\n    if (vals.length === 0) {\n      return;\n    }\n\n    const records = vals.map(v => v.value);\n    let i = 0;\n\n    try {\n      i = bestRecord(this.selectors, key, records);\n    } catch (err) {\n      // Assume the first record if no selector available\n      if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n        throw err;\n      }\n    }\n\n    const best = records[i];\n    this.log('GetValue %b %b', key, best);\n\n    if (best == null) {\n      throw new CodeError('best value was not found', 'ERR_NOT_FOUND');\n    }\n\n    yield* this.sendCorrectionRecord(key, vals, best, options);\n    yield vals[i];\n  }\n  /**\n   * Get the `n` values to the given key without sorting\n   */\n\n\n  async *getMany(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.log('getMany values for %b', key);\n\n    try {\n      const localRec = await this.getLocal(key);\n      yield valueEvent({\n        value: localRec.value,\n        from: this.components.peerId\n      });\n    } catch (err) {\n      this.log('error getting local value for %b', key, err);\n    }\n\n    const id = await convertBuffer(key);\n    const rtp = this.routingTable.closestPeers(id);\n    this.log('found %d peers in routing table', rtp.length);\n    const self = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\n    const getValueQuery = async function* (_ref) {\n      let {\n        peer,\n        signal\n      } = _ref;\n\n      for await (const event of self.peerRouting.getValueOrPeers(peer, key, {\n        signal\n      })) {\n        yield event;\n\n        if (event.name === 'PEER_RESPONSE' && event.record != null) {\n          yield valueEvent({\n            from: peer,\n            value: event.record.value\n          });\n        }\n      }\n    }; // we have peers, lets send the actual query to them\n\n\n    yield* this.queryManager.run(key, rtp, getValueQuery, options);\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,SAAT,QAA0B,2BAA1B;AACA,SAASC,MAAM,IAAIC,gBAAnB,QAA2C,oBAA3C;AACA,SAASC,YAAT,QAA6B,gBAA7B;AACA,SAASC,YAAT,QAA6B,2BAA7B;AACA,SAASC,UAAT,QAA2B,0BAA3B;AACA,OAAOC,QAAP,MAAqB,aAArB;AACA,OAAOC,GAAP,MAAgB,QAAhB;AACA,SACEC,UADF,EAEEC,eAFF,QAGO,oBAHP;AAIA,SAASC,OAAT,EAAkBC,YAAlB,QAAsC,qBAAtC;AACA,SAASC,IAAT,QAAqB,SAArB;AACA,SACEC,KADF,QAEO,iBAFP;AAGA,SAASC,eAAT,EAA0BC,aAA1B,EAAyCC,iBAAzC,QAAkE,aAAlE;AACA,SAASC,MAAT,QAAuB,gBAAvB;AAqBA,OAAM,MAAOC,eAAP,CAAsB;AAU1BC,cAAaC,UAAb,EAA2CC,IAA3C,EAAoE;AAClE,UAAM;AAAEC,gBAAF;AAAcC,eAAd;AAAyBC,iBAAzB;AAAsCC,kBAAtC;AAAoDC,kBAApD;AAAkEC,aAAlE;AAA2EC;AAA3E,QAAmFP,IAAzF;AAEA,SAAKD,UAAL,GAAkBA,UAAlB;AACA,SAAKS,GAAL,GAAWZ,MAAM,CAAC,kBAAkBW,GAAG,GAAG,KAAH,GAAW,KAAK,mBAAtC,CAAjB;AACA,SAAKN,UAAL,GAAkBA,UAAlB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAEa,QAARG,QAAQ,CAAEC,GAAF,EAAmBC,GAAnB,EAAkC;AAC9C,UAAMC,KAAK,GAAGjB,iBAAiB,CAACe,GAAD,CAA/B;AACA,UAAM,KAAKX,UAAL,CAAgBc,SAAhB,CAA0BC,GAA1B,CAA8BF,KAA9B,EAAqCD,GAArC,CAAN;AACD;AAED;;;;;;AAIc,QAARI,QAAQ,CAAEL,GAAF,EAAiB;AAC7B,SAAKF,GAAL,CAAS,aAAT,EAAwBE,GAAxB;AAEA,UAAME,KAAK,GAAGjB,iBAAiB,CAACe,GAAD,CAA/B;AAEA,SAAKF,GAAL,CAAS,4BAAT,EAAuCI,KAAvC;AAEA,UAAMI,GAAG,GAAG,MAAM,KAAKjB,UAAL,CAAgBc,SAAhB,CAA0BI,GAA1B,CAA8BL,KAA9B,CAAlB;AACA,SAAKJ,GAAL,CAAS,6BAAT,EAAwCI,KAAxC;AAEA,UAAMD,GAAG,GAAG7B,YAAY,CAACoC,WAAb,CAAyBF,GAAzB,CAAZ;AAEA,UAAMjC,YAAY,CAAC,KAAKkB,UAAN,EAAkBU,GAAlB,CAAlB;AAEA,WAAOA,GAAP;AACD;AAED;;;;;AAG4B,SAApBQ,oBAAoB,CAAET,GAAF,EAAmBU,IAAnB,EAAuCC,IAAvC,EAAmF;AAAA,QAA1BC,OAA0B,uEAAF,EAAE;AAC7G,SAAKd,GAAL,CAAS,uBAAT,EAAkCE,GAAlC;AACA,UAAMa,QAAQ,GAAG9B,eAAe,CAACiB,GAAD,EAAMW,IAAN,CAAhC;;AAEA,SAAK,MAAM;AAAEG,WAAF;AAASC;AAAT,KAAX,IAA8BL,IAA9B,EAAoC;AAClC;AACA,UAAIvC,gBAAgB,CAAC2C,KAAD,EAAQH,IAAR,CAApB,EAAmC;AACjC,aAAKb,GAAL,CAAS,eAAT;AACA;AACD,OALiC,CAOlC;;;AACA,UAAI,KAAKT,UAAL,CAAgB2B,MAAhB,CAAuB9C,MAAvB,CAA8B6C,IAA9B,CAAJ,EAAyC;AACvC,YAAI;AACF,gBAAMb,KAAK,GAAGjB,iBAAiB,CAACe,GAAD,CAA/B;AACA,eAAKF,GAAL,CAAS,oCAAoCI,KAAK,CAACe,QAAN,EAAgB,EAA7D;AACA,gBAAM,KAAK5B,UAAL,CAAgBc,SAAhB,CAA0BC,GAA1B,CAA8BF,KAA9B,EAAqCW,QAAQ,CAACK,QAAT,EAArC,CAAN;AACD,SAJD,CAIE,OAAOC,GAAP,EAAiB;AACjB,eAAKrB,GAAL,CAASsB,KAAT,CAAe,8BAAf,EAA+CD,GAA/C;AACD;;AAED;AACD,OAlBiC,CAoBlC;;;AACA,UAAIE,cAAc,GAAG,KAArB;AACA,YAAMC,OAAO,GAAG,IAAI3C,OAAJ,CAAYC,YAAY,CAAC2C,SAAzB,EAAoCvB,GAApC,EAAyC,CAAzC,CAAhB;AACAsB,aAAO,CAACE,MAAR,GAAiBpD,YAAY,CAACoC,WAAb,CAAyBK,QAAzB,CAAjB;;AAEA,iBAAW,MAAMY,KAAjB,IAA0B,KAAK7B,OAAL,CAAa8B,WAAb,CAAyBX,IAAzB,EAA+BO,OAA/B,EAAwCV,OAAxC,CAA1B,EAA4E;AAC1E,YAAIa,KAAK,CAACE,IAAN,KAAe,eAAf,IAAmCF,KAAK,CAACD,MAAN,IAAgB,IAAnD,IAA4DrD,gBAAgB,CAACsD,KAAK,CAACD,MAAN,CAAaV,KAAd,EAAqB1C,YAAY,CAACoC,WAAb,CAAyBK,QAAzB,EAAmCC,KAAxD,CAAhF,EAAgJ;AAC9IO,wBAAc,GAAG,IAAjB;AACD;;AAED,cAAMI,KAAN;AACD;;AAED,UAAI,CAACJ,cAAL,EAAqB;AACnB,cAAM3C,eAAe,CAAC;AAAEqC,cAAF;AAAQK,eAAK,EAAE,IAAInD,SAAJ,CAAc,yBAAd,EAAyC,uBAAzC;AAAf,SAAD,CAArB;AACD;;AAED,WAAK6B,GAAL,CAASsB,KAAT,CAAe,+BAAf;AACD;AACF;AAED;;;;;AAGW,SAAHhB,GAAG,CAAEJ,GAAF,EAAmBc,KAAnB,EAAgE;AAAA,QAA1BF,OAA0B,uEAAF,EAAE;AACzE,SAAKd,GAAL,CAAS,qBAAT,EAAgCE,GAAhC,EAAqCc,KAArC,EADyE,CAGzE;;AACA,UAAMU,MAAM,GAAGzC,eAAe,CAACiB,GAAD,EAAMc,KAAN,CAA9B,CAJyE,CAMzE;;AACA,UAAMZ,KAAK,GAAGjB,iBAAiB,CAACe,GAAD,CAA/B;AACA,SAAKF,GAAL,CAAS,0BAA0BI,KAAK,CAACe,QAAN,EAAgB,EAAnD;AACA,UAAM,KAAK5B,UAAL,CAAgBc,SAAhB,CAA0BC,GAA1B,CAA8BF,KAA9B,EAAqCsB,MAAM,CAACN,QAAP,EAArC,CAAN,CATyE,CAWzE;;AACA,WAAQrC,IAAI,CACV,KAAKY,WAAL,CAAiBmC,eAAjB,CAAiC5B,GAAjC,EAAsC;AAAE6B,YAAM,EAAEjB,OAAO,CAACiB;AAAlB,KAAtC,CADU,EAETC,MAAD,IAAYtD,GAAG,CAACsD,MAAD,EAAUL,KAAD,IAAU;AAChC,aAAO,YAAW;AAChB,YAAIA,KAAK,CAACE,IAAN,KAAe,YAAnB,EAAiC;AAC/B,iBAAO,CAACF,KAAD,CAAP;AACD;;AAED,cAAMM,MAAM,GAAG,EAAf;AAEA,cAAMC,GAAG,GAAG,IAAIrD,OAAJ,CAAYC,YAAY,CAAC2C,SAAzB,EAAoCvB,GAApC,EAAyC,CAAzC,CAAZ;AACAgC,WAAG,CAACR,MAAJ,GAAapD,YAAY,CAACoC,WAAb,CAAyBgB,MAAzB,CAAb;AAEA,aAAK1B,GAAL,CAAS,gBAAT,EAA2B2B,KAAK,CAACQ,IAAN,CAAWC,EAAtC;;AACA,mBAAW,MAAMC,QAAjB,IAA6B,KAAKvC,OAAL,CAAa8B,WAAb,CAAyBD,KAAK,CAACQ,IAAN,CAAWC,EAApC,EAAwCF,GAAxC,EAA6CpB,OAA7C,CAA7B,EAAoF;AAClFmB,gBAAM,CAACK,IAAP,CAAYD,QAAZ;;AAEA,cAAIA,QAAQ,CAACR,IAAT,KAAkB,eAAtB,EAAuC;AACrC;AACD;;AAED,cAAI,EAAEQ,QAAQ,CAACX,MAAT,IAAmB,IAAnB,IAA2BrD,gBAAgB,CAACgE,QAAQ,CAACX,MAAT,CAAgBV,KAAjB,EAAwB1C,YAAY,CAACoC,WAAb,CAAyBgB,MAAzB,EAAiCV,KAAzD,CAA7C,CAAJ,EAAmH;AACjHiB,kBAAM,CAACK,IAAP,CAAY1D,eAAe,CAAC;AAAEqC,kBAAI,EAAEU,KAAK,CAACQ,IAAN,CAAWC,EAAnB;AAAuBd,mBAAK,EAAE,IAAInD,SAAJ,CAAc,yBAAd,EAAyC,uBAAzC;AAA9B,aAAD,CAA3B;AACD;AACF;;AAED,eAAO8D,MAAP;AACD,OAxBD;AAyBD,KA1Bc,CAFL,EA6BTD,MAAD,IAAYvD,QAAQ,CAACuD,MAAD,EAAS;AAC3BO,aAAO,EAAE,KADkB;AAE3BC,iBAAW,EAAExD;AAFc,KAAT,CA7BV,EAiCV,iBAAkBgD,MAAlB,EAAwB;AACtB,iBAAW,MAAMC,MAAjB,IAA2BD,MAA3B,EAAmC;AACjC,eAAQC,MAAR;AACD;AACF,KArCS,CAAZ;AAuCD;AAED;;;;;AAGW,SAAHxB,GAAG,CAAEP,GAAF,EAA6C;AAAA,QAA1BY,OAA0B,uEAAF,EAAE;AACtD,SAAKd,GAAL,CAAS,QAAT,EAAmBE,GAAnB;AAEA,UAAMU,IAAI,GAAiB,EAA3B;;AAEA,eAAW,MAAMe,KAAjB,IAA0B,KAAKc,OAAL,CAAavC,GAAb,EAAkBY,OAAlB,CAA1B,EAAsD;AACpD,UAAIa,KAAK,CAACE,IAAN,KAAe,OAAnB,EAA4B;AAC1BjB,YAAI,CAAC0B,IAAL,CAAUX,KAAV;AACD;;AAED,YAAMA,KAAN;AACD;;AAED,QAAIf,IAAI,CAAC8B,MAAL,KAAgB,CAApB,EAAuB;AACrB;AACD;;AAED,UAAMC,OAAO,GAAG/B,IAAI,CAAClC,GAAL,CAAUkE,CAAD,IAAOA,CAAC,CAAC5B,KAAlB,CAAhB;AACA,QAAI6B,CAAC,GAAG,CAAR;;AAEA,QAAI;AACFA,OAAC,GAAGrE,UAAU,CAAC,KAAKkB,SAAN,EAAiBQ,GAAjB,EAAsByC,OAAtB,CAAd;AACD,KAFD,CAEE,OAAOtB,GAAP,EAAiB;AACjB;AACA,UAAIA,GAAG,CAACyB,IAAJ,KAAa,yCAAjB,EAA4D;AAC1D,cAAMzB,GAAN;AACD;AACF;;AAED,UAAMR,IAAI,GAAG8B,OAAO,CAACE,CAAD,CAApB;AACA,SAAK7C,GAAL,CAAS,gBAAT,EAA2BE,GAA3B,EAAgCW,IAAhC;;AAEA,QAAIA,IAAI,IAAI,IAAZ,EAAkB;AAChB,YAAM,IAAI1C,SAAJ,CAAc,0BAAd,EAA0C,eAA1C,CAAN;AACD;;AAED,WAAQ,KAAKwC,oBAAL,CAA0BT,GAA1B,EAA+BU,IAA/B,EAAqCC,IAArC,EAA2CC,OAA3C,CAAR;AAEA,UAAMF,IAAI,CAACiC,CAAD,CAAV;AACD;AAED;;;;;AAGe,SAAPJ,OAAO,CAAEvC,GAAF,EAA6C;AAAA,QAA1BY,OAA0B,uEAAF,EAAE;AAC1D,SAAKd,GAAL,CAAS,uBAAT,EAAkCE,GAAlC;;AAEA,QAAI;AACF,YAAM6C,QAAQ,GAAG,MAAM,KAAKxC,QAAL,CAAcL,GAAd,CAAvB;AAEA,YAAMvB,UAAU,CAAC;AACfqC,aAAK,EAAE+B,QAAQ,CAAC/B,KADD;AAEfC,YAAI,EAAE,KAAK1B,UAAL,CAAgB2B;AAFP,OAAD,CAAhB;AAID,KAPD,CAOE,OAAOG,GAAP,EAAiB;AACjB,WAAKrB,GAAL,CAAS,kCAAT,EAA6CE,GAA7C,EAAkDmB,GAAlD;AACD;;AAED,UAAMe,EAAE,GAAG,MAAMlD,aAAa,CAACgB,GAAD,CAA9B;AACA,UAAM8C,GAAG,GAAG,KAAKnD,YAAL,CAAkBoD,YAAlB,CAA+Bb,EAA/B,CAAZ;AAEA,SAAKpC,GAAL,CAAS,iCAAT,EAA4CgD,GAAG,CAACN,MAAhD;AAEA,UAAMQ,IAAI,GAAG,IAAb,CAnB0D,CAmBxC;;AAElB,UAAMC,aAAa,GAAc,uBAAkC;AAAA,UAAhB;AAAEhB,YAAF;AAAQJ;AAAR,OAAgB;;AACjE,iBAAW,MAAMJ,KAAjB,IAA0BuB,IAAI,CAACvD,WAAL,CAAiByD,eAAjB,CAAiCjB,IAAjC,EAAuCjC,GAAvC,EAA4C;AAAE6B;AAAF,OAA5C,CAA1B,EAAmF;AACjF,cAAMJ,KAAN;;AAEA,YAAIA,KAAK,CAACE,IAAN,KAAe,eAAf,IAAmCF,KAAK,CAACD,MAAN,IAAgB,IAAvD,EAA8D;AAC5D,gBAAM/C,UAAU,CAAC;AAAEsC,gBAAI,EAAEkB,IAAR;AAAcnB,iBAAK,EAAEW,KAAK,CAACD,MAAN,CAAaV;AAAlC,WAAD,CAAhB;AACD;AACF;AACF,KARD,CArB0D,CA+B1D;;;AACA,WAAQ,KAAKpB,YAAL,CAAkByD,GAAlB,CAAsBnD,GAAtB,EAA2B8C,GAA3B,EAAgCG,aAAhC,EAA+CrC,OAA/C,CAAR;AACD;;AAzOyB","names":["CodeError","equals","uint8ArrayEquals","Libp2pRecord","verifyRecord","bestRecord","parallel","map","valueEvent","queryErrorEvent","Message","MESSAGE_TYPE","pipe","ALPHA","createPutRecord","convertBuffer","bufferToRecordKey","logger","ContentFetching","constructor","components","init","validators","selectors","peerRouting","queryManager","routingTable","network","lan","log","putLocal","key","rec","dsKey","datastore","put","getLocal","raw","get","deserialize","sendCorrectionRecord","vals","best","options","fixupRec","value","from","peerId","toString","subarray","err","error","sentCorrection","request","PUT_VALUE","record","event","sendRequest","name","getClosestPeers","signal","source","events","msg","peer","id","putEvent","push","ordered","concurrency","getMany","length","records","v","i","code","localRec","rtp","closestPeers","self","getValueQuery","getValueOrPeers","run"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\content-fetching\\index.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { Libp2pRecord } from '@libp2p/record'\nimport { verifyRecord } from '@libp2p/record/validators'\nimport { bestRecord } from '@libp2p/record/selectors'\nimport parallel from 'it-parallel'\nimport map from 'it-map'\nimport {\n  valueEvent,\n  queryErrorEvent\n} from '../query/events.js'\nimport { Message, MESSAGE_TYPE } from '../message/index.js'\nimport { pipe } from 'it-pipe'\nimport {\n  ALPHA\n} from '../constants.js'\nimport { createPutRecord, convertBuffer, bufferToRecordKey } from '../utils.js'\nimport { logger } from '@libp2p/logger'\nimport type { Validators, Selectors, ValueEvent, QueryOptions, QueryEvent } from '@libp2p/interface-dht'\nimport type { PeerRouting } from '../peer-routing/index.js'\nimport type { QueryManager } from '../query/manager.js'\nimport type { RoutingTable } from '../routing-table/index.js'\nimport type { Network } from '../network.js'\nimport type { Logger } from '@libp2p/logger'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { QueryFunc } from '../query/types.js'\nimport type { KadDHTComponents } from '../index.js'\n\nexport interface ContentFetchingInit {\n  validators: Validators\n  selectors: Selectors\n  peerRouting: PeerRouting\n  queryManager: QueryManager\n  routingTable: RoutingTable\n  network: Network\n  lan: boolean\n}\n\nexport class ContentFetching {\n  private readonly log: Logger\n  private readonly components: KadDHTComponents\n  private readonly validators: Validators\n  private readonly selectors: Selectors\n  private readonly peerRouting: PeerRouting\n  private readonly queryManager: QueryManager\n  private readonly routingTable: RoutingTable\n  private readonly network: Network\n\n  constructor (components: KadDHTComponents, init: ContentFetchingInit) {\n    const { validators, selectors, peerRouting, queryManager, routingTable, network, lan } = init\n\n    this.components = components\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:content-fetching`)\n    this.validators = validators\n    this.selectors = selectors\n    this.peerRouting = peerRouting\n    this.queryManager = queryManager\n    this.routingTable = routingTable\n    this.network = network\n  }\n\n  async putLocal (key: Uint8Array, rec: Uint8Array): Promise<void> {\n    const dsKey = bufferToRecordKey(key)\n    await this.components.datastore.put(dsKey, rec)\n  }\n\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore\n   */\n  async getLocal (key: Uint8Array): Promise<Libp2pRecord> {\n    this.log('getLocal %b', key)\n\n    const dsKey = bufferToRecordKey(key)\n\n    this.log('fetching record for key %k', dsKey)\n\n    const raw = await this.components.datastore.get(dsKey)\n    this.log('found %k in local datastore', dsKey)\n\n    const rec = Libp2pRecord.deserialize(raw)\n\n    await verifyRecord(this.validators, rec)\n\n    return rec\n  }\n\n  /**\n   * Send the best record found to any peers that have an out of date record\n   */\n  async * sendCorrectionRecord (key: Uint8Array, vals: ValueEvent[], best: Uint8Array, options: AbortOptions = {}): AsyncGenerator<QueryEvent> {\n    this.log('sendCorrection for %b', key)\n    const fixupRec = createPutRecord(key, best)\n\n    for (const { value, from } of vals) {\n      // no need to do anything\n      if (uint8ArrayEquals(value, best)) {\n        this.log('record was ok')\n        continue\n      }\n\n      // correct ourself\n      if (this.components.peerId.equals(from)) {\n        try {\n          const dsKey = bufferToRecordKey(key)\n          this.log(`Storing corrected record for key ${dsKey.toString()}`)\n          await this.components.datastore.put(dsKey, fixupRec.subarray())\n        } catch (err: any) {\n          this.log.error('Failed error correcting self', err)\n        }\n\n        continue\n      }\n\n      // send correction\n      let sentCorrection = false\n      const request = new Message(MESSAGE_TYPE.PUT_VALUE, key, 0)\n      request.record = Libp2pRecord.deserialize(fixupRec)\n\n      for await (const event of this.network.sendRequest(from, request, options)) {\n        if (event.name === 'PEER_RESPONSE' && (event.record != null) && uint8ArrayEquals(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {\n          sentCorrection = true\n        }\n\n        yield event\n      }\n\n      if (!sentCorrection) {\n        yield queryErrorEvent({ from, error: new CodeError('value not put correctly', 'ERR_PUT_VALUE_INVALID') })\n      }\n\n      this.log.error('Failed error correcting entry')\n    }\n  }\n\n  /**\n   * Store the given key/value pair in the DHT\n   */\n  async * put (key: Uint8Array, value: Uint8Array, options: AbortOptions = {}): AsyncGenerator<unknown, void, undefined> {\n    this.log('put key %b value %b', key, value)\n\n    // create record in the dht format\n    const record = createPutRecord(key, value)\n\n    // store the record locally\n    const dsKey = bufferToRecordKey(key)\n    this.log(`storing record for key ${dsKey.toString()}`)\n    await this.components.datastore.put(dsKey, record.subarray())\n\n    // put record to the closest peers\n    yield * pipe(\n      this.peerRouting.getClosestPeers(key, { signal: options.signal }),\n      (source) => map(source, (event) => {\n        return async () => {\n          if (event.name !== 'FINAL_PEER') {\n            return [event]\n          }\n\n          const events = []\n\n          const msg = new Message(MESSAGE_TYPE.PUT_VALUE, key, 0)\n          msg.record = Libp2pRecord.deserialize(record)\n\n          this.log('send put to %p', event.peer.id)\n          for await (const putEvent of this.network.sendRequest(event.peer.id, msg, options)) {\n            events.push(putEvent)\n\n            if (putEvent.name !== 'PEER_RESPONSE') {\n              continue\n            }\n\n            if (!(putEvent.record != null && uint8ArrayEquals(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {\n              events.push(queryErrorEvent({ from: event.peer.id, error: new CodeError('value not put correctly', 'ERR_PUT_VALUE_INVALID') }))\n            }\n          }\n\n          return events\n        }\n      }),\n      (source) => parallel(source, {\n        ordered: false,\n        concurrency: ALPHA\n      }),\n      async function * (source) {\n        for await (const events of source) {\n          yield * events\n        }\n      }\n    )\n  }\n\n  /**\n   * Get the value to the given key\n   */\n  async * get (key: Uint8Array, options: QueryOptions = {}): AsyncGenerator<QueryEvent | ValueEvent> {\n    this.log('get %b', key)\n\n    const vals: ValueEvent[] = []\n\n    for await (const event of this.getMany(key, options)) {\n      if (event.name === 'VALUE') {\n        vals.push(event)\n      }\n\n      yield event\n    }\n\n    if (vals.length === 0) {\n      return\n    }\n\n    const records = vals.map((v) => v.value)\n    let i = 0\n\n    try {\n      i = bestRecord(this.selectors, key, records)\n    } catch (err: any) {\n      // Assume the first record if no selector available\n      if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n        throw err\n      }\n    }\n\n    const best = records[i]\n    this.log('GetValue %b %b', key, best)\n\n    if (best == null) {\n      throw new CodeError('best value was not found', 'ERR_NOT_FOUND')\n    }\n\n    yield * this.sendCorrectionRecord(key, vals, best, options)\n\n    yield vals[i]\n  }\n\n  /**\n   * Get the `n` values to the given key without sorting\n   */\n  async * getMany (key: Uint8Array, options: QueryOptions = {}): AsyncGenerator<QueryEvent> {\n    this.log('getMany values for %b', key)\n\n    try {\n      const localRec = await this.getLocal(key)\n\n      yield valueEvent({\n        value: localRec.value,\n        from: this.components.peerId\n      })\n    } catch (err: any) {\n      this.log('error getting local value for %b', key, err)\n    }\n\n    const id = await convertBuffer(key)\n    const rtp = this.routingTable.closestPeers(id)\n\n    this.log('found %d peers in routing table', rtp.length)\n\n    const self = this // eslint-disable-line @typescript-eslint/no-this-alias\n\n    const getValueQuery: QueryFunc = async function * ({ peer, signal }) {\n      for await (const event of self.peerRouting.getValueOrPeers(peer, key, { signal })) {\n        yield event\n\n        if (event.name === 'PEER_RESPONSE' && (event.record != null)) {\n          yield valueEvent({ from: peer, value: event.record.value })\n        }\n      }\n    }\n\n    // we have peers, lets send the actual query to them\n    yield * this.queryManager.run(key, rtp, getValueQuery, options)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}