{"ast":null,"code":"import { EventIterator } from 'event-iterator';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'; // copied from github.com/feross/buffer\n// Some ArrayBuffers are not passing the instanceof check, so we need to do a bit more work :(\n\nfunction isArrayBuffer(obj) {\n  return obj instanceof ArrayBuffer || obj?.constructor?.name === 'ArrayBuffer' && typeof obj?.byteLength === 'number';\n}\n\nexport default (socket => {\n  socket.binaryType = 'arraybuffer';\n\n  const connected = async () => await new Promise((resolve, reject) => {\n    if (isConnected) {\n      return resolve();\n    }\n\n    if (connError != null) {\n      return reject(connError);\n    }\n\n    const cleanUp = cont => {\n      socket.removeEventListener('open', onOpen);\n      socket.removeEventListener('error', onError);\n      cont();\n    };\n\n    const onOpen = () => cleanUp(resolve);\n\n    const onError = event => {\n      cleanUp(() => reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)));\n    };\n\n    socket.addEventListener('open', onOpen);\n    socket.addEventListener('error', onError);\n  });\n\n  const source = async function* () {\n    const messages = new EventIterator(_ref => {\n      let {\n        push,\n        stop,\n        fail\n      } = _ref;\n\n      const onMessage = event => {\n        let data = null;\n\n        if (typeof event.data === 'string') {\n          data = uint8ArrayFromString(event.data);\n        }\n\n        if (isArrayBuffer(event.data)) {\n          data = new Uint8Array(event.data);\n        }\n\n        if (event.data instanceof Uint8Array) {\n          data = event.data;\n        }\n\n        if (data == null) {\n          return;\n        }\n\n        push(data);\n      };\n\n      const onError = event => fail(event.error ?? new Error('Socket error'));\n\n      socket.addEventListener('message', onMessage);\n      socket.addEventListener('error', onError);\n      socket.addEventListener('close', stop);\n      return () => {\n        socket.removeEventListener('message', onMessage);\n        socket.removeEventListener('error', onError);\n        socket.removeEventListener('close', stop);\n      };\n    }, {\n      highWaterMark: Infinity\n    });\n    await connected();\n\n    for await (const chunk of messages) {\n      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;\n    }\n  }();\n\n  let isConnected = socket.readyState === 1;\n  let connError;\n  socket.addEventListener('open', () => {\n    isConnected = true;\n    connError = null;\n  });\n  socket.addEventListener('close', () => {\n    isConnected = false;\n    connError = null;\n  });\n  socket.addEventListener('error', event => {\n    if (!isConnected) {\n      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);\n    }\n  });\n  return Object.assign(source, {\n    connected\n  });\n});","map":{"version":3,"mappings":"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","names":["EventIterator","fromString","uint8ArrayFromString","isArrayBuffer","obj","ArrayBuffer","constructor","name","byteLength","socket","binaryType","connected","Promise","resolve","reject","isConnected","connError","cleanUp","cont","removeEventListener","onOpen","onError","event","error","Error","url","addEventListener","source","messages","push","stop","fail","onMessage","data","Uint8Array","highWaterMark","Infinity","chunk","readyState","Object","assign"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-ws\\src\\source.ts"],"sourcesContent":["\nimport { EventIterator } from 'event-iterator'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { WebSocket, ErrorEvent, MessageEvent } from 'ws'\n\n// copied from github.com/feross/buffer\n// Some ArrayBuffers are not passing the instanceof check, so we need to do a bit more work :(\nfunction isArrayBuffer (obj: any): obj is ArrayBuffer {\n  return (obj instanceof ArrayBuffer) ||\n    (obj?.constructor?.name === 'ArrayBuffer' && typeof obj?.byteLength === 'number')\n}\n\nexport interface ConnectedSource extends AsyncIterable<Uint8Array> {\n  connected: () => Promise<void>\n}\n\nexport default (socket: WebSocket): ConnectedSource => {\n  socket.binaryType = 'arraybuffer'\n\n  const connected = async () => await new Promise<void>((resolve, reject) => {\n    if (isConnected) {\n      return resolve()\n    }\n    if (connError != null) {\n      return reject(connError)\n    }\n\n    const cleanUp = (cont: () => void) => {\n      socket.removeEventListener('open', onOpen)\n      socket.removeEventListener('error', onError)\n      cont()\n    }\n\n    const onOpen = () => cleanUp(resolve)\n    const onError = (event: ErrorEvent) => {\n      cleanUp(() => reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)))\n    }\n\n    socket.addEventListener('open', onOpen)\n    socket.addEventListener('error', onError)\n  })\n\n  const source = (async function * () {\n    const messages = new EventIterator<Uint8Array>(\n      ({ push, stop, fail }) => {\n        const onMessage = (event: MessageEvent) => {\n          let data: Uint8Array | null = null\n\n          if (typeof event.data === 'string') {\n            data = uint8ArrayFromString(event.data)\n          }\n\n          if (isArrayBuffer(event.data)) {\n            data = new Uint8Array(event.data)\n          }\n\n          if (event.data instanceof Uint8Array) {\n            data = event.data\n          }\n\n          if (data == null) {\n            return\n          }\n\n          push(data)\n        }\n        const onError = (event: ErrorEvent) => fail(event.error ?? new Error('Socket error'))\n\n        socket.addEventListener('message', onMessage)\n        socket.addEventListener('error', onError)\n        socket.addEventListener('close', stop)\n\n        return () => {\n          socket.removeEventListener('message', onMessage)\n          socket.removeEventListener('error', onError)\n          socket.removeEventListener('close', stop)\n        }\n      },\n      { highWaterMark: Infinity }\n    )\n\n    await connected()\n\n    for await (const chunk of messages) {\n      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk\n    }\n  }())\n\n  let isConnected = socket.readyState === 1\n  let connError: Error | null\n\n  socket.addEventListener('open', () => {\n    isConnected = true\n    connError = null\n  })\n\n  socket.addEventListener('close', () => {\n    isConnected = false\n    connError = null\n  })\n\n  socket.addEventListener('error', event => {\n    if (!isConnected) {\n      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)\n    }\n  })\n\n  return Object.assign(source, {\n    connected\n  })\n}\n"]},"metadata":{},"sourceType":"module"}