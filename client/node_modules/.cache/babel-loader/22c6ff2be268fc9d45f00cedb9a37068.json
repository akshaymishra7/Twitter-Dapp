{"ast":null,"code":"import { isPeerId } from '@libp2p/interface-peer-id';\nimport { notFoundError } from 'datastore-core/errors';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport * as ipns from 'ipns';\nconst log = logger('ipfs:ipns:publisher');\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-keys').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst ERR_NOT_FOUND = notFoundError().code;\nconst defaultRecordLifetime = 60 * 60 * 1000; // IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\n\nexport class IpnsPublisher {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor(routing, datastore) {\n    this._routing = routing;\n    this._datastore = datastore;\n  }\n  /**\n   * Publish record with a eol\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n\n\n  async publishWithEOL(peerId, value, lifetime, options) {\n    const record = await this._updateOrCreateRecord(peerId, value, lifetime, options);\n    return this._putRecordToRouting(record, peerId, options);\n  }\n  /**\n   * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} options\n   */\n\n\n  publish(peerId, value, options) {\n    return this.publishWithEOL(peerId, value, defaultRecordLifetime, options);\n  }\n  /**\n   * @param {Uint8Array} record\n   * @param {PeerId} peerId\n   * @param {AbortOptions} [options]\n   */\n\n\n  async _putRecordToRouting(record, peerId, options) {\n    if (!isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    if (peerId.publicKey == null) {\n      throw errcode(new Error('Public key was missing'), 'ERR_MISSING_PUBLIC_KEY');\n    }\n\n    const routingKey = ipns.peerIdToRoutingKey(peerId);\n    await this._publishEntry(routingKey, record, options);\n    return record;\n  }\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} entry\n   * @param {AbortOptions} [options]\n   */\n\n\n  async _publishEntry(key, entry, options) {\n    // Add record to routing (buffer key)\n    try {\n      const res = await this._routing.put(key, entry, options);\n      log(`ipns record for ${uint8ArrayToString(key, 'base32')} was stored in the routing`);\n      return res;\n    } catch (\n    /** @type {any} */\n    err) {\n      const errMsg = `ipns record for ${uint8ArrayToString(key, 'base32')} could not be stored in the routing - ${err.stack}`;\n      log.error(errMsg);\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n    }\n  }\n  /**\n   * Returns the record this node has published corresponding to the given peer ID.\n   *\n   * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n   *\n   * @param {PeerId} peerId\n   * @param {object} options\n   * @param {boolean} [options.checkRouting]\n   */\n\n\n  async _getPublished(peerId) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    const checkRouting = options.checkRouting !== false;\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.toBytes())); // unmarshal data\n\n      return this._unmarshalData(dsVal);\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.toString()} from datastore`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');\n      }\n\n      if (!checkRouting) {\n        throw errcode(err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED');\n      } // Try to get from routing\n\n\n      try {\n        const routingKey = ipns.peerIdToRoutingKey(peerId);\n        const res = await this._routing.get(routingKey); // unmarshal data\n\n        return this._unmarshalData(res);\n      } catch (\n      /** @type {any} */\n      err) {\n        log.error(err);\n        throw err;\n      }\n    }\n  }\n  /**\n   * @param {Uint8Array} data\n   */\n\n\n  _unmarshalData(data) {\n    try {\n      return ipns.unmarshal(data);\n    } catch (\n    /** @type {any} */\n    err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA');\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n\n\n  async _updateOrCreateRecord(peerId, value, lifetime, options) {\n    if (!isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    };\n    /** @type {IPNSEntry | undefined} */\n\n    let record;\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions);\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.toString()} ${err.stack}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD');\n      }\n    } // Determinate the record sequence number\n\n\n    let seqNumber = 0n;\n\n    if (record && record.sequence !== undefined) {\n      // Increment if the published value is different\n      seqNumber = uint8ArrayEquals(record.value, value) ? record.sequence : record.sequence + BigInt(1);\n    }\n    /** @type {IPNSEntry} */\n\n\n    let entryData;\n\n    try {\n      // Create record\n      entryData = await ipns.create(peerId, value, seqNumber, lifetime);\n    } catch (\n    /** @type {any} */\n    err) {\n      const errMsg = `ipns record for ${value} could not be created`;\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD');\n    } // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData); // Store the new record\n\n      await this._datastore.put(ipns.getLocalKey(peerId.toBytes()), data, options);\n      log(`ipns record for ${uint8ArrayToString(value, 'base32')} was stored in the datastore`);\n      return data;\n    } catch (\n    /** @type {any} */\n    err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE');\n    }\n  }\n\n}\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/ipns/publisher.js"],"names":["isPeerId","notFoundError","errcode","logger","toString","uint8ArrayToString","equals","uint8ArrayEquals","ipns","log","ERR_NOT_FOUND","code","defaultRecordLifetime","IpnsPublisher","constructor","routing","datastore","_routing","_datastore","publishWithEOL","peerId","value","lifetime","options","record","_updateOrCreateRecord","_putRecordToRouting","publish","errMsg","error","Error","publicKey","routingKey","peerIdToRoutingKey","_publishEntry","key","entry","res","put","err","stack","_getPublished","checkRouting","dsVal","get","getLocalKey","toBytes","_unmarshalData","data","unmarshal","getPublishedOptions","seqNumber","sequence","undefined","BigInt","entryData","create","marshal"],"mappings":"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","sourcesContent":["import { isPeerId } from '@libp2p/interface-peer-id'\nimport { notFoundError } from 'datastore-core/errors'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport * as ipns from 'ipns'\n\nconst log = logger('ipfs:ipns:publisher')\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-keys').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst ERR_NOT_FOUND = notFoundError().code\nconst defaultRecordLifetime = 60 * 60 * 1000\n\n// IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\nexport class IpnsPublisher {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor (routing, datastore) {\n    this._routing = routing\n    this._datastore = datastore\n  }\n\n  /**\n   * Publish record with a eol\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  async publishWithEOL (peerId, value, lifetime, options) {\n    const record = await this._updateOrCreateRecord(peerId, value, lifetime, options)\n\n    return this._putRecordToRouting(record, peerId, options)\n  }\n\n  /**\n   * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} options\n   */\n  publish (peerId, value, options) {\n    return this.publishWithEOL(peerId, value, defaultRecordLifetime, options)\n  }\n\n  /**\n   * @param {Uint8Array} record\n   * @param {PeerId} peerId\n   * @param {AbortOptions} [options]\n   */\n  async _putRecordToRouting (record, peerId, options) {\n    if (!(isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    if (peerId.publicKey == null) {\n      throw errcode(new Error('Public key was missing'), 'ERR_MISSING_PUBLIC_KEY')\n    }\n\n    const routingKey = ipns.peerIdToRoutingKey(peerId)\n\n    await this._publishEntry(routingKey, record, options)\n\n    return record\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} entry\n   * @param {AbortOptions} [options]\n   */\n  async _publishEntry (key, entry, options) {\n    // Add record to routing (buffer key)\n    try {\n      const res = await this._routing.put(key, entry, options)\n      log(`ipns record for ${uint8ArrayToString(key, 'base32')} was stored in the routing`)\n\n      return res\n    } catch (/** @type {any} */err) {\n      const errMsg = `ipns record for ${uint8ArrayToString(key, 'base32')} could not be stored in the routing - ${err.stack}`\n      log.error(errMsg)\n      log.error(err)\n\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING')\n    }\n  }\n\n  /**\n   * Returns the record this node has published corresponding to the given peer ID.\n   *\n   * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n   *\n   * @param {PeerId} peerId\n   * @param {object} options\n   * @param {boolean} [options.checkRouting]\n   */\n  async _getPublished (peerId, options = {}) {\n    if (!(isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const checkRouting = options.checkRouting !== false\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.toBytes()))\n\n      // unmarshal data\n      return this._unmarshalData(dsVal)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.toString()} from datastore`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE')\n      }\n\n      if (!checkRouting) {\n        throw errcode(err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED')\n      }\n\n      // Try to get from routing\n      try {\n        const routingKey = ipns.peerIdToRoutingKey(peerId)\n        const res = await this._routing.get(routingKey)\n\n        // unmarshal data\n        return this._unmarshalData(res)\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n\n        throw err\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  _unmarshalData (data) {\n    try {\n      return ipns.unmarshal(data)\n    } catch (/** @type {any} */ err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA')\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  async _updateOrCreateRecord (peerId, value, lifetime, options) {\n    if (!(isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    }\n\n    /** @type {IPNSEntry | undefined} */\n    let record\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.toString()} ${err.stack}`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD')\n      }\n    }\n\n    // Determinate the record sequence number\n    let seqNumber = 0n\n\n    if (record && record.sequence !== undefined) {\n      // Increment if the published value is different\n      seqNumber = uint8ArrayEquals(record.value, value) ? record.sequence : record.sequence + BigInt(1)\n    }\n\n    /** @type {IPNSEntry} */\n    let entryData\n\n    try {\n      // Create record\n      entryData = await ipns.create(peerId, value, seqNumber, lifetime)\n    } catch (/** @type {any} */ err) {\n      const errMsg = `ipns record for ${value} could not be created`\n\n      log.error(err)\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD')\n    }\n\n    // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData)\n\n      // Store the new record\n      await this._datastore.put(ipns.getLocalKey(peerId.toBytes()), data, options)\n\n      log(`ipns record for ${uint8ArrayToString(value, 'base32')} was stored in the datastore`)\n\n      return data\n    } catch (/** @type {any} */ err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE')\n    }\n  }\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime\n"]},"metadata":{},"sourceType":"module"}