{"ast":null,"code":"/* global EventTarget Event */\nimport defer from 'p-defer';\nconst CustomEvent = globalThis.CustomEvent ?? Event;\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\n\nexport default async function* parallel(source) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let concurrency = options.concurrency ?? Infinity;\n\n  if (concurrency < 1) {\n    concurrency = Infinity;\n  }\n\n  const ordered = options.ordered == null ? false : options.ordered;\n  const emitter = new EventTarget();\n  const ops = [];\n  let slotAvailable = defer();\n  let resultAvailable = defer();\n  let sourceFinished = false;\n  let sourceErr;\n  let opErred = false;\n  emitter.addEventListener('task-complete', () => {\n    resultAvailable.resolve();\n  });\n  void Promise.resolve().then(async () => {\n    try {\n      for await (const task of source) {\n        if (ops.length === concurrency) {\n          slotAvailable = defer();\n          await slotAvailable.promise;\n        }\n\n        if (opErred) {\n          break;\n        }\n\n        const op = {\n          done: false\n        };\n        ops.push(op);\n        task().then(result => {\n          op.done = true;\n          op.ok = true;\n          op.value = result;\n          emitter.dispatchEvent(new CustomEvent('task-complete'));\n        }, err => {\n          op.done = true;\n          op.err = err;\n          emitter.dispatchEvent(new CustomEvent('task-complete'));\n        });\n      }\n\n      sourceFinished = true;\n      emitter.dispatchEvent(new CustomEvent('task-complete'));\n    } catch (err) {\n      sourceErr = err;\n      emitter.dispatchEvent(new CustomEvent('task-complete'));\n    }\n  });\n\n  function valuesAvailable() {\n    if (ordered) {\n      return ops[0]?.done;\n    }\n\n    return Boolean(ops.find(op => op.done));\n  }\n\n  function* yieldOrderedValues() {\n    while (ops.length > 0 && ops[0].done) {\n      const op = ops[0];\n      ops.shift();\n\n      if (op.ok) {\n        yield op.value;\n      } else {\n        // allow the source to exit\n        opErred = true;\n        slotAvailable.resolve();\n        throw op.err;\n      }\n\n      slotAvailable.resolve();\n    }\n  }\n\n  function* yieldUnOrderedValues() {\n    // more values can become available while we wait for `yield`\n    // to return control to this function\n    while (valuesAvailable()) {\n      for (let i = 0; i < ops.length; i++) {\n        if (ops[i].done) {\n          const op = ops[i];\n          ops.splice(i, 1);\n          i--;\n\n          if (op.ok) {\n            yield op.value;\n          } else {\n            opErred = true;\n            slotAvailable.resolve();\n            throw op.err;\n          }\n\n          slotAvailable.resolve();\n        }\n      }\n    }\n  }\n\n  while (true) {\n    if (!valuesAvailable()) {\n      resultAvailable = defer();\n      await resultAvailable.promise;\n    }\n\n    if (sourceErr != null) {\n      // the source threw an error, propagate it\n      throw sourceErr;\n    }\n\n    if (ordered) {\n      yield* yieldOrderedValues();\n    } else {\n      yield* yieldUnOrderedValues();\n    }\n\n    if (sourceFinished && ops.length === 0) {\n      // not waiting for any results and no more tasks so we are done\n      break;\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["defer","CustomEvent","globalThis","Event","parallel","source","options","concurrency","Infinity","ordered","emitter","EventTarget","ops","slotAvailable","resultAvailable","sourceFinished","sourceErr","opErred","addEventListener","resolve","Promise","then","task","length","promise","op","done","push","result","ok","value","dispatchEvent","err","valuesAvailable","Boolean","find","yieldOrderedValues","shift","yieldUnOrderedValues","i","splice"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-parallel\\src\\index.ts"],"sourcesContent":["/* global EventTarget Event */\n\nimport defer from 'p-defer'\n\ninterface Operation<T> {\n  done: boolean\n  ok: boolean\n  err: Error\n  value: T\n}\n\nconst CustomEvent = globalThis.CustomEvent ?? Event\n\nexport interface ParallelOptions {\n  /**\n   * How many jobs to execute in parallel (default: )\n   */\n  concurrency?: number\n  ordered?: boolean\n}\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function * parallel <T> (source: Iterable<() => Promise<T>> | AsyncIterable<() => Promise<T>>, options: ParallelOptions = {}): AsyncGenerator<T, void, undefined> {\n  let concurrency = options.concurrency ?? Infinity\n\n  if (concurrency < 1) {\n    concurrency = Infinity\n  }\n\n  const ordered = options.ordered == null ? false : options.ordered\n  const emitter = new EventTarget()\n\n  const ops: Array<Operation<T>> = []\n  let slotAvailable = defer()\n  let resultAvailable = defer()\n  let sourceFinished = false\n  let sourceErr: Error | undefined\n  let opErred = false\n\n  emitter.addEventListener('task-complete', () => {\n    resultAvailable.resolve()\n  })\n\n  void Promise.resolve().then(async () => {\n    try {\n      for await (const task of source) {\n        if (ops.length === concurrency) {\n          slotAvailable = defer()\n          await slotAvailable.promise\n        }\n\n        if (opErred) {\n          break\n        }\n\n        const op: any = {\n          done: false\n        }\n        ops.push(op)\n\n        task()\n          .then(result => {\n            op.done = true\n            op.ok = true\n            op.value = result\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          }, err => {\n            op.done = true\n            op.err = err\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          })\n      }\n\n      sourceFinished = true\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    } catch (err: any) {\n      sourceErr = err\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    }\n  })\n\n  function valuesAvailable (): boolean {\n    if (ordered) {\n      return ops[0]?.done\n    }\n\n    return Boolean(ops.find(op => op.done))\n  }\n\n  function * yieldOrderedValues (): Generator<T, void, unknown> {\n    while ((ops.length > 0) && ops[0].done) {\n      const op = ops[0]\n      ops.shift()\n\n      if (op.ok) {\n        yield op.value\n      } else {\n        // allow the source to exit\n        opErred = true\n        slotAvailable.resolve()\n\n        throw op.err\n      }\n\n      slotAvailable.resolve()\n    }\n  }\n\n  function * yieldUnOrderedValues (): Generator<T, void, unknown> {\n    // more values can become available while we wait for `yield`\n    // to return control to this function\n    while (valuesAvailable()) {\n      for (let i = 0; i < ops.length; i++) {\n        if (ops[i].done) {\n          const op = ops[i]\n          ops.splice(i, 1)\n          i--\n\n          if (op.ok) {\n            yield op.value\n          } else {\n            opErred = true\n            slotAvailable.resolve()\n\n            throw op.err\n          }\n\n          slotAvailable.resolve()\n        }\n      }\n    }\n  }\n\n  while (true) {\n    if (!valuesAvailable()) {\n      resultAvailable = defer()\n      await resultAvailable.promise\n    }\n\n    if (sourceErr != null) {\n      // the source threw an error, propagate it\n      throw sourceErr\n    }\n\n    if (ordered) {\n      yield * yieldOrderedValues()\n    } else {\n      yield * yieldUnOrderedValues()\n    }\n\n    if (sourceFinished && ops.length === 0) {\n      // not waiting for any results and no more tasks so we are done\n      break\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}