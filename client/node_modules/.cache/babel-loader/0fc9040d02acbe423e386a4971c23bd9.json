{"ast":null,"code":"import { BaseBlockstore } from 'blockstore-core';\nimport merge from 'it-merge';\nimport { pushable } from 'it-pushable';\nimport filter from 'it-filter';\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Query} Query\n * @typedef {import('interface-blockstore').KeyQuery} KeyQuery\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-bitswap').IPFSBitswap} Bitswap\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/block').RmOptions} RmOptions\n */\n\n/**\n * BlockStorage is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n *\n * @implements {Blockstore}\n */\n\nexport class BlockStorage extends BaseBlockstore {\n  /**\n   * Create a new BlockStorage\n   *\n   * @param {Blockstore} blockstore\n   * @param {Bitswap} bitswap\n   */\n  constructor(blockstore, bitswap) {\n    super();\n    this.child = blockstore;\n    this.bitswap = bitswap;\n  }\n\n  open() {\n    return this.child.open();\n  }\n\n  close() {\n    return this.child.close();\n  }\n\n  unwrap() {\n    return this.child;\n  }\n  /**\n   * Put a block to the underlying datastore\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {AbortOptions} [options]\n   */\n\n\n  async put(cid, block) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (await this.has(cid)) {\n      return;\n    }\n\n    if (this.bitswap.isStarted()) {\n      await this.bitswap.put(cid, block, options);\n    } else {\n      await this.child.put(cid, block, options);\n    }\n  }\n  /**\n   * Put a multiple blocks to the underlying datastore\n   *\n   * @param {AsyncIterable<{ key: CID, value: Uint8Array }> | Iterable<{ key: CID, value: Uint8Array }>} blocks\n   * @param {AbortOptions} [options]\n   */\n\n\n  async *putMany(blocks) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const missingBlocks = filter(blocks, async _ref => {\n      let {\n        key\n      } = _ref;\n      return !(await this.has(key));\n    });\n\n    if (this.bitswap.isStarted()) {\n      yield* this.bitswap.putMany(missingBlocks, options);\n    } else {\n      yield* this.child.putMany(missingBlocks, options);\n    }\n  }\n  /**\n   * Get a block by cid\n   *\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n\n\n  async get(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!(await this.has(cid)) && this.bitswap.isStarted()) {\n      return this.bitswap.get(cid, options);\n    } else {\n      return this.child.get(cid, options);\n    }\n  }\n  /**\n   * Get multiple blocks back from an array of cids\n   *\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {AbortOptions} [options]\n   */\n\n\n  async *getMany(cids) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const getFromBitswap = pushable({\n      objectMode: true\n    });\n    const getFromChild = pushable({\n      objectMode: true\n    });\n    Promise.resolve().then(async () => {\n      for await (const cid of cids) {\n        if (!(await this.has(cid)) && this.bitswap.isStarted()) {\n          getFromBitswap.push(cid);\n        } else {\n          getFromChild.push(cid);\n        }\n      }\n\n      getFromBitswap.end();\n      getFromChild.end();\n    });\n    yield* merge(this.bitswap.getMany(getFromBitswap, options), this.child.getMany(getFromChild, options));\n  }\n  /**\n   * Delete a block from the blockstore\n   *\n   * @param {CID} cid\n   * @param {RmOptions} [options]\n   */\n\n\n  async delete(cid, options) {\n    await this.child.delete(cid, options);\n  }\n  /**\n   * Delete multiple blocks from the blockstore\n   *\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {RmOptions} [options]\n   */\n\n\n  async *deleteMany(cids, options) {\n    yield* this.child.deleteMany(cids, options);\n  }\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} options\n   */\n\n\n  async has(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.child.has(cid, options);\n  }\n  /**\n   * @param {Query} q\n   * @param {AbortOptions} options\n   */\n\n\n  async *query(q) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.child.query(q, options);\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {AbortOptions} options\n   */\n\n\n  async *queryKeys(q) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.child.queryKeys(q, options);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/block-storage.js"],"names":["BaseBlockstore","merge","pushable","filter","BlockStorage","constructor","blockstore","bitswap","child","open","close","unwrap","put","cid","block","options","has","isStarted","putMany","blocks","missingBlocks","key","get","getMany","cids","getFromBitswap","objectMode","getFromChild","Promise","resolve","then","push","end","delete","deleteMany","query","q","queryKeys"],"mappings":"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","sourcesContent":["import { BaseBlockstore } from 'blockstore-core'\nimport merge from 'it-merge'\nimport { pushable } from 'it-pushable'\nimport filter from 'it-filter'\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Query} Query\n * @typedef {import('interface-blockstore').KeyQuery} KeyQuery\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-bitswap').IPFSBitswap} Bitswap\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/block').RmOptions} RmOptions\n */\n\n/**\n * BlockStorage is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n *\n * @implements {Blockstore}\n */\nexport class BlockStorage extends BaseBlockstore {\n  /**\n   * Create a new BlockStorage\n   *\n   * @param {Blockstore} blockstore\n   * @param {Bitswap} bitswap\n   */\n  constructor (blockstore, bitswap) {\n    super()\n\n    this.child = blockstore\n    this.bitswap = bitswap\n  }\n\n  open () {\n    return this.child.open()\n  }\n\n  close () {\n    return this.child.close()\n  }\n\n  unwrap () {\n    return this.child\n  }\n\n  /**\n   * Put a block to the underlying datastore\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {AbortOptions} [options]\n   */\n  async put (cid, block, options = {}) {\n    if (await this.has(cid)) {\n      return\n    }\n\n    if (this.bitswap.isStarted()) {\n      await this.bitswap.put(cid, block, options)\n    } else {\n      await this.child.put(cid, block, options)\n    }\n  }\n\n  /**\n   * Put a multiple blocks to the underlying datastore\n   *\n   * @param {AsyncIterable<{ key: CID, value: Uint8Array }> | Iterable<{ key: CID, value: Uint8Array }>} blocks\n   * @param {AbortOptions} [options]\n   */\n  async * putMany (blocks, options = {}) {\n    const missingBlocks = filter(blocks, async ({ key }) => { return !(await this.has(key)) })\n\n    if (this.bitswap.isStarted()) {\n      yield * this.bitswap.putMany(missingBlocks, options)\n    } else {\n      yield * this.child.putMany(missingBlocks, options)\n    }\n  }\n\n  /**\n   * Get a block by cid\n   *\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n  async get (cid, options = {}) {\n    if (!(await this.has(cid)) && this.bitswap.isStarted()) {\n      return this.bitswap.get(cid, options)\n    } else {\n      return this.child.get(cid, options)\n    }\n  }\n\n  /**\n   * Get multiple blocks back from an array of cids\n   *\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {AbortOptions} [options]\n   */\n  async * getMany (cids, options = {}) {\n    const getFromBitswap = pushable({ objectMode: true })\n    const getFromChild = pushable({ objectMode: true })\n\n    Promise.resolve().then(async () => {\n      for await (const cid of cids) {\n        if (!(await this.has(cid)) && this.bitswap.isStarted()) {\n          getFromBitswap.push(cid)\n        } else {\n          getFromChild.push(cid)\n        }\n      }\n\n      getFromBitswap.end()\n      getFromChild.end()\n    })\n\n    yield * merge(\n      this.bitswap.getMany(getFromBitswap, options),\n      this.child.getMany(getFromChild, options)\n    )\n  }\n\n  /**\n   * Delete a block from the blockstore\n   *\n   * @param {CID} cid\n   * @param {RmOptions} [options]\n   */\n  async delete (cid, options) {\n    await this.child.delete(cid, options)\n  }\n\n  /**\n   * Delete multiple blocks from the blockstore\n   *\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {RmOptions} [options]\n   */\n  async * deleteMany (cids, options) {\n    yield * this.child.deleteMany(cids, options)\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} options\n   */\n  async has (cid, options = {}) {\n    return this.child.has(cid, options)\n  }\n\n  /**\n   * @param {Query} q\n   * @param {AbortOptions} options\n   */\n  async * query (q, options = {}) {\n    yield * this.child.query(q, options)\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {AbortOptions} options\n   */\n  async * queryKeys (q, options = {}) {\n    yield * this.child.queryKeys(q, options)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}