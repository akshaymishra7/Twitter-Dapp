{"ast":null,"code":"import { bytes as binary, CID } from './index.js'; // Linter can see that API is used in types.\n// eslint-disable-next-line\n\nimport * as API from './interface.js';\n\nfunction readonly() {\n  let {\n    enumerable = true,\n    configurable = false\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    enumerable,\n    configurable,\n    writable: false\n  };\n}\n/**\n * @param {[string|number, string]} path\n * @param {any} value\n * @returns {Iterable<[string, CID]>}\n */\n\n\nfunction* linksWithin(path, value) {\n  if (value != null && typeof value === 'object') {\n    if (Array.isArray(value)) {\n      for (const [index, element] of value.entries()) {\n        const elementPath = [...path, index];\n        const cid = CID.asCID(element);\n\n        if (cid) {\n          yield [elementPath.join('/'), cid];\n        } else if (typeof element === 'object') {\n          yield* links(element, elementPath);\n        }\n      }\n    } else {\n      const cid = CID.asCID(value);\n\n      if (cid) {\n        yield [path.join('/'), cid];\n      } else {\n        yield* links(value, path);\n      }\n    }\n  }\n}\n/**\n * @template T\n * @param {T} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\n\n\nfunction* links(source, base) {\n  if (source == null || source instanceof Uint8Array) {\n    return;\n  }\n\n  const cid = CID.asCID(source);\n\n  if (cid) {\n    yield [base.join('/'), cid];\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path =\n    /** @type {[string|number, string]} */\n    [...base, key];\n    yield* linksWithin(path, value);\n  }\n}\n/**\n * @param {[string|number, string]} path\n * @param {any} value\n * @returns {Iterable<string>}\n */\n\n\nfunction* treeWithin(path, value) {\n  if (Array.isArray(value)) {\n    for (const [index, element] of value.entries()) {\n      const elementPath = [...path, index];\n      yield elementPath.join('/');\n\n      if (typeof element === 'object' && !CID.asCID(element)) {\n        yield* tree(element, elementPath);\n      }\n    }\n  } else {\n    yield* tree(value, path);\n  }\n}\n/**\n * @template T\n * @param {T} source\n * @param {Array<string|number>} base\n * @returns {Iterable<string>}\n */\n\n\nfunction* tree(source, base) {\n  if (source == null || typeof source !== 'object') {\n    return;\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path =\n    /** @type {[string|number, string]} */\n    [...base, key];\n    yield path.join('/');\n\n    if (value != null && !(value instanceof Uint8Array) && typeof value === 'object' && !CID.asCID(value)) {\n      yield* treeWithin(path, value);\n    }\n  }\n}\n/**\n *\n * @template T\n * @param {T} source\n * @param {string[]} path\n * @returns {API.BlockCursorView<unknown>}\n */\n\n\nfunction get(source, path) {\n  let node =\n  /** @type {Record<string, any>} */\n  source;\n\n  for (const [index, key] of path.entries()) {\n    node = node[key];\n\n    if (node == null) {\n      throw new Error(`Object has no property at ${path.slice(0, index + 1).map(part => `[${JSON.stringify(part)}]`).join('')}`);\n    }\n\n    const cid = CID.asCID(node);\n\n    if (cid) {\n      return {\n        value: cid,\n        remaining: path.slice(index + 1).join('/')\n      };\n    }\n  }\n\n  return {\n    value: node\n  };\n}\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} C - multicodec code corresponding to codec used to encode the block\n * @template {number} A - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @implements {API.BlockView<T, C, A, V>}\n */\n\n\nclass Block {\n  /**\n   * @param {object} options\n   * @param {CID<T, C, A, V>} options.cid\n   * @param {API.ByteView<T>} options.bytes\n   * @param {T} options.value\n   */\n  constructor(_ref) {\n    let {\n      cid,\n      bytes,\n      value\n    } = _ref;\n\n    if (!cid || !bytes || typeof value === 'undefined') {\n      throw new Error('Missing required argument');\n    }\n\n    this.cid = cid;\n    this.bytes = bytes;\n    this.value = value;\n    this.asBlock = this; // Mark all the properties immutable\n\n    Object.defineProperties(this, {\n      cid: readonly(),\n      bytes: readonly(),\n      value: readonly(),\n      asBlock: readonly()\n    });\n  }\n\n  links() {\n    return links(this.value, []);\n  }\n\n  tree() {\n    return tree(this.value, []);\n  }\n  /**\n   *\n   * @param {string} [path]\n   * @returns {API.BlockCursorView<unknown>}\n   */\n\n\n  get() {\n    let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n    return get(this.value, path.split('/').filter(Boolean));\n  }\n\n}\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @param {object} options\n * @param {T} options.value\n * @param {API.BlockEncoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg>>}\n */\n\n\nasync function encode(_ref2) {\n  let {\n    value,\n    codec,\n    hasher\n  } = _ref2;\n  if (typeof value === 'undefined') throw new Error('Missing required argument \"value\"');\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher');\n  const bytes = codec.encode(value);\n  const hash = await hasher.digest(bytes);\n  /** @type {CID<T, Code, Alg, 1>} */\n\n  const cid = CID.create(1, codec.code, hash);\n  return new Block({\n    value,\n    bytes,\n    cid\n  });\n}\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @param {object} options\n * @param {API.ByteView<T>} options.bytes\n * @param {API.BlockDecoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg>>}\n */\n\n\nasync function decode(_ref3) {\n  let {\n    bytes,\n    codec,\n    hasher\n  } = _ref3;\n  if (!bytes) throw new Error('Missing required argument \"bytes\"');\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher');\n  const value = codec.decode(bytes);\n  const hash = await hasher.digest(bytes);\n  /** @type {CID<T, Code, Alg, 1>} */\n\n  const cid = CID.create(1, codec.code, hash);\n  return new Block({\n    value,\n    bytes,\n    cid\n  });\n}\n/**\n * @typedef {object} RequiredCreateOptions\n * @property {CID} options.cid\n */\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @param {{ cid: API.Link<T, Code, Alg, V>, value:T, codec?: API.BlockDecoder<Code, T>, bytes: API.ByteView<T> }|{cid:API.Link<T, Code, Alg, V>, bytes:API.ByteView<T>, value?:void, codec:API.BlockDecoder<Code, T>}} options\n * @returns {API.BlockView<T, Code, Alg, V>}\n */\n\n\nfunction createUnsafe(_ref4) {\n  let {\n    bytes,\n    cid,\n    value: maybeValue,\n    codec\n  } = _ref4;\n  const value = maybeValue !== undefined ? maybeValue : codec && codec.decode(bytes);\n  if (value === undefined) throw new Error('Missing required argument, must either provide \"value\" or \"codec\"');\n  return new Block({\n    // eslint-disable-next-line object-shorthand\n    cid:\n    /** @type {CID<T, Code, Alg, V>} */\n    cid,\n    bytes,\n    value\n  });\n}\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @param {object} options\n * @param {API.Link<T, Code, Alg, V>} options.cid\n * @param {API.ByteView<T>} options.bytes\n * @param {API.BlockDecoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg, V>>}\n */\n\n\nasync function create(_ref5) {\n  let {\n    bytes,\n    cid,\n    hasher,\n    codec\n  } = _ref5;\n  if (!bytes) throw new Error('Missing required argument \"bytes\"');\n  if (!hasher) throw new Error('Missing required argument \"hasher\"');\n  const value = codec.decode(bytes);\n  const hash = await hasher.digest(bytes);\n\n  if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n    throw new Error('CID hash does not match bytes');\n  }\n\n  return createUnsafe({\n    bytes,\n    cid,\n    value,\n    codec\n  });\n}\n\nexport { encode, decode, create, createUnsafe, Block };","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/multiformats/src/block.js"],"names":["bytes","binary","CID","API","readonly","enumerable","configurable","writable","linksWithin","path","value","Array","isArray","index","element","entries","elementPath","cid","asCID","join","links","source","base","Uint8Array","key","Object","treeWithin","tree","get","node","Error","slice","map","part","JSON","stringify","remaining","Block","constructor","asBlock","defineProperties","split","filter","Boolean","encode","codec","hasher","hash","digest","create","code","decode","createUnsafe","maybeValue","undefined","equals","multihash"],"mappings":"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","sourcesContent":["import { bytes as binary, CID } from './index.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\nfunction readonly ({ enumerable = true, configurable = false } = {}) {\n  return { enumerable, configurable, writable: false }\n}\n\n/**\n * @param {[string|number, string]} path\n * @param {any} value\n * @returns {Iterable<[string, CID]>}\n */\nfunction * linksWithin (path, value) {\n  if (value != null && typeof value === 'object') {\n    if (Array.isArray(value)) {\n      for (const [index, element] of value.entries()) {\n        const elementPath = [...path, index]\n        const cid = CID.asCID(element)\n        if (cid) {\n          yield [elementPath.join('/'), cid]\n        } else if (typeof element === 'object') {\n          yield * links(element, elementPath)\n        }\n      }\n    } else {\n      const cid = CID.asCID(value)\n      if (cid) {\n        yield [path.join('/'), cid]\n      } else {\n        yield * links(value, path)\n      }\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nfunction * links (source, base) {\n  if (source == null || source instanceof Uint8Array) {\n    return\n  }\n  const cid = CID.asCID(source)\n  if (cid) {\n    yield [base.join('/'), cid]\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = /** @type {[string|number, string]} */ ([...base, key])\n    yield * linksWithin(path, value)\n  }\n}\n\n/**\n * @param {[string|number, string]} path\n * @param {any} value\n * @returns {Iterable<string>}\n */\nfunction * treeWithin (path, value) {\n  if (Array.isArray(value)) {\n    for (const [index, element] of value.entries()) {\n      const elementPath = [...path, index]\n      yield elementPath.join('/')\n      if (typeof element === 'object' && !CID.asCID(element)) {\n        yield * tree(element, elementPath)\n      }\n    }\n  } else {\n    yield * tree(value, path)\n  }\n}\n\n/**\n * @template T\n * @param {T} source\n * @param {Array<string|number>} base\n * @returns {Iterable<string>}\n */\nfunction * tree (source, base) {\n  if (source == null || typeof source !== 'object') {\n    return\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = /** @type {[string|number, string]} */ ([...base, key])\n    yield path.join('/')\n    if (value != null && !(value instanceof Uint8Array) && typeof value === 'object' && !CID.asCID(value)) {\n      yield * treeWithin(path, value)\n    }\n  }\n}\n\n/**\n *\n * @template T\n * @param {T} source\n * @param {string[]} path\n * @returns {API.BlockCursorView<unknown>}\n */\nfunction get (source, path) {\n  let node = /** @type {Record<string, any>} */(source)\n  for (const [index, key] of path.entries()) {\n    node = node[key]\n    if (node == null) {\n      throw new Error(`Object has no property at ${path.slice(0, index + 1).map(part => `[${JSON.stringify(part)}]`).join('')}`)\n    }\n    const cid = CID.asCID(node)\n    if (cid) {\n      return { value: cid, remaining: path.slice(index + 1).join('/') }\n    }\n  }\n  return { value: node }\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} C - multicodec code corresponding to codec used to encode the block\n * @template {number} A - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @implements {API.BlockView<T, C, A, V>}\n */\nclass Block {\n  /**\n   * @param {object} options\n   * @param {CID<T, C, A, V>} options.cid\n   * @param {API.ByteView<T>} options.bytes\n   * @param {T} options.value\n   */\n  constructor ({ cid, bytes, value }) {\n    if (!cid || !bytes || typeof value === 'undefined') { throw new Error('Missing required argument') }\n\n    this.cid = cid\n    this.bytes = bytes\n    this.value = value\n    this.asBlock = this\n\n    // Mark all the properties immutable\n    Object.defineProperties(this, {\n      cid: readonly(),\n      bytes: readonly(),\n      value: readonly(),\n      asBlock: readonly()\n    })\n  }\n\n  links () {\n    return links(this.value, [])\n  }\n\n  tree () {\n    return tree(this.value, [])\n  }\n\n  /**\n   *\n   * @param {string} [path]\n   * @returns {API.BlockCursorView<unknown>}\n   */\n  get (path = '/') {\n    return get(this.value, path.split('/').filter(Boolean))\n  }\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @param {object} options\n * @param {T} options.value\n * @param {API.BlockEncoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg>>}\n */\nasync function encode ({ value, codec, hasher }) {\n  if (typeof value === 'undefined') throw new Error('Missing required argument \"value\"')\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher')\n\n  const bytes = codec.encode(value)\n  const hash = await hasher.digest(bytes)\n  /** @type {CID<T, Code, Alg, 1>} */\n  const cid = CID.create(\n    1,\n    codec.code,\n    hash\n  )\n\n  return new Block({ value, bytes, cid })\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @param {object} options\n * @param {API.ByteView<T>} options.bytes\n * @param {API.BlockDecoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg>>}\n */\nasync function decode ({ bytes, codec, hasher }) {\n  if (!bytes) throw new Error('Missing required argument \"bytes\"')\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher')\n\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n  /** @type {CID<T, Code, Alg, 1>} */\n  const cid = CID.create(1, codec.code, hash)\n\n  return new Block({ value, bytes, cid })\n}\n\n/**\n * @typedef {object} RequiredCreateOptions\n * @property {CID} options.cid\n */\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @param {{ cid: API.Link<T, Code, Alg, V>, value:T, codec?: API.BlockDecoder<Code, T>, bytes: API.ByteView<T> }|{cid:API.Link<T, Code, Alg, V>, bytes:API.ByteView<T>, value?:void, codec:API.BlockDecoder<Code, T>}} options\n * @returns {API.BlockView<T, Code, Alg, V>}\n */\nfunction createUnsafe ({ bytes, cid, value: maybeValue, codec }) {\n  const value = maybeValue !== undefined\n    ? maybeValue\n    : (codec && codec.decode(bytes))\n\n  if (value === undefined) throw new Error('Missing required argument, must either provide \"value\" or \"codec\"')\n\n  return new Block({\n    // eslint-disable-next-line object-shorthand\n    cid: /** @type {CID<T, Code, Alg, V>} */ (cid),\n    bytes,\n    value\n  })\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @param {object} options\n * @param {API.Link<T, Code, Alg, V>} options.cid\n * @param {API.ByteView<T>} options.bytes\n * @param {API.BlockDecoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg, V>>}\n */\nasync function create ({ bytes, cid, hasher, codec }) {\n  if (!bytes) throw new Error('Missing required argument \"bytes\"')\n  if (!hasher) throw new Error('Missing required argument \"hasher\"')\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n  if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n    throw new Error('CID hash does not match bytes')\n  }\n\n  return createUnsafe({\n    bytes,\n    cid,\n    value,\n    codec\n  })\n}\n\nexport { encode, decode, create, createUnsafe, Block }\n"]},"metadata":{},"sourceType":"module"}