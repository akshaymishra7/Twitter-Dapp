{"ast":null,"code":"import { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { marshalPublicKey, unmarshalPublicKey } from '@libp2p/crypto/keys';\nimport { randomBytes } from '@libp2p/crypto';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { RPC } from '../message/rpc.js';\nimport { PublishConfigType, ValidateError } from '../types.js';\nimport { StrictSign, StrictNoSign } from '@libp2p/interface-pubsub';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nexport const SignPrefix = uint8ArrayFromString('libp2p-pubsub:');\nexport async function buildRawMessage(publishConfig, topic, originalData, transformedData) {\n  switch (publishConfig.type) {\n    case PublishConfigType.Signing:\n      {\n        const rpcMsg = {\n          from: publishConfig.author.toBytes(),\n          data: transformedData,\n          seqno: randomBytes(8),\n          topic,\n          signature: undefined,\n          key: undefined // Exclude key field for signing\n\n        }; // Get the message in bytes, and prepend with the pubsub prefix\n        // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n\n        const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsg).finish()]);\n        rpcMsg.signature = await publishConfig.privateKey.sign(bytes);\n        rpcMsg.key = publishConfig.key;\n        const msg = {\n          type: 'signed',\n          from: publishConfig.author,\n          data: originalData,\n          sequenceNumber: BigInt(`0x${uint8ArrayToString(rpcMsg.seqno, 'base16')}`),\n          topic,\n          signature: rpcMsg.signature,\n          key: rpcMsg.key\n        };\n        return {\n          raw: rpcMsg,\n          msg: msg\n        };\n      }\n\n    case PublishConfigType.Anonymous:\n      {\n        return {\n          raw: {\n            from: undefined,\n            data: transformedData,\n            seqno: undefined,\n            topic,\n            signature: undefined,\n            key: undefined\n          },\n          msg: {\n            type: 'unsigned',\n            data: originalData,\n            topic\n          }\n        };\n      }\n  }\n}\nexport async function validateToRawMessage(signaturePolicy, msg) {\n  // If strict-sign, verify all\n  // If anonymous (no-sign), ensure no preven\n  switch (signaturePolicy) {\n    case StrictNoSign:\n      if (msg.signature != null) return {\n        valid: false,\n        error: ValidateError.SignaturePresent\n      };\n      if (msg.seqno != null) return {\n        valid: false,\n        error: ValidateError.SeqnoPresent\n      };\n      if (msg.key != null) return {\n        valid: false,\n        error: ValidateError.FromPresent\n      };\n      return {\n        valid: true,\n        message: {\n          type: 'unsigned',\n          topic: msg.topic,\n          data: msg.data ?? new Uint8Array(0)\n        }\n      };\n\n    case StrictSign:\n      {\n        // Verify seqno\n        if (msg.seqno == null) return {\n          valid: false,\n          error: ValidateError.InvalidSeqno\n        };\n\n        if (msg.seqno.length !== 8) {\n          return {\n            valid: false,\n            error: ValidateError.InvalidSeqno\n          };\n        }\n\n        if (msg.signature == null) return {\n          valid: false,\n          error: ValidateError.InvalidSignature\n        };\n        if (msg.from == null) return {\n          valid: false,\n          error: ValidateError.InvalidPeerId\n        };\n        let fromPeerId;\n\n        try {\n          // TODO: Fix PeerId types\n          fromPeerId = peerIdFromBytes(msg.from);\n        } catch (e) {\n          return {\n            valid: false,\n            error: ValidateError.InvalidPeerId\n          };\n        } // - check from defined\n        // - transform source to PeerId\n        // - parse signature\n        // - get .key, else from source\n        // - check key == source if present\n        // - verify sig\n\n\n        let publicKey;\n\n        if (msg.key) {\n          publicKey = unmarshalPublicKey(msg.key); // TODO: Should `fromPeerId.pubKey` be optional?\n\n          if (fromPeerId.publicKey !== undefined && !uint8ArrayEquals(publicKey.bytes, fromPeerId.publicKey)) {\n            return {\n              valid: false,\n              error: ValidateError.InvalidPeerId\n            };\n          }\n        } else {\n          if (fromPeerId.publicKey == null) {\n            return {\n              valid: false,\n              error: ValidateError.InvalidPeerId\n            };\n          }\n\n          publicKey = unmarshalPublicKey(fromPeerId.publicKey);\n        }\n\n        const rpcMsgPreSign = {\n          from: msg.from,\n          data: msg.data,\n          seqno: msg.seqno,\n          topic: msg.topic,\n          signature: undefined,\n          key: undefined // Exclude key field for signing\n\n        }; // Get the message in bytes, and prepend with the pubsub prefix\n        // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n\n        const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsgPreSign).finish()]);\n\n        if (!(await publicKey.verify(bytes, msg.signature))) {\n          return {\n            valid: false,\n            error: ValidateError.InvalidSignature\n          };\n        }\n\n        return {\n          valid: true,\n          message: {\n            type: 'signed',\n            from: fromPeerId,\n            data: msg.data ?? new Uint8Array(0),\n            sequenceNumber: BigInt(`0x${uint8ArrayToString(msg.seqno, 'base16')}`),\n            topic: msg.topic,\n            signature: msg.signature,\n            key: msg.key ?? marshalPublicKey(publicKey)\n          }\n        };\n      }\n  }\n}","map":{"version":3,"mappings":"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","names":["concat","uint8ArrayConcat","fromString","uint8ArrayFromString","marshalPublicKey","unmarshalPublicKey","randomBytes","peerIdFromBytes","equals","uint8ArrayEquals","RPC","PublishConfigType","ValidateError","StrictSign","StrictNoSign","toString","uint8ArrayToString","SignPrefix","buildRawMessage","publishConfig","topic","originalData","transformedData","type","Signing","rpcMsg","from","author","toBytes","data","seqno","signature","undefined","key","bytes","Message","encode","finish","privateKey","sign","msg","sequenceNumber","BigInt","raw","Anonymous","validateToRawMessage","signaturePolicy","valid","error","SignaturePresent","SeqnoPresent","FromPresent","message","Uint8Array","InvalidSeqno","length","InvalidSignature","InvalidPeerId","fromPeerId","e","publicKey","rpcMsgPreSign","verify"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\utils\\buildRawMessage.ts"],"sourcesContent":["import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { marshalPublicKey, unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { randomBytes } from '@libp2p/crypto'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport type { PublicKey } from '@libp2p/interface-keys'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { RPC } from '../message/rpc.js'\nimport { PublishConfig, PublishConfigType, TopicStr, ValidateError } from '../types.js'\nimport { StrictSign, StrictNoSign, Message } from '@libp2p/interface-pubsub'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nexport const SignPrefix = uint8ArrayFromString('libp2p-pubsub:')\n\nexport type RawMessageAndMessage = {\n  raw: RPC.IMessage\n  msg: Message\n}\n\nexport async function buildRawMessage(\n  publishConfig: PublishConfig,\n  topic: TopicStr,\n  originalData: Uint8Array,\n  transformedData: Uint8Array\n): Promise<RawMessageAndMessage> {\n  switch (publishConfig.type) {\n    case PublishConfigType.Signing: {\n      const rpcMsg: RPC.IMessage = {\n        from: publishConfig.author.toBytes(),\n        data: transformedData,\n        seqno: randomBytes(8),\n        topic,\n        signature: undefined, // Exclude signature field for signing\n        key: undefined // Exclude key field for signing\n      }\n\n      // Get the message in bytes, and prepend with the pubsub prefix\n      // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n      const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsg).finish()])\n\n      rpcMsg.signature = await publishConfig.privateKey.sign(bytes)\n      rpcMsg.key = publishConfig.key\n\n      const msg: Message = {\n        type: 'signed',\n        from: publishConfig.author,\n        data: originalData,\n        sequenceNumber: BigInt(`0x${uint8ArrayToString(rpcMsg.seqno as Uint8Array, 'base16')}`),\n        topic,\n        signature: rpcMsg.signature,\n        key: rpcMsg.key\n      }\n      return {\n        raw: rpcMsg,\n        msg: msg\n      }\n    }\n\n    case PublishConfigType.Anonymous: {\n      return {\n        raw: {\n          from: undefined,\n          data: transformedData,\n          seqno: undefined,\n          topic,\n          signature: undefined,\n          key: undefined\n        },\n        msg: {\n          type: 'unsigned',\n          data: originalData,\n          topic\n        }\n      }\n    }\n  }\n}\n\nexport type ValidationResult = { valid: true; message: Message } | { valid: false; error: ValidateError }\n\nexport async function validateToRawMessage(\n  signaturePolicy: typeof StrictNoSign | typeof StrictSign,\n  msg: RPC.IMessage\n): Promise<ValidationResult> {\n  // If strict-sign, verify all\n  // If anonymous (no-sign), ensure no preven\n\n  switch (signaturePolicy) {\n    case StrictNoSign:\n      if (msg.signature != null) return { valid: false, error: ValidateError.SignaturePresent }\n      if (msg.seqno != null) return { valid: false, error: ValidateError.SeqnoPresent }\n      if (msg.key != null) return { valid: false, error: ValidateError.FromPresent }\n\n      return { valid: true, message: { type: 'unsigned', topic: msg.topic, data: msg.data ?? new Uint8Array(0) } }\n\n    case StrictSign: {\n      // Verify seqno\n      if (msg.seqno == null) return { valid: false, error: ValidateError.InvalidSeqno }\n      if (msg.seqno.length !== 8) {\n        return { valid: false, error: ValidateError.InvalidSeqno }\n      }\n\n      if (msg.signature == null) return { valid: false, error: ValidateError.InvalidSignature }\n      if (msg.from == null) return { valid: false, error: ValidateError.InvalidPeerId }\n\n      let fromPeerId: PeerId\n      try {\n        // TODO: Fix PeerId types\n        fromPeerId = peerIdFromBytes(msg.from)\n      } catch (e) {\n        return { valid: false, error: ValidateError.InvalidPeerId }\n      }\n\n      // - check from defined\n      // - transform source to PeerId\n      // - parse signature\n      // - get .key, else from source\n      // - check key == source if present\n      // - verify sig\n\n      let publicKey: PublicKey\n      if (msg.key) {\n        publicKey = unmarshalPublicKey(msg.key)\n        // TODO: Should `fromPeerId.pubKey` be optional?\n        if (fromPeerId.publicKey !== undefined && !uint8ArrayEquals(publicKey.bytes, fromPeerId.publicKey)) {\n          return { valid: false, error: ValidateError.InvalidPeerId }\n        }\n      } else {\n        if (fromPeerId.publicKey == null) {\n          return { valid: false, error: ValidateError.InvalidPeerId }\n        }\n        publicKey = unmarshalPublicKey(fromPeerId.publicKey)\n      }\n\n      const rpcMsgPreSign: RPC.IMessage = {\n        from: msg.from,\n        data: msg.data,\n        seqno: msg.seqno,\n        topic: msg.topic,\n        signature: undefined, // Exclude signature field for signing\n        key: undefined // Exclude key field for signing\n      }\n\n      // Get the message in bytes, and prepend with the pubsub prefix\n      // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n      const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsgPreSign).finish()])\n\n      if (!(await publicKey.verify(bytes, msg.signature))) {\n        return { valid: false, error: ValidateError.InvalidSignature }\n      }\n\n      return {\n        valid: true,\n        message: {\n          type: 'signed',\n          from: fromPeerId,\n          data: msg.data ?? new Uint8Array(0),\n          sequenceNumber: BigInt(`0x${uint8ArrayToString(msg.seqno, 'base16')}`),\n          topic: msg.topic,\n          signature: msg.signature,\n          key: msg.key ?? marshalPublicKey(publicKey)\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}