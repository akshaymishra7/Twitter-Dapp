{"ast":null,"code":"/* eslint complexity: [\"error\", 28] */\nimport defaultMigrations from './migrations/index.js';\nimport * as repoVersion from './repo/version.js';\nimport * as Errors from './errors.js';\nimport { wrapBackends } from './utils.js';\nimport debug from 'debug';\nconst log = debug('ipfs:repo:migrator');\n/**\n * @typedef {import('./types').Migration} Migration\n * @typedef {import('./types').MigrationOptions} MigrationOptions\n * @typedef {import('./types').ProgressCallback} ProgressCallback\n * @typedef {import('./types').MigrationProgressCallback} MigrationProgressCallback\n */\n\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {Migration[]} [migrations] - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n */\n\nexport function getLatestMigrationVersion(migrations) {\n  migrations = migrations || defaultMigrations;\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0;\n  }\n\n  return migrations[migrations.length - 1].version;\n}\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo should be migrated.\n * @param {MigrationOptions} [options] - Options for migration\n */\n\nexport async function migrate(path, backends, repoOptions, toVersion) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  const ignoreLock = options.ignoreLock ?? false;\n  const onProgress = options.onProgress;\n  const isDryRun = options.isDryRun ?? false;\n  const migrations = options.migrations ?? defaultMigrations;\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!');\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!');\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('toVersion argument is required!');\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!');\n  } // make sure we can read pre-level@5 datastores\n\n\n  backends = wrapBackends(backends);\n  const currentVersion = await repoVersion.getVersion(backends);\n\n  if (currentVersion === toVersion) {\n    log('Nothing to migrate.');\n    return;\n  }\n\n  if (currentVersion > toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);\n  }\n\n  verifyAvailableMigrations(migrations, currentVersion, toVersion);\n  let lock;\n\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path);\n  }\n\n  try {\n    for (const migration of migrations) {\n      if (toVersion !== undefined && migration.version > toVersion) {\n        break;\n      }\n\n      if (migration.version <= currentVersion) {\n        continue;\n      }\n\n      log(`Migrating version ${migration.version}`);\n\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {};\n\n          if (onProgress) {\n            // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n          }\n\n          await migration.migrate(backends, progressCallback);\n        }\n      } catch (\n      /** @type {any} */\n      e) {\n        const lastSuccessfullyMigratedVersion = migration.version - 1;\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);\n        await repoVersion.setVersion(lastSuccessfullyMigratedVersion, backends);\n        throw new Error(`During migration to version ${migration.version} exception was raised: ${e.stack || e.message || e}`);\n      }\n\n      log(`Migrating to version ${migration.version} finished`);\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion || getLatestMigrationVersion(migrations), backends);\n    }\n\n    log('Repo successfully migrated', toVersion !== undefined ? `to version ${toVersion}!` : 'to latest version!');\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close();\n    }\n  }\n}\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo will be reverted.\n * @param {MigrationOptions} [options] - Options for the reversion\n */\n\nexport async function revert(path, backends, repoOptions, toVersion) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  const ignoreLock = options.ignoreLock ?? false;\n  const onProgress = options.onProgress;\n  const isDryRun = options.isDryRun ?? false;\n  const migrations = options.migrations ?? defaultMigrations;\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!');\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!');\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!');\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!');\n  } // make sure we can read pre-level@5 datastores\n\n\n  backends = wrapBackends(backends);\n  const currentVersion = await repoVersion.getVersion(backends);\n\n  if (currentVersion === toVersion) {\n    log('Nothing to revert.');\n    return;\n  }\n\n  if (currentVersion < toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);\n  }\n\n  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);\n  let lock;\n\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path);\n  }\n\n  log(`Reverting from version ${currentVersion} to ${toVersion}`);\n\n  try {\n    const reversedMigrationArray = migrations.slice().reverse();\n\n    for (const migration of reversedMigrationArray) {\n      if (migration.version <= toVersion) {\n        break;\n      }\n\n      if (migration.version > currentVersion) {\n        continue;\n      }\n\n      log(`Reverting migration version ${migration.version}`);\n\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {};\n\n          if (onProgress) {\n            // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n          }\n\n          await migration.revert(backends, progressCallback);\n        }\n      } catch (\n      /** @type {any} */\n      e) {\n        const lastSuccessfullyRevertedVersion = migration.version;\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);\n        await repoVersion.setVersion(lastSuccessfullyRevertedVersion, backends);\n        e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`;\n        throw e;\n      }\n\n      log(`Reverting to version ${migration.version} finished`);\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion, backends);\n    }\n\n    log(`All migrations successfully reverted to version ${toVersion}!`);\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close();\n    }\n  }\n}\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {Migration[]} migrations\n * @param {number} fromVersion\n * @param {number} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n */\n\nfunction verifyAvailableMigrations(migrations, fromVersion, toVersion) {\n  let checkReversibility = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let migrationCounter = 0;\n\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break;\n    }\n\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`);\n      }\n\n      migrationCounter++;\n    }\n  }\n\n  if (migrationCounter !== toVersion - fromVersion) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);\n  }\n}\n\nexport const getCurrentRepoVersion = repoVersion.getVersion;\nexport const errors = Errors;\nexport const migrations = defaultMigrations;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-repo-migrations/src/index.js"],"names":["defaultMigrations","repoVersion","Errors","wrapBackends","debug","log","getLatestMigrationVersion","migrations","Array","isArray","length","version","migrate","path","backends","repoOptions","toVersion","options","ignoreLock","onProgress","isDryRun","errors","RequiredParameterError","Number","isInteger","InvalidValueError","currentVersion","getVersion","verifyAvailableMigrations","lock","repoLock","migration","undefined","progressCallback","percent","message","toFixed","e","lastSuccessfullyMigratedVersion","setVersion","Error","stack","close","revert","reversedMigrationArray","slice","reverse","lastSuccessfullyRevertedVersion","fromVersion","checkReversibility","migrationCounter","NonReversibleMigrationError","getCurrentRepoVersion"],"mappings":"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","sourcesContent":["/* eslint complexity: [\"error\", 28] */\n\nimport defaultMigrations from './migrations/index.js'\nimport * as repoVersion from './repo/version.js'\nimport * as Errors from './errors.js'\nimport { wrapBackends } from './utils.js'\nimport debug from 'debug'\n\nconst log = debug('ipfs:repo:migrator')\n\n/**\n * @typedef {import('./types').Migration} Migration\n * @typedef {import('./types').MigrationOptions} MigrationOptions\n * @typedef {import('./types').ProgressCallback} ProgressCallback\n * @typedef {import('./types').MigrationProgressCallback} MigrationProgressCallback\n */\n\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {Migration[]} [migrations] - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n */\nexport function getLatestMigrationVersion (migrations) {\n  migrations = migrations || defaultMigrations\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0\n  }\n\n  return migrations[migrations.length - 1].version\n}\n\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo should be migrated.\n * @param {MigrationOptions} [options] - Options for migration\n */\nexport async function migrate (path, backends, repoOptions, toVersion, options = {}) {\n  const ignoreLock = options.ignoreLock ?? false\n  const onProgress = options.onProgress\n  const isDryRun = options.isDryRun ?? false\n  const migrations = options.migrations ?? defaultMigrations\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('toVersion argument is required!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  // make sure we can read pre-level@5 datastores\n  backends = wrapBackends(backends)\n\n  const currentVersion = await repoVersion.getVersion(backends)\n\n  if (currentVersion === toVersion) {\n    log('Nothing to migrate.')\n    return\n  }\n\n  if (currentVersion > toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`)\n  }\n\n  verifyAvailableMigrations(migrations, currentVersion, toVersion)\n\n  let lock\n\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path)\n  }\n\n  try {\n    for (const migration of migrations) {\n      if (toVersion !== undefined && migration.version > toVersion) {\n        break\n      }\n\n      if (migration.version <= currentVersion) {\n        continue\n      }\n\n      log(`Migrating version ${migration.version}`)\n\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {}\n\n          if (onProgress) { // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message)\n          }\n\n          await migration.migrate(backends, progressCallback)\n        }\n      } catch (/** @type {any} */ e) {\n        const lastSuccessfullyMigratedVersion = migration.version - 1\n\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`)\n        await repoVersion.setVersion(lastSuccessfullyMigratedVersion, backends)\n\n        throw new Error(`During migration to version ${migration.version} exception was raised: ${e.stack || e.message || e}`)\n      }\n\n      log(`Migrating to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion || getLatestMigrationVersion(migrations), backends)\n    }\n\n    log('Repo successfully migrated', toVersion !== undefined ? `to version ${toVersion}!` : 'to latest version!')\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close()\n    }\n  }\n}\n\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo will be reverted.\n * @param {MigrationOptions} [options] - Options for the reversion\n */\nexport async function revert (path, backends, repoOptions, toVersion, options = {}) {\n  const ignoreLock = options.ignoreLock ?? false\n  const onProgress = options.onProgress\n  const isDryRun = options.isDryRun ?? false\n  const migrations = options.migrations ?? defaultMigrations\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  // make sure we can read pre-level@5 datastores\n  backends = wrapBackends(backends)\n\n  const currentVersion = await repoVersion.getVersion(backends)\n\n  if (currentVersion === toVersion) {\n    log('Nothing to revert.')\n    return\n  }\n\n  if (currentVersion < toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`)\n  }\n\n  verifyAvailableMigrations(migrations, toVersion, currentVersion, true)\n\n  let lock\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path)\n  }\n\n  log(`Reverting from version ${currentVersion} to ${toVersion}`)\n\n  try {\n    const reversedMigrationArray = migrations.slice().reverse()\n\n    for (const migration of reversedMigrationArray) {\n      if (migration.version <= toVersion) {\n        break\n      }\n\n      if (migration.version > currentVersion) {\n        continue\n      }\n\n      log(`Reverting migration version ${migration.version}`)\n\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {}\n\n          if (onProgress) { // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message)\n          }\n\n          await migration.revert(backends, progressCallback)\n        }\n      } catch (/** @type {any} */ e) {\n        const lastSuccessfullyRevertedVersion = migration.version\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`)\n        await repoVersion.setVersion(lastSuccessfullyRevertedVersion, backends)\n\n        e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`\n        throw e\n      }\n\n      log(`Reverting to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion, backends)\n    }\n\n    log(`All migrations successfully reverted to version ${toVersion}!`)\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close()\n    }\n  }\n}\n\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {Migration[]} migrations\n * @param {number} fromVersion\n * @param {number} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n */\nfunction verifyAvailableMigrations (migrations, fromVersion, toVersion, checkReversibility = false) {\n  let migrationCounter = 0\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break\n    }\n\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`)\n      }\n\n      migrationCounter++\n    }\n  }\n\n  if (migrationCounter !== (toVersion - fromVersion)) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`)\n  }\n}\n\nexport const getCurrentRepoVersion = repoVersion.getVersion\nexport const errors = Errors\nexport const migrations = defaultMigrations\n"]},"metadata":{},"sourceType":"module"}