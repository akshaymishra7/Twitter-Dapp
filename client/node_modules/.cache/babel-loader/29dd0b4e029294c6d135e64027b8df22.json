{"ast":null,"code":"import * as ed from '@noble/ed25519';\nconst PUBLIC_KEY_BYTE_LENGTH = 32;\nconst PRIVATE_KEY_BYTE_LENGTH = 64; // private key is actually 32 bytes but for historical reasons we concat private and public keys\n\nconst KEYS_BYTE_LENGTH = 32;\nexport { PUBLIC_KEY_BYTE_LENGTH as publicKeyLength };\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength };\nexport async function generateKey() {\n  // the actual private key (32 bytes)\n  const privateKeyRaw = ed.utils.randomPrivateKey();\n  const publicKey = await ed.getPublicKey(privateKeyRaw); // concatenated the public key to the private key\n\n  const privateKey = concatKeys(privateKeyRaw, publicKey);\n  return {\n    privateKey,\n    publicKey\n  };\n}\n/**\n * Generate keypair from a 32 byte uint8array\n */\n\nexport async function generateKeyFromSeed(seed) {\n  if (seed.length !== KEYS_BYTE_LENGTH) {\n    throw new TypeError('\"seed\" must be 32 bytes in length.');\n  } else if (!(seed instanceof Uint8Array)) {\n    throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.');\n  } // based on node forges algorithm, the seed is used directly as private key\n\n\n  const privateKeyRaw = seed;\n  const publicKey = await ed.getPublicKey(privateKeyRaw);\n  const privateKey = concatKeys(privateKeyRaw, publicKey);\n  return {\n    privateKey,\n    publicKey\n  };\n}\nexport async function hashAndSign(privateKey, msg) {\n  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);\n  return ed.sign(msg, privateKeyRaw);\n}\nexport async function hashAndVerify(publicKey, sig, msg) {\n  return ed.verify(sig, msg, publicKey);\n}\n\nfunction concatKeys(privateKeyRaw, publicKey) {\n  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);\n\n  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n    privateKey[i] = privateKeyRaw[i];\n    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];\n  }\n\n  return privateKey;\n}","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,EAAZ,MAAoB,gBAApB;AAGA,MAAMC,sBAAsB,GAAG,EAA/B;AACA,MAAMC,uBAAuB,GAAG,EAAhC,C,CAAmC;;AACnC,MAAMC,gBAAgB,GAAG,EAAzB;AAEA,SAASF,sBAAsB,IAAIG,eAAnC;AACA,SAASF,uBAAuB,IAAIG,gBAApC;AAEA,OAAO,eAAeC,WAAf,GAA0B;AAC/B;AACA,QAAMC,aAAa,GAAGP,EAAE,CAACQ,KAAH,CAASC,gBAAT,EAAtB;AACA,QAAMC,SAAS,GAAG,MAAMV,EAAE,CAACW,YAAH,CAAgBJ,aAAhB,CAAxB,CAH+B,CAK/B;;AACA,QAAMK,UAAU,GAAGC,UAAU,CAACN,aAAD,EAAgBG,SAAhB,CAA7B;AAEA,SAAO;AACLE,cADK;AAELF;AAFK,GAAP;AAID;AAED;;;;AAGA,OAAO,eAAeI,mBAAf,CAAoCC,IAApC,EAAoD;AACzD,MAAIA,IAAI,CAACC,MAAL,KAAgBb,gBAApB,EAAsC;AACpC,UAAM,IAAIc,SAAJ,CAAc,oCAAd,CAAN;AACD,GAFD,MAEO,IAAI,EAAEF,IAAI,YAAYG,UAAlB,CAAJ,EAAmC;AACxC,UAAM,IAAID,SAAJ,CAAc,iDAAd,CAAN;AACD,GALwD,CAOzD;;;AACA,QAAMV,aAAa,GAAGQ,IAAtB;AACA,QAAML,SAAS,GAAG,MAAMV,EAAE,CAACW,YAAH,CAAgBJ,aAAhB,CAAxB;AAEA,QAAMK,UAAU,GAAGC,UAAU,CAACN,aAAD,EAAgBG,SAAhB,CAA7B;AAEA,SAAO;AACLE,cADK;AAELF;AAFK,GAAP;AAID;AAED,OAAO,eAAeS,WAAf,CAA4BP,UAA5B,EAAoDQ,GAApD,EAAmE;AACxE,QAAMb,aAAa,GAAGK,UAAU,CAACS,QAAX,CAAoB,CAApB,EAAuBlB,gBAAvB,CAAtB;AAEA,SAAOH,EAAE,CAACsB,IAAH,CAAQF,GAAR,EAAab,aAAb,CAAP;AACD;AAED,OAAO,eAAegB,aAAf,CAA8Bb,SAA9B,EAAqDc,GAArD,EAAsEJ,GAAtE,EAAqF;AAC1F,SAAOpB,EAAE,CAACyB,MAAH,CAAUD,GAAV,EAAeJ,GAAf,EAAoBV,SAApB,CAAP;AACD;;AAED,SAASG,UAAT,CAAqBN,aAArB,EAAgDG,SAAhD,EAAqE;AACnE,QAAME,UAAU,GAAG,IAAIM,UAAJ,CAAehB,uBAAf,CAAnB;;AACA,OAAK,IAAIwB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvB,gBAApB,EAAsCuB,CAAC,EAAvC,EAA2C;AACzCd,cAAU,CAACc,CAAD,CAAV,GAAgBnB,aAAa,CAACmB,CAAD,CAA7B;AACAd,cAAU,CAACT,gBAAgB,GAAGuB,CAApB,CAAV,GAAmChB,SAAS,CAACgB,CAAD,CAA5C;AACD;;AACD,SAAOd,UAAP;AACD","names":["ed","PUBLIC_KEY_BYTE_LENGTH","PRIVATE_KEY_BYTE_LENGTH","KEYS_BYTE_LENGTH","publicKeyLength","privateKeyLength","generateKey","privateKeyRaw","utils","randomPrivateKey","publicKey","getPublicKey","privateKey","concatKeys","generateKeyFromSeed","seed","length","TypeError","Uint8Array","hashAndSign","msg","subarray","sign","hashAndVerify","sig","verify","i"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\crypto\\src\\keys\\ed25519-browser.ts"],"sourcesContent":["import * as ed from '@noble/ed25519'\nimport type { Uint8ArrayKeyPair } from './interface'\n\nconst PUBLIC_KEY_BYTE_LENGTH = 32\nconst PRIVATE_KEY_BYTE_LENGTH = 64 // private key is actually 32 bytes but for historical reasons we concat private and public keys\nconst KEYS_BYTE_LENGTH = 32\n\nexport { PUBLIC_KEY_BYTE_LENGTH as publicKeyLength }\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\nexport async function generateKey (): Promise<Uint8ArrayKeyPair> {\n  // the actual private key (32 bytes)\n  const privateKeyRaw = ed.utils.randomPrivateKey()\n  const publicKey = await ed.getPublicKey(privateKeyRaw)\n\n  // concatenated the public key to the private key\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\n/**\n * Generate keypair from a 32 byte uint8array\n */\nexport async function generateKeyFromSeed (seed: Uint8Array): Promise<Uint8ArrayKeyPair> {\n  if (seed.length !== KEYS_BYTE_LENGTH) {\n    throw new TypeError('\"seed\" must be 32 bytes in length.')\n  } else if (!(seed instanceof Uint8Array)) {\n    throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.')\n  }\n\n  // based on node forges algorithm, the seed is used directly as private key\n  const privateKeyRaw = seed\n  const publicKey = await ed.getPublicKey(privateKeyRaw)\n\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\nexport async function hashAndSign (privateKey: Uint8Array, msg: Uint8Array): Promise<Uint8Array> {\n  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH)\n\n  return ed.sign(msg, privateKeyRaw)\n}\n\nexport async function hashAndVerify (publicKey: Uint8Array, sig: Uint8Array, msg: Uint8Array): Promise<boolean> {\n  return ed.verify(sig, msg, publicKey)\n}\n\nfunction concatKeys (privateKeyRaw: Uint8Array, publicKey: Uint8Array): Uint8Array {\n  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH)\n  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n    privateKey[i] = privateKeyRaw[i]\n    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i]\n  }\n  return privateKey\n}\n"]},"metadata":{},"sourceType":"module"}