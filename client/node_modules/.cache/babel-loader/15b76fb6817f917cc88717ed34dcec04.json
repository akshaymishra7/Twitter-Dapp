{"ast":null,"code":"import filter from 'it-filter';\nimport { pushable } from 'it-pushable';\nimport drain from 'it-drain';\nimport { CID } from 'multiformats/cid';\nimport errCode from 'err-code';\nimport { identity } from 'multiformats/hashes/identity';\n/**\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} DatastoreOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @param {Blockstore} store\n * @returns {Blockstore}\n */\n\nexport function createIdStore(store) {\n  return {\n    open() {\n      return store.open();\n    },\n\n    close() {\n      return store.close();\n    },\n\n    query(query, options) {\n      return store.query(query, options);\n    },\n\n    queryKeys(query, options) {\n      return store.queryKeys(query, options);\n    },\n\n    async get(cid, options) {\n      const extracted = extractContents(cid);\n\n      if (extracted.isIdentity) {\n        return Promise.resolve(extracted.digest);\n      }\n\n      return store.get(cid, options);\n    },\n\n    async *getMany(cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options);\n      }\n    },\n\n    async put(cid, buf, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return;\n      }\n\n      await store.put(cid, buf, options);\n    },\n\n    async *putMany(pairs, options) {\n      // in order to return all blocks. we're going to assemble a seperate iterable\n      // return rather than return the resolves of store.putMany using the same\n      // process used by blockstore.putMany\n      const output = pushable({\n        objectMode: true\n      }); // process.nextTick runs on the microtask queue, setImmediate runs on the next\n      // event loop iteration so is slower. Use process.nextTick if it is available.\n\n      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;\n      runner(async () => {\n        try {\n          await drain(store.putMany(async function* () {\n            for await (const {\n              key,\n              value\n            } of pairs) {\n              if (!extractContents(key).isIdentity) {\n                yield {\n                  key,\n                  value\n                };\n              } // if non identity blocks successfully write, blocks are included in output\n\n\n              output.push({\n                key,\n                value\n              });\n            }\n          }()));\n          output.end();\n        } catch (\n        /** @type {any} */\n        err) {\n          output.end(err);\n        }\n      });\n      yield* output;\n    },\n\n    has(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return Promise.resolve(true);\n      }\n\n      return store.has(cid, options);\n    },\n\n    delete(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return Promise.resolve();\n      }\n\n      return store.delete(cid, options);\n    },\n\n    deleteMany(cids, options) {\n      return store.deleteMany(filter(cids, cid => !extractContents(cid).isIdentity), options);\n    },\n\n    batch() {\n      const batch = store.batch();\n      return {\n        put(cid, buf) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n\n          if (isIdentity) {\n            return;\n          }\n\n          batch.put(cid, buf);\n        },\n\n        delete(cid) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n\n          if (isIdentity) {\n            return;\n          }\n\n          batch.delete(cid);\n        },\n\n        commit: options => {\n          return batch.commit(options);\n        }\n      };\n    }\n\n  };\n}\n/**\n * @param {CID} k\n * @returns {{ isIdentity: false } | { isIdentity: true, digest: Uint8Array}}\n */\n\nfunction extractContents(k) {\n  const cid = CID.asCID(k);\n\n  if (cid == null) {\n    throw errCode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n  }\n\n  if (cid.multihash.code !== identity.code) {\n    return {\n      isIdentity: false\n    };\n  }\n\n  return {\n    isIdentity: true,\n    digest: cid.multihash.digest\n  };\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-repo/src/idstore.js"],"names":["filter","pushable","drain","CID","errCode","identity","createIdStore","store","open","close","query","options","queryKeys","get","cid","extracted","extractContents","isIdentity","Promise","resolve","digest","getMany","cids","put","buf","putMany","pairs","output","objectMode","runner","globalThis","process","nextTick","setImmediate","setTimeout","key","value","push","end","err","has","delete","deleteMany","batch","commit","k","asCID","Error","multihash","code"],"mappings":"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","sourcesContent":["\nimport filter from 'it-filter'\nimport { pushable } from 'it-pushable'\nimport drain from 'it-drain'\nimport { CID } from 'multiformats/cid'\nimport errCode from 'err-code'\nimport { identity } from 'multiformats/hashes/identity'\n\n/**\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} DatastoreOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @param {Blockstore} store\n * @returns {Blockstore}\n */\nexport function createIdStore (store) {\n  return {\n    open () {\n      return store.open()\n    },\n\n    close () {\n      return store.close()\n    },\n\n    query (query, options) {\n      return store.query(query, options)\n    },\n\n    queryKeys (query, options) {\n      return store.queryKeys(query, options)\n    },\n\n    async get (cid, options) {\n      const extracted = extractContents(cid)\n      if (extracted.isIdentity) {\n        return Promise.resolve(extracted.digest)\n      }\n      return store.get(cid, options)\n    },\n\n    async * getMany (cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options)\n      }\n    },\n\n    async put (cid, buf, options) {\n      const { isIdentity } = extractContents(cid)\n\n      if (isIdentity) {\n        return\n      }\n\n      await store.put(cid, buf, options)\n    },\n\n    async * putMany (pairs, options) {\n      // in order to return all blocks. we're going to assemble a seperate iterable\n      // return rather than return the resolves of store.putMany using the same\n      // process used by blockstore.putMany\n      const output = pushable({\n        objectMode: true\n      })\n\n      // process.nextTick runs on the microtask queue, setImmediate runs on the next\n      // event loop iteration so is slower. Use process.nextTick if it is available.\n      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : (globalThis.setImmediate || globalThis.setTimeout)\n\n      runner(async () => {\n        try {\n          await drain(store.putMany(async function * () {\n            for await (const { key, value } of pairs) {\n              if (!extractContents(key).isIdentity) {\n                yield { key, value }\n              }\n\n              // if non identity blocks successfully write, blocks are included in output\n              output.push({ key, value })\n            }\n          }()))\n\n          output.end()\n        } catch (/** @type {any} */ err) {\n          output.end(err)\n        }\n      })\n\n      yield * output\n    },\n\n    has (cid, options) {\n      const { isIdentity } = extractContents(cid)\n      if (isIdentity) {\n        return Promise.resolve(true)\n      }\n      return store.has(cid, options)\n    },\n\n    delete (cid, options) {\n      const { isIdentity } = extractContents(cid)\n      if (isIdentity) {\n        return Promise.resolve()\n      }\n      return store.delete(cid, options)\n    },\n\n    deleteMany (cids, options) {\n      return store.deleteMany(filter(cids, (cid) => !extractContents(cid).isIdentity), options)\n    },\n\n    batch () {\n      const batch = store.batch()\n\n      return {\n        put (cid, buf) {\n          const { isIdentity } = extractContents(cid)\n\n          if (isIdentity) {\n            return\n          }\n\n          batch.put(cid, buf)\n        },\n        delete (cid) {\n          const { isIdentity } = extractContents(cid)\n\n          if (isIdentity) {\n            return\n          }\n\n          batch.delete(cid)\n        },\n        commit: (options) => {\n          return batch.commit(options)\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {CID} k\n * @returns {{ isIdentity: false } | { isIdentity: true, digest: Uint8Array}}\n */\nfunction extractContents (k) {\n  const cid = CID.asCID(k)\n\n  if (cid == null) {\n    throw errCode(new Error('Not a valid cid'), 'ERR_INVALID_CID')\n  }\n\n  if (cid.multihash.code !== identity.code) {\n    return {\n      isIdentity: false\n    }\n  }\n\n  return {\n    isIdentity: true,\n    digest: cid.multihash.digest\n  }\n}\n"]},"metadata":{},"sourceType":"module"}