{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport drain from 'it-drain';\nimport PQueue from 'p-queue';\nimport defer from 'p-defer';\nimport errCode from 'err-code';\nimport anySignal from 'any-signal';\nconst log = logger('libp2p:delegated-content-routing');\nconst DEFAULT_TIMEOUT = 30e3; // 30 second default\n\nconst CONCURRENT_HTTP_REQUESTS = 4;\nconst CONCURRENT_HTTP_REFS_REQUESTS = 2;\nexport var EventTypes;\n\n(function (EventTypes) {\n  EventTypes[EventTypes[\"SENDING_QUERY\"] = 0] = \"SENDING_QUERY\";\n  EventTypes[EventTypes[\"PEER_RESPONSE\"] = 1] = \"PEER_RESPONSE\";\n  EventTypes[EventTypes[\"FINAL_PEER\"] = 2] = \"FINAL_PEER\";\n  EventTypes[EventTypes[\"QUERY_ERROR\"] = 3] = \"QUERY_ERROR\";\n  EventTypes[EventTypes[\"PROVIDER\"] = 4] = \"PROVIDER\";\n  EventTypes[EventTypes[\"VALUE\"] = 5] = \"VALUE\";\n  EventTypes[EventTypes[\"ADDING_PEER\"] = 6] = \"ADDING_PEER\";\n  EventTypes[EventTypes[\"DIALING_PEER\"] = 7] = \"DIALING_PEER\";\n})(EventTypes || (EventTypes = {}));\n/**\n * The types of messages set/received during DHT queries\n */\n\n\nexport var MessageType;\n\n(function (MessageType) {\n  MessageType[MessageType[\"PUT_VALUE\"] = 0] = \"PUT_VALUE\";\n  MessageType[MessageType[\"GET_VALUE\"] = 1] = \"GET_VALUE\";\n  MessageType[MessageType[\"ADD_PROVIDER\"] = 2] = \"ADD_PROVIDER\";\n  MessageType[MessageType[\"GET_PROVIDERS\"] = 3] = \"GET_PROVIDERS\";\n  MessageType[MessageType[\"FIND_NODE\"] = 4] = \"FIND_NODE\";\n  MessageType[MessageType[\"PING\"] = 5] = \"PING\";\n})(MessageType || (MessageType = {}));\n/**\n * An implementation of content routing, using a delegated peer\n */\n\n\nclass DelegatedContentRouting {\n  /**\n   * Create a new DelegatedContentRouting instance\n   */\n  constructor(client) {\n    if (client == null) {\n      throw new Error('missing ipfs http client');\n    }\n\n    this.client = client;\n    this.started = false;\n    this.abortController = new AbortController(); // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n\n    this.httpQueue = new PQueue({\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    }); // sometimes refs requests take long time, they need separate queue\n    // to not suffocate regular business\n\n    this.httpQueueRefs = new PQueue({\n      concurrency: CONCURRENT_HTTP_REFS_REQUESTS\n    });\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig();\n    log(`enabled DelegatedContentRouting via ${protocol}://${host}:${port}`);\n  }\n\n  isStarted() {\n    return this.started;\n  }\n\n  start() {\n    this.started = true;\n  }\n\n  stop() {\n    this.httpQueue.clear();\n    this.httpQueueRefs.clear();\n    this.abortController.abort();\n    this.abortController = new AbortController();\n    this.started = false;\n  }\n  /**\n   * Search the dht for providers of the given CID.\n   *\n   * - call `findProviders` on the delegated node.\n   */\n\n\n  async *findProviders(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    log('findProviders starts: %c', key);\n    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;\n    options.signal = anySignal([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));\n    const onStart = defer();\n    const onFinish = defer();\n    void this.httpQueue.add(async () => {\n      onStart.resolve();\n      return await onFinish.promise;\n    });\n\n    try {\n      await onStart.promise;\n\n      for await (const event of this.client.dht.findProvs(key, options)) {\n        if (event.name === 'PROVIDER') {\n          yield* event.providers.map(prov => {\n            const peerInfo = {\n              id: prov.id,\n              protocols: [],\n              multiaddrs: prov.multiaddrs\n            };\n            return peerInfo;\n          });\n        }\n      }\n    } catch (err) {\n      log.error('findProviders errored:', err);\n      throw err;\n    } finally {\n      onFinish.resolve();\n      log('findProviders finished: %c', key);\n    }\n  }\n  /**\n   * Announce to the network that the delegated node can provide the given key.\n   *\n   * Currently this uses the following hack\n   * - delegate is one of bootstrap nodes, so we are always connected to it\n   * - call block stat on the delegated node, so it fetches the content\n   * - call dht provide with the passed cid\n   *\n   * N.B. this must be called for every block in the dag you want provided otherwise\n   * the delegate will only be able to supply the root block of the dag when asked\n   * for the data by an interested peer.\n   */\n\n\n  async provide(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    log('provide starts: %c', key);\n    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;\n    options.signal = anySignal([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));\n    await this.httpQueueRefs.add(async () => {\n      await this.client.block.stat(key, options);\n      await drain(this.client.dht.provide(key, options));\n    });\n    log('provide finished: %c', key);\n  }\n  /**\n   * Stores a value in the backing key/value store of the delegated content router.\n   * This may fail if the delegated node's content routing implementation does not\n   * use a key/value store, or if the delegated operation fails.\n   */\n\n\n  async put(key, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    log('put value start: %b', key);\n    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;\n    options.signal = anySignal([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));\n    await this.httpQueue.add(async () => {\n      await drain(this.client.dht.put(key, value, options));\n    });\n    log('put value finished: %b', key);\n  }\n  /**\n   * Fetches an value from the backing key/value store of the delegated content router.\n   * This may fail if the delegated node's content routing implementation does not\n   * use a key/value store, or if the delegated operation fails.\n   */\n\n\n  async get(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    log('get value start: %b', key);\n    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;\n    options.signal = anySignal([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));\n    const value = await this.httpQueue.add(async () => {\n      for await (const event of this.client.dht.get(key, options)) {\n        if (event.name === 'VALUE') {\n          log('get value finished: %b', key);\n          return event.value;\n        }\n      }\n\n      throw errCode(new Error('Not found'), 'ERR_NOT_FOUND');\n    });\n\n    if (value === undefined) {\n      throw errCode(new Error('Not found'), 'ERR_NOT_FOUND');\n    } else {\n      return value;\n    }\n  }\n\n}\n\nexport function delegatedContentRouting(client) {\n  return () => new DelegatedContentRouting(client);\n}","map":{"version":3,"mappings":"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","names":["logger","drain","PQueue","defer","errCode","anySignal","log","DEFAULT_TIMEOUT","CONCURRENT_HTTP_REQUESTS","CONCURRENT_HTTP_REFS_REQUESTS","EventTypes","MessageType","DelegatedContentRouting","constructor","client","Error","started","abortController","AbortController","httpQueue","concurrency","httpQueueRefs","protocol","host","port","getEndpointConfig","isStarted","start","stop","clear","abort","findProviders","key","options","timeout","signal","concat","onStart","onFinish","add","resolve","promise","event","dht","findProvs","name","providers","map","prov","peerInfo","id","protocols","multiaddrs","err","error","provide","block","stat","put","value","get","undefined","delegatedContentRouting"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\delegated-content-routing\\src\\index.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport drain from 'it-drain'\nimport PQueue from 'p-queue'\nimport defer from 'p-defer'\nimport errCode from 'err-code'\nimport anySignal from 'any-signal'\nimport type { AbortOptions } from 'ipfs-core-types/src/utils'\nimport type { ContentRouting } from '@libp2p/interface-content-routing'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { CID } from 'multiformats/cid'\nimport type { PeerId } from '@libp2p/interface-peer-id'\n\nconst log = logger('libp2p:delegated-content-routing')\n\nconst DEFAULT_TIMEOUT = 30e3 // 30 second default\nconst CONCURRENT_HTTP_REQUESTS = 4\nconst CONCURRENT_HTTP_REFS_REQUESTS = 2\n\nexport interface HTTPClientExtraOptions {\n  headers?: Record<string, string>\n  searchParams?: URLSearchParams\n}\n\nexport enum EventTypes {\n  SENDING_QUERY = 0,\n  PEER_RESPONSE,\n  FINAL_PEER,\n  QUERY_ERROR,\n  PROVIDER,\n  VALUE,\n  ADDING_PEER,\n  DIALING_PEER\n}\n\n/**\n * The types of messages set/received during DHT queries\n */\nexport enum MessageType {\n  PUT_VALUE = 0,\n  GET_VALUE,\n  ADD_PROVIDER,\n  GET_PROVIDERS,\n  FIND_NODE,\n  PING\n}\n\nexport type MessageName = keyof typeof MessageType\n\nexport interface DHTRecord {\n  key: Uint8Array\n  value: Uint8Array\n  timeReceived?: Date\n}\n\nexport interface SendingQueryEvent {\n  type: EventTypes.SENDING_QUERY\n  name: 'SENDING_QUERY'\n}\n\nexport interface PeerResponseEvent {\n  from: PeerId\n  type: EventTypes.PEER_RESPONSE\n  name: 'PEER_RESPONSE'\n  messageType: MessageType\n  messageName: MessageName\n  providers: PeerInfo[]\n  closer: PeerInfo[]\n  record?: DHTRecord\n}\n\nexport interface FinalPeerEvent {\n  peer: PeerInfo\n  type: EventTypes.FINAL_PEER\n  name: 'FINAL_PEER'\n}\n\nexport interface QueryErrorEvent {\n  type: EventTypes.QUERY_ERROR\n  name: 'QUERY_ERROR'\n  error: Error\n}\n\nexport interface ProviderEvent {\n  type: EventTypes.PROVIDER\n  name: 'PROVIDER'\n  providers: PeerInfo[]\n}\n\nexport interface ValueEvent {\n  type: EventTypes.VALUE\n  name: 'VALUE'\n  value: Uint8Array\n}\n\nexport interface AddingPeerEvent {\n  type: EventTypes.ADDING_PEER\n  name: 'ADDING_PEER'\n  peer: PeerId\n}\n\nexport interface DialingPeerEvent {\n  peer: PeerId\n  type: EventTypes.DIALING_PEER\n  name: 'DIALING_PEER'\n}\n\nexport type QueryEvent = SendingQueryEvent | PeerResponseEvent | FinalPeerEvent | QueryErrorEvent | ProviderEvent | ValueEvent | AddingPeerEvent | DialingPeerEvent\n\nexport interface DHTProvideOptions extends AbortOptions {\n  recursive?: boolean\n}\n\nexport interface StatResult {\n  cid: CID\n  size: number\n}\n\nexport interface Delegate {\n  getEndpointConfig: () => { protocol: string, host: string, port: string }\n\n  block: {\n    stat: (cid: CID, options?: AbortOptions) => Promise<StatResult>\n  }\n\n  dht: {\n    findProvs: (cid: CID, options?: HTTPClientExtraOptions & AbortOptions) => AsyncIterable<QueryEvent>\n    provide: (cid: CID, options?: HTTPClientExtraOptions & DHTProvideOptions) => AsyncIterable<QueryEvent>\n    put: (key: string | Uint8Array, value: Uint8Array, options?: HTTPClientExtraOptions & AbortOptions) => AsyncIterable<QueryEvent>\n    get: (key: string | Uint8Array, options?: HTTPClientExtraOptions & AbortOptions) => AsyncIterable<QueryEvent>\n  }\n}\n\n/**\n * An implementation of content routing, using a delegated peer\n */\nclass DelegatedContentRouting implements ContentRouting, Startable {\n  private readonly client: Delegate\n  private readonly httpQueue: PQueue\n  private readonly httpQueueRefs: PQueue\n  private started: boolean\n  private abortController: AbortController\n\n  /**\n   * Create a new DelegatedContentRouting instance\n   */\n  constructor (client: Delegate) {\n    if (client == null) {\n      throw new Error('missing ipfs http client')\n    }\n\n    this.client = client\n    this.started = false\n    this.abortController = new AbortController()\n\n    // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n    this.httpQueue = new PQueue({\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    })\n    // sometimes refs requests take long time, they need separate queue\n    // to not suffocate regular business\n    this.httpQueueRefs = new PQueue({\n      concurrency: CONCURRENT_HTTP_REFS_REQUESTS\n    })\n\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig()\n\n    log(`enabled DelegatedContentRouting via ${protocol}://${host}:${port}`)\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  stop (): void {\n    this.httpQueue.clear()\n    this.httpQueueRefs.clear()\n    this.abortController.abort()\n    this.abortController = new AbortController()\n    this.started = false\n  }\n\n  /**\n   * Search the dht for providers of the given CID.\n   *\n   * - call `findProviders` on the delegated node.\n   */\n  async * findProviders (key: CID, options: HTTPClientExtraOptions & AbortOptions = {}): AsyncIterable<PeerInfo> {\n    log('findProviders starts: %c', key)\n    options.timeout = options.timeout ?? DEFAULT_TIMEOUT\n    options.signal = anySignal([this.abortController.signal].concat((options.signal != null) ? [options.signal] : []))\n\n    const onStart = defer()\n    const onFinish = defer()\n\n    void this.httpQueue.add(async () => {\n      onStart.resolve()\n      return await onFinish.promise\n    })\n\n    try {\n      await onStart.promise\n\n      for await (const event of this.client.dht.findProvs(key, options)) {\n        if (event.name === 'PROVIDER') {\n          yield * event.providers.map(prov => {\n            const peerInfo: PeerInfo = {\n              id: prov.id,\n              protocols: [],\n              multiaddrs: prov.multiaddrs\n            }\n\n            return peerInfo\n          })\n        }\n      }\n    } catch (err) {\n      log.error('findProviders errored:', err)\n      throw err\n    } finally {\n      onFinish.resolve()\n      log('findProviders finished: %c', key)\n    }\n  }\n\n  /**\n   * Announce to the network that the delegated node can provide the given key.\n   *\n   * Currently this uses the following hack\n   * - delegate is one of bootstrap nodes, so we are always connected to it\n   * - call block stat on the delegated node, so it fetches the content\n   * - call dht provide with the passed cid\n   *\n   * N.B. this must be called for every block in the dag you want provided otherwise\n   * the delegate will only be able to supply the root block of the dag when asked\n   * for the data by an interested peer.\n   */\n  async provide (key: CID, options: HTTPClientExtraOptions & AbortOptions = {}): Promise<void> {\n    log('provide starts: %c', key)\n    options.timeout = options.timeout ?? DEFAULT_TIMEOUT\n    options.signal = anySignal([this.abortController.signal].concat((options.signal != null) ? [options.signal] : []))\n\n    await this.httpQueueRefs.add(async () => {\n      await this.client.block.stat(key, options)\n      await drain(this.client.dht.provide(key, options))\n    })\n    log('provide finished: %c', key)\n  }\n\n  /**\n   * Stores a value in the backing key/value store of the delegated content router.\n   * This may fail if the delegated node's content routing implementation does not\n   * use a key/value store, or if the delegated operation fails.\n   */\n  async put (key: Uint8Array, value: Uint8Array, options: HTTPClientExtraOptions & AbortOptions = {}): Promise<void> {\n    log('put value start: %b', key)\n    options.timeout = options.timeout ?? DEFAULT_TIMEOUT\n    options.signal = anySignal([this.abortController.signal].concat((options.signal != null) ? [options.signal] : []))\n\n    await this.httpQueue.add(async () => {\n      await drain(this.client.dht.put(key, value, options))\n    })\n\n    log('put value finished: %b', key)\n  }\n\n  /**\n   * Fetches an value from the backing key/value store of the delegated content router.\n   * This may fail if the delegated node's content routing implementation does not\n   * use a key/value store, or if the delegated operation fails.\n   */\n  async get (key: Uint8Array, options: HTTPClientExtraOptions & AbortOptions = {}): Promise<Uint8Array> {\n    log('get value start: %b', key)\n    options.timeout = options.timeout ?? DEFAULT_TIMEOUT\n    options.signal = anySignal([this.abortController.signal].concat((options.signal != null) ? [options.signal] : []))\n\n    const value = await this.httpQueue.add(async () => {\n      for await (const event of this.client.dht.get(key, options)) {\n        if (event.name === 'VALUE') {\n          log('get value finished: %b', key)\n          return event.value\n        }\n      }\n\n      throw errCode(new Error('Not found'), 'ERR_NOT_FOUND')\n    })\n\n    if (value === undefined) {\n      throw errCode(new Error('Not found'), 'ERR_NOT_FOUND')\n    } else {\n      return value\n    }\n  }\n}\n\nexport function delegatedContentRouting (client: Delegate): (components?: any) => ContentRouting {\n  return () => new DelegatedContentRouting(client)\n}\n"]},"metadata":{},"sourceType":"module"}