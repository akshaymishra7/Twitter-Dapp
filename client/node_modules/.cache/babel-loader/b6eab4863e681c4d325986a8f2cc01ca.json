{"ast":null,"code":"// @ts-expect-error no types\nimport KBuck from 'k-bucket';\nimport * as utils from '../utils.js';\nimport Queue from 'p-queue';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { logger } from '@libp2p/logger';\nimport { PeerSet } from '@libp2p/peer-collections';\nexport const KAD_CLOSE_TAG_NAME = 'kad-close';\nexport const KAD_CLOSE_TAG_VALUE = 50;\nexport const KBUCKET_SIZE = 20;\nexport const PING_TIMEOUT = 10000;\nexport const PING_CONCURRENCY = 10;\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\n\nexport class RoutingTable {\n  constructor(components, init) {\n    const {\n      kBucketSize,\n      pingTimeout,\n      lan,\n      pingConcurrency,\n      protocol,\n      tagName,\n      tagValue\n    } = init;\n    this.components = components;\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:routing-table`);\n    this.kBucketSize = kBucketSize ?? KBUCKET_SIZE;\n    this.pingTimeout = pingTimeout ?? PING_TIMEOUT;\n    this.pingConcurrency = pingConcurrency ?? PING_CONCURRENCY;\n    this.lan = lan;\n    this.running = false;\n    this.protocol = protocol;\n    this.tagName = tagName ?? KAD_CLOSE_TAG_NAME;\n    this.tagValue = tagValue ?? KAD_CLOSE_TAG_VALUE;\n\n    const updatePingQueueSizeMetric = () => {\n      this.metrics?.pingQueueSize.update(this.pingQueue.size);\n      this.metrics?.pingRunning.update(this.pingQueue.pending);\n    };\n\n    this.pingQueue = new Queue({\n      concurrency: this.pingConcurrency\n    });\n    this.pingQueue.addListener('add', updatePingQueueSizeMetric);\n    this.pingQueue.addListener('next', updatePingQueueSizeMetric);\n    this._onPing = this._onPing.bind(this);\n  }\n\n  isStarted() {\n    return this.running;\n  }\n\n  async start() {\n    this.running = true;\n\n    if (this.components.metrics != null) {\n      this.metrics = {\n        routingTableSize: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? 'lan' : 'wan'}_routing_table_size`),\n        pingQueueSize: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? 'lan' : 'wan'}_ping_queue_size`),\n        pingRunning: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? 'lan' : 'wan'}_ping_running`)\n      };\n    }\n\n    const kBuck = new KBuck({\n      localNodeId: await utils.convertPeerId(this.components.peerId),\n      numberOfNodesPerKBucket: this.kBucketSize,\n      numberOfNodesToPing: 1\n    });\n    this.kb = kBuck; // test whether to evict peers\n\n    kBuck.on('ping', this._onPing); // tag kad-close peers\n\n    this._tagPeers(kBuck);\n  }\n\n  async stop() {\n    this.running = false;\n    this.pingQueue.clear();\n    this.kb = undefined;\n  }\n  /**\n   * Keep track of our k-closest peers and tag them in the peer store as such\n   * - this will lower the chances that connections to them get closed when\n   * we reach connection limits\n   */\n\n\n  _tagPeers(kBuck) {\n    let kClosest = new PeerSet();\n    const updatePeerTags = utils.debounce(() => {\n      const newClosest = new PeerSet(kBuck.closest(kBuck.localNodeId, KBUCKET_SIZE).map(contact => contact.peer));\n      const addedPeers = newClosest.difference(kClosest);\n      const removedPeers = kClosest.difference(newClosest);\n      Promise.resolve().then(async () => {\n        for (const peer of addedPeers) {\n          await this.components.peerStore.tagPeer(peer, this.tagName, {\n            value: this.tagValue\n          });\n        }\n\n        for (const peer of removedPeers) {\n          await this.components.peerStore.unTagPeer(peer, this.tagName);\n        }\n      }).catch(err => {\n        this.log.error('Could not update peer tags', err);\n      });\n      kClosest = newClosest;\n    });\n    kBuck.on('added', () => {\n      updatePeerTags();\n    });\n    kBuck.on('removed', () => {\n      updatePeerTags();\n    });\n  }\n  /**\n   * Called on the `ping` event from `k-bucket` when a bucket is full\n   * and cannot split.\n   *\n   * `oldContacts.length` is defined by the `numberOfNodesToPing` param\n   * passed to the `k-bucket` constructor.\n   *\n   * `oldContacts` will not be empty and is the list of contacts that\n   * have not been contacted for the longest.\n   */\n\n\n  _onPing(oldContacts, newContact) {\n    // add to a queue so multiple ping requests do not overlap and we don't\n    // flood the network with ping requests if lots of newContact requests\n    // are received\n    this.pingQueue.add(async () => {\n      if (!this.running) {\n        return;\n      }\n\n      let responded = 0;\n\n      try {\n        await Promise.all(oldContacts.map(async oldContact => {\n          let timeoutController;\n\n          try {\n            timeoutController = new TimeoutController(this.pingTimeout);\n            const options = {\n              signal: timeoutController.signal\n            };\n            this.log('pinging old contact %p', oldContact.peer);\n            const connection = await this.components.connectionManager.openConnection(oldContact.peer, options);\n            const stream = await connection.newStream(this.protocol, options);\n            stream.close();\n            responded++;\n          } catch (err) {\n            if (this.running && this.kb != null) {\n              // only evict peers if we are still running, otherwise we evict when dialing is\n              // cancelled due to shutdown in progress\n              this.log.error('could not ping peer %p', oldContact.peer, err);\n              this.log('evicting old contact after ping failed %p', oldContact);\n              this.kb.remove(oldContact.id);\n            }\n          } finally {\n            if (timeoutController != null) {\n              timeoutController.clear();\n            }\n\n            this.metrics?.routingTableSize.update(this.size);\n          }\n        }));\n\n        if (this.running && responded < oldContacts.length && this.kb != null) {\n          this.log('adding new contact %p', newContact.peer);\n          this.kb.add(newContact);\n        }\n      } catch (err) {\n        this.log.error('could not process k-bucket ping event', err);\n      }\n    }).catch(err => {\n      this.log.error('could not process k-bucket ping event', err);\n    });\n  } // -- Public Interface\n\n  /**\n   * Amount of currently stored peers\n   */\n\n\n  get size() {\n    if (this.kb == null) {\n      return 0;\n    }\n\n    return this.kb.count();\n  }\n  /**\n   * Find a specific peer by id\n   */\n\n\n  async find(peer) {\n    const key = await utils.convertPeerId(peer);\n    const closest = this.closestPeer(key);\n\n    if (closest != null && peer.equals(closest)) {\n      return closest;\n    }\n\n    return undefined;\n  }\n  /**\n   * Retrieve the closest peers to the given key\n   */\n\n\n  closestPeer(key) {\n    const res = this.closestPeers(key, 1);\n\n    if (res.length > 0) {\n      return res[0];\n    }\n\n    return undefined;\n  }\n  /**\n   * Retrieve the `count`-closest peers to the given key\n   */\n\n\n  closestPeers(key) {\n    let count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.kBucketSize;\n\n    if (this.kb == null) {\n      return [];\n    }\n\n    const closest = this.kb.closest(key, count);\n    return closest.map(p => p.peer);\n  }\n  /**\n   * Add or update the routing table with the given peer\n   */\n\n\n  async add(peer) {\n    if (this.kb == null) {\n      throw new Error('RoutingTable is not started');\n    }\n\n    const id = await utils.convertPeerId(peer);\n    this.kb.add({\n      id,\n      peer\n    });\n    this.log('added %p with kad id %b', peer, id);\n    this.metrics?.routingTableSize.update(this.size);\n  }\n  /**\n   * Remove a given peer from the table\n   */\n\n\n  async remove(peer) {\n    if (this.kb == null) {\n      throw new Error('RoutingTable is not started');\n    }\n\n    const id = await utils.convertPeerId(peer);\n    this.kb.remove(id);\n    this.metrics?.routingTableSize.update(this.size);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["KBuck","utils","Queue","TimeoutController","logger","PeerSet","KAD_CLOSE_TAG_NAME","KAD_CLOSE_TAG_VALUE","KBUCKET_SIZE","PING_TIMEOUT","PING_CONCURRENCY","RoutingTable","constructor","components","init","kBucketSize","pingTimeout","lan","pingConcurrency","protocol","tagName","tagValue","log","running","updatePingQueueSizeMetric","metrics","pingQueueSize","update","pingQueue","size","pingRunning","pending","concurrency","addListener","_onPing","bind","isStarted","start","routingTableSize","registerMetric","kBuck","localNodeId","convertPeerId","peerId","numberOfNodesPerKBucket","numberOfNodesToPing","kb","on","_tagPeers","stop","clear","undefined","kClosest","updatePeerTags","debounce","newClosest","closest","map","contact","peer","addedPeers","difference","removedPeers","Promise","resolve","then","peerStore","tagPeer","value","unTagPeer","catch","err","error","oldContacts","newContact","add","responded","all","oldContact","timeoutController","options","signal","connection","connectionManager","openConnection","stream","newStream","close","remove","id","length","count","find","key","closestPeer","equals","res","closestPeers","p","Error"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\routing-table\\index.ts"],"sourcesContent":["// @ts-expect-error no types\nimport KBuck from 'k-bucket'\nimport * as utils from '../utils.js'\nimport Queue from 'p-queue'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { logger } from '@libp2p/logger'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { Logger } from '@libp2p/logger'\nimport { PeerSet } from '@libp2p/peer-collections'\nimport type { Metric, Metrics } from '@libp2p/interface-metrics'\nimport type { PeerStore } from '@libp2p/interface-peer-store'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\n\nexport const KAD_CLOSE_TAG_NAME = 'kad-close'\nexport const KAD_CLOSE_TAG_VALUE = 50\nexport const KBUCKET_SIZE = 20\nexport const PING_TIMEOUT = 10000\nexport const PING_CONCURRENCY = 10\n\nexport interface KBucketPeer {\n  id: Uint8Array\n  peer: PeerId\n}\n\nexport interface KBucket {\n  id: Uint8Array\n  contacts: KBucketPeer[]\n  dontSplit: boolean\n  left: KBucket\n  right: KBucket\n}\n\ninterface KBucketTreeEvents {\n  'ping': (oldContacts: KBucketPeer[], newContact: KBucketPeer) => void\n  'added': (contact: KBucketPeer) => void\n  'removed': (contact: KBucketPeer) => void\n}\n\nexport interface KBucketTree {\n  root: KBucket\n  localNodeId: Uint8Array\n\n  on: <U extends keyof KBucketTreeEvents>(\n    event: U, listener: KBucketTreeEvents[U]\n  ) => this\n\n  closest: (key: Uint8Array, count: number) => KBucketPeer[]\n  closestPeer: (key: Uint8Array) => KBucketPeer\n  remove: (key: Uint8Array) => void\n  add: (peer: KBucketPeer) => void\n  get: (key: Uint8Array) => Uint8Array\n  count: () => number\n  toIterable: () => Iterable<KBucketPeer>\n}\n\nexport interface RoutingTableInit {\n  lan: boolean\n  protocol: string\n  kBucketSize?: number\n  pingTimeout?: number\n  pingConcurrency?: number\n  tagName?: string\n  tagValue?: number\n}\n\nexport interface RoutingTableComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  connectionManager: ConnectionManager\n  metrics?: Metrics\n}\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nexport class RoutingTable implements Startable {\n  public kBucketSize: number\n  public kb?: KBucketTree\n  public pingQueue: Queue\n\n  private readonly log: Logger\n  private readonly components: RoutingTableComponents\n  private readonly lan: boolean\n  private readonly pingTimeout: number\n  private readonly pingConcurrency: number\n  private running: boolean\n  private readonly protocol: string\n  private readonly tagName: string\n  private readonly tagValue: number\n  private metrics?: {\n    routingTableSize: Metric\n    pingQueueSize: Metric\n    pingRunning: Metric\n  }\n\n  constructor (components: RoutingTableComponents, init: RoutingTableInit) {\n    const { kBucketSize, pingTimeout, lan, pingConcurrency, protocol, tagName, tagValue } = init\n\n    this.components = components\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:routing-table`)\n    this.kBucketSize = kBucketSize ?? KBUCKET_SIZE\n    this.pingTimeout = pingTimeout ?? PING_TIMEOUT\n    this.pingConcurrency = pingConcurrency ?? PING_CONCURRENCY\n    this.lan = lan\n    this.running = false\n    this.protocol = protocol\n    this.tagName = tagName ?? KAD_CLOSE_TAG_NAME\n    this.tagValue = tagValue ?? KAD_CLOSE_TAG_VALUE\n\n    const updatePingQueueSizeMetric = (): void => {\n      this.metrics?.pingQueueSize.update(this.pingQueue.size)\n      this.metrics?.pingRunning.update(this.pingQueue.pending)\n    }\n\n    this.pingQueue = new Queue({ concurrency: this.pingConcurrency })\n    this.pingQueue.addListener('add', updatePingQueueSizeMetric)\n    this.pingQueue.addListener('next', updatePingQueueSizeMetric)\n\n    this._onPing = this._onPing.bind(this)\n  }\n\n  isStarted (): boolean {\n    return this.running\n  }\n\n  async start (): Promise<void> {\n    this.running = true\n\n    if (this.components.metrics != null) {\n      this.metrics = {\n        routingTableSize: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? 'lan' : 'wan'}_routing_table_size`),\n        pingQueueSize: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? 'lan' : 'wan'}_ping_queue_size`),\n        pingRunning: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? 'lan' : 'wan'}_ping_running`)\n      }\n    }\n\n    const kBuck: KBucketTree = new KBuck({\n      localNodeId: await utils.convertPeerId(this.components.peerId),\n      numberOfNodesPerKBucket: this.kBucketSize,\n      numberOfNodesToPing: 1\n    })\n    this.kb = kBuck\n\n    // test whether to evict peers\n    kBuck.on('ping', this._onPing)\n\n    // tag kad-close peers\n    this._tagPeers(kBuck)\n  }\n\n  async stop (): Promise<void> {\n    this.running = false\n    this.pingQueue.clear()\n    this.kb = undefined\n  }\n\n  /**\n   * Keep track of our k-closest peers and tag them in the peer store as such\n   * - this will lower the chances that connections to them get closed when\n   * we reach connection limits\n   */\n  _tagPeers (kBuck: KBucketTree): void {\n    let kClosest = new PeerSet()\n\n    const updatePeerTags = utils.debounce(() => {\n      const newClosest = new PeerSet(\n        kBuck.closest(kBuck.localNodeId, KBUCKET_SIZE).map(contact => contact.peer)\n      )\n      const addedPeers = newClosest.difference(kClosest)\n      const removedPeers = kClosest.difference(newClosest)\n\n      Promise.resolve()\n        .then(async () => {\n          for (const peer of addedPeers) {\n            await this.components.peerStore.tagPeer(peer, this.tagName, {\n              value: this.tagValue\n            })\n          }\n\n          for (const peer of removedPeers) {\n            await this.components.peerStore.unTagPeer(peer, this.tagName)\n          }\n        })\n        .catch(err => {\n          this.log.error('Could not update peer tags', err)\n        })\n\n      kClosest = newClosest\n    })\n\n    kBuck.on('added', () => {\n      updatePeerTags()\n    })\n    kBuck.on('removed', () => {\n      updatePeerTags()\n    })\n  }\n\n  /**\n   * Called on the `ping` event from `k-bucket` when a bucket is full\n   * and cannot split.\n   *\n   * `oldContacts.length` is defined by the `numberOfNodesToPing` param\n   * passed to the `k-bucket` constructor.\n   *\n   * `oldContacts` will not be empty and is the list of contacts that\n   * have not been contacted for the longest.\n   */\n  _onPing (oldContacts: KBucketPeer[], newContact: KBucketPeer): void {\n    // add to a queue so multiple ping requests do not overlap and we don't\n    // flood the network with ping requests if lots of newContact requests\n    // are received\n    this.pingQueue.add(async () => {\n      if (!this.running) {\n        return\n      }\n\n      let responded = 0\n\n      try {\n        await Promise.all(\n          oldContacts.map(async oldContact => {\n            let timeoutController\n\n            try {\n              timeoutController = new TimeoutController(this.pingTimeout)\n\n              const options = {\n                signal: timeoutController.signal\n              }\n\n              this.log('pinging old contact %p', oldContact.peer)\n              const connection = await this.components.connectionManager.openConnection(oldContact.peer, options)\n              const stream = await connection.newStream(this.protocol, options)\n              stream.close()\n              responded++\n            } catch (err: any) {\n              if (this.running && this.kb != null) {\n                // only evict peers if we are still running, otherwise we evict when dialing is\n                // cancelled due to shutdown in progress\n                this.log.error('could not ping peer %p', oldContact.peer, err)\n                this.log('evicting old contact after ping failed %p', oldContact)\n                this.kb.remove(oldContact.id)\n              }\n            } finally {\n              if (timeoutController != null) {\n                timeoutController.clear()\n              }\n\n              this.metrics?.routingTableSize.update(this.size)\n            }\n          })\n        )\n\n        if (this.running && responded < oldContacts.length && this.kb != null) {\n          this.log('adding new contact %p', newContact.peer)\n          this.kb.add(newContact)\n        }\n      } catch (err: any) {\n        this.log.error('could not process k-bucket ping event', err)\n      }\n    })\n      .catch(err => {\n        this.log.error('could not process k-bucket ping event', err)\n      })\n  }\n\n  // -- Public Interface\n\n  /**\n   * Amount of currently stored peers\n   */\n  get size (): number {\n    if (this.kb == null) {\n      return 0\n    }\n\n    return this.kb.count()\n  }\n\n  /**\n   * Find a specific peer by id\n   */\n  async find (peer: PeerId): Promise<PeerId | undefined> {\n    const key = await utils.convertPeerId(peer)\n    const closest = this.closestPeer(key)\n\n    if (closest != null && peer.equals(closest)) {\n      return closest\n    }\n\n    return undefined\n  }\n\n  /**\n   * Retrieve the closest peers to the given key\n   */\n  closestPeer (key: Uint8Array): PeerId | undefined {\n    const res = this.closestPeers(key, 1)\n\n    if (res.length > 0) {\n      return res[0]\n    }\n\n    return undefined\n  }\n\n  /**\n   * Retrieve the `count`-closest peers to the given key\n   */\n  closestPeers (key: Uint8Array, count = this.kBucketSize): PeerId[] {\n    if (this.kb == null) {\n      return []\n    }\n\n    const closest = this.kb.closest(key, count)\n\n    return closest.map(p => p.peer)\n  }\n\n  /**\n   * Add or update the routing table with the given peer\n   */\n  async add (peer: PeerId): Promise<void> {\n    if (this.kb == null) {\n      throw new Error('RoutingTable is not started')\n    }\n\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.add({ id, peer })\n\n    this.log('added %p with kad id %b', peer, id)\n\n    this.metrics?.routingTableSize.update(this.size)\n  }\n\n  /**\n   * Remove a given peer from the table\n   */\n  async remove (peer: PeerId): Promise<void> {\n    if (this.kb == null) {\n      throw new Error('RoutingTable is not started')\n    }\n\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.remove(id)\n\n    this.metrics?.routingTableSize.update(this.size)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}