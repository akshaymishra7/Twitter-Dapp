{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport mergeOptions from 'merge-options';\nimport { LatencyMonitor } from './latency-monitor.js';\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { codes } from '../errors.js';\nimport { isPeerId } from '@libp2p/interface-peer-id';\nimport { setMaxListeners } from 'events';\nimport * as STATUS from '@libp2p/interface-connection/status';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { PeerMap } from '@libp2p/peer-collections';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { KEEP_ALIVE } from '@libp2p/interface-peer-store/tags';\nimport { RateLimiterMemory } from 'rate-limiter-flexible';\nimport { getPeerAddress } from '../get-peer.js';\nconst log = logger('libp2p:connection-manager');\nconst defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  autoDialInterval: 10000,\n  inboundConnectionThreshold: 5,\n  maxIncomingPendingConnections: 10\n};\nconst STARTUP_RECONNECT_TIMEOUT = 60000;\n/**\n * Responsible for managing known connections.\n */\n\nexport class DefaultConnectionManager extends EventEmitter {\n  constructor(components, init) {\n    super();\n    this.opts = mergeOptions.call({\n      ignoreUndefined: true\n    }, defaultOptions, init);\n\n    if (this.opts.maxConnections < this.opts.minConnections) {\n      throw errCode(new Error('Connection Manager maxConnections must be greater than minConnections'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('options: %o', this.opts);\n    this.components = components;\n    /**\n     * Map of connections per peer\n     */\n\n    this.connections = new Map();\n    this.started = false;\n\n    if (init.maxEventLoopDelay != null && init.maxEventLoopDelay > 0 && init.maxEventLoopDelay !== Infinity) {\n      this.latencyMonitor = new LatencyMonitor({\n        latencyCheckIntervalMs: init.pollInterval,\n        dataEmitIntervalMs: init.pollInterval\n      });\n    }\n\n    try {\n      // This emitter gets listened to a lot\n      setMaxListeners?.(Infinity, this);\n    } catch {}\n\n    this.onConnect = this.onConnect.bind(this);\n    this.onDisconnect = this.onDisconnect.bind(this);\n    this.startupReconnectTimeout = init.startupReconnectTimeout ?? STARTUP_RECONNECT_TIMEOUT;\n    this.dialTimeout = init.dialTimeout ?? 30000;\n    this.allow = (init.allow ?? []).map(ma => multiaddr(ma));\n    this.deny = (init.deny ?? []).map(ma => multiaddr(ma));\n    this.inboundConnectionRateLimiter = new RateLimiterMemory({\n      points: this.opts.inboundConnectionThreshold,\n      duration: 1\n    });\n    this.incomingPendingConnections = 0;\n  }\n\n  isStarted() {\n    return this.started;\n  }\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n\n\n  async start() {\n    // track inbound/outbound connections\n    this.components.metrics?.registerMetricGroup('libp2p_connection_manager_connections', {\n      calculate: () => {\n        const metric = {\n          inbound: 0,\n          outbound: 0\n        };\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            if (conn.stat.direction === 'inbound') {\n              metric.inbound++;\n            } else {\n              metric.outbound++;\n            }\n          }\n        }\n\n        return metric;\n      }\n    }); // track total number of streams per protocol\n\n    this.components.metrics?.registerMetricGroup('libp2p_protocol_streams_total', {\n      label: 'protocol',\n      calculate: () => {\n        const metric = {};\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            for (const stream of conn.streams) {\n              const key = `${stream.stat.direction} ${stream.stat.protocol ?? 'unnegotiated'}`;\n              metric[key] = (metric[key] ?? 0) + 1;\n            }\n          }\n        }\n\n        return metric;\n      }\n    }); // track 90th percentile of streams per protocol\n\n    this.components.metrics?.registerMetricGroup('libp2p_connection_manager_protocol_streams_per_connection_90th_percentile', {\n      label: 'protocol',\n      calculate: () => {\n        const allStreams = {};\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            const streams = {};\n\n            for (const stream of conn.streams) {\n              const key = `${stream.stat.direction} ${stream.stat.protocol ?? 'unnegotiated'}`;\n              streams[key] = (streams[key] ?? 0) + 1;\n            }\n\n            for (const [protocol, count] of Object.entries(streams)) {\n              allStreams[protocol] = allStreams[protocol] ?? [];\n              allStreams[protocol].push(count);\n            }\n          }\n        }\n\n        const metric = {};\n\n        for (let [protocol, counts] of Object.entries(allStreams)) {\n          counts = counts.sort((a, b) => a - b);\n          const index = Math.floor(counts.length * 0.9);\n          metric[protocol] = counts[index];\n        }\n\n        return metric;\n      }\n    }); // latency monitor\n\n    this.latencyMonitor?.start();\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this);\n    this.latencyMonitor?.addEventListener('data', this._onLatencyMeasure);\n    this.started = true;\n    log('started');\n  }\n\n  async afterStart() {\n    this.components.upgrader.addEventListener('connection', this.onConnect);\n    this.components.upgrader.addEventListener('connectionEnd', this.onDisconnect); // re-connect to any peers with the KEEP_ALIVE tag\n\n    void Promise.resolve().then(async () => {\n      const keepAlivePeers = [];\n\n      for (const peer of await this.components.peerStore.all()) {\n        const tags = await this.components.peerStore.getTags(peer.id);\n        const hasKeepAlive = tags.filter(tag => tag.name === KEEP_ALIVE).length > 0;\n\n        if (hasKeepAlive) {\n          keepAlivePeers.push(peer.id);\n        }\n      }\n\n      this.connectOnStartupController?.clear();\n      this.connectOnStartupController = new TimeoutController(this.startupReconnectTimeout);\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, this.connectOnStartupController.signal);\n      } catch {}\n\n      await Promise.all(keepAlivePeers.map(async peer => {\n        await this.openConnection(peer, {\n          signal: this.connectOnStartupController?.signal\n        }).catch(err => {\n          log.error(err);\n        });\n      }));\n    }).catch(err => {\n      log.error(err);\n    }).finally(() => {\n      this.connectOnStartupController?.clear();\n    });\n  }\n\n  async beforeStop() {\n    // if we are still dialing KEEP_ALIVE peers, abort those dials\n    this.connectOnStartupController?.abort();\n    this.components.upgrader.removeEventListener('connection', this.onConnect);\n    this.components.upgrader.removeEventListener('connectionEnd', this.onDisconnect);\n  }\n  /**\n   * Stops the Connection Manager\n   */\n\n\n  async stop() {\n    this.latencyMonitor?.removeEventListener('data', this._onLatencyMeasure);\n    this.latencyMonitor?.stop();\n    this.started = false;\n    await this._close();\n    log('stopped');\n  }\n  /**\n   * Cleans up the connections\n   */\n\n\n  async _close() {\n    // Close all connections we're tracking\n    const tasks = [];\n\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push((async () => {\n          try {\n            await connection.close();\n          } catch (err) {\n            log.error(err);\n          }\n        })());\n      }\n    }\n\n    log('closing %d connections', tasks.length);\n    await Promise.all(tasks);\n    this.connections.clear();\n  }\n\n  onConnect(evt) {\n    void this._onConnect(evt).catch(err => {\n      log.error(err);\n    });\n  }\n  /**\n   * Tracks the incoming connection and check the connection limit\n   */\n\n\n  async _onConnect(evt) {\n    const {\n      detail: connection\n    } = evt;\n\n    if (!this.started) {\n      // This can happen when we are in the process of shutting down the node\n      await connection.close();\n      return;\n    }\n\n    const peerId = connection.remotePeer;\n    const peerIdStr = peerId.toString();\n    const storedConns = this.connections.get(peerIdStr);\n\n    if (storedConns != null) {\n      storedConns.push(connection);\n    } else {\n      this.connections.set(peerIdStr, [connection]);\n    }\n\n    if (peerId.publicKey != null) {\n      await this.components.peerStore.keyBook.set(peerId, peerId.publicKey);\n    }\n\n    const numConnections = this.getConnections().length;\n    const toPrune = numConnections - this.opts.maxConnections;\n    await this._checkMaxLimit('maxConnections', numConnections, toPrune);\n    this.dispatchEvent(new CustomEvent('peer:connect', {\n      detail: connection\n    }));\n  }\n  /**\n   * Removes the connection from tracking\n   */\n\n\n  onDisconnect(evt) {\n    const {\n      detail: connection\n    } = evt;\n\n    if (!this.started) {\n      // This can happen when we are in the process of shutting down the node\n      return;\n    }\n\n    const peerId = connection.remotePeer.toString();\n    let storedConn = this.connections.get(peerId);\n\n    if (storedConn != null && storedConn.length > 1) {\n      storedConn = storedConn.filter(conn => conn.id !== connection.id);\n      this.connections.set(peerId, storedConn);\n    } else if (storedConn != null) {\n      this.connections.delete(peerId);\n      this.dispatchEvent(new CustomEvent('peer:disconnect', {\n        detail: connection\n      }));\n    }\n  }\n\n  getConnections(peerId) {\n    if (peerId != null) {\n      return this.connections.get(peerId.toString()) ?? [];\n    }\n\n    let conns = [];\n\n    for (const c of this.connections.values()) {\n      conns = conns.concat(c);\n    }\n\n    return conns;\n  }\n\n  async openConnection(peerIdOrMultiaddr) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      peerId,\n      multiaddr\n    } = getPeerAddress(peerIdOrMultiaddr);\n\n    if (peerId == null && multiaddr == null) {\n      throw errCode(new TypeError('Can only open connections to PeerIds or Multiaddrs'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (peerId != null) {\n      log('dial to', peerId);\n      const existingConnections = this.getConnections(peerId);\n\n      if (existingConnections.length > 0) {\n        log('had an existing connection to %p', peerId);\n        return existingConnections[0];\n      }\n    }\n\n    let timeoutController;\n\n    if (options?.signal == null) {\n      timeoutController = new TimeoutController(this.dialTimeout);\n      options.signal = timeoutController.signal;\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal);\n      } catch {}\n    }\n\n    try {\n      const connection = await this.components.dialer.dial(peerIdOrMultiaddr, options);\n      let peerConnections = this.connections.get(connection.remotePeer.toString());\n\n      if (peerConnections == null) {\n        peerConnections = [];\n        this.connections.set(connection.remotePeer.toString(), peerConnections);\n      } // we get notified of connections via the Upgrader emitting \"connection\"\n      // events, double check we aren't already tracking this connection before\n      // storing it\n\n\n      let trackedConnection = false;\n\n      for (const conn of peerConnections) {\n        if (conn.id === connection.id) {\n          trackedConnection = true;\n        }\n      }\n\n      if (!trackedConnection) {\n        peerConnections.push(connection);\n      }\n\n      return connection;\n    } finally {\n      if (timeoutController != null) {\n        timeoutController.clear();\n      }\n    }\n  }\n\n  async closeConnections(peerId) {\n    const connections = this.connections.get(peerId.toString()) ?? [];\n    await Promise.all(connections.map(async connection => {\n      return await connection.close();\n    }));\n  }\n  /**\n   * Get all open connections with a peer\n   */\n\n\n  getAll(peerId) {\n    if (!isPeerId(peerId)) {\n      throw errCode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    const id = peerId.toString();\n    const connections = this.connections.get(id); // Return all open connections\n\n    if (connections != null) {\n      return connections.filter(connection => connection.stat.status === STATUS.OPEN);\n    }\n\n    return [];\n  }\n  /**\n   * If the event loop is slow, maybe close a connection\n   */\n\n\n  _onLatencyMeasure(evt) {\n    const {\n      detail: summary\n    } = evt;\n\n    this._checkMaxLimit('maxEventLoopDelay', summary.avgMs, 1).catch(err => {\n      log.error(err);\n    });\n  }\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   */\n\n\n  async _checkMaxLimit(name, value) {\n    let toPrune = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const limit = this.opts[name];\n\n    if (limit == null) {\n      log.trace('limit %s was not set so it cannot be applied', name);\n      return;\n    }\n\n    log.trace('checking limit of %s. current value: %d of %d', name, value, limit);\n\n    if (value > limit) {\n      log('%s: limit exceeded: %p, %d/%d, pruning %d connection(s)', this.components.peerId, name, value, limit, toPrune);\n      await this._pruneConnections(toPrune);\n    }\n  }\n  /**\n   * If we have more connections than our maximum, select some excess connections\n   * to prune based on peer value\n   */\n\n\n  async _pruneConnections(toPrune) {\n    const connections = this.getConnections();\n    const peerValues = new PeerMap(); // work out peer values\n\n    for (const connection of connections) {\n      const remotePeer = connection.remotePeer;\n\n      if (peerValues.has(remotePeer)) {\n        continue;\n      }\n\n      const tags = await this.components.peerStore.getTags(remotePeer); // sum all tag values\n\n      peerValues.set(remotePeer, tags.reduce((acc, curr) => {\n        return acc + curr.value;\n      }, 0));\n    } // sort by value, lowest to highest\n\n\n    const sortedConnections = connections.sort((a, b) => {\n      const peerAValue = peerValues.get(a.remotePeer) ?? 0;\n      const peerBValue = peerValues.get(b.remotePeer) ?? 0;\n\n      if (peerAValue > peerBValue) {\n        return 1;\n      }\n\n      if (peerAValue < peerBValue) {\n        return -1;\n      } // if the peers have an equal tag value then we want to close short-lived connections first\n\n\n      const connectionALifespan = a.stat.timeline.open;\n      const connectionBLifespan = b.stat.timeline.open;\n\n      if (connectionALifespan < connectionBLifespan) {\n        return 1;\n      }\n\n      if (connectionALifespan > connectionBLifespan) {\n        return -1;\n      }\n\n      return 0;\n    }); // close some connections\n\n    const toClose = [];\n\n    for (const connection of sortedConnections) {\n      log('too many connections open - closing a connection to %p', connection.remotePeer);\n      toClose.push(connection);\n\n      if (toClose.length === toPrune) {\n        break;\n      }\n    } // close connections\n\n\n    await Promise.all(toClose.map(async connection => {\n      try {\n        await connection.close();\n      } catch (err) {\n        log.error(err);\n      } // TODO: should not need to invoke this manually\n\n\n      this.onDisconnect(new CustomEvent('connectionEnd', {\n        detail: connection\n      }));\n    }));\n  }\n\n  async acceptIncomingConnection(maConn) {\n    // check deny list\n    const denyConnection = this.deny.some(ma => {\n      return maConn.remoteAddr.toString().startsWith(ma.toString());\n    });\n\n    if (denyConnection) {\n      log('connection from %s refused - connection remote address was in deny list', maConn.remoteAddr);\n      return false;\n    } // check allow list\n\n\n    const allowConnection = this.allow.some(ma => {\n      return maConn.remoteAddr.toString().startsWith(ma.toString());\n    });\n\n    if (allowConnection) {\n      this.incomingPendingConnections++;\n      return true;\n    } // check pending connections\n\n\n    if (this.incomingPendingConnections === this.opts.maxIncomingPendingConnections) {\n      log('connection from %s refused - incomingPendingConnections exceeded by peer %s', maConn.remoteAddr);\n      return false;\n    }\n\n    if (maConn.remoteAddr.isThinWaistAddress()) {\n      const host = maConn.remoteAddr.nodeAddress().address;\n\n      try {\n        await this.inboundConnectionRateLimiter.consume(host, 1);\n      } catch {\n        log('connection from %s refused - inboundConnectionThreshold exceeded by host %s', host, maConn.remoteAddr);\n        return false;\n      }\n    }\n\n    if (this.getConnections().length < this.opts.maxConnections) {\n      this.incomingPendingConnections++;\n      return true;\n    }\n\n    log('connection from %s refused - maxConnections exceeded', maConn.remoteAddr);\n    return false;\n  }\n\n  afterUpgradeInbound() {\n    this.incomingPendingConnections--;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","errCode","mergeOptions","LatencyMonitor","CustomEvent","EventEmitter","codes","isPeerId","setMaxListeners","STATUS","multiaddr","PeerMap","TimeoutController","KEEP_ALIVE","RateLimiterMemory","getPeerAddress","log","defaultOptions","maxConnections","Infinity","minConnections","maxEventLoopDelay","pollInterval","autoDialInterval","inboundConnectionThreshold","maxIncomingPendingConnections","STARTUP_RECONNECT_TIMEOUT","DefaultConnectionManager","constructor","components","init","opts","call","ignoreUndefined","Error","ERR_INVALID_PARAMETERS","connections","Map","started","latencyMonitor","latencyCheckIntervalMs","dataEmitIntervalMs","onConnect","bind","onDisconnect","startupReconnectTimeout","dialTimeout","allow","map","ma","deny","inboundConnectionRateLimiter","points","duration","incomingPendingConnections","isStarted","start","metrics","registerMetricGroup","calculate","metric","inbound","outbound","conns","values","conn","stat","direction","label","stream","streams","key","protocol","allStreams","count","Object","entries","push","counts","sort","a","b","index","Math","floor","length","_onLatencyMeasure","addEventListener","afterStart","upgrader","Promise","resolve","then","keepAlivePeers","peer","peerStore","all","tags","getTags","id","hasKeepAlive","filter","tag","name","connectOnStartupController","clear","signal","openConnection","catch","err","error","finally","beforeStop","abort","removeEventListener","stop","_close","tasks","connectionList","connection","close","evt","_onConnect","detail","peerId","remotePeer","peerIdStr","toString","storedConns","get","set","publicKey","keyBook","numConnections","getConnections","toPrune","_checkMaxLimit","dispatchEvent","storedConn","delete","c","concat","peerIdOrMultiaddr","options","TypeError","existingConnections","timeoutController","dialer","dial","peerConnections","trackedConnection","closeConnections","getAll","status","OPEN","summary","avgMs","value","limit","trace","_pruneConnections","peerValues","has","reduce","acc","curr","sortedConnections","peerAValue","peerBValue","connectionALifespan","timeline","open","connectionBLifespan","toClose","acceptIncomingConnection","maConn","denyConnection","some","remoteAddr","startsWith","allowConnection","isThinWaistAddress","host","nodeAddress","address","consume","afterUpgradeInbound"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\connection-manager\\index.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport mergeOptions from 'merge-options'\nimport { LatencyMonitor, SummaryObject } from './latency-monitor.js'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport { codes } from '../errors.js'\nimport { isPeerId, PeerId } from '@libp2p/interface-peer-id'\nimport { setMaxListeners } from 'events'\nimport type { Connection, MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { ConnectionManager, ConnectionManagerEvents, Dialer } from '@libp2p/interface-connection-manager'\nimport * as STATUS from '@libp2p/interface-connection/status'\nimport type { AddressSorter, PeerStore } from '@libp2p/interface-peer-store'\nimport { multiaddr, Multiaddr, Resolver } from '@multiformats/multiaddr'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { KEEP_ALIVE } from '@libp2p/interface-peer-store/tags'\nimport { RateLimiterMemory } from 'rate-limiter-flexible'\nimport type { Metrics } from '@libp2p/interface-metrics'\nimport type { Upgrader } from '@libp2p/interface-transport'\nimport { getPeerAddress } from '../get-peer.js'\n\nconst log = logger('libp2p:connection-manager')\n\nexport interface ConnectionManagerConfig {\n  /**\n   * The maximum number of connections libp2p is willing to have before it starts disconnecting. Defaults to `Infinity`\n   */\n  maxConnections: number\n\n  /**\n   * The minimum number of connections below which libp2p not activate preemptive disconnections. Defaults to `0`.\n   */\n  minConnections: number\n\n  /**\n   * Sets the maximum event loop delay (measured in milliseconds) this node is willing to endure before it starts disconnecting peers. Defaults to `Infinity`.\n   */\n  maxEventLoopDelay?: number\n\n  /**\n   * Sets the poll interval (in milliseconds) for assessing the current state and determining if this peer needs to force a disconnect. Defaults to `2000` (2 seconds).\n   */\n  pollInterval?: number\n\n  /**\n   * If true, try to connect to all discovered peers up to the connection manager limit\n   */\n  autoDial?: boolean\n\n  /**\n   * How long to wait between attempting to keep our number of concurrent connections\n   * above minConnections\n   */\n  autoDialInterval: number\n\n  /**\n   * Sort the known addresses of a peer before trying to dial\n   */\n  addressSorter?: AddressSorter\n\n  /**\n   * Number of max concurrent dials\n   */\n  maxParallelDials?: number\n\n  /**\n   * Number of max addresses to dial for a given peer\n   */\n  maxAddrsToDial?: number\n\n  /**\n   * How long a dial attempt is allowed to take, including DNS resolution\n   * of the multiaddr, opening a socket and upgrading it to a Connection.\n   */\n  dialTimeout?: number\n\n  /**\n   * When a new inbound connection is opened, the upgrade process (e.g. protect,\n   * encrypt, multiplex etc) must complete within this number of ms.\n   */\n  inboundUpgradeTimeout: number\n\n  /**\n   * Number of max concurrent dials per peer\n   */\n  maxDialsPerPeer?: number\n\n  /**\n   * Multiaddr resolvers to use when dialing\n   */\n  resolvers?: Record<string, Resolver>\n\n  /**\n   * On startup we try to dial any peer that has previously been\n   * tagged with KEEP_ALIVE up to this timeout in ms. (default: 60000)\n   */\n  startupReconnectTimeout?: number\n\n  /**\n   * A list of multiaddrs that will always be allowed (except if they are in the\n   * deny list) to open connections to this node even if we've reached maxConnections\n   */\n  allow?: string[]\n\n  /**\n   * A list of multiaddrs that will never be allowed to open connections to\n   * this node under any circumstances\n   */\n  deny?: string[]\n\n  /**\n   * If more than this many connections are opened per second by a single\n   * host, reject subsequent connections\n   */\n  inboundConnectionThreshold?: number\n\n  /**\n   * The maximum number of parallel incoming connections allowed that have yet to\n   * complete the connection upgrade - e.g. choosing connection encryption, muxer, etc\n   */\n  maxIncomingPendingConnections?: number\n}\n\nconst defaultOptions: Partial<ConnectionManagerConfig> = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  autoDialInterval: 10000,\n  inboundConnectionThreshold: 5,\n  maxIncomingPendingConnections: 10\n}\n\nconst STARTUP_RECONNECT_TIMEOUT = 60000\n\nexport interface DefaultConnectionManagerComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  upgrader: Upgrader\n  peerStore: PeerStore\n  dialer: Dialer\n}\n\nexport type ConnectionManagerInit = ConnectionManagerConfig\n\n/**\n * Responsible for managing known connections.\n */\nexport class DefaultConnectionManager extends EventEmitter<ConnectionManagerEvents> implements ConnectionManager, Startable {\n  private readonly components: DefaultConnectionManagerComponents\n  private readonly opts: ConnectionManagerInit\n  private readonly connections: Map<string, Connection[]>\n  private started: boolean\n  private readonly latencyMonitor?: LatencyMonitor\n  private readonly startupReconnectTimeout: number\n  private connectOnStartupController?: TimeoutController\n  private readonly dialTimeout: number\n  private readonly allow: Multiaddr[]\n  private readonly deny: Multiaddr[]\n  private readonly inboundConnectionRateLimiter: RateLimiterMemory\n  private incomingPendingConnections: number\n\n  constructor (components: DefaultConnectionManagerComponents, init: ConnectionManagerConfig) {\n    super()\n\n    this.opts = mergeOptions.call({ ignoreUndefined: true }, defaultOptions, init)\n\n    if (this.opts.maxConnections < this.opts.minConnections) {\n      throw errCode(new Error('Connection Manager maxConnections must be greater than minConnections'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('options: %o', this.opts)\n\n    this.components = components\n\n    /**\n     * Map of connections per peer\n     */\n    this.connections = new Map()\n\n    this.started = false\n\n    if (init.maxEventLoopDelay != null && init.maxEventLoopDelay > 0 && init.maxEventLoopDelay !== Infinity) {\n      this.latencyMonitor = new LatencyMonitor({\n        latencyCheckIntervalMs: init.pollInterval,\n        dataEmitIntervalMs: init.pollInterval\n      })\n    }\n\n    try {\n      // This emitter gets listened to a lot\n      setMaxListeners?.(Infinity, this)\n    } catch {}\n\n    this.onConnect = this.onConnect.bind(this)\n    this.onDisconnect = this.onDisconnect.bind(this)\n\n    this.startupReconnectTimeout = init.startupReconnectTimeout ?? STARTUP_RECONNECT_TIMEOUT\n    this.dialTimeout = init.dialTimeout ?? 30000\n\n    this.allow = (init.allow ?? []).map(ma => multiaddr(ma))\n    this.deny = (init.deny ?? []).map(ma => multiaddr(ma))\n\n    this.inboundConnectionRateLimiter = new RateLimiterMemory({\n      points: this.opts.inboundConnectionThreshold,\n      duration: 1\n    })\n\n    this.incomingPendingConnections = 0\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n  async start () {\n    // track inbound/outbound connections\n    this.components.metrics?.registerMetricGroup('libp2p_connection_manager_connections', {\n      calculate: () => {\n        const metric = {\n          inbound: 0,\n          outbound: 0\n        }\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            if (conn.stat.direction === 'inbound') {\n              metric.inbound++\n            } else {\n              metric.outbound++\n            }\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track total number of streams per protocol\n    this.components.metrics?.registerMetricGroup('libp2p_protocol_streams_total', {\n      label: 'protocol',\n      calculate: () => {\n        const metric: Record<string, number> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            for (const stream of conn.streams) {\n              const key = `${stream.stat.direction} ${stream.stat.protocol ?? 'unnegotiated'}`\n\n              metric[key] = (metric[key] ?? 0) + 1\n            }\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track 90th percentile of streams per protocol\n    this.components.metrics?.registerMetricGroup('libp2p_connection_manager_protocol_streams_per_connection_90th_percentile', {\n      label: 'protocol',\n      calculate: () => {\n        const allStreams: Record<string, number[]> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            const streams: Record<string, number> = {}\n\n            for (const stream of conn.streams) {\n              const key = `${stream.stat.direction} ${stream.stat.protocol ?? 'unnegotiated'}`\n\n              streams[key] = (streams[key] ?? 0) + 1\n            }\n\n            for (const [protocol, count] of Object.entries(streams)) {\n              allStreams[protocol] = allStreams[protocol] ?? []\n              allStreams[protocol].push(count)\n            }\n          }\n        }\n\n        const metric: Record<string, number> = {}\n\n        for (let [protocol, counts] of Object.entries(allStreams)) {\n          counts = counts.sort((a, b) => a - b)\n\n          const index = Math.floor(counts.length * 0.9)\n          metric[protocol] = counts[index]\n        }\n\n        return metric\n      }\n    })\n\n    // latency monitor\n    this.latencyMonitor?.start()\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this)\n    this.latencyMonitor?.addEventListener('data', this._onLatencyMeasure)\n\n    this.started = true\n    log('started')\n  }\n\n  async afterStart () {\n    this.components.upgrader.addEventListener('connection', this.onConnect)\n    this.components.upgrader.addEventListener('connectionEnd', this.onDisconnect)\n\n    // re-connect to any peers with the KEEP_ALIVE tag\n    void Promise.resolve()\n      .then(async () => {\n        const keepAlivePeers: PeerId[] = []\n\n        for (const peer of await this.components.peerStore.all()) {\n          const tags = await this.components.peerStore.getTags(peer.id)\n          const hasKeepAlive = tags.filter(tag => tag.name === KEEP_ALIVE).length > 0\n\n          if (hasKeepAlive) {\n            keepAlivePeers.push(peer.id)\n          }\n        }\n\n        this.connectOnStartupController?.clear()\n        this.connectOnStartupController = new TimeoutController(this.startupReconnectTimeout)\n\n        try {\n          // fails on node < 15.4\n          setMaxListeners?.(Infinity, this.connectOnStartupController.signal)\n        } catch {}\n\n        await Promise.all(\n          keepAlivePeers.map(async peer => {\n            await this.openConnection(peer, {\n              signal: this.connectOnStartupController?.signal\n            })\n              .catch(err => {\n                log.error(err)\n              })\n          })\n        )\n      })\n      .catch(err => {\n        log.error(err)\n      })\n      .finally(() => {\n        this.connectOnStartupController?.clear()\n      })\n  }\n\n  async beforeStop () {\n    // if we are still dialing KEEP_ALIVE peers, abort those dials\n    this.connectOnStartupController?.abort()\n    this.components.upgrader.removeEventListener('connection', this.onConnect)\n    this.components.upgrader.removeEventListener('connectionEnd', this.onDisconnect)\n  }\n\n  /**\n   * Stops the Connection Manager\n   */\n  async stop () {\n    this.latencyMonitor?.removeEventListener('data', this._onLatencyMeasure)\n    this.latencyMonitor?.stop()\n\n    this.started = false\n    await this._close()\n    log('stopped')\n  }\n\n  /**\n   * Cleans up the connections\n   */\n  async _close () {\n    // Close all connections we're tracking\n    const tasks: Array<Promise<void>> = []\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push((async () => {\n          try {\n            await connection.close()\n          } catch (err) {\n            log.error(err)\n          }\n        })())\n      }\n    }\n\n    log('closing %d connections', tasks.length)\n    await Promise.all(tasks)\n    this.connections.clear()\n  }\n\n  onConnect (evt: CustomEvent<Connection>) {\n    void this._onConnect(evt).catch(err => {\n      log.error(err)\n    })\n  }\n\n  /**\n   * Tracks the incoming connection and check the connection limit\n   */\n  async _onConnect (evt: CustomEvent<Connection>) {\n    const { detail: connection } = evt\n\n    if (!this.started) {\n      // This can happen when we are in the process of shutting down the node\n      await connection.close()\n      return\n    }\n\n    const peerId = connection.remotePeer\n    const peerIdStr = peerId.toString()\n    const storedConns = this.connections.get(peerIdStr)\n\n    if (storedConns != null) {\n      storedConns.push(connection)\n    } else {\n      this.connections.set(peerIdStr, [connection])\n    }\n\n    if (peerId.publicKey != null) {\n      await this.components.peerStore.keyBook.set(peerId, peerId.publicKey)\n    }\n\n    const numConnections = this.getConnections().length\n    const toPrune = numConnections - this.opts.maxConnections\n\n    await this._checkMaxLimit('maxConnections', numConnections, toPrune)\n    this.dispatchEvent(new CustomEvent<Connection>('peer:connect', { detail: connection }))\n  }\n\n  /**\n   * Removes the connection from tracking\n   */\n  onDisconnect (evt: CustomEvent<Connection>) {\n    const { detail: connection } = evt\n\n    if (!this.started) {\n      // This can happen when we are in the process of shutting down the node\n      return\n    }\n\n    const peerId = connection.remotePeer.toString()\n    let storedConn = this.connections.get(peerId)\n\n    if (storedConn != null && storedConn.length > 1) {\n      storedConn = storedConn.filter((conn) => conn.id !== connection.id)\n      this.connections.set(peerId, storedConn)\n    } else if (storedConn != null) {\n      this.connections.delete(peerId)\n      this.dispatchEvent(new CustomEvent<Connection>('peer:disconnect', { detail: connection }))\n    }\n  }\n\n  getConnections (peerId?: PeerId): Connection[] {\n    if (peerId != null) {\n      return this.connections.get(peerId.toString()) ?? []\n    }\n\n    let conns: Connection[] = []\n\n    for (const c of this.connections.values()) {\n      conns = conns.concat(c)\n    }\n\n    return conns\n  }\n\n  async openConnection (peerIdOrMultiaddr: PeerId | Multiaddr, options: AbortOptions = {}): Promise<Connection> {\n    const { peerId, multiaddr } = getPeerAddress(peerIdOrMultiaddr)\n\n    if (peerId == null && multiaddr == null) {\n      throw errCode(new TypeError('Can only open connections to PeerIds or Multiaddrs'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (peerId != null) {\n      log('dial to', peerId)\n\n      const existingConnections = this.getConnections(peerId)\n\n      if (existingConnections.length > 0) {\n        log('had an existing connection to %p', peerId)\n\n        return existingConnections[0]\n      }\n    }\n\n    let timeoutController: TimeoutController | undefined\n\n    if (options?.signal == null) {\n      timeoutController = new TimeoutController(this.dialTimeout)\n      options.signal = timeoutController.signal\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal)\n      } catch {}\n    }\n\n    try {\n      const connection = await this.components.dialer.dial(peerIdOrMultiaddr, options)\n      let peerConnections = this.connections.get(connection.remotePeer.toString())\n\n      if (peerConnections == null) {\n        peerConnections = []\n        this.connections.set(connection.remotePeer.toString(), peerConnections)\n      }\n\n      // we get notified of connections via the Upgrader emitting \"connection\"\n      // events, double check we aren't already tracking this connection before\n      // storing it\n      let trackedConnection = false\n\n      for (const conn of peerConnections) {\n        if (conn.id === connection.id) {\n          trackedConnection = true\n        }\n      }\n\n      if (!trackedConnection) {\n        peerConnections.push(connection)\n      }\n\n      return connection\n    } finally {\n      if (timeoutController != null) {\n        timeoutController.clear()\n      }\n    }\n  }\n\n  async closeConnections (peerId: PeerId): Promise<void> {\n    const connections = this.connections.get(peerId.toString()) ?? []\n\n    await Promise.all(\n      connections.map(async connection => {\n        return await connection.close()\n      })\n    )\n  }\n\n  /**\n   * Get all open connections with a peer\n   */\n  getAll (peerId: PeerId): Connection[] {\n    if (!isPeerId(peerId)) {\n      throw errCode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    const id = peerId.toString()\n    const connections = this.connections.get(id)\n\n    // Return all open connections\n    if (connections != null) {\n      return connections.filter(connection => connection.stat.status === STATUS.OPEN)\n    }\n\n    return []\n  }\n\n  /**\n   * If the event loop is slow, maybe close a connection\n   */\n  _onLatencyMeasure (evt: CustomEvent<SummaryObject>) {\n    const { detail: summary } = evt\n\n    this._checkMaxLimit('maxEventLoopDelay', summary.avgMs, 1)\n      .catch(err => {\n        log.error(err)\n      })\n  }\n\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   */\n  async _checkMaxLimit (name: keyof ConnectionManagerInit, value: number, toPrune: number = 1) {\n    const limit = this.opts[name]\n\n    if (limit == null) {\n      log.trace('limit %s was not set so it cannot be applied', name)\n      return\n    }\n\n    log.trace('checking limit of %s. current value: %d of %d', name, value, limit)\n    if (value > limit) {\n      log('%s: limit exceeded: %p, %d/%d, pruning %d connection(s)', this.components.peerId, name, value, limit, toPrune)\n      await this._pruneConnections(toPrune)\n    }\n  }\n\n  /**\n   * If we have more connections than our maximum, select some excess connections\n   * to prune based on peer value\n   */\n  async _pruneConnections (toPrune: number) {\n    const connections = this.getConnections()\n    const peerValues = new PeerMap<number>()\n\n    // work out peer values\n    for (const connection of connections) {\n      const remotePeer = connection.remotePeer\n\n      if (peerValues.has(remotePeer)) {\n        continue\n      }\n\n      const tags = await this.components.peerStore.getTags(remotePeer)\n\n      // sum all tag values\n      peerValues.set(remotePeer, tags.reduce((acc, curr) => {\n        return acc + curr.value\n      }, 0))\n    }\n\n    // sort by value, lowest to highest\n    const sortedConnections = connections.sort((a, b) => {\n      const peerAValue = peerValues.get(a.remotePeer) ?? 0\n      const peerBValue = peerValues.get(b.remotePeer) ?? 0\n\n      if (peerAValue > peerBValue) {\n        return 1\n      }\n\n      if (peerAValue < peerBValue) {\n        return -1\n      }\n\n      // if the peers have an equal tag value then we want to close short-lived connections first\n      const connectionALifespan = a.stat.timeline.open\n      const connectionBLifespan = b.stat.timeline.open\n\n      if (connectionALifespan < connectionBLifespan) {\n        return 1\n      }\n\n      if (connectionALifespan > connectionBLifespan) {\n        return -1\n      }\n\n      return 0\n    })\n\n    // close some connections\n    const toClose = []\n\n    for (const connection of sortedConnections) {\n      log('too many connections open - closing a connection to %p', connection.remotePeer)\n      toClose.push(connection)\n\n      if (toClose.length === toPrune) {\n        break\n      }\n    }\n\n    // close connections\n    await Promise.all(\n      toClose.map(async connection => {\n        try {\n          await connection.close()\n        } catch (err) {\n          log.error(err)\n        }\n\n        // TODO: should not need to invoke this manually\n        this.onDisconnect(new CustomEvent<Connection>('connectionEnd', {\n          detail: connection\n        }))\n      })\n    )\n  }\n\n  async acceptIncomingConnection (maConn: MultiaddrConnection): Promise<boolean> {\n    // check deny list\n    const denyConnection = this.deny.some(ma => {\n      return maConn.remoteAddr.toString().startsWith(ma.toString())\n    })\n\n    if (denyConnection) {\n      log('connection from %s refused - connection remote address was in deny list', maConn.remoteAddr)\n      return false\n    }\n\n    // check allow list\n    const allowConnection = this.allow.some(ma => {\n      return maConn.remoteAddr.toString().startsWith(ma.toString())\n    })\n\n    if (allowConnection) {\n      this.incomingPendingConnections++\n\n      return true\n    }\n\n    // check pending connections\n    if (this.incomingPendingConnections === this.opts.maxIncomingPendingConnections) {\n      log('connection from %s refused - incomingPendingConnections exceeded by peer %s', maConn.remoteAddr)\n      return false\n    }\n\n    if (maConn.remoteAddr.isThinWaistAddress()) {\n      const host = maConn.remoteAddr.nodeAddress().address\n\n      try {\n        await this.inboundConnectionRateLimiter.consume(host, 1)\n      } catch {\n        log('connection from %s refused - inboundConnectionThreshold exceeded by host %s', host, maConn.remoteAddr)\n        return false\n      }\n    }\n\n    if (this.getConnections().length < this.opts.maxConnections) {\n      this.incomingPendingConnections++\n\n      return true\n    }\n\n    log('connection from %s refused - maxConnections exceeded', maConn.remoteAddr)\n    return false\n  }\n\n  afterUpgradeInbound () {\n    this.incomingPendingConnections--\n  }\n}\n"]},"metadata":{},"sourceType":"module"}