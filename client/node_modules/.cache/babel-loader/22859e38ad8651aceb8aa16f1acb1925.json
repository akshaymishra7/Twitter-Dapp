{"ast":null,"code":"/*eslint-disable*/\nimport $protobuf from \"protobufjs/minimal.js\"; // Common aliases\n\nconst $Reader = $protobuf.Reader,\n      $Writer = $protobuf.Writer,\n      $util = $protobuf.util; // Exported root namespace\n\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\nexport const Addresses = $root.Addresses = (() => {\n  /**\n   * Properties of an Addresses.\n   * @exports IAddresses\n   * @interface IAddresses\n   * @property {Array.<Addresses.IAddress>|null} [addrs] Addresses addrs\n   * @property {Addresses.ICertifiedRecord|null} [certifiedRecord] Addresses certifiedRecord\n   */\n\n  /**\n   * Constructs a new Addresses.\n   * @exports Addresses\n   * @classdesc Represents an Addresses.\n   * @implements IAddresses\n   * @constructor\n   * @param {IAddresses=} [p] Properties to set\n   */\n  function Addresses(p) {\n    this.addrs = [];\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * Addresses addrs.\n   * @member {Array.<Addresses.IAddress>} addrs\n   * @memberof Addresses\n   * @instance\n   */\n\n\n  Addresses.prototype.addrs = $util.emptyArray;\n  /**\n   * Addresses certifiedRecord.\n   * @member {Addresses.ICertifiedRecord|null|undefined} certifiedRecord\n   * @memberof Addresses\n   * @instance\n   */\n\n  Addresses.prototype.certifiedRecord = null;\n  /**\n   * Encodes the specified Addresses message. Does not implicitly {@link Addresses.verify|verify} messages.\n   * @function encode\n   * @memberof Addresses\n   * @static\n   * @param {IAddresses} m Addresses message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  Addresses.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n\n    if (m.addrs != null && m.addrs.length) {\n      for (var i = 0; i < m.addrs.length; ++i) $root.Addresses.Address.encode(m.addrs[i], w.uint32(10).fork()).ldelim();\n    }\n\n    if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, \"certifiedRecord\")) $root.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();\n    return w;\n  };\n  /**\n   * Decodes an Addresses message from the specified reader or buffer.\n   * @function decode\n   * @memberof Addresses\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {Addresses} Addresses\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Addresses.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.Addresses();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          if (!(m.addrs && m.addrs.length)) m.addrs = [];\n          m.addrs.push($root.Addresses.Address.decode(r, r.uint32()));\n          break;\n\n        case 2:\n          m.certifiedRecord = $root.Addresses.CertifiedRecord.decode(r, r.uint32());\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    return m;\n  };\n  /**\n   * Creates an Addresses message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Addresses\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {Addresses} Addresses\n   */\n\n\n  Addresses.fromObject = function fromObject(d) {\n    if (d instanceof $root.Addresses) return d;\n    var m = new $root.Addresses();\n\n    if (d.addrs) {\n      if (!Array.isArray(d.addrs)) throw TypeError(\".Addresses.addrs: array expected\");\n      m.addrs = [];\n\n      for (var i = 0; i < d.addrs.length; ++i) {\n        if (typeof d.addrs[i] !== \"object\") throw TypeError(\".Addresses.addrs: object expected\");\n        m.addrs[i] = $root.Addresses.Address.fromObject(d.addrs[i]);\n      }\n    }\n\n    if (d.certifiedRecord != null) {\n      if (typeof d.certifiedRecord !== \"object\") throw TypeError(\".Addresses.certifiedRecord: object expected\");\n      m.certifiedRecord = $root.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from an Addresses message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Addresses\n   * @static\n   * @param {Addresses} m Addresses\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Addresses.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.arrays || o.defaults) {\n      d.addrs = [];\n    }\n\n    if (o.defaults) {\n      d.certifiedRecord = null;\n    }\n\n    if (m.addrs && m.addrs.length) {\n      d.addrs = [];\n\n      for (var j = 0; j < m.addrs.length; ++j) {\n        d.addrs[j] = $root.Addresses.Address.toObject(m.addrs[j], o);\n      }\n    }\n\n    if (m.certifiedRecord != null && m.hasOwnProperty(\"certifiedRecord\")) {\n      d.certifiedRecord = $root.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);\n    }\n\n    return d;\n  };\n  /**\n   * Converts this Addresses to JSON.\n   * @function toJSON\n   * @memberof Addresses\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Addresses.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  Addresses.Address = function () {\n    /**\n     * Properties of an Address.\n     * @memberof Addresses\n     * @interface IAddress\n     * @property {Uint8Array|null} [multiaddr] Address multiaddr\n     * @property {boolean|null} [isCertified] Address isCertified\n     */\n\n    /**\n     * Constructs a new Address.\n     * @memberof Addresses\n     * @classdesc Represents an Address.\n     * @implements IAddress\n     * @constructor\n     * @param {Addresses.IAddress=} [p] Properties to set\n     */\n    function Address(p) {\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n    /**\n     * Address multiaddr.\n     * @member {Uint8Array} multiaddr\n     * @memberof Addresses.Address\n     * @instance\n     */\n\n\n    Address.prototype.multiaddr = $util.newBuffer([]);\n    /**\n     * Address isCertified.\n     * @member {boolean|null|undefined} isCertified\n     * @memberof Addresses.Address\n     * @instance\n     */\n\n    Address.prototype.isCertified = null; // OneOf field names bound to virtual getters and setters\n\n    let $oneOfFields;\n    /**\n     * Address _isCertified.\n     * @member {\"isCertified\"|undefined} _isCertified\n     * @memberof Addresses.Address\n     * @instance\n     */\n\n    Object.defineProperty(Address.prototype, \"_isCertified\", {\n      get: $util.oneOfGetter($oneOfFields = [\"isCertified\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Encodes the specified Address message. Does not implicitly {@link Addresses.Address.verify|verify} messages.\n     * @function encode\n     * @memberof Addresses.Address\n     * @static\n     * @param {Addresses.IAddress} m Address message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n    Address.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n      if (m.multiaddr != null && Object.hasOwnProperty.call(m, \"multiaddr\")) w.uint32(10).bytes(m.multiaddr);\n      if (m.isCertified != null && Object.hasOwnProperty.call(m, \"isCertified\")) w.uint32(16).bool(m.isCertified);\n      return w;\n    };\n    /**\n     * Decodes an Address message from the specified reader or buffer.\n     * @function decode\n     * @memberof Addresses.Address\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Addresses.Address} Address\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Address.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n          m = new $root.Addresses.Address();\n\n      while (r.pos < c) {\n        var t = r.uint32();\n\n        switch (t >>> 3) {\n          case 1:\n            m.multiaddr = r.bytes();\n            break;\n\n          case 2:\n            m.isCertified = r.bool();\n            break;\n\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n\n      return m;\n    };\n    /**\n     * Creates an Address message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Addresses.Address\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Addresses.Address} Address\n     */\n\n\n    Address.fromObject = function fromObject(d) {\n      if (d instanceof $root.Addresses.Address) return d;\n      var m = new $root.Addresses.Address();\n\n      if (d.multiaddr != null) {\n        if (typeof d.multiaddr === \"string\") $util.base64.decode(d.multiaddr, m.multiaddr = $util.newBuffer($util.base64.length(d.multiaddr)), 0);else if (d.multiaddr.length) m.multiaddr = d.multiaddr;\n      }\n\n      if (d.isCertified != null) {\n        m.isCertified = Boolean(d.isCertified);\n      }\n\n      return m;\n    };\n    /**\n     * Creates a plain object from an Address message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Addresses.Address\n     * @static\n     * @param {Addresses.Address} m Address\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Address.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n\n      if (o.defaults) {\n        if (o.bytes === String) d.multiaddr = \"\";else {\n          d.multiaddr = [];\n          if (o.bytes !== Array) d.multiaddr = $util.newBuffer(d.multiaddr);\n        }\n      }\n\n      if (m.multiaddr != null && m.hasOwnProperty(\"multiaddr\")) {\n        d.multiaddr = o.bytes === String ? $util.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;\n      }\n\n      if (m.isCertified != null && m.hasOwnProperty(\"isCertified\")) {\n        d.isCertified = m.isCertified;\n        if (o.oneofs) d._isCertified = \"isCertified\";\n      }\n\n      return d;\n    };\n    /**\n     * Converts this Address to JSON.\n     * @function toJSON\n     * @memberof Addresses.Address\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Address.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Address;\n  }();\n\n  Addresses.CertifiedRecord = function () {\n    /**\n     * Properties of a CertifiedRecord.\n     * @memberof Addresses\n     * @interface ICertifiedRecord\n     * @property {number|null} [seq] CertifiedRecord seq\n     * @property {Uint8Array|null} [raw] CertifiedRecord raw\n     */\n\n    /**\n     * Constructs a new CertifiedRecord.\n     * @memberof Addresses\n     * @classdesc Represents a CertifiedRecord.\n     * @implements ICertifiedRecord\n     * @constructor\n     * @param {Addresses.ICertifiedRecord=} [p] Properties to set\n     */\n    function CertifiedRecord(p) {\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n    /**\n     * CertifiedRecord seq.\n     * @member {number} seq\n     * @memberof Addresses.CertifiedRecord\n     * @instance\n     */\n\n\n    CertifiedRecord.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n    /**\n     * CertifiedRecord raw.\n     * @member {Uint8Array} raw\n     * @memberof Addresses.CertifiedRecord\n     * @instance\n     */\n\n    CertifiedRecord.prototype.raw = $util.newBuffer([]);\n    /**\n     * Encodes the specified CertifiedRecord message. Does not implicitly {@link Addresses.CertifiedRecord.verify|verify} messages.\n     * @function encode\n     * @memberof Addresses.CertifiedRecord\n     * @static\n     * @param {Addresses.ICertifiedRecord} m CertifiedRecord message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n    CertifiedRecord.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n      if (m.seq != null && Object.hasOwnProperty.call(m, \"seq\")) w.uint32(8).uint64(m.seq);\n      if (m.raw != null && Object.hasOwnProperty.call(m, \"raw\")) w.uint32(18).bytes(m.raw);\n      return w;\n    };\n    /**\n     * Decodes a CertifiedRecord message from the specified reader or buffer.\n     * @function decode\n     * @memberof Addresses.CertifiedRecord\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Addresses.CertifiedRecord} CertifiedRecord\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CertifiedRecord.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n          m = new $root.Addresses.CertifiedRecord();\n\n      while (r.pos < c) {\n        var t = r.uint32();\n\n        switch (t >>> 3) {\n          case 1:\n            m.seq = r.uint64();\n            break;\n\n          case 2:\n            m.raw = r.bytes();\n            break;\n\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n\n      return m;\n    };\n    /**\n     * Creates a CertifiedRecord message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Addresses.CertifiedRecord\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Addresses.CertifiedRecord} CertifiedRecord\n     */\n\n\n    CertifiedRecord.fromObject = function fromObject(d) {\n      if (d instanceof $root.Addresses.CertifiedRecord) return d;\n      var m = new $root.Addresses.CertifiedRecord();\n\n      if (d.seq != null) {\n        if ($util.Long) (m.seq = $util.Long.fromValue(d.seq)).unsigned = true;else if (typeof d.seq === \"string\") m.seq = parseInt(d.seq, 10);else if (typeof d.seq === \"number\") m.seq = d.seq;else if (typeof d.seq === \"object\") m.seq = new $util.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);\n      }\n\n      if (d.raw != null) {\n        if (typeof d.raw === \"string\") $util.base64.decode(d.raw, m.raw = $util.newBuffer($util.base64.length(d.raw)), 0);else if (d.raw.length) m.raw = d.raw;\n      }\n\n      return m;\n    };\n    /**\n     * Creates a plain object from a CertifiedRecord message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Addresses.CertifiedRecord\n     * @static\n     * @param {Addresses.CertifiedRecord} m CertifiedRecord\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    CertifiedRecord.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n\n      if (o.defaults) {\n        if ($util.Long) {\n          var n = new $util.Long(0, 0, true);\n          d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n        } else d.seq = o.longs === String ? \"0\" : 0;\n\n        if (o.bytes === String) d.raw = \"\";else {\n          d.raw = [];\n          if (o.bytes !== Array) d.raw = $util.newBuffer(d.raw);\n        }\n      }\n\n      if (m.seq != null && m.hasOwnProperty(\"seq\")) {\n        if (typeof m.seq === \"number\") d.seq = o.longs === String ? String(m.seq) : m.seq;else d.seq = o.longs === String ? $util.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;\n      }\n\n      if (m.raw != null && m.hasOwnProperty(\"raw\")) {\n        d.raw = o.bytes === String ? $util.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;\n      }\n\n      return d;\n    };\n    /**\n     * Converts this CertifiedRecord to JSON.\n     * @function toJSON\n     * @memberof Addresses.CertifiedRecord\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    CertifiedRecord.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CertifiedRecord;\n  }();\n\n  return Addresses;\n})();\nexport { $root as default };","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-repo-migrations/src/migrations/migration-12/pb/address-book.js"],"names":["$protobuf","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","Addresses","p","addrs","ks","Object","keys","i","length","prototype","emptyArray","certifiedRecord","encode","m","w","create","Address","uint32","fork","ldelim","hasOwnProperty","call","CertifiedRecord","decode","r","l","c","undefined","len","pos","t","push","skipType","fromObject","d","Array","isArray","TypeError","toObject","o","arrays","defaults","j","toJSON","constructor","toJSONOptions","multiaddr","newBuffer","isCertified","$oneOfFields","defineProperty","get","oneOfGetter","set","oneOfSetter","bytes","bool","base64","Boolean","String","slice","oneofs","_isCertified","seq","Long","fromBits","raw","uint64","fromValue","unsigned","parseInt","LongBits","low","high","toNumber","n","longs","toString","Number","default"],"mappings":"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","sourcesContent":["/*eslint-disable*/\nimport $protobuf from \"protobufjs/minimal.js\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\nexport const Addresses = $root.Addresses = (() => {\n\n    /**\n     * Properties of an Addresses.\n     * @exports IAddresses\n     * @interface IAddresses\n     * @property {Array.<Addresses.IAddress>|null} [addrs] Addresses addrs\n     * @property {Addresses.ICertifiedRecord|null} [certifiedRecord] Addresses certifiedRecord\n     */\n\n    /**\n     * Constructs a new Addresses.\n     * @exports Addresses\n     * @classdesc Represents an Addresses.\n     * @implements IAddresses\n     * @constructor\n     * @param {IAddresses=} [p] Properties to set\n     */\n    function Addresses(p) {\n        this.addrs = [];\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * Addresses addrs.\n     * @member {Array.<Addresses.IAddress>} addrs\n     * @memberof Addresses\n     * @instance\n     */\n    Addresses.prototype.addrs = $util.emptyArray;\n\n    /**\n     * Addresses certifiedRecord.\n     * @member {Addresses.ICertifiedRecord|null|undefined} certifiedRecord\n     * @memberof Addresses\n     * @instance\n     */\n    Addresses.prototype.certifiedRecord = null;\n\n    /**\n     * Encodes the specified Addresses message. Does not implicitly {@link Addresses.verify|verify} messages.\n     * @function encode\n     * @memberof Addresses\n     * @static\n     * @param {IAddresses} m Addresses message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Addresses.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        if (m.addrs != null && m.addrs.length) {\n            for (var i = 0; i < m.addrs.length; ++i)\n                $root.Addresses.Address.encode(m.addrs[i], w.uint32(10).fork()).ldelim();\n        }\n        if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, \"certifiedRecord\"))\n            $root.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();\n        return w;\n    };\n\n    /**\n     * Decodes an Addresses message from the specified reader or buffer.\n     * @function decode\n     * @memberof Addresses\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Addresses} Addresses\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Addresses.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.Addresses();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                if (!(m.addrs && m.addrs.length))\n                    m.addrs = [];\n                m.addrs.push($root.Addresses.Address.decode(r, r.uint32()));\n                break;\n            case 2:\n                m.certifiedRecord = $root.Addresses.CertifiedRecord.decode(r, r.uint32());\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        return m;\n    };\n\n    /**\n     * Creates an Addresses message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Addresses\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Addresses} Addresses\n     */\n    Addresses.fromObject = function fromObject(d) {\n        if (d instanceof $root.Addresses)\n            return d;\n        var m = new $root.Addresses();\n        if (d.addrs) {\n            if (!Array.isArray(d.addrs))\n                throw TypeError(\".Addresses.addrs: array expected\");\n            m.addrs = [];\n            for (var i = 0; i < d.addrs.length; ++i) {\n                if (typeof d.addrs[i] !== \"object\")\n                    throw TypeError(\".Addresses.addrs: object expected\");\n                m.addrs[i] = $root.Addresses.Address.fromObject(d.addrs[i]);\n            }\n        }\n        if (d.certifiedRecord != null) {\n            if (typeof d.certifiedRecord !== \"object\")\n                throw TypeError(\".Addresses.certifiedRecord: object expected\");\n            m.certifiedRecord = $root.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from an Addresses message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Addresses\n     * @static\n     * @param {Addresses} m Addresses\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Addresses.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.arrays || o.defaults) {\n            d.addrs = [];\n        }\n        if (o.defaults) {\n            d.certifiedRecord = null;\n        }\n        if (m.addrs && m.addrs.length) {\n            d.addrs = [];\n            for (var j = 0; j < m.addrs.length; ++j) {\n                d.addrs[j] = $root.Addresses.Address.toObject(m.addrs[j], o);\n            }\n        }\n        if (m.certifiedRecord != null && m.hasOwnProperty(\"certifiedRecord\")) {\n            d.certifiedRecord = $root.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);\n        }\n        return d;\n    };\n\n    /**\n     * Converts this Addresses to JSON.\n     * @function toJSON\n     * @memberof Addresses\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Addresses.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    Addresses.Address = (function() {\n\n        /**\n         * Properties of an Address.\n         * @memberof Addresses\n         * @interface IAddress\n         * @property {Uint8Array|null} [multiaddr] Address multiaddr\n         * @property {boolean|null} [isCertified] Address isCertified\n         */\n\n        /**\n         * Constructs a new Address.\n         * @memberof Addresses\n         * @classdesc Represents an Address.\n         * @implements IAddress\n         * @constructor\n         * @param {Addresses.IAddress=} [p] Properties to set\n         */\n        function Address(p) {\n            if (p)\n                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                    if (p[ks[i]] != null)\n                        this[ks[i]] = p[ks[i]];\n        }\n\n        /**\n         * Address multiaddr.\n         * @member {Uint8Array} multiaddr\n         * @memberof Addresses.Address\n         * @instance\n         */\n        Address.prototype.multiaddr = $util.newBuffer([]);\n\n        /**\n         * Address isCertified.\n         * @member {boolean|null|undefined} isCertified\n         * @memberof Addresses.Address\n         * @instance\n         */\n        Address.prototype.isCertified = null;\n\n        // OneOf field names bound to virtual getters and setters\n        let $oneOfFields;\n\n        /**\n         * Address _isCertified.\n         * @member {\"isCertified\"|undefined} _isCertified\n         * @memberof Addresses.Address\n         * @instance\n         */\n        Object.defineProperty(Address.prototype, \"_isCertified\", {\n            get: $util.oneOfGetter($oneOfFields = [\"isCertified\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Encodes the specified Address message. Does not implicitly {@link Addresses.Address.verify|verify} messages.\n         * @function encode\n         * @memberof Addresses.Address\n         * @static\n         * @param {Addresses.IAddress} m Address message or plain object to encode\n         * @param {$protobuf.Writer} [w] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Address.encode = function encode(m, w) {\n            if (!w)\n                w = $Writer.create();\n            if (m.multiaddr != null && Object.hasOwnProperty.call(m, \"multiaddr\"))\n                w.uint32(10).bytes(m.multiaddr);\n            if (m.isCertified != null && Object.hasOwnProperty.call(m, \"isCertified\"))\n                w.uint32(16).bool(m.isCertified);\n            return w;\n        };\n\n        /**\n         * Decodes an Address message from the specified reader or buffer.\n         * @function decode\n         * @memberof Addresses.Address\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n         * @param {number} [l] Message length if known beforehand\n         * @returns {Addresses.Address} Address\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Address.decode = function decode(r, l) {\n            if (!(r instanceof $Reader))\n                r = $Reader.create(r);\n            var c = l === undefined ? r.len : r.pos + l, m = new $root.Addresses.Address();\n            while (r.pos < c) {\n                var t = r.uint32();\n                switch (t >>> 3) {\n                case 1:\n                    m.multiaddr = r.bytes();\n                    break;\n                case 2:\n                    m.isCertified = r.bool();\n                    break;\n                default:\n                    r.skipType(t & 7);\n                    break;\n                }\n            }\n            return m;\n        };\n\n        /**\n         * Creates an Address message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Addresses.Address\n         * @static\n         * @param {Object.<string,*>} d Plain object\n         * @returns {Addresses.Address} Address\n         */\n        Address.fromObject = function fromObject(d) {\n            if (d instanceof $root.Addresses.Address)\n                return d;\n            var m = new $root.Addresses.Address();\n            if (d.multiaddr != null) {\n                if (typeof d.multiaddr === \"string\")\n                    $util.base64.decode(d.multiaddr, m.multiaddr = $util.newBuffer($util.base64.length(d.multiaddr)), 0);\n                else if (d.multiaddr.length)\n                    m.multiaddr = d.multiaddr;\n            }\n            if (d.isCertified != null) {\n                m.isCertified = Boolean(d.isCertified);\n            }\n            return m;\n        };\n\n        /**\n         * Creates a plain object from an Address message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Addresses.Address\n         * @static\n         * @param {Addresses.Address} m Address\n         * @param {$protobuf.IConversionOptions} [o] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Address.toObject = function toObject(m, o) {\n            if (!o)\n                o = {};\n            var d = {};\n            if (o.defaults) {\n                if (o.bytes === String)\n                    d.multiaddr = \"\";\n                else {\n                    d.multiaddr = [];\n                    if (o.bytes !== Array)\n                        d.multiaddr = $util.newBuffer(d.multiaddr);\n                }\n            }\n            if (m.multiaddr != null && m.hasOwnProperty(\"multiaddr\")) {\n                d.multiaddr = o.bytes === String ? $util.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;\n            }\n            if (m.isCertified != null && m.hasOwnProperty(\"isCertified\")) {\n                d.isCertified = m.isCertified;\n                if (o.oneofs)\n                    d._isCertified = \"isCertified\";\n            }\n            return d;\n        };\n\n        /**\n         * Converts this Address to JSON.\n         * @function toJSON\n         * @memberof Addresses.Address\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Address.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Address;\n    })();\n\n    Addresses.CertifiedRecord = (function() {\n\n        /**\n         * Properties of a CertifiedRecord.\n         * @memberof Addresses\n         * @interface ICertifiedRecord\n         * @property {number|null} [seq] CertifiedRecord seq\n         * @property {Uint8Array|null} [raw] CertifiedRecord raw\n         */\n\n        /**\n         * Constructs a new CertifiedRecord.\n         * @memberof Addresses\n         * @classdesc Represents a CertifiedRecord.\n         * @implements ICertifiedRecord\n         * @constructor\n         * @param {Addresses.ICertifiedRecord=} [p] Properties to set\n         */\n        function CertifiedRecord(p) {\n            if (p)\n                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                    if (p[ks[i]] != null)\n                        this[ks[i]] = p[ks[i]];\n        }\n\n        /**\n         * CertifiedRecord seq.\n         * @member {number} seq\n         * @memberof Addresses.CertifiedRecord\n         * @instance\n         */\n        CertifiedRecord.prototype.seq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n        /**\n         * CertifiedRecord raw.\n         * @member {Uint8Array} raw\n         * @memberof Addresses.CertifiedRecord\n         * @instance\n         */\n        CertifiedRecord.prototype.raw = $util.newBuffer([]);\n\n        /**\n         * Encodes the specified CertifiedRecord message. Does not implicitly {@link Addresses.CertifiedRecord.verify|verify} messages.\n         * @function encode\n         * @memberof Addresses.CertifiedRecord\n         * @static\n         * @param {Addresses.ICertifiedRecord} m CertifiedRecord message or plain object to encode\n         * @param {$protobuf.Writer} [w] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CertifiedRecord.encode = function encode(m, w) {\n            if (!w)\n                w = $Writer.create();\n            if (m.seq != null && Object.hasOwnProperty.call(m, \"seq\"))\n                w.uint32(8).uint64(m.seq);\n            if (m.raw != null && Object.hasOwnProperty.call(m, \"raw\"))\n                w.uint32(18).bytes(m.raw);\n            return w;\n        };\n\n        /**\n         * Decodes a CertifiedRecord message from the specified reader or buffer.\n         * @function decode\n         * @memberof Addresses.CertifiedRecord\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n         * @param {number} [l] Message length if known beforehand\n         * @returns {Addresses.CertifiedRecord} CertifiedRecord\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CertifiedRecord.decode = function decode(r, l) {\n            if (!(r instanceof $Reader))\n                r = $Reader.create(r);\n            var c = l === undefined ? r.len : r.pos + l, m = new $root.Addresses.CertifiedRecord();\n            while (r.pos < c) {\n                var t = r.uint32();\n                switch (t >>> 3) {\n                case 1:\n                    m.seq = r.uint64();\n                    break;\n                case 2:\n                    m.raw = r.bytes();\n                    break;\n                default:\n                    r.skipType(t & 7);\n                    break;\n                }\n            }\n            return m;\n        };\n\n        /**\n         * Creates a CertifiedRecord message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Addresses.CertifiedRecord\n         * @static\n         * @param {Object.<string,*>} d Plain object\n         * @returns {Addresses.CertifiedRecord} CertifiedRecord\n         */\n        CertifiedRecord.fromObject = function fromObject(d) {\n            if (d instanceof $root.Addresses.CertifiedRecord)\n                return d;\n            var m = new $root.Addresses.CertifiedRecord();\n            if (d.seq != null) {\n                if ($util.Long)\n                    (m.seq = $util.Long.fromValue(d.seq)).unsigned = true;\n                else if (typeof d.seq === \"string\")\n                    m.seq = parseInt(d.seq, 10);\n                else if (typeof d.seq === \"number\")\n                    m.seq = d.seq;\n                else if (typeof d.seq === \"object\")\n                    m.seq = new $util.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);\n            }\n            if (d.raw != null) {\n                if (typeof d.raw === \"string\")\n                    $util.base64.decode(d.raw, m.raw = $util.newBuffer($util.base64.length(d.raw)), 0);\n                else if (d.raw.length)\n                    m.raw = d.raw;\n            }\n            return m;\n        };\n\n        /**\n         * Creates a plain object from a CertifiedRecord message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Addresses.CertifiedRecord\n         * @static\n         * @param {Addresses.CertifiedRecord} m CertifiedRecord\n         * @param {$protobuf.IConversionOptions} [o] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CertifiedRecord.toObject = function toObject(m, o) {\n            if (!o)\n                o = {};\n            var d = {};\n            if (o.defaults) {\n                if ($util.Long) {\n                    var n = new $util.Long(0, 0, true);\n                    d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n                } else\n                    d.seq = o.longs === String ? \"0\" : 0;\n                if (o.bytes === String)\n                    d.raw = \"\";\n                else {\n                    d.raw = [];\n                    if (o.bytes !== Array)\n                        d.raw = $util.newBuffer(d.raw);\n                }\n            }\n            if (m.seq != null && m.hasOwnProperty(\"seq\")) {\n                if (typeof m.seq === \"number\")\n                    d.seq = o.longs === String ? String(m.seq) : m.seq;\n                else\n                    d.seq = o.longs === String ? $util.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;\n            }\n            if (m.raw != null && m.hasOwnProperty(\"raw\")) {\n                d.raw = o.bytes === String ? $util.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;\n            }\n            return d;\n        };\n\n        /**\n         * Converts this CertifiedRecord to JSON.\n         * @function toJSON\n         * @memberof Addresses.CertifiedRecord\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CertifiedRecord.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CertifiedRecord;\n    })();\n\n    return Addresses;\n})();\n\nexport { $root as default };\n"]},"metadata":{},"sourceType":"module"}