{"ast":null,"code":"import { namespaceLength, namespace, peerIdToRoutingKey } from 'ipns';\nimport { ipnsValidator } from 'ipns/validator';\nimport { ipnsSelector } from 'ipns/selector';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { PubSubDatastore } from 'datastore-pubsub';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromString } from '@libp2p/peer-id';\nconst log = logger('ipfs:ipns:pubsub');\n/**\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n// Pubsub datastore aims to manage the pubsub subscriptions for IPNS\n\nexport class IpnsPubsubDatastore {\n  /**\n   * @param {import('@libp2p/interface-pubsub').PubSub} pubsub\n   * @param {import('interface-datastore').Datastore} localDatastore\n   * @param {import('@libp2p/interface-peer-id').PeerId} peerId\n   */\n  constructor(pubsub, localDatastore, peerId) {\n    /** @type {Record<string, string>} */\n    this._subscriptions = {}; // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);\n    this._pubsubDs = new PubSubDatastore(pubsub, localDatastore, peerId, ipnsValidator, ipnsSelector, this._handleSubscriptionKey);\n  }\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   * @param {AbortOptions} [options]\n   */\n\n\n  async put(key, value, options) {\n    try {\n      await this._pubsubDs.put(key, value, options);\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n      throw err;\n    }\n  }\n  /**\n   * Get a value from the pubsub datastore indexed by the received key properly encoded.\n   * Also, the identifier topic is subscribed to and the pubsub datastore records will be\n   * updated once new publishes occur.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   * @param {AbortOptions} [options]\n   */\n\n\n  async get(key, options) {\n    let res;\n    let err;\n\n    try {\n      res = await this._pubsubDs.get(key, options);\n    } catch (\n    /** @type {any} */\n    e) {\n      err = e;\n    } // Add topic subscribed\n\n\n    const ns = key.slice(0, namespaceLength);\n\n    if (uint8ArrayToString(ns) === namespace) {\n      const stringifiedTopic = base58btc.encode(key).substring(1);\n      const id = base58btc.encode(key.slice(namespaceLength)).substring(1);\n      this._subscriptions[stringifiedTopic] = id;\n      log(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`);\n    } // If no data was obtained, after storing the subscription, return the error.\n\n\n    if (err) {\n      throw err;\n    }\n\n    return res;\n  }\n  /**\n   * Modify subscription key to have a proper encoding\n   *\n   * @param {Uint8Array | string} key\n   */\n\n\n  _handleSubscriptionKey(key) {\n    if (key instanceof Uint8Array) {\n      key = uint8ArrayToString(key, 'base58btc');\n    }\n\n    const subscriber = this._subscriptions[key];\n\n    if (!subscriber) {\n      throw errcode(new Error(`key ${key} does not correspond to a subscription`), 'ERR_INVALID_KEY');\n    }\n\n    try {\n      const k = peerIdToRoutingKey(peerIdFromString(subscriber));\n      return k;\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n      throw err;\n    }\n  }\n  /**\n   * Get pubsub subscriptions related to ipns.\n   */\n\n\n  getSubscriptions() {\n    const subscriptions = Object.values(this._subscriptions).filter(Boolean);\n    return subscriptions.map(sub => `${namespace}${sub}`);\n  }\n  /**\n   * Cancel pubsub subscriptions related to ipns.\n   *\n   * @param {string} name - ipns path to cancel the pubsub subscription.\n   */\n\n\n  async cancel(name) {\n    // eslint-disable-line require-await\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME');\n    } // Trim /ipns/ prefix from the name\n\n\n    if (name.startsWith(namespace)) {\n      name = name.substring(namespaceLength);\n    }\n\n    const stringifiedTopic = Object.keys(this._subscriptions).find(key => this._subscriptions[key] === name); // Not found topic\n\n    if (!stringifiedTopic) {\n      return {\n        canceled: false\n      };\n    } // Unsubscribe topic\n\n\n    const bufTopic = uint8ArrayFromString(stringifiedTopic);\n\n    this._pubsubDs.unsubscribe(bufTopic);\n\n    delete this._subscriptions[stringifiedTopic];\n    log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`);\n    return {\n      canceled: true\n    };\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/ipns/routing/pubsub-datastore.js"],"names":["namespaceLength","namespace","peerIdToRoutingKey","ipnsValidator","ipnsSelector","base58btc","PubSubDatastore","fromString","uint8ArrayFromString","toString","uint8ArrayToString","errcode","logger","peerIdFromString","log","IpnsPubsubDatastore","constructor","pubsub","localDatastore","peerId","_subscriptions","_handleSubscriptionKey","bind","_pubsubDs","put","key","value","options","err","error","get","res","e","ns","slice","stringifiedTopic","encode","substring","id","Uint8Array","subscriber","Error","k","getSubscriptions","subscriptions","Object","values","filter","Boolean","map","sub","cancel","name","startsWith","keys","find","canceled","bufTopic","unsubscribe"],"mappings":"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","sourcesContent":["import { namespaceLength, namespace, peerIdToRoutingKey } from 'ipns'\nimport { ipnsValidator } from 'ipns/validator'\nimport { ipnsSelector } from 'ipns/selector'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { PubSubDatastore } from 'datastore-pubsub'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { peerIdFromString } from '@libp2p/peer-id'\n\nconst log = logger('ipfs:ipns:pubsub')\n\n/**\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\n// Pubsub datastore aims to manage the pubsub subscriptions for IPNS\nexport class IpnsPubsubDatastore {\n  /**\n   * @param {import('@libp2p/interface-pubsub').PubSub} pubsub\n   * @param {import('interface-datastore').Datastore} localDatastore\n   * @param {import('@libp2p/interface-peer-id').PeerId} peerId\n   */\n  constructor (pubsub, localDatastore, peerId) {\n    /** @type {Record<string, string>} */\n    this._subscriptions = {}\n\n    // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this)\n\n    this._pubsubDs = new PubSubDatastore(pubsub, localDatastore, peerId, ipnsValidator, ipnsSelector, this._handleSubscriptionKey)\n  }\n\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   * @param {AbortOptions} [options]\n   */\n  async put (key, value, options) {\n    try {\n      await this._pubsubDs.put(key, value, options)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw err\n    }\n  }\n\n  /**\n   * Get a value from the pubsub datastore indexed by the received key properly encoded.\n   * Also, the identifier topic is subscribed to and the pubsub datastore records will be\n   * updated once new publishes occur.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   * @param {AbortOptions} [options]\n   */\n  async get (key, options) {\n    let res\n    let err\n\n    try {\n      res = await this._pubsubDs.get(key, options)\n    } catch (/** @type {any} */ e) {\n      err = e\n    }\n\n    // Add topic subscribed\n    const ns = key.slice(0, namespaceLength)\n\n    if (uint8ArrayToString(ns) === namespace) {\n      const stringifiedTopic = base58btc.encode(key).substring(1)\n      const id = base58btc.encode(key.slice(namespaceLength)).substring(1)\n\n      this._subscriptions[stringifiedTopic] = id\n\n      log(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`)\n    }\n\n    // If no data was obtained, after storing the subscription, return the error.\n    if (err) {\n      throw err\n    }\n\n    return res\n  }\n\n  /**\n   * Modify subscription key to have a proper encoding\n   *\n   * @param {Uint8Array | string} key\n   */\n  _handleSubscriptionKey (key) {\n    if (key instanceof Uint8Array) {\n      key = uint8ArrayToString(key, 'base58btc')\n    }\n\n    const subscriber = this._subscriptions[key]\n\n    if (!subscriber) {\n      throw errcode(new Error(`key ${key} does not correspond to a subscription`), 'ERR_INVALID_KEY')\n    }\n\n    try {\n      const k = peerIdToRoutingKey(peerIdFromString(subscriber))\n      return k\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw err\n    }\n  }\n\n  /**\n   * Get pubsub subscriptions related to ipns.\n   */\n  getSubscriptions () {\n    const subscriptions = Object.values(this._subscriptions).filter(Boolean)\n\n    return subscriptions.map((sub) => `${namespace}${sub}`)\n  }\n\n  /**\n   * Cancel pubsub subscriptions related to ipns.\n   *\n   * @param {string} name - ipns path to cancel the pubsub subscription.\n   */\n  async cancel (name) { // eslint-disable-line require-await\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME')\n    }\n\n    // Trim /ipns/ prefix from the name\n    if (name.startsWith(namespace)) {\n      name = name.substring(namespaceLength)\n    }\n\n    const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name)\n\n    // Not found topic\n    if (!stringifiedTopic) {\n      return {\n        canceled: false\n      }\n    }\n\n    // Unsubscribe topic\n    const bufTopic = uint8ArrayFromString(stringifiedTopic)\n\n    this._pubsubDs.unsubscribe(bufTopic)\n\n    delete this._subscriptions[stringifiedTopic]\n    log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`)\n\n    return {\n      canceled: true\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}