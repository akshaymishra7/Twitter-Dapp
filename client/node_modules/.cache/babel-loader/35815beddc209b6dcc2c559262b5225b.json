{"ast":null,"code":"import { sha256 } from 'multiformats/hashes/sha2';\nimport { Key } from 'interface-datastore/key';\nimport { Libp2pRecord } from '@libp2p/record';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport isPrivateIp from 'private-ip';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport { RECORD_KEY_PREFIX } from './constants.js'; // const IPNS_PREFIX = uint8ArrayFromString('/ipns/')\n\nconst PK_PREFIX = uint8ArrayFromString('/pk/');\nexport function removePrivateAddresses(peer) {\n  return { ...peer,\n    multiaddrs: peer.multiaddrs.filter(multiaddr => {\n      const [[type, addr]] = multiaddr.stringTuples(); // treat /dns, /dns4, and /dns6 addrs as public\n\n      if (type === 53 || type === 54 || type === 55) {\n        // localhost can be a dns address but it's private\n        if (addr === 'localhost') {\n          return false;\n        }\n\n        return true;\n      }\n\n      if (type !== 4 && type !== 6) {\n        return false;\n      }\n\n      if (addr == null) {\n        return false;\n      }\n\n      const isPrivate = isPrivateIp(addr);\n\n      if (isPrivate == null) {\n        // not an ip address\n        return true;\n      }\n\n      return !isPrivate;\n    })\n  };\n}\nexport function removePublicAddresses(peer) {\n  return { ...peer,\n    multiaddrs: peer.multiaddrs.filter(multiaddr => {\n      const [[type, addr]] = multiaddr.stringTuples();\n\n      if (addr === 'localhost') {\n        return true;\n      }\n\n      if (type !== 4 && type !== 6) {\n        return false;\n      }\n\n      if (addr == null) {\n        return false;\n      }\n\n      const isPrivate = isPrivateIp(addr);\n\n      if (isPrivate == null) {\n        // not an ip address\n        return false;\n      }\n\n      return isPrivate;\n    })\n  };\n}\n/**\n * Creates a DHT ID by hashing a given Uint8Array\n */\n\nexport async function convertBuffer(buf) {\n  const multihash = await sha256.digest(buf);\n  return multihash.digest;\n}\n/**\n * Creates a DHT ID by hashing a Peer ID\n */\n\nexport async function convertPeerId(peerId) {\n  return await convertBuffer(peerId.toBytes());\n}\n/**\n * Convert a Uint8Array to their SHA2-256 hash\n */\n\nexport function bufferToKey(buf) {\n  return new Key('/' + uint8ArrayToString(buf, 'base32'), false);\n}\n/**\n * Convert a Uint8Array to their SHA2-256 hash\n */\n\nexport function bufferToRecordKey(buf) {\n  return new Key(`${RECORD_KEY_PREFIX}/${uint8ArrayToString(buf, 'base32')}`, false);\n}\n/**\n * Generate the key for a public key.\n */\n\nexport function keyForPublicKey(peer) {\n  return uint8ArrayConcat([PK_PREFIX, peer.toBytes()]);\n}\nexport function isPublicKeyKey(key) {\n  return uint8ArrayToString(key.subarray(0, 4)) === '/pk/';\n}\nexport function isIPNSKey(key) {\n  return uint8ArrayToString(key.subarray(0, 4)) === '/ipns/';\n}\nexport function fromPublicKeyKey(key) {\n  return peerIdFromBytes(key.subarray(4));\n}\n/**\n * Create a new put record, encodes and signs it if enabled\n */\n\nexport function createPutRecord(key, value) {\n  const timeReceived = new Date();\n  const rec = new Libp2pRecord(key, value, timeReceived);\n  return rec.serialize();\n}\nexport function debounce(callback) {\n  let wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n  let timeout;\n  return () => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      callback();\n    }, wait);\n  };\n}","map":{"version":3,"mappings":"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","names":["sha256","Key","Libp2pRecord","fromString","uint8ArrayFromString","toString","uint8ArrayToString","concat","uint8ArrayConcat","isPrivateIp","peerIdFromBytes","RECORD_KEY_PREFIX","PK_PREFIX","removePrivateAddresses","peer","multiaddrs","filter","multiaddr","type","addr","stringTuples","isPrivate","removePublicAddresses","convertBuffer","buf","multihash","digest","convertPeerId","peerId","toBytes","bufferToKey","bufferToRecordKey","keyForPublicKey","isPublicKeyKey","key","subarray","isIPNSKey","fromPublicKeyKey","createPutRecord","value","timeReceived","Date","rec","serialize","debounce","callback","wait","timeout","clearTimeout","setTimeout"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\utils.ts"],"sourcesContent":["import { sha256 } from 'multiformats/hashes/sha2'\nimport { Key } from 'interface-datastore/key'\nimport { Libp2pRecord } from '@libp2p/record'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport isPrivateIp from 'private-ip'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport { RECORD_KEY_PREFIX } from './constants.js'\n\n// const IPNS_PREFIX = uint8ArrayFromString('/ipns/')\nconst PK_PREFIX = uint8ArrayFromString('/pk/')\n\nexport function removePrivateAddresses (peer: PeerInfo): PeerInfo {\n  return {\n    ...peer,\n    multiaddrs: peer.multiaddrs.filter(multiaddr => {\n      const [[type, addr]] = multiaddr.stringTuples()\n\n      // treat /dns, /dns4, and /dns6 addrs as public\n      if (type === 53 || type === 54 || type === 55) {\n        // localhost can be a dns address but it's private\n        if (addr === 'localhost') {\n          return false\n        }\n\n        return true\n      }\n\n      if (type !== 4 && type !== 6) {\n        return false\n      }\n\n      if (addr == null) {\n        return false\n      }\n\n      const isPrivate = isPrivateIp(addr)\n\n      if (isPrivate == null) {\n        // not an ip address\n        return true\n      }\n\n      return !isPrivate\n    })\n  }\n}\n\nexport function removePublicAddresses (peer: PeerInfo): PeerInfo {\n  return {\n    ...peer,\n    multiaddrs: peer.multiaddrs.filter(multiaddr => {\n      const [[type, addr]] = multiaddr.stringTuples()\n\n      if (addr === 'localhost') {\n        return true\n      }\n\n      if (type !== 4 && type !== 6) {\n        return false\n      }\n\n      if (addr == null) {\n        return false\n      }\n\n      const isPrivate = isPrivateIp(addr)\n\n      if (isPrivate == null) {\n        // not an ip address\n        return false\n      }\n\n      return isPrivate\n    })\n  }\n}\n\n/**\n * Creates a DHT ID by hashing a given Uint8Array\n */\nexport async function convertBuffer (buf: Uint8Array): Promise<Uint8Array> {\n  const multihash = await sha256.digest(buf)\n\n  return multihash.digest\n}\n\n/**\n * Creates a DHT ID by hashing a Peer ID\n */\nexport async function convertPeerId (peerId: PeerId): Promise<Uint8Array> {\n  return await convertBuffer(peerId.toBytes())\n}\n\n/**\n * Convert a Uint8Array to their SHA2-256 hash\n */\nexport function bufferToKey (buf: Uint8Array): Key {\n  return new Key('/' + uint8ArrayToString(buf, 'base32'), false)\n}\n\n/**\n * Convert a Uint8Array to their SHA2-256 hash\n */\nexport function bufferToRecordKey (buf: Uint8Array): Key {\n  return new Key(`${RECORD_KEY_PREFIX}/${uint8ArrayToString(buf, 'base32')}`, false)\n}\n\n/**\n * Generate the key for a public key.\n */\nexport function keyForPublicKey (peer: PeerId): Uint8Array {\n  return uint8ArrayConcat([\n    PK_PREFIX,\n    peer.toBytes()\n  ])\n}\n\nexport function isPublicKeyKey (key: Uint8Array): boolean {\n  return uint8ArrayToString(key.subarray(0, 4)) === '/pk/'\n}\n\nexport function isIPNSKey (key: Uint8Array): boolean {\n  return uint8ArrayToString(key.subarray(0, 4)) === '/ipns/'\n}\n\nexport function fromPublicKeyKey (key: Uint8Array): PeerId {\n  return peerIdFromBytes(key.subarray(4))\n}\n\n/**\n * Create a new put record, encodes and signs it if enabled\n */\nexport function createPutRecord (key: Uint8Array, value: Uint8Array): Uint8Array {\n  const timeReceived = new Date()\n  const rec = new Libp2pRecord(key, value, timeReceived)\n\n  return rec.serialize()\n}\n\nexport function debounce (callback: () => void, wait: number = 100): () => void {\n  let timeout: ReturnType<typeof setTimeout>\n\n  return (): void => {\n    clearTimeout(timeout)\n    timeout = setTimeout(() => { callback() }, wait)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}