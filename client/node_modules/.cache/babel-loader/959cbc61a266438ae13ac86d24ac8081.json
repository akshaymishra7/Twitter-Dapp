{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport * as multistream from './multistream.js';\nimport { handshake } from 'it-handshake';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { PROTOCOL_ID } from './index.js';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { pushable } from 'it-pushable';\nimport merge from 'it-merge';\nimport { reader } from 'it-reader';\nconst log = logger('libp2p:mss:select');\nexport async function select(stream, protocols) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];\n  const {\n    reader,\n    writer,\n    rest,\n    stream: shakeStream\n  } = handshake(stream);\n  const protocol = protocols.shift();\n\n  if (protocol == null) {\n    throw new Error('At least one protocol must be specified');\n  }\n\n  log.trace('select: write [\"%s\", \"%s\"]', PROTOCOL_ID, protocol);\n  const p1 = uint8ArrayFromString(PROTOCOL_ID);\n  const p2 = uint8ArrayFromString(protocol);\n  multistream.writeAll(writer, [p1, p2], options);\n  let response = await multistream.readString(reader, options);\n  log.trace('select: read \"%s\"', response); // Read the protocol response if we got the protocolId in return\n\n  if (response === PROTOCOL_ID) {\n    response = await multistream.readString(reader, options);\n    log.trace('select: read \"%s\"', response);\n  } // We're done\n\n\n  if (response === protocol) {\n    rest();\n    return {\n      stream: shakeStream,\n      protocol\n    };\n  } // We haven't gotten a valid ack, try the other protocols\n\n\n  for (const protocol of protocols) {\n    log.trace('select: write \"%s\"', protocol);\n    multistream.write(writer, uint8ArrayFromString(protocol), options);\n    const response = await multistream.readString(reader, options);\n    log.trace('select: read \"%s\" for \"%s\"', response, protocol);\n\n    if (response === protocol) {\n      rest(); // End our writer so others can start writing to stream\n\n      return {\n        stream: shakeStream,\n        protocol\n      };\n    }\n  }\n\n  rest();\n  throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL');\n}\nexport function lazySelect(stream, protocol) {\n  // This is a signal to write the multistream headers if the consumer tries to\n  // read from the source\n  const negotiateTrigger = pushable();\n  let negotiated = false;\n  return {\n    stream: {\n      sink: async source => {\n        await stream.sink(async function* () {\n          let first = true;\n\n          for await (const chunk of merge(source, negotiateTrigger)) {\n            if (first) {\n              first = false;\n              negotiated = true;\n              negotiateTrigger.end();\n              const p1 = uint8ArrayFromString(PROTOCOL_ID);\n              const p2 = uint8ArrayFromString(protocol);\n              const list = new Uint8ArrayList(multistream.encode(p1), multistream.encode(p2));\n              if (chunk.length > 0) list.append(chunk);\n              yield* list;\n            } else {\n              yield chunk;\n            }\n          }\n        }());\n      },\n      source: async function* () {\n        if (!negotiated) negotiateTrigger.push(new Uint8Array());\n        const byteReader = reader(stream.source);\n        let response = await multistream.readString(byteReader);\n\n        if (response === PROTOCOL_ID) {\n          response = await multistream.readString(byteReader);\n        }\n\n        if (response !== protocol) {\n          throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL');\n        }\n\n        for await (const chunk of byteReader) {\n          yield* chunk;\n        }\n      }()\n    },\n    protocol\n  };\n}","map":{"version":3,"mappings":"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","names":["logger","CodeError","multistream","handshake","fromString","uint8ArrayFromString","PROTOCOL_ID","Uint8ArrayList","pushable","merge","reader","log","select","stream","protocols","options","Array","isArray","writer","rest","shakeStream","protocol","shift","Error","trace","p1","p2","writeAll","response","readString","write","lazySelect","negotiateTrigger","negotiated","sink","source","first","chunk","end","list","encode","length","append","push","Uint8Array","byteReader"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\multistream-select\\src\\select.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport * as multistream from './multistream.js'\nimport { handshake } from 'it-handshake'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { PROTOCOL_ID } from './index.js'\nimport type { Duplex, Source } from 'it-stream-types'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { pushable } from 'it-pushable'\nimport merge from 'it-merge'\nimport { reader } from 'it-reader'\nimport type { ByteArrayInit, ByteListInit, MultistreamSelectInit, ProtocolStream } from './index.js'\n\nconst log = logger('libp2p:mss:select')\n\n/**\n * Negotiate a protocol to use from a list of protocols.\n *\n * @param stream - A duplex iterable stream to dial on\n * @param protocols - A list of protocols (or single protocol) to negotiate with. Protocols are attempted in order until a match is made.\n * @param options - An options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`.\n * @example\n *\n * ```js\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex()\n * const muxedStream = muxer.newStream()\n *\n * // mss.select(protocol(s))\n * // Select from one of the passed protocols (in priority order)\n * // Returns selected stream and protocol\n * const { stream: dhtStream, protocol } = await mss.select(muxedStream, [\n *   // This might just be different versions of DHT, but could be different impls\n *   '/ipfs-dht/2.0.0', // Most of the time this will probably just be one item.\n *   '/ipfs-dht/1.0.0'\n * ])\n *\n * // Typically this stream will be passed back to the caller of libp2p.dialProtocol\n * //\n * // ...it might then do something like this:\n * // try {\n * //   await pipe(\n * //     [uint8ArrayFromString('Some DHT data')]\n * //     dhtStream,\n * //     async source => {\n * //       for await (const chunk of source)\n * //         // DHT response data\n * //     }\n * //   )\n * // } catch (err) {\n * //   // Error in stream\n * // }\n * ```\n */\nexport async function select (stream: Duplex<AsyncGenerator<Uint8Array>, Source<Uint8Array>>, protocols: string | string[], options: ByteArrayInit): Promise<ProtocolStream<Uint8Array>>\nexport async function select (stream: Duplex<AsyncGenerator<Uint8ArrayList | Uint8Array>, Source<Uint8ArrayList | Uint8Array>>, protocols: string | string[], options?: ByteListInit): Promise<ProtocolStream<Uint8ArrayList, Uint8ArrayList | Uint8Array>>\nexport async function select (stream: any, protocols: string | string[], options: MultistreamSelectInit = {}): Promise<ProtocolStream<any>> {\n  protocols = Array.isArray(protocols) ? [...protocols] : [protocols]\n  const { reader, writer, rest, stream: shakeStream } = handshake(stream)\n\n  const protocol = protocols.shift()\n\n  if (protocol == null) {\n    throw new Error('At least one protocol must be specified')\n  }\n\n  log.trace('select: write [\"%s\", \"%s\"]', PROTOCOL_ID, protocol)\n  const p1 = uint8ArrayFromString(PROTOCOL_ID)\n  const p2 = uint8ArrayFromString(protocol)\n  multistream.writeAll(writer, [p1, p2], options)\n\n  let response = await multistream.readString(reader, options)\n  log.trace('select: read \"%s\"', response)\n\n  // Read the protocol response if we got the protocolId in return\n  if (response === PROTOCOL_ID) {\n    response = await multistream.readString(reader, options)\n    log.trace('select: read \"%s\"', response)\n  }\n\n  // We're done\n  if (response === protocol) {\n    rest()\n    return { stream: shakeStream, protocol }\n  }\n\n  // We haven't gotten a valid ack, try the other protocols\n  for (const protocol of protocols) {\n    log.trace('select: write \"%s\"', protocol)\n    multistream.write(writer, uint8ArrayFromString(protocol), options)\n    const response = await multistream.readString(reader, options)\n    log.trace('select: read \"%s\" for \"%s\"', response, protocol)\n\n    if (response === protocol) {\n      rest() // End our writer so others can start writing to stream\n      return { stream: shakeStream, protocol }\n    }\n  }\n\n  rest()\n  throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL')\n}\n\n/**\n * Lazily negotiates a protocol.\n *\n * It *does not* block writes waiting for the other end to respond. Instead, it\n * simply assumes the negotiation went successfully and starts writing data.\n *\n * Use when it is known that the receiver supports the desired protocol.\n */\nexport function lazySelect (stream: Duplex<Source<Uint8Array>, Source<Uint8Array>>, protocol: string): ProtocolStream<Uint8Array>\nexport function lazySelect (stream: Duplex<Source<Uint8ArrayList | Uint8Array>, Source<Uint8ArrayList | Uint8Array>>, protocol: string): ProtocolStream<Uint8ArrayList, Uint8ArrayList | Uint8Array>\nexport function lazySelect (stream: Duplex<any>, protocol: string): ProtocolStream<any> {\n  // This is a signal to write the multistream headers if the consumer tries to\n  // read from the source\n  const negotiateTrigger = pushable()\n  let negotiated = false\n  return {\n    stream: {\n      sink: async source => {\n        await stream.sink((async function * () {\n          let first = true\n          for await (const chunk of merge(source, negotiateTrigger)) {\n            if (first) {\n              first = false\n              negotiated = true\n              negotiateTrigger.end()\n              const p1 = uint8ArrayFromString(PROTOCOL_ID)\n              const p2 = uint8ArrayFromString(protocol)\n              const list = new Uint8ArrayList(multistream.encode(p1), multistream.encode(p2))\n              if (chunk.length > 0) list.append(chunk)\n              yield * list\n            } else {\n              yield chunk\n            }\n          }\n        })())\n      },\n      source: (async function * () {\n        if (!negotiated) negotiateTrigger.push(new Uint8Array())\n        const byteReader = reader(stream.source)\n        let response = await multistream.readString(byteReader)\n        if (response === PROTOCOL_ID) {\n          response = await multistream.readString(byteReader)\n        }\n        if (response !== protocol) {\n          throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL')\n        }\n        for await (const chunk of byteReader) {\n          yield * chunk\n        }\n      })()\n    },\n    protocol\n  }\n}\n"]},"metadata":{},"sourceType":"module"}