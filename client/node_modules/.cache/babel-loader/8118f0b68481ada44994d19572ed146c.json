{"ast":null,"code":"/* eslint-disable import/export */\n\n/* eslint-disable complexity */\n\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var PeerRecord;\n\n(function (PeerRecord) {\n  let AddressInfo;\n\n  (function (AddressInfo) {\n    let _codec;\n\n    AddressInfo.codec = () => {\n      if (_codec == null) {\n        _codec = message(function (obj, w) {\n          let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {\n            w.uint32(10);\n            w.bytes(obj.multiaddr);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        }, (reader, length) => {\n          const obj = {\n            multiaddr: new Uint8Array(0)\n          };\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.multiaddr = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        });\n      }\n\n      return _codec;\n    };\n\n    AddressInfo.encode = obj => {\n      return encodeMessage(obj, AddressInfo.codec());\n    };\n\n    AddressInfo.decode = buf => {\n      return decodeMessage(buf, AddressInfo.codec());\n    };\n  })(AddressInfo = PeerRecord.AddressInfo || (PeerRecord.AddressInfo = {}));\n\n  let _codec;\n\n  PeerRecord.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.peerId != null && obj.peerId.byteLength > 0) {\n          w.uint32(10);\n          w.bytes(obj.peerId);\n        }\n\n        if (obj.seq != null && obj.seq !== 0n) {\n          w.uint32(16);\n          w.uint64(obj.seq);\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(26);\n            PeerRecord.AddressInfo.codec().encode(value, w);\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {\n          peerId: new Uint8Array(0),\n          seq: 0n,\n          addresses: []\n        };\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.peerId = reader.bytes();\n              break;\n\n            case 2:\n              obj.seq = reader.uint64();\n              break;\n\n            case 3:\n              obj.addresses.push(PeerRecord.AddressInfo.codec().decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  PeerRecord.encode = obj => {\n    return encodeMessage(obj, PeerRecord.codec());\n  };\n\n  PeerRecord.decode = buf => {\n    return decodeMessage(buf, PeerRecord.codec());\n  };\n})(PeerRecord || (PeerRecord = {}));","map":{"version":3,"mappings":"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","names":["encodeMessage","decodeMessage","message","PeerRecord","AddressInfo","_codec","obj","w","opts","lengthDelimited","fork","multiaddr","byteLength","uint32","bytes","ldelim","reader","length","Uint8Array","end","len","pos","tag","skipType","codec","buf","peerId","seq","uint64","addresses","value","encode","push","decode"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\peer-record\\src\\peer-record\\peer-record.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface PeerRecord {\n  peerId: Uint8Array\n  seq: bigint\n  addresses: PeerRecord.AddressInfo[]\n}\n\nexport namespace PeerRecord {\n  export interface AddressInfo {\n    multiaddr: Uint8Array\n  }\n\n  export namespace AddressInfo {\n    let _codec: Codec<AddressInfo>\n\n    export const codec = (): Codec<AddressInfo> => {\n      if (_codec == null) {\n        _codec = message<AddressInfo>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n            w.uint32(10)\n            w.bytes(obj.multiaddr)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length) => {\n          const obj: any = {\n            multiaddr: new Uint8Array(0)\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.multiaddr = reader.bytes()\n                break\n              default:\n                reader.skipType(tag & 7)\n                break\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<AddressInfo>): Uint8Array => {\n      return encodeMessage(obj, AddressInfo.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList): AddressInfo => {\n      return decodeMessage(buf, AddressInfo.codec())\n    }\n  }\n\n  let _codec: Codec<PeerRecord>\n\n  export const codec = (): Codec<PeerRecord> => {\n    if (_codec == null) {\n      _codec = message<PeerRecord>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.peerId != null && obj.peerId.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.peerId)\n        }\n\n        if ((obj.seq != null && obj.seq !== 0n)) {\n          w.uint32(16)\n          w.uint64(obj.seq)\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(26)\n            PeerRecord.AddressInfo.codec().encode(value, w)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          peerId: new Uint8Array(0),\n          seq: 0n,\n          addresses: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.peerId = reader.bytes()\n              break\n            case 2:\n              obj.seq = reader.uint64()\n              break\n            case 3:\n              obj.addresses.push(PeerRecord.AddressInfo.codec().decode(reader, reader.uint32()))\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PeerRecord>): Uint8Array => {\n    return encodeMessage(obj, PeerRecord.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PeerRecord => {\n    return decodeMessage(buf, PeerRecord.codec())\n  }\n}\n"]},"metadata":{},"sourceType":"module"}