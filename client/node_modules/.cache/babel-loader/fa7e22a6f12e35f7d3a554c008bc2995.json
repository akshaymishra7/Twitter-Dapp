{"ast":null,"code":"import { CodeError } from '@libp2p/interfaces/errors';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport * as crypto from './ed25519.js';\nimport { exporter } from './exporter.js';\nimport * as pbm from './keys.js';\nexport class Ed25519PublicKey {\n  _key;\n\n  constructor(key) {\n    this._key = ensureKey(key, crypto.publicKeyLength);\n  }\n\n  async verify(data, sig) {\n    return crypto.hashAndVerify(this._key, sig, data);\n  }\n\n  marshal() {\n    return this._key;\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).subarray();\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    const {\n      bytes\n    } = await sha256.digest(this.bytes);\n    return bytes;\n  }\n\n}\nexport class Ed25519PrivateKey {\n  _key;\n  _publicKey; // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n\n  constructor(key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength);\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength);\n  }\n\n  async sign(message) {\n    return crypto.hashAndSign(this._key, message);\n  }\n\n  get public() {\n    return new Ed25519PublicKey(this._publicKey);\n  }\n\n  marshal() {\n    return this._key;\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).subarray();\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    const {\n      bytes\n    } = await sha256.digest(this.bytes);\n    return bytes;\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the identity multihash containing its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n\n\n  async id() {\n    const encoding = identity.digest(this.public.bytes);\n    return base58btc.encode(encoding.bytes).substring(1);\n  }\n  /**\n   * Exports the key into a password protected `format`\n   */\n\n\n  async export(password) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'libp2p-key';\n\n    if (format === 'libp2p-key') {\n      return exporter(this.bytes, password);\n    } else {\n      throw new CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT');\n    }\n  }\n\n}\nexport function unmarshalEd25519PrivateKey(bytes) {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength);\n    const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength);\n    const publicKeyBytes = bytes.subarray(crypto.privateKeyLength, bytes.length);\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n  }\n\n  bytes = ensureKey(bytes, crypto.privateKeyLength);\n  const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength);\n  const publicKeyBytes = bytes.subarray(crypto.publicKeyLength);\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n}\nexport function unmarshalEd25519PublicKey(bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength);\n  return new Ed25519PublicKey(bytes);\n}\nexport async function generateKeyPair() {\n  const {\n    privateKey,\n    publicKey\n  } = await crypto.generateKey();\n  return new Ed25519PrivateKey(privateKey, publicKey);\n}\nexport async function generateKeyPairFromSeed(seed) {\n  const {\n    privateKey,\n    publicKey\n  } = await crypto.generateKeyFromSeed(seed);\n  return new Ed25519PrivateKey(privateKey, publicKey);\n}\n\nfunction ensureKey(key, length) {\n  key = Uint8Array.from(key ?? []);\n\n  if (key.length !== length) {\n    throw new CodeError(`Key must be a Uint8Array of length ${length}, got ${key.length}`, 'ERR_INVALID_KEY_TYPE');\n  }\n\n  return key;\n}","map":{"version":3,"mappings":"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","names":["CodeError","base58btc","identity","sha256","equals","uint8ArrayEquals","crypto","exporter","pbm","Ed25519PublicKey","_key","constructor","key","ensureKey","publicKeyLength","verify","data","sig","hashAndVerify","marshal","bytes","PublicKey","encode","Type","KeyType","Ed25519","Data","subarray","hash","digest","Ed25519PrivateKey","_publicKey","publicKey","privateKeyLength","sign","message","hashAndSign","public","PrivateKey","id","encoding","substring","export","password","format","unmarshalEd25519PrivateKey","length","privateKeyBytes","publicKeyBytes","unmarshalEd25519PublicKey","generateKeyPair","privateKey","generateKey","generateKeyPairFromSeed","seed","generateKeyFromSeed","Uint8Array","from"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\crypto\\src\\keys\\ed25519-class.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { identity } from 'multiformats/hashes/identity'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport * as crypto from './ed25519.js'\nimport { exporter } from './exporter.js'\nimport * as pbm from './keys.js'\nimport type { Multibase } from 'multiformats'\n\nexport class Ed25519PublicKey {\n  private readonly _key: Uint8Array\n\n  constructor (key: Uint8Array) {\n    this._key = ensureKey(key, crypto.publicKeyLength)\n  }\n\n  async verify (data: Uint8Array, sig: Uint8Array): Promise<boolean> { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal (): Uint8Array {\n    return this._key\n  }\n\n  get bytes (): Uint8Array {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).subarray()\n  }\n\n  equals (key: any): boolean {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash (): Promise<Uint8Array> {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n}\n\nexport class Ed25519PrivateKey {\n  private readonly _key: Uint8Array\n  private readonly _publicKey: Uint8Array\n\n  // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n  constructor (key: Uint8Array, publicKey: Uint8Array) {\n    this._key = ensureKey(key, crypto.privateKeyLength)\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength)\n  }\n\n  async sign (message: Uint8Array): Promise<Uint8Array> { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public (): Ed25519PublicKey {\n    return new Ed25519PublicKey(this._publicKey)\n  }\n\n  marshal (): Uint8Array {\n    return this._key\n  }\n\n  get bytes (): Uint8Array {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).subarray()\n  }\n\n  equals (key: any): boolean {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash (): Promise<Uint8Array> {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the identity multihash containing its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n  async id (): Promise<string> {\n    const encoding = identity.digest(this.public.bytes)\n    return base58btc.encode(encoding.bytes).substring(1)\n  }\n\n  /**\n   * Exports the key into a password protected `format`\n   */\n  async export (password: string, format = 'libp2p-key'): Promise<Multibase<'m'>> {\n    if (format === 'libp2p-key') {\n      return exporter(this.bytes, password)\n    } else {\n      throw new CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nexport function unmarshalEd25519PrivateKey (bytes: Uint8Array): Ed25519PrivateKey {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength)\n    const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength)\n    const publicKeyBytes = bytes.subarray(crypto.privateKeyLength, bytes.length)\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n  }\n\n  bytes = ensureKey(bytes, crypto.privateKeyLength)\n  const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength)\n  const publicKeyBytes = bytes.subarray(crypto.publicKeyLength)\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n}\n\nexport function unmarshalEd25519PublicKey (bytes: Uint8Array): Ed25519PublicKey {\n  bytes = ensureKey(bytes, crypto.publicKeyLength)\n  return new Ed25519PublicKey(bytes)\n}\n\nexport async function generateKeyPair (): Promise<Ed25519PrivateKey> {\n  const { privateKey, publicKey } = await crypto.generateKey()\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nexport async function generateKeyPairFromSeed (seed: Uint8Array): Promise<Ed25519PrivateKey> {\n  const { privateKey, publicKey } = await crypto.generateKeyFromSeed(seed)\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nfunction ensureKey (key: Uint8Array, length: number): Uint8Array {\n  key = Uint8Array.from(key ?? [])\n  if (key.length !== length) {\n    throw new CodeError(`Key must be a Uint8Array of length ${length}, got ${key.length}`, 'ERR_INVALID_KEY_TYPE')\n  }\n  return key\n}\n"]},"metadata":{},"sourceType":"module"}