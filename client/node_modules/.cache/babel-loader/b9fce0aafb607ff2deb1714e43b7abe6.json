{"ast":null,"code":"import { TopicValidatorResult } from '@libp2p/interface-pubsub';\nexport var SignaturePolicy;\n\n(function (SignaturePolicy) {\n  /**\n   * On the producing side:\n   * - Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n   *\n   * On the consuming side:\n   * - Enforce the fields to be present, reject otherwise.\n   * - Propagate only if the fields are valid and signature can be verified, reject otherwise.\n   */\n  SignaturePolicy[\"StrictSign\"] = \"StrictSign\";\n  /**\n   * On the producing side:\n   * - Build messages without the signature, key, from and seqno fields.\n   * - The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n   *\n   * On the consuming side:\n   * - Enforce the fields to be absent, reject otherwise.\n   * - Propagate only if the fields are absent, reject otherwise.\n   * - A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n   */\n\n  SignaturePolicy[\"StrictNoSign\"] = \"StrictNoSign\";\n})(SignaturePolicy || (SignaturePolicy = {}));\n\nexport var PublishConfigType;\n\n(function (PublishConfigType) {\n  PublishConfigType[PublishConfigType[\"Signing\"] = 0] = \"Signing\";\n  PublishConfigType[PublishConfigType[\"Anonymous\"] = 1] = \"Anonymous\";\n})(PublishConfigType || (PublishConfigType = {}));\n\nexport var RejectReason;\n\n(function (RejectReason) {\n  /**\n   * The message failed the configured validation during decoding.\n   * SelfOrigin is considered a ValidationError\n   */\n  RejectReason[\"Error\"] = \"error\";\n  /**\n   * Custom validator fn reported status IGNORE.\n   */\n\n  RejectReason[\"Ignore\"] = \"ignore\";\n  /**\n   * Custom validator fn reported status REJECT.\n   */\n\n  RejectReason[\"Reject\"] = \"reject\";\n  /**\n   * The peer that sent the message OR the source from field is blacklisted.\n   * Causes messages to be ignored, not penalized, neither do score record creation.\n   */\n\n  RejectReason[\"Blacklisted\"] = \"blacklisted\";\n})(RejectReason || (RejectReason = {}));\n\nexport var ValidateError;\n\n(function (ValidateError) {\n  /// The message has an invalid signature,\n  ValidateError[\"InvalidSignature\"] = \"invalid_signature\"; /// The sequence number was the incorrect size\n\n  ValidateError[\"InvalidSeqno\"] = \"invalid_seqno\"; /// The PeerId was invalid\n\n  ValidateError[\"InvalidPeerId\"] = \"invalid_peerid\"; /// Signature existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n\n  ValidateError[\"SignaturePresent\"] = \"signature_present\"; /// Sequence number existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n\n  ValidateError[\"SeqnoPresent\"] = \"seqno_present\"; /// Message source existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n\n  ValidateError[\"FromPresent\"] = \"from_present\"; /// The data transformation failed.\n\n  ValidateError[\"TransformFailed\"] = \"transform_failed\";\n})(ValidateError || (ValidateError = {}));\n\nexport var MessageStatus;\n\n(function (MessageStatus) {\n  MessageStatus[\"duplicate\"] = \"duplicate\";\n  MessageStatus[\"invalid\"] = \"invalid\";\n  MessageStatus[\"valid\"] = \"valid\";\n})(MessageStatus || (MessageStatus = {}));\n/**\n * Typesafe conversion of MessageAcceptance -> RejectReason. TS ensures all values covered\n */\n\n\nexport function rejectReasonFromAcceptance(acceptance) {\n  switch (acceptance) {\n    case TopicValidatorResult.Ignore:\n      return RejectReason.Ignore;\n\n    case TopicValidatorResult.Reject:\n      return RejectReason.Reject;\n  }\n}","map":{"version":3,"mappings":"AAIA,SAAkBA,oBAAlB,QAA8C,0BAA9C;AA+CA,WAAYC,eAAZ;;AAAA,WAAYA,eAAZ,EAA2B;AACzB;;;;;;;;AAQAA;AACA;;;;;;;;;;;AAUAA;AACD,CArBD,EAAYA,eAAe,KAAfA,eAAe,MAA3B;;AA4BA,WAAYC,iBAAZ;;AAAA,WAAYA,iBAAZ,EAA6B;AAC3BA;AACAA;AACD,CAHD,EAAYA,iBAAiB,KAAjBA,iBAAiB,MAA7B;;AAkBA,WAAYC,YAAZ;;AAAA,WAAYA,YAAZ,EAAwB;AACtB;;;;AAIAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;;AAIAA;AACD,CAnBD,EAAYA,YAAY,KAAZA,YAAY,MAAxB;;AAqBA,WAAYC,aAAZ;;AAAA,WAAYA,aAAZ,EAAyB;AACvB;AACAA,0DAFuB,CAGvB;;AACAA,kDAJuB,CAKvB;;AACAA,oDANuB,CAOvB;AACA;;AACAA,0DATuB,CAUvB;AACA;;AACAA,kDAZuB,CAavB;AACA;;AACAA,gDAfuB,CAgBvB;;AACAA;AACD,CAlBD,EAAYA,aAAa,KAAbA,aAAa,MAAzB;;AAoBA,WAAYC,aAAZ;;AAAA,WAAYA,aAAZ,EAAyB;AACvBA;AACAA;AACAA;AACD,CAJD,EAAYA,aAAa,KAAbA,aAAa,MAAzB;AAeA;;;;;AAGA,OAAM,SAAUC,0BAAV,CACJC,UADI,EACkE;AAEtE,UAAQA,UAAR;AACE,SAAKP,oBAAoB,CAACQ,MAA1B;AACE,aAAOL,YAAY,CAACK,MAApB;;AACF,SAAKR,oBAAoB,CAACS,MAA1B;AACE,aAAON,YAAY,CAACM,MAApB;AAJJ;AAMD","names":["TopicValidatorResult","SignaturePolicy","PublishConfigType","RejectReason","ValidateError","MessageStatus","rejectReasonFromAcceptance","acceptance","Ignore","Reject"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\types.ts"],"sourcesContent":["import type { PeerId } from '@libp2p/interface-peer-id'\nimport type { PrivateKey } from '@libp2p/interface-keys'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { RPC } from './message/rpc.js'\nimport { Message, TopicValidatorResult } from '@libp2p/interface-pubsub'\n\nexport type MsgIdStr = string\nexport type PeerIdStr = string\nexport type TopicStr = string\nexport type IPStr = string\n\nexport interface AddrInfo {\n  id: PeerId\n  addrs: Multiaddr[]\n}\n\n/**\n * Compute a local non-spec'ed msg-id for faster de-duplication of seen messages.\n * Used exclusively for a local seen_cache\n */\nexport type FastMsgIdFn = (msg: RPC.IMessage) => string | number\n\n/**\n * By default, gossipsub only provide a browser friendly function to convert Uint8Array message id to string.\n * Application could use this option to provide a more efficient function.\n */\nexport type MsgIdToStrFn = (msgId: Uint8Array) => string\n\n/**\n * Compute spec'ed msg-id. Used for IHAVE / IWANT messages\n */\nexport interface MsgIdFn {\n  (msg: Message): Promise<Uint8Array> | Uint8Array\n}\n\nexport interface DataTransform {\n  /**\n   * Takes the data published by peers on a topic and transforms the data.\n   * Should be the reverse of outboundTransform(). Example:\n   * - `inboundTransform()`: decompress snappy payload\n   * - `outboundTransform()`: compress snappy payload\n   */\n  inboundTransform(topic: TopicStr, data: Uint8Array): Uint8Array\n\n  /**\n   * Takes the data to be published (a topic and associated data) transforms the data. The\n   * transformed data will then be used to create a `RawGossipsubMessage` to be sent to peers.\n   */\n  outboundTransform(topic: TopicStr, data: Uint8Array): Uint8Array\n}\n\nexport enum SignaturePolicy {\n  /**\n   * On the producing side:\n   * - Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n   *\n   * On the consuming side:\n   * - Enforce the fields to be present, reject otherwise.\n   * - Propagate only if the fields are valid and signature can be verified, reject otherwise.\n   */\n  StrictSign = 'StrictSign',\n  /**\n   * On the producing side:\n   * - Build messages without the signature, key, from and seqno fields.\n   * - The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n   *\n   * On the consuming side:\n   * - Enforce the fields to be absent, reject otherwise.\n   * - Propagate only if the fields are absent, reject otherwise.\n   * - A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n   */\n  StrictNoSign = 'StrictNoSign'\n}\n\nexport type PublishOpts = {\n  allowPublishToZeroPeers?: boolean\n  ignoreDuplicatePublishError?: boolean\n}\n\nexport enum PublishConfigType {\n  Signing,\n  Anonymous\n}\n\nexport type PublishConfig =\n  | {\n      type: PublishConfigType.Signing\n      author: PeerId\n      key: Uint8Array\n      privateKey: PrivateKey\n    }\n  | { type: PublishConfigType.Anonymous }\n\nexport type RejectReasonObj =\n  | { reason: RejectReason.Error; error: ValidateError }\n  | { reason: Exclude<RejectReason, RejectReason.Error> }\n\nexport enum RejectReason {\n  /**\n   * The message failed the configured validation during decoding.\n   * SelfOrigin is considered a ValidationError\n   */\n  Error = 'error',\n  /**\n   * Custom validator fn reported status IGNORE.\n   */\n  Ignore = 'ignore',\n  /**\n   * Custom validator fn reported status REJECT.\n   */\n  Reject = 'reject',\n  /**\n   * The peer that sent the message OR the source from field is blacklisted.\n   * Causes messages to be ignored, not penalized, neither do score record creation.\n   */\n  Blacklisted = 'blacklisted'\n}\n\nexport enum ValidateError {\n  /// The message has an invalid signature,\n  InvalidSignature = 'invalid_signature',\n  /// The sequence number was the incorrect size\n  InvalidSeqno = 'invalid_seqno',\n  /// The PeerId was invalid\n  InvalidPeerId = 'invalid_peerid',\n  /// Signature existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  SignaturePresent = 'signature_present',\n  /// Sequence number existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  SeqnoPresent = 'seqno_present',\n  /// Message source existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  FromPresent = 'from_present',\n  /// The data transformation failed.\n  TransformFailed = 'transform_failed'\n}\n\nexport enum MessageStatus {\n  duplicate = 'duplicate',\n  invalid = 'invalid',\n  valid = 'valid'\n}\n\n/**\n * Store both Uint8Array and string message id so that we don't have to convert data between the two.\n * See https://github.com/ChainSafe/js-libp2p-gossipsub/pull/274\n */\nexport type MessageId = {\n  msgId: Uint8Array\n  msgIdStr: MsgIdStr\n}\n\n/**\n * Typesafe conversion of MessageAcceptance -> RejectReason. TS ensures all values covered\n */\nexport function rejectReasonFromAcceptance(\n  acceptance: Exclude<TopicValidatorResult, TopicValidatorResult.Accept>\n): RejectReason.Ignore | RejectReason.Reject {\n  switch (acceptance) {\n    case TopicValidatorResult.Ignore:\n      return RejectReason.Ignore\n    case TopicValidatorResult.Reject:\n      return RejectReason.Reject\n  }\n}\n"]},"metadata":{},"sourceType":"module"}