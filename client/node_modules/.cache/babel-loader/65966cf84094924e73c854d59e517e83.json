{"ast":null,"code":"export function computeScore(peer, pstats, params, peerIPs) {\n  let score = 0; // topic stores\n\n  Object.entries(pstats.topics).forEach(_ref => {\n    let [topic, tstats] = _ref;\n    // the topic parameters\n    const topicParams = params.topics[topic];\n\n    if (topicParams === undefined) {\n      // we are not scoring this topic\n      return;\n    }\n\n    let topicScore = 0; // P1: time in Mesh\n\n    if (tstats.inMesh) {\n      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;\n\n      if (p1 > topicParams.timeInMeshCap) {\n        p1 = topicParams.timeInMeshCap;\n      }\n\n      topicScore += p1 * topicParams.timeInMeshWeight;\n    } // P2: first message deliveries\n\n\n    let p2 = tstats.firstMessageDeliveries;\n\n    if (p2 > topicParams.firstMessageDeliveriesCap) {\n      p2 = topicParams.firstMessageDeliveriesCap;\n    }\n\n    topicScore += p2 * topicParams.firstMessageDeliveriesWeight; // P3: mesh message deliveries\n\n    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {\n      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;\n      const p3 = deficit * deficit;\n      topicScore += p3 * topicParams.meshMessageDeliveriesWeight;\n    } // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n\n\n    const p3b = tstats.meshFailurePenalty;\n    topicScore += p3b * topicParams.meshFailurePenaltyWeight; // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;\n    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight; // update score, mixing with topic weight\n\n    score += topicScore * topicParams.topicWeight;\n  }); // apply the topic score cap, if any\n\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap;\n  } // P5: application-specific score\n\n\n  const p5 = params.appSpecificScore(peer);\n  score += p5 * params.appSpecificWeight; // P6: IP colocation factor\n\n  pstats.knownIPs.forEach(ip => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return;\n    } // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n\n\n    const peersInIP = peerIPs.get(ip);\n    const numPeersInIP = peersInIP ? peersInIP.size : 0;\n\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold;\n      const p6 = surplus * surplus;\n      score += p6 * params.IPColocationFactorWeight;\n    }\n  }); // P7: behavioural pattern penalty\n\n  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {\n    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold;\n    const p7 = excess * excess;\n    score += p7 * params.behaviourPenaltyWeight;\n  }\n\n  return score;\n}","map":{"version":3,"mappings":"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","names":["computeScore","peer","pstats","params","peerIPs","score","Object","entries","topics","forEach","topic","tstats","topicParams","undefined","topicScore","inMesh","p1","meshTime","timeInMeshQuantum","timeInMeshCap","timeInMeshWeight","p2","firstMessageDeliveries","firstMessageDeliveriesCap","firstMessageDeliveriesWeight","meshMessageDeliveriesActive","meshMessageDeliveries","meshMessageDeliveriesThreshold","deficit","p3","meshMessageDeliveriesWeight","p3b","meshFailurePenalty","meshFailurePenaltyWeight","p4","invalidMessageDeliveries","invalidMessageDeliveriesWeight","topicWeight","topicScoreCap","p5","appSpecificScore","appSpecificWeight","knownIPs","ip","IPColocationFactorWhitelist","has","peersInIP","get","numPeersInIP","size","IPColocationFactorThreshold","surplus","p6","IPColocationFactorWeight","behaviourPenalty","behaviourPenaltyThreshold","excess","p7","behaviourPenaltyWeight"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\score\\compute-score.ts"],"sourcesContent":["import type { PeerStats } from './peer-stats.js'\nimport type { PeerScoreParams } from './peer-score-params.js'\n\nexport function computeScore(\n  peer: string,\n  pstats: PeerStats,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>\n): number {\n  let score = 0\n\n  // topic stores\n  Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n    // the topic parameters\n    const topicParams = params.topics[topic]\n    if (topicParams === undefined) {\n      // we are not scoring this topic\n      return\n    }\n\n    let topicScore = 0\n\n    // P1: time in Mesh\n    if (tstats.inMesh) {\n      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum\n      if (p1 > topicParams.timeInMeshCap) {\n        p1 = topicParams.timeInMeshCap\n      }\n      topicScore += p1 * topicParams.timeInMeshWeight\n    }\n\n    // P2: first message deliveries\n    let p2 = tstats.firstMessageDeliveries\n    if (p2 > topicParams.firstMessageDeliveriesCap) {\n      p2 = topicParams.firstMessageDeliveriesCap\n    }\n    topicScore += p2 * topicParams.firstMessageDeliveriesWeight\n\n    // P3: mesh message deliveries\n    if (\n      tstats.meshMessageDeliveriesActive &&\n      tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold\n    ) {\n      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries\n      const p3 = deficit * deficit\n      topicScore += p3 * topicParams.meshMessageDeliveriesWeight\n    }\n\n    // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n    const p3b = tstats.meshFailurePenalty\n    topicScore += p3b * topicParams.meshFailurePenaltyWeight\n\n    // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries\n    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight\n\n    // update score, mixing with topic weight\n    score += topicScore * topicParams.topicWeight\n  })\n\n  // apply the topic score cap, if any\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap\n  }\n\n  // P5: application-specific score\n  const p5 = params.appSpecificScore(peer)\n  score += p5 * params.appSpecificWeight\n\n  // P6: IP colocation factor\n  pstats.knownIPs.forEach((ip) => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return\n    }\n\n    // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n    const peersInIP = peerIPs.get(ip)\n    const numPeersInIP = peersInIP ? peersInIP.size : 0\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold\n      const p6 = surplus * surplus\n      score += p6 * params.IPColocationFactorWeight\n    }\n  })\n\n  // P7: behavioural pattern penalty\n  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {\n    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold\n    const p7 = excess * excess\n    score += p7 * params.behaviourPenaltyWeight\n  }\n\n  return score\n}\n"]},"metadata":{},"sourceType":"module"}