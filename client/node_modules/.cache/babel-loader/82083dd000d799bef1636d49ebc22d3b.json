{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\nimport { resolvePath } from '../../utils.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { normaliseInput } from 'ipfs-core-utils/pins/normalise-input';\nimport { PinTypes } from 'ipfs-repo/pin-types';\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {object} config\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\nexport function createAddAll(_ref) {\n  let {\n    repo,\n    codecs\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/pin').API<{}>[\"addAll\"]}\n   */\n  async function* addAll(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * @returns {AsyncIterable<CID>}\n     */\n    const pinAdd = async function* () {\n      for await (const {\n        path,\n        recursive,\n        metadata\n      } of normaliseInput(source)) {\n        const {\n          cid\n        } = await resolvePath(repo, codecs, path); // verify that each hash can be pinned\n\n        const {\n          reason\n        } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]);\n\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(`${cid} already pinned recursively`);\n        }\n\n        if (recursive) {\n          await repo.pins.pinRecursively(cid, {\n            metadata\n          });\n        } else {\n          await repo.pins.pinDirectly(cid, {\n            metadata\n          });\n        }\n\n        yield cid;\n      }\n    }; // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n\n\n    const lock = Boolean(options.lock);\n\n    if (!lock) {\n      yield* pinAdd();\n      return;\n    }\n\n    const release = await repo.gcLock.readLock();\n\n    try {\n      yield* pinAdd();\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption(addAll);\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/pin/add-all.js"],"names":["resolvePath","withTimeoutOption","normaliseInput","PinTypes","createAddAll","repo","codecs","addAll","source","options","pinAdd","path","recursive","metadata","cid","reason","pins","isPinnedWithType","direct","Error","pinRecursively","pinDirectly","lock","Boolean","release","gcLock","readLock"],"mappings":"AAAA;AAEA,SAASA,WAAT,QAA4B,gBAA5B;AACA,SAASC,iBAAT,QAAkC,qCAAlC;AACA,SAASC,cAAT,QAA+B,sCAA/B;AACA,SAASC,QAAT,QAAyB,qBAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,YAAT,OAAyC;AAAA,MAAlB;AAAEC,IAAAA,IAAF;AAAQC,IAAAA;AAAR,GAAkB;;AAC9C;AACF;AACA;AACE,kBAAiBC,MAAjB,CAAyBC,MAAzB,EAA+C;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAC7C;AACJ;AACA;AACI,UAAMC,MAAM,GAAG,mBAAoB;AACjC,iBAAW,MAAM;AAAEC,QAAAA,IAAF;AAAQC,QAAAA,SAAR;AAAmBC,QAAAA;AAAnB,OAAjB,IAAkDX,cAAc,CAACM,MAAD,CAAhE,EAA0E;AACxE,cAAM;AAAEM,UAAAA;AAAF,YAAU,MAAMd,WAAW,CAACK,IAAD,EAAOC,MAAP,EAAeK,IAAf,CAAjC,CADwE,CAGxE;;AACA,cAAM;AAAEI,UAAAA;AAAF,YAAa,MAAMV,IAAI,CAACW,IAAL,CAAUC,gBAAV,CAA2BH,GAA3B,EAAgC,CAACX,QAAQ,CAACS,SAAV,EAAqBT,QAAQ,CAACe,MAA9B,CAAhC,CAAzB;;AAEA,YAAIH,MAAM,KAAK,WAAX,IAA0B,CAACH,SAA/B,EAA0C;AACxC;AACA,gBAAM,IAAIO,KAAJ,CAAW,GAAEL,GAAI,6BAAjB,CAAN;AACD;;AAED,YAAIF,SAAJ,EAAe;AACb,gBAAMP,IAAI,CAACW,IAAL,CAAUI,cAAV,CAAyBN,GAAzB,EAA8B;AAAED,YAAAA;AAAF,WAA9B,CAAN;AACD,SAFD,MAEO;AACL,gBAAMR,IAAI,CAACW,IAAL,CAAUK,WAAV,CAAsBP,GAAtB,EAA2B;AAAED,YAAAA;AAAF,WAA3B,CAAN;AACD;;AAED,cAAMC,GAAN;AACD;AACF,KApBD,CAJ6C,CA0B7C;AACA;;;AACA,UAAMQ,IAAI,GAAGC,OAAO,CAACd,OAAO,CAACa,IAAT,CAApB;;AAEA,QAAI,CAACA,IAAL,EAAW;AACT,aAAQZ,MAAM,EAAd;AACA;AACD;;AAED,UAAMc,OAAO,GAAG,MAAMnB,IAAI,CAACoB,MAAL,CAAYC,QAAZ,EAAtB;;AAEA,QAAI;AACF,aAAQhB,MAAM,EAAd;AACD,KAFD,SAEU;AACRc,MAAAA,OAAO;AACR;AACF;;AAED,SAAOvB,iBAAiB,CAACM,MAAD,CAAxB;AACD","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n\nimport { resolvePath } from '../../utils.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { normaliseInput } from 'ipfs-core-utils/pins/normalise-input'\nimport { PinTypes } from 'ipfs-repo/pin-types'\n\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {object} config\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nexport function createAddAll ({ repo, codecs }) {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API<{}>[\"addAll\"]}\n   */\n  async function * addAll (source, options = {}) {\n    /**\n     * @returns {AsyncIterable<CID>}\n     */\n    const pinAdd = async function * () {\n      for await (const { path, recursive, metadata } of normaliseInput(source)) {\n        const { cid } = await resolvePath(repo, codecs, path)\n\n        // verify that each hash can be pinned\n        const { reason } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct])\n\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(`${cid} already pinned recursively`)\n        }\n\n        if (recursive) {\n          await repo.pins.pinRecursively(cid, { metadata })\n        } else {\n          await repo.pins.pinDirectly(cid, { metadata })\n        }\n\n        yield cid\n      }\n    }\n\n    // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n    const lock = Boolean(options.lock)\n\n    if (!lock) {\n      yield * pinAdd()\n      return\n    }\n\n    const release = await repo.gcLock.readLock()\n\n    try {\n      yield * pinAdd()\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(addAll)\n}\n"]},"metadata":{},"sourceType":"module"}