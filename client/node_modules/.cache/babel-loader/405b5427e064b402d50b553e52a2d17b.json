{"ast":null,"code":"import { createLock } from './utils/create-lock.js';\nimport * as isIpfs from 'is-ipfs';\nimport { createStat } from './stat.js';\nimport { createChmod } from './chmod.js';\nimport { createCp } from './cp.js';\nimport { createFlush } from './flush.js';\nimport { createMkdir } from './mkdir.js';\nimport { createMv } from './mv.js';\nimport { createRm } from './rm.js';\nimport { createTouch } from './touch.js';\nimport { createRead } from './read.js';\nimport { createWrite } from './write.js';\nimport { createLs } from './ls.js';\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('ipfs-core-utils/multihashes').Multihashes} Multihashes\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n *\n * @typedef {object} MfsContext\n * @property {IPFSRepo} repo\n * @property {Multihashes} hashers\n */\n\n/**\n * These operations are read-locked at the function level and will execute simultaneously\n *\n * @type {Record<string, any>}\n */\n\nconst readOperations = {\n  stat: createStat\n};\n/**\n * These operations are locked at the function level and will execute in series\n *\n * @type {Record<string, any>}\n */\n\nconst writeOperations = {\n  chmod: createChmod,\n  cp: createCp,\n  flush: createFlush,\n  mkdir: createMkdir,\n  mv: createMv,\n  rm: createRm,\n  touch: createTouch\n};\n/**\n * These operations are asynchronous and manage their own locking\n *\n * @type {Record<string, any>}\n */\n\nconst unwrappedOperations = {\n  write: createWrite,\n  read: createRead,\n  ls: createLs\n};\n/**\n * @param {object} arg\n * @param {MfsContext} arg.options\n * @param {*} arg.mfs\n * @param {*} arg.operations\n * @param {*} arg.lock\n */\n\nconst wrap = _ref => {\n  let {\n    options,\n    mfs,\n    operations,\n    lock\n  } = _ref;\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options));\n  });\n};\n\nconst defaultOptions = {\n  repoOwner: true,\n  repo: null\n};\n/**\n * @param {object} options\n * @param {IPFSRepo} options.repo\n * @param {boolean} options.repoOwner\n * @param {Multihashes} options.hashers\n */\n\nfunction createMfs(options) {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options);\n  const lock = createLock(repoOwner);\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n\n  const readLock = operation => {\n    return lock.readLock(operation);\n  };\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n\n\n  const writeLock = operation => {\n    return lock.writeLock(operation);\n  };\n  /** @type {Record<string, any>} */\n\n\n  const mfs = {};\n  wrap({\n    options,\n    mfs,\n    operations: readOperations,\n    lock: readLock\n  });\n  wrap({\n    options,\n    mfs,\n    operations: writeOperations,\n    lock: writeLock\n  });\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options);\n  });\n  return mfs;\n}\n/**\n * @param {object} context\n * @param {IPFSRepo} context.repo\n * @param {import('../../types').Preload} context.preload\n * @param {import('..').Options} context.options\n * @param {Multihashes} context.hashers\n * @returns {import('ipfs-core-types/src/files').API}\n */\n\n\nexport function createFiles(_ref2) {\n  let {\n    repo,\n    preload,\n    hashers,\n    options: constructorOptions\n  } = _ref2;\n  const methods = createMfs({\n    repo,\n    repoOwner: constructorOptions.repoOwner !== false,\n    hashers\n  });\n  /**\n   * @param {any} fn\n   */\n\n  const withPreload = fn => {\n    /**\n     * @param  {...any} args\n     */\n    const wrapped = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg));\n\n      if (paths.length) {\n        const options = args[args.length - 1];\n\n        if (options && options.preload !== false) {\n          paths.forEach(path => preload(path));\n        }\n      }\n\n      return fn(...args);\n    };\n\n    return wrapped;\n  };\n\n  return { ...methods,\n    chmod: methods.chmod,\n    cp: withPreload(methods.cp),\n    mkdir: methods.mkdir,\n    stat: withPreload(methods.stat),\n    rm: methods.rm,\n    read: withPreload(methods.read),\n    touch: methods.touch,\n    write: methods.write,\n    mv: withPreload(methods.mv),\n    flush: methods.flush,\n    ls: withPreload(async function* () {\n      for await (const file of methods.ls(...arguments)) {\n        yield { ...file,\n          size: file.size || 0\n        };\n      }\n    })\n  };\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/files/index.js"],"names":["createLock","isIpfs","createStat","createChmod","createCp","createFlush","createMkdir","createMv","createRm","createTouch","createRead","createWrite","createLs","readOperations","stat","writeOperations","chmod","cp","flush","mkdir","mv","rm","touch","unwrappedOperations","write","read","ls","wrap","options","mfs","operations","lock","Object","keys","forEach","key","defaultOptions","repoOwner","repo","createMfs","assign","readLock","operation","writeLock","createFiles","preload","hashers","constructorOptions","methods","withPreload","fn","wrapped","args","paths","filter","arg","ipfsPath","cid","length","path","file","size"],"mappings":"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","sourcesContent":["import { createLock } from './utils/create-lock.js'\nimport * as isIpfs from 'is-ipfs'\nimport { createStat } from './stat.js'\nimport { createChmod } from './chmod.js'\nimport { createCp } from './cp.js'\nimport { createFlush } from './flush.js'\nimport { createMkdir } from './mkdir.js'\nimport { createMv } from './mv.js'\nimport { createRm } from './rm.js'\nimport { createTouch } from './touch.js'\nimport { createRead } from './read.js'\nimport { createWrite } from './write.js'\nimport { createLs } from './ls.js'\n\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('ipfs-core-utils/multihashes').Multihashes} Multihashes\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n *\n * @typedef {object} MfsContext\n * @property {IPFSRepo} repo\n * @property {Multihashes} hashers\n */\n\n/**\n * These operations are read-locked at the function level and will execute simultaneously\n *\n * @type {Record<string, any>}\n */\nconst readOperations = {\n  stat: createStat\n}\n\n/**\n * These operations are locked at the function level and will execute in series\n *\n * @type {Record<string, any>}\n */\nconst writeOperations = {\n  chmod: createChmod,\n  cp: createCp,\n  flush: createFlush,\n  mkdir: createMkdir,\n  mv: createMv,\n  rm: createRm,\n  touch: createTouch\n}\n\n/**\n * These operations are asynchronous and manage their own locking\n *\n * @type {Record<string, any>}\n */\nconst unwrappedOperations = {\n  write: createWrite,\n  read: createRead,\n  ls: createLs\n}\n\n/**\n * @param {object} arg\n * @param {MfsContext} arg.options\n * @param {*} arg.mfs\n * @param {*} arg.operations\n * @param {*} arg.lock\n */\nconst wrap = ({\n  options, mfs, operations, lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options))\n  })\n}\n\nconst defaultOptions = {\n  repoOwner: true,\n  repo: null\n}\n\n/**\n * @param {object} options\n * @param {IPFSRepo} options.repo\n * @param {boolean} options.repoOwner\n * @param {Multihashes} options.hashers\n */\nfunction createMfs (options) {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options)\n\n  const lock = createLock(repoOwner)\n\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n  const readLock = (operation) => {\n    return lock.readLock(operation)\n  }\n\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n  const writeLock = (operation) => {\n    return lock.writeLock(operation)\n  }\n\n  /** @type {Record<string, any>} */\n  const mfs = {}\n\n  wrap({\n    options, mfs, operations: readOperations, lock: readLock\n  })\n  wrap({\n    options, mfs, operations: writeOperations, lock: writeLock\n  })\n\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options)\n  })\n\n  return mfs\n}\n\n/**\n * @param {object} context\n * @param {IPFSRepo} context.repo\n * @param {import('../../types').Preload} context.preload\n * @param {import('..').Options} context.options\n * @param {Multihashes} context.hashers\n * @returns {import('ipfs-core-types/src/files').API}\n */\nexport function createFiles ({ repo, preload, hashers, options: constructorOptions }) {\n  const methods = createMfs({\n    repo,\n    repoOwner: constructorOptions.repoOwner !== false,\n    hashers\n  })\n\n  /**\n   * @param {any} fn\n   */\n  const withPreload = fn => {\n    /**\n     * @param  {...any} args\n     */\n    const wrapped = (...args) => {\n      const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg))\n\n      if (paths.length) {\n        const options = args[args.length - 1]\n        if (options && options.preload !== false) {\n          paths.forEach(path => preload(path))\n        }\n      }\n\n      return fn(...args)\n    }\n\n    return wrapped\n  }\n\n  return {\n    ...methods,\n    chmod: methods.chmod,\n    cp: withPreload(methods.cp),\n    mkdir: methods.mkdir,\n    stat: withPreload(methods.stat),\n    rm: methods.rm,\n    read: withPreload(methods.read),\n    touch: methods.touch,\n    write: methods.write,\n    mv: withPreload(methods.mv),\n    flush: methods.flush,\n    ls: withPreload(async function * (/** @type {...any} */ ...args) {\n      for await (const file of methods.ls(...args)) {\n        yield { ...file, size: file.size || 0 }\n      }\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}