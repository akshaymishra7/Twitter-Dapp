{"ast":null,"code":"export const MIN_NONCE = 0; // For performance reasons, the nonce is represented as a JS `number`\n// Although JS `number` can safely represent integers up to 2 ** 53 - 1, we choose to only use\n// 4 bytes to store the data for performance reason.\n// This is a slight deviation from the noise spec, which describes the max nonce as 2 ** 64 - 2\n// The effect is that this implementation will need a new handshake to be performed after fewer messages are exchanged than other implementations with full uint64 nonces.\n// this MAX_NONCE is still a large number of messages, so the practical effect of this is negligible.\n\nexport const MAX_NONCE = 0xffffffff;\nconst ERR_MAX_NONCE = 'Cipherstate has reached maximum n, a new handshake must be performed';\n/**\n * The nonce is an uint that's increased over time.\n * Maintaining different representations help improve performance.\n */\n\nexport class Nonce {\n  constructor() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MIN_NONCE;\n    this.n = n;\n    this.bytes = new Uint8Array(12);\n    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);\n    this.view.setUint32(4, n, true);\n  }\n\n  increment() {\n    this.n++; // Even though we're treating the nonce as 8 bytes, RFC7539 specifies 12 bytes for a nonce.\n\n    this.view.setUint32(4, this.n, true);\n  }\n\n  getBytes() {\n    return this.bytes;\n  }\n\n  getUint64() {\n    return this.n;\n  }\n\n  assertValue() {\n    if (this.n > MAX_NONCE) {\n      throw new Error(ERR_MAX_NONCE);\n    }\n  }\n\n}","map":{"version":3,"mappings":"AAEA,OAAO,MAAMA,SAAS,GAAG,CAAlB,C,CACP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,SAAS,GAAG,UAAlB;AAEP,MAAMC,aAAa,GAAG,sEAAtB;AAEA;;;;;AAIA,OAAM,MAAOC,KAAP,CAAY;AAKhBC,gBAA0B;AAAA,QAAbC,CAAa,uEAATL,SAAS;AACxB,SAAKK,CAAL,GAASA,CAAT;AACA,SAAKC,KAAL,GAAa,IAAIC,UAAJ,CAAe,EAAf,CAAb;AACA,SAAKC,IAAL,GAAY,IAAIC,QAAJ,CAAa,KAAKH,KAAL,CAAWI,MAAxB,EAAgC,KAAKJ,KAAL,CAAWK,UAA3C,EAAuD,KAAKL,KAAL,CAAWM,UAAlE,CAAZ;AACA,SAAKJ,IAAL,CAAUK,SAAV,CAAoB,CAApB,EAAuBR,CAAvB,EAA0B,IAA1B;AACD;;AAEDS,WAAS;AACP,SAAKT,CAAL,GADO,CAEP;;AACA,SAAKG,IAAL,CAAUK,SAAV,CAAoB,CAApB,EAAuB,KAAKR,CAA5B,EAA+B,IAA/B;AACD;;AAEDU,UAAQ;AACN,WAAO,KAAKT,KAAZ;AACD;;AAEDU,WAAS;AACP,WAAO,KAAKX,CAAZ;AACD;;AAEDY,aAAW;AACT,QAAI,KAAKZ,CAAL,GAASJ,SAAb,EAAwB;AACtB,YAAM,IAAIiB,KAAJ,CAAUhB,aAAV,CAAN;AACD;AACF;;AA9Be","names":["MIN_NONCE","MAX_NONCE","ERR_MAX_NONCE","Nonce","constructor","n","bytes","Uint8Array","view","DataView","buffer","byteOffset","byteLength","setUint32","increment","getBytes","getUint64","assertValue","Error"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-noise\\src\\nonce.ts"],"sourcesContent":["import type { bytes, uint64 } from './@types/basic'\n\nexport const MIN_NONCE = 0\n// For performance reasons, the nonce is represented as a JS `number`\n// Although JS `number` can safely represent integers up to 2 ** 53 - 1, we choose to only use\n// 4 bytes to store the data for performance reason.\n// This is a slight deviation from the noise spec, which describes the max nonce as 2 ** 64 - 2\n// The effect is that this implementation will need a new handshake to be performed after fewer messages are exchanged than other implementations with full uint64 nonces.\n// this MAX_NONCE is still a large number of messages, so the practical effect of this is negligible.\nexport const MAX_NONCE = 0xffffffff\n\nconst ERR_MAX_NONCE = 'Cipherstate has reached maximum n, a new handshake must be performed'\n\n/**\n * The nonce is an uint that's increased over time.\n * Maintaining different representations help improve performance.\n */\nexport class Nonce {\n  private n: uint64\n  private readonly bytes: bytes\n  private readonly view: DataView\n\n  constructor (n = MIN_NONCE) {\n    this.n = n\n    this.bytes = new Uint8Array(12)\n    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength)\n    this.view.setUint32(4, n, true)\n  }\n\n  increment (): void {\n    this.n++\n    // Even though we're treating the nonce as 8 bytes, RFC7539 specifies 12 bytes for a nonce.\n    this.view.setUint32(4, this.n, true)\n  }\n\n  getBytes (): bytes {\n    return this.bytes\n  }\n\n  getUint64 (): uint64 {\n    return this.n\n  }\n\n  assertValue (): void {\n    if (this.n > MAX_NONCE) {\n      throw new Error(ERR_MAX_NONCE)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}