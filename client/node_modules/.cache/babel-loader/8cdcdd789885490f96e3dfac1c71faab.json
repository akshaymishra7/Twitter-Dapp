{"ast":null,"code":"/* eslint-disable import/export */\n\n/* eslint-disable complexity */\n\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Envelope;\n\n(function (Envelope) {\n  let _codec;\n\n  Envelope.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {\n          w.uint32(10);\n          w.bytes(obj.publicKey);\n        }\n\n        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {\n          w.uint32(18);\n          w.bytes(obj.payloadType);\n        }\n\n        if (obj.payload != null && obj.payload.byteLength > 0) {\n          w.uint32(26);\n          w.bytes(obj.payload);\n        }\n\n        if (obj.signature != null && obj.signature.byteLength > 0) {\n          w.uint32(42);\n          w.bytes(obj.signature);\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {\n          publicKey: new Uint8Array(0),\n          payloadType: new Uint8Array(0),\n          payload: new Uint8Array(0),\n          signature: new Uint8Array(0)\n        };\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.publicKey = reader.bytes();\n              break;\n\n            case 2:\n              obj.payloadType = reader.bytes();\n              break;\n\n            case 3:\n              obj.payload = reader.bytes();\n              break;\n\n            case 5:\n              obj.signature = reader.bytes();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  Envelope.encode = obj => {\n    return encodeMessage(obj, Envelope.codec());\n  };\n\n  Envelope.decode = buf => {\n    return decodeMessage(buf, Envelope.codec());\n  };\n})(Envelope || (Envelope = {}));","map":{"version":3,"mappings":"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","names":["encodeMessage","decodeMessage","message","Envelope","_codec","obj","w","opts","lengthDelimited","fork","publicKey","byteLength","uint32","bytes","payloadType","payload","signature","ldelim","reader","length","Uint8Array","end","len","pos","tag","skipType","codec","buf"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\peer-record\\src\\envelope\\envelope.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Envelope {\n  publicKey: Uint8Array\n  payloadType: Uint8Array\n  payload: Uint8Array\n  signature: Uint8Array\n}\n\nexport namespace Envelope {\n  let _codec: Codec<Envelope>\n\n  export const codec = (): Codec<Envelope> => {\n    if (_codec == null) {\n      _codec = message<Envelope>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.publicKey != null && obj.publicKey.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.publicKey)\n        }\n\n        if ((obj.payloadType != null && obj.payloadType.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.payloadType)\n        }\n\n        if ((obj.payload != null && obj.payload.byteLength > 0)) {\n          w.uint32(26)\n          w.bytes(obj.payload)\n        }\n\n        if ((obj.signature != null && obj.signature.byteLength > 0)) {\n          w.uint32(42)\n          w.bytes(obj.signature)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          publicKey: new Uint8Array(0),\n          payloadType: new Uint8Array(0),\n          payload: new Uint8Array(0),\n          signature: new Uint8Array(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.publicKey = reader.bytes()\n              break\n            case 2:\n              obj.payloadType = reader.bytes()\n              break\n            case 3:\n              obj.payload = reader.bytes()\n              break\n            case 5:\n              obj.signature = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Envelope>): Uint8Array => {\n    return encodeMessage(obj, Envelope.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Envelope => {\n    return decodeMessage(buf, Envelope.codec())\n  }\n}\n"]},"metadata":{},"sourceType":"module"}