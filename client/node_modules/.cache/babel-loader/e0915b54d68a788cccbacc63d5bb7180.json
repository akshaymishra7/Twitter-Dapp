{"ast":null,"code":"/* eslint-disable import/export */\n\n/* eslint-disable complexity */\n\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Identify;\n\n(function (Identify) {\n  let _codec;\n\n  Identify.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.protocolVersion != null) {\n          w.uint32(42);\n          w.string(obj.protocolVersion);\n        }\n\n        if (obj.agentVersion != null) {\n          w.uint32(50);\n          w.string(obj.agentVersion);\n        }\n\n        if (obj.publicKey != null) {\n          w.uint32(10);\n          w.bytes(obj.publicKey);\n        }\n\n        if (obj.listenAddrs != null) {\n          for (const value of obj.listenAddrs) {\n            w.uint32(18);\n            w.bytes(value);\n          }\n        }\n\n        if (obj.observedAddr != null) {\n          w.uint32(34);\n          w.bytes(obj.observedAddr);\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(26);\n            w.string(value);\n          }\n        }\n\n        if (obj.signedPeerRecord != null) {\n          w.uint32(66);\n          w.bytes(obj.signedPeerRecord);\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {\n          listenAddrs: [],\n          protocols: []\n        };\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 5:\n              obj.protocolVersion = reader.string();\n              break;\n\n            case 6:\n              obj.agentVersion = reader.string();\n              break;\n\n            case 1:\n              obj.publicKey = reader.bytes();\n              break;\n\n            case 2:\n              obj.listenAddrs.push(reader.bytes());\n              break;\n\n            case 4:\n              obj.observedAddr = reader.bytes();\n              break;\n\n            case 3:\n              obj.protocols.push(reader.string());\n              break;\n\n            case 8:\n              obj.signedPeerRecord = reader.bytes();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  Identify.encode = obj => {\n    return encodeMessage(obj, Identify.codec());\n  };\n\n  Identify.decode = buf => {\n    return decodeMessage(buf, Identify.codec());\n  };\n})(Identify || (Identify = {}));","map":{"version":3,"mappings":"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","names":["encodeMessage","decodeMessage","message","Identify","_codec","obj","w","opts","lengthDelimited","fork","protocolVersion","uint32","string","agentVersion","publicKey","bytes","listenAddrs","value","observedAddr","protocols","signedPeerRecord","ldelim","reader","length","end","len","pos","tag","push","skipType","codec","buf"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\identify\\pb\\message.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { Codec } from 'protons-runtime'\n\nexport interface Identify {\n  protocolVersion?: string\n  agentVersion?: string\n  publicKey?: Uint8Array\n  listenAddrs: Uint8Array[]\n  observedAddr?: Uint8Array\n  protocols: string[]\n  signedPeerRecord?: Uint8Array\n}\n\nexport namespace Identify {\n  let _codec: Codec<Identify>\n\n  export const codec = (): Codec<Identify> => {\n    if (_codec == null) {\n      _codec = message<Identify>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.protocolVersion != null) {\n          w.uint32(42)\n          w.string(obj.protocolVersion)\n        }\n\n        if (obj.agentVersion != null) {\n          w.uint32(50)\n          w.string(obj.agentVersion)\n        }\n\n        if (obj.publicKey != null) {\n          w.uint32(10)\n          w.bytes(obj.publicKey)\n        }\n\n        if (obj.listenAddrs != null) {\n          for (const value of obj.listenAddrs) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (obj.observedAddr != null) {\n          w.uint32(34)\n          w.bytes(obj.observedAddr)\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(26)\n            w.string(value)\n          }\n        }\n\n        if (obj.signedPeerRecord != null) {\n          w.uint32(66)\n          w.bytes(obj.signedPeerRecord)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          listenAddrs: [],\n          protocols: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 5:\n              obj.protocolVersion = reader.string()\n              break\n            case 6:\n              obj.agentVersion = reader.string()\n              break\n            case 1:\n              obj.publicKey = reader.bytes()\n              break\n            case 2:\n              obj.listenAddrs.push(reader.bytes())\n              break\n            case 4:\n              obj.observedAddr = reader.bytes()\n              break\n            case 3:\n              obj.protocols.push(reader.string())\n              break\n            case 8:\n              obj.signedPeerRecord = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Identify): Uint8Array => {\n    return encodeMessage(obj, Identify.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Identify => {\n    return decodeMessage(buf, Identify.codec())\n  }\n}\n"]},"metadata":{},"sourceType":"module"}