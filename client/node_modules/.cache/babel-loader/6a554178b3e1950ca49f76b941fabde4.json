{"ast":null,"code":"import { CID } from 'multiformats/cid';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:kad-dht:rpc:handlers:add-provider');\nexport class AddProviderHandler {\n  constructor(init) {\n    const {\n      providers\n    } = init;\n    this.providers = providers;\n  }\n\n  async handle(peerId, msg) {\n    log('start');\n\n    if (msg.key == null || msg.key.length === 0) {\n      throw new CodeError('Missing key', 'ERR_MISSING_KEY');\n    }\n\n    let cid;\n\n    try {\n      // this is actually just the multihash, not the whole CID\n      cid = CID.decode(msg.key);\n    } catch (err) {\n      throw new CodeError('Invalid CID', 'ERR_INVALID_CID');\n    }\n\n    if (msg.providerPeers == null || msg.providerPeers.length === 0) {\n      log.error('no providers found in message');\n    }\n\n    await Promise.all(msg.providerPeers.map(async pi => {\n      // Ignore providers not from the originator\n      if (!pi.id.equals(peerId)) {\n        log('invalid provider peer %p from %p', pi.id, peerId);\n        return;\n      }\n\n      if (pi.multiaddrs.length < 1) {\n        log('no valid addresses for provider %p. Ignore', peerId);\n        return;\n      }\n\n      log('received provider %p for %s (addrs %s)', peerId, cid, pi.multiaddrs.map(m => m.toString()));\n      await this.providers.addProvider(cid, pi.id);\n    }));\n    return undefined;\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,GAAT,QAAoB,kBAApB;AACA,SAASC,SAAT,QAA0B,2BAA1B;AACA,SAASC,MAAT,QAAuB,gBAAvB;AAMA,MAAMC,GAAG,GAAGD,MAAM,CAAC,0CAAD,CAAlB;AAMA,OAAM,MAAOE,kBAAP,CAAyB;AAG7BC,cAAaC,IAAb,EAAyC;AACvC,UAAM;AAAEC;AAAF,QAAgBD,IAAtB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACD;;AAEW,QAANC,MAAM,CAAEC,MAAF,EAAkBC,GAAlB,EAA8B;AACxCP,OAAG,CAAC,OAAD,CAAH;;AAEA,QAAIO,GAAG,CAACC,GAAJ,IAAW,IAAX,IAAmBD,GAAG,CAACC,GAAJ,CAAQC,MAAR,KAAmB,CAA1C,EAA6C;AAC3C,YAAM,IAAIX,SAAJ,CAAc,aAAd,EAA6B,iBAA7B,CAAN;AACD;;AAED,QAAIY,GAAJ;;AACA,QAAI;AACF;AACAA,SAAG,GAAGb,GAAG,CAACc,MAAJ,CAAWJ,GAAG,CAACC,GAAf,CAAN;AACD,KAHD,CAGE,OAAOI,GAAP,EAAiB;AACjB,YAAM,IAAId,SAAJ,CAAc,aAAd,EAA6B,iBAA7B,CAAN;AACD;;AAED,QAAIS,GAAG,CAACM,aAAJ,IAAqB,IAArB,IAA6BN,GAAG,CAACM,aAAJ,CAAkBJ,MAAlB,KAA6B,CAA9D,EAAiE;AAC/DT,SAAG,CAACc,KAAJ,CAAU,+BAAV;AACD;;AAED,UAAMC,OAAO,CAACC,GAAR,CACJT,GAAG,CAACM,aAAJ,CAAkBI,GAAlB,CAAsB,MAAOC,EAAP,IAAa;AACjC;AACA,UAAI,CAACA,EAAE,CAACC,EAAH,CAAMC,MAAN,CAAad,MAAb,CAAL,EAA2B;AACzBN,WAAG,CAAC,kCAAD,EAAqCkB,EAAE,CAACC,EAAxC,EAA4Cb,MAA5C,CAAH;AACA;AACD;;AAED,UAAIY,EAAE,CAACG,UAAH,CAAcZ,MAAd,GAAuB,CAA3B,EAA8B;AAC5BT,WAAG,CAAC,4CAAD,EAA+CM,MAA/C,CAAH;AACA;AACD;;AAEDN,SAAG,CAAC,wCAAD,EAA2CM,MAA3C,EAAmDI,GAAnD,EAAwDQ,EAAE,CAACG,UAAH,CAAcJ,GAAd,CAAmBK,CAAD,IAAOA,CAAC,CAACC,QAAF,EAAzB,CAAxD,CAAH;AAEA,YAAM,KAAKnB,SAAL,CAAeoB,WAAf,CAA2Bd,GAA3B,EAAgCQ,EAAE,CAACC,EAAnC,CAAN;AACD,KAfD,CADI,CAAN;AAmBA,WAAOM,SAAP;AACD;;AA/C4B","names":["CID","CodeError","logger","log","AddProviderHandler","constructor","init","providers","handle","peerId","msg","key","length","cid","decode","err","providerPeers","error","Promise","all","map","pi","id","equals","multiaddrs","m","toString","addProvider","undefined"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\rpc\\handlers\\add-provider.ts"],"sourcesContent":["import { CID } from 'multiformats/cid'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { logger } from '@libp2p/logger'\nimport type { Providers } from '../../providers'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { DHTMessageHandler } from '../index.js'\nimport type { Message } from '../../message/index.js'\n\nconst log = logger('libp2p:kad-dht:rpc:handlers:add-provider')\n\nexport interface AddProviderHandlerInit {\n  providers: Providers\n}\n\nexport class AddProviderHandler implements DHTMessageHandler {\n  private readonly providers: Providers\n\n  constructor (init: AddProviderHandlerInit) {\n    const { providers } = init\n    this.providers = providers\n  }\n\n  async handle (peerId: PeerId, msg: Message): Promise<Message | undefined> {\n    log('start')\n\n    if (msg.key == null || msg.key.length === 0) {\n      throw new CodeError('Missing key', 'ERR_MISSING_KEY')\n    }\n\n    let cid: CID\n    try {\n      // this is actually just the multihash, not the whole CID\n      cid = CID.decode(msg.key)\n    } catch (err: any) {\n      throw new CodeError('Invalid CID', 'ERR_INVALID_CID')\n    }\n\n    if (msg.providerPeers == null || msg.providerPeers.length === 0) {\n      log.error('no providers found in message')\n    }\n\n    await Promise.all(\n      msg.providerPeers.map(async (pi) => {\n        // Ignore providers not from the originator\n        if (!pi.id.equals(peerId)) {\n          log('invalid provider peer %p from %p', pi.id, peerId)\n          return\n        }\n\n        if (pi.multiaddrs.length < 1) {\n          log('no valid addresses for provider %p. Ignore', peerId)\n          return\n        }\n\n        log('received provider %p for %s (addrs %s)', peerId, cid, pi.multiaddrs.map((m) => m.toString()))\n\n        await this.providers.addProvider(cid, pi.id)\n      })\n    )\n\n    return undefined\n  }\n}\n"]},"metadata":{},"sourceType":"module"}