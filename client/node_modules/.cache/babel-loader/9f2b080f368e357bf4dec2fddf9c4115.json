{"ast":null,"code":"import { abortableSource } from 'abortable-iterator';\nimport { pipe } from 'it-pipe';\nimport { pushable } from 'it-pushable';\nimport { encode, decode } from 'it-length-prefixed';\nexport class OutboundStream {\n  constructor(rawStream, errCallback, opts) {\n    this.rawStream = rawStream;\n    this.pushable = pushable({\n      objectMode: false\n    });\n    this.closeController = new AbortController();\n    this.maxBufferSize = opts.maxBufferSize ?? Infinity;\n    pipe(abortableSource(this.pushable, this.closeController.signal, {\n      returnOnAbort: true\n    }), encode(), this.rawStream).catch(errCallback);\n  }\n\n  get protocol() {\n    // TODO remove this non-nullish assertion after https://github.com/libp2p/js-libp2p-interfaces/pull/265 is incorporated\n    return this.rawStream.stat.protocol;\n  }\n\n  push(data) {\n    if (this.pushable.readableLength > this.maxBufferSize) {\n      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);\n    }\n\n    this.pushable.push(data);\n  }\n\n  close() {\n    this.closeController.abort(); // similar to pushable.end() but clear the internal buffer\n\n    this.pushable.return();\n    this.rawStream.close();\n  }\n\n}\nexport class InboundStream {\n  constructor(rawStream) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.rawStream = rawStream;\n    this.closeController = new AbortController();\n    this.source = abortableSource(pipe(this.rawStream, decode(opts)), this.closeController.signal, {\n      returnOnAbort: true\n    });\n  }\n\n  close() {\n    this.closeController.abort();\n    this.rawStream.close();\n  }\n\n}","map":{"version":3,"mappings":"AACA,SAASA,eAAT,QAAgC,oBAAhC;AACA,SAASC,IAAT,QAAqB,SAArB;AACA,SAASC,QAAT,QAAmC,aAAnC;AACA,SAASC,MAAT,EAAiBC,MAAjB,QAA+B,oBAA/B;AAaA,OAAM,MAAOC,cAAP,CAAqB;AAKzBC,cAA6BC,SAA7B,EAAgDC,WAAhD,EAAiFC,IAAjF,EAAyG;AAA5E;AAC3B,SAAKP,QAAL,GAAgBA,QAAQ,CAAC;AAAEQ,gBAAU,EAAE;AAAd,KAAD,CAAxB;AACA,SAAKC,eAAL,GAAuB,IAAIC,eAAJ,EAAvB;AACA,SAAKC,aAAL,GAAqBJ,IAAI,CAACI,aAAL,IAAsBC,QAA3C;AAEAb,QAAI,CACFD,eAAe,CAAC,KAAKE,QAAN,EAAgB,KAAKS,eAAL,CAAqBI,MAArC,EAA6C;AAAEC,mBAAa,EAAE;AAAjB,KAA7C,CADb,EAEFb,MAAM,EAFJ,EAGF,KAAKI,SAHH,CAAJ,CAIEU,KAJF,CAIQT,WAJR;AAKD;;AAEW,MAARU,QAAQ;AACV;AACA,WAAO,KAAKX,SAAL,CAAeY,IAAf,CAAoBD,QAA3B;AACD;;AAEDE,MAAI,CAACC,IAAD,EAAiB;AACnB,QAAI,KAAKnB,QAAL,CAAcoB,cAAd,GAA+B,KAAKT,aAAxC,EAAuD;AACrD,YAAMU,KAAK,CAAC,sCAAsC,KAAKV,aAAa,EAAzD,CAAX;AACD;;AAED,SAAKX,QAAL,CAAckB,IAAd,CAAmBC,IAAnB;AACD;;AAEDG,OAAK;AACH,SAAKb,eAAL,CAAqBc,KAArB,GADG,CAEH;;AACA,SAAKvB,QAAL,CAAcwB,MAAd;AACA,SAAKnB,SAAL,CAAeiB,KAAf;AACD;;AAnCwB;AAsC3B,OAAM,MAAOG,aAAP,CAAoB;AAMxBrB,cAAYC,SAAZ,EAA2D;AAAA,QAA5BE,IAA4B,uEAAF,EAAE;AACzD,SAAKF,SAAL,GAAiBA,SAAjB;AACA,SAAKI,eAAL,GAAuB,IAAIC,eAAJ,EAAvB;AAEA,SAAKgB,MAAL,GAAc5B,eAAe,CAACC,IAAI,CAAC,KAAKM,SAAN,EAAiBH,MAAM,CAACK,IAAD,CAAvB,CAAL,EAAqC,KAAKE,eAAL,CAAqBI,MAA1D,EAAkE;AAC7FC,mBAAa,EAAE;AAD8E,KAAlE,CAA7B;AAGD;;AAEDQ,OAAK;AACH,SAAKb,eAAL,CAAqBc,KAArB;AACA,SAAKlB,SAAL,CAAeiB,KAAf;AACD;;AAlBuB","names":["abortableSource","pipe","pushable","encode","decode","OutboundStream","constructor","rawStream","errCallback","opts","objectMode","closeController","AbortController","maxBufferSize","Infinity","signal","returnOnAbort","catch","protocol","stat","push","data","readableLength","Error","close","abort","return","InboundStream","source"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\stream.ts"],"sourcesContent":["import { Stream } from '@libp2p/interface-connection'\nimport { abortableSource } from 'abortable-iterator'\nimport { pipe } from 'it-pipe'\nimport { pushable, Pushable } from 'it-pushable'\nimport { encode, decode } from 'it-length-prefixed'\nimport { Uint8ArrayList } from 'uint8arraylist'\n\ntype OutboundStreamOpts = {\n  /** Max size in bytes for pushable buffer. If full, will throw on .push */\n  maxBufferSize?: number\n}\n\ntype InboundStreamOpts = {\n  /** Max size in bytes for reading messages from the stream */\n  maxDataLength?: number\n}\n\nexport class OutboundStream {\n  private readonly pushable: Pushable<Uint8Array>\n  private readonly closeController: AbortController\n  private readonly maxBufferSize: number\n\n  constructor(private readonly rawStream: Stream, errCallback: (e: Error) => void, opts: OutboundStreamOpts) {\n    this.pushable = pushable({ objectMode: false })\n    this.closeController = new AbortController()\n    this.maxBufferSize = opts.maxBufferSize ?? Infinity\n\n    pipe(\n      abortableSource(this.pushable, this.closeController.signal, { returnOnAbort: true }),\n      encode(),\n      this.rawStream\n    ).catch(errCallback)\n  }\n\n  get protocol(): string {\n    // TODO remove this non-nullish assertion after https://github.com/libp2p/js-libp2p-interfaces/pull/265 is incorporated\n    return this.rawStream.stat.protocol!\n  }\n\n  push(data: Uint8Array): void {\n    if (this.pushable.readableLength > this.maxBufferSize) {\n      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`)\n    }\n\n    this.pushable.push(data)\n  }\n\n  close(): void {\n    this.closeController.abort()\n    // similar to pushable.end() but clear the internal buffer\n    this.pushable.return()\n    this.rawStream.close()\n  }\n}\n\nexport class InboundStream {\n  public readonly source: AsyncIterable<Uint8ArrayList>\n\n  private readonly rawStream: Stream\n  private readonly closeController: AbortController\n\n  constructor(rawStream: Stream, opts: InboundStreamOpts = {}) {\n    this.rawStream = rawStream\n    this.closeController = new AbortController()\n\n    this.source = abortableSource(pipe(this.rawStream, decode(opts)), this.closeController.signal, {\n      returnOnAbort: true\n    })\n  }\n\n  close(): void {\n    this.closeController.abort()\n    this.rawStream.close()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}