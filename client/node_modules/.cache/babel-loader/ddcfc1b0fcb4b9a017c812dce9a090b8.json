{"ast":null,"code":"import { Key } from 'interface-datastore';\nimport { BaseDatastore } from 'datastore-core';\nimport { encodeBase32, keyToTopic, topicToKey } from './utils.js';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { logger } from '@libp2p/logger';\nconst log = logger('datastore-pubsub:publisher');\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('@libp2p/interface-pubsub').Message} PubSubMessage\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\n\nexport class PubSubDatastore extends BaseDatastore {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('@libp2p/interface-pubsub').PubSub} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {import('@libp2p/interface-dht').ValidateFn} validator - validator function\n   * @param {import('@libp2p/interface-dht').SelectFn} selector - selector function\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  constructor(pubsub, datastore, peerId, validator, selector, subscriptionKeyFn) {\n    super();\n\n    if (!validator) {\n      throw new CodeError('missing validator', 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator !== 'function') {\n      throw new CodeError('missing validate function', 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof selector !== 'function') {\n      throw new CodeError('missing select function', 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw new CodeError('invalid subscriptionKeyFn received', 'ERR_INVALID_PARAMETERS');\n    }\n\n    this._pubsub = pubsub;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._validator = validator;\n    this._selector = selector;\n    this._handleSubscriptionKeyFn = subscriptionKeyFn; // Bind _onMessage function, which is called by pubsub.\n\n    this._onMessage = this._onMessage.bind(this);\n\n    this._pubsub.addEventListener('message', this._onMessage);\n  }\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   * @param {AbortOptions} [options]\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n\n\n  async put(key, val, options) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    if (!(val instanceof Uint8Array)) {\n      const errMsg = 'received value is not a Uint8Array';\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_INVALID_VALUE_RECEIVED');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    log(`publish value for topic ${stringifiedTopic}`); // Publish record to pubsub\n\n    await this._pubsub.publish(stringifiedTopic, val);\n  }\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   * @param {AbortOptions} [options]\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n\n\n  async get(key, options) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    const subscriptions = await this._pubsub.getTopics(); // If already subscribed, just try to get it\n\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key, options);\n    } // subscribe\n\n\n    try {\n      await this._pubsub.subscribe(stringifiedTopic);\n    } catch (\n    /** @type {any} */\n    err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`;\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_SUBSCRIBING_TOPIC');\n    }\n\n    log(`subscribed values for key ${stringifiedTopic}`);\n    return this._getLocal(key);\n  }\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n\n\n  unsubscribe(key) {\n    const stringifiedTopic = keyToTopic(key);\n    return this._pubsub.unsubscribe(stringifiedTopic);\n  }\n  /**\n   * Get record from local datastore\n   *\n   * @private\n   * @param {Uint8Array} key\n   * @param {AbortOptions} [options]\n   */\n\n\n  async _getLocal(key, options) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    let dsVal;\n\n    try {\n      dsVal = await this._datastore.get(routingKey, options);\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`;\n        log.error(errMsg);\n        throw new CodeError(errMsg, 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n      }\n\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`;\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_NOT_FOUND');\n    }\n\n    if (!(dsVal instanceof Uint8Array)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value';\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_INVALID_RECORD_RECEIVED');\n    }\n\n    return dsVal;\n  }\n  /**\n   * handles pubsub subscription messages\n   *\n   * @param {CustomEvent<PubSubMessage>} evt\n   */\n\n\n  async _onMessage(evt) {\n    const msg = evt.detail;\n\n    if (msg.type !== 'signed') {\n      log.error('unsigned message received, this module can only work with signed messages');\n      return;\n    }\n\n    const {\n      data,\n      from,\n      topic\n    } = msg;\n    let key;\n\n    try {\n      key = topicToKey(topic);\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n      return;\n    }\n\n    log(`message received for topic ${topic}`); // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n\n    if (this._peerId.equals(from)) {\n      log('message discarded as it is from the same peer');\n      return;\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res;\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key);\n      } catch (\n      /** @type {any} */\n      err) {\n        log.error('message discarded by the subscriptionKeyFn');\n        return;\n      }\n\n      key = res;\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data);\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Store the received record if it is better than the current stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   * @param {AbortOptions} [options]\n   */\n\n\n  async _storeIfSubscriptionIsBetter(key, data, options) {\n    let isBetter = false;\n\n    try {\n      isBetter = await this._isBetter(key, data);\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err;\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(key, data, options);\n    }\n  }\n  /**\n   * Validate record according to the received validation function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   */\n\n\n  async _validateRecord(key, value) {\n    // eslint-disable-line require-await\n    return this._validator(key, value);\n  }\n  /**\n   * Select the best record according to the received select function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array[]} records\n   */\n\n\n  async _selectRecord(key, records) {\n    const res = await this._selector(key, records); // If the selected was the first (0), it should be stored (true)\n\n    return res === 0;\n  }\n  /**\n   * Verify if the record received through pubsub is valid and better than the one currently stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} val\n   */\n\n\n  async _isBetter(key, val) {\n    try {\n      await this._validateRecord(key, val);\n    } catch (\n    /** @type {any} */\n    err) {\n      // If not valid, it is not better than the one currently available\n      const errMsg = 'record received through pubsub is not valid';\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_NOT_VALID_RECORD');\n    } // Get Local record\n\n\n    const dsKey = new Key(key);\n    let currentRecord;\n\n    try {\n      currentRecord = await this._getLocal(dsKey.uint8Array());\n    } catch (\n    /** @type {any} */\n    err) {\n      // if the old one is invalid, the new one is *always* better\n      return true;\n    } // if the same record, do not need to store\n\n\n    if (uint8ArrayEquals(currentRecord, val)) {\n      return false;\n    } // verify if the received record should replace the current one\n\n\n    return this._selectRecord(key, [currentRecord, val]);\n  }\n  /**\n   * add record to datastore\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   * @param {AbortOptions} [options]\n   */\n\n\n  async _storeRecord(key, data, options) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    await this._datastore.put(routingKey, data, options);\n    log(`record for ${keyToTopic(key)} was stored in the datastore`);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/datastore-pubsub/src/index.js"],"names":["Key","BaseDatastore","encodeBase32","keyToTopic","topicToKey","equals","uint8ArrayEquals","CodeError","logger","log","PubSubDatastore","constructor","pubsub","datastore","peerId","validator","selector","subscriptionKeyFn","_pubsub","_datastore","_peerId","_validator","_selector","_handleSubscriptionKeyFn","_onMessage","bind","addEventListener","put","key","val","options","Uint8Array","errMsg","error","stringifiedTopic","publish","get","subscriptions","getTopics","Array","isArray","indexOf","_getLocal","subscribe","err","unsubscribe","routingKey","dsVal","code","toString","evt","msg","detail","type","data","from","topic","res","_storeIfSubscriptionIsBetter","isBetter","_isBetter","_storeRecord","_validateRecord","value","_selectRecord","records","dsKey","currentRecord","uint8Array"],"mappings":"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","sourcesContent":["import { Key } from 'interface-datastore'\nimport { BaseDatastore } from 'datastore-core'\nimport { encodeBase32, keyToTopic, topicToKey } from './utils.js'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('datastore-pubsub:publisher')\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('@libp2p/interface-pubsub').Message} PubSubMessage\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\nexport class PubSubDatastore extends BaseDatastore {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('@libp2p/interface-pubsub').PubSub} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {import('@libp2p/interface-dht').ValidateFn} validator - validator function\n   * @param {import('@libp2p/interface-dht').SelectFn} selector - selector function\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  constructor (pubsub, datastore, peerId, validator, selector, subscriptionKeyFn) {\n    super()\n\n    if (!validator) {\n      throw new CodeError('missing validator', 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator !== 'function') {\n      throw new CodeError('missing validate function', 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof selector !== 'function') {\n      throw new CodeError('missing select function', 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw new CodeError('invalid subscriptionKeyFn received', 'ERR_INVALID_PARAMETERS')\n    }\n\n    this._pubsub = pubsub\n    this._datastore = datastore\n    this._peerId = peerId\n    this._validator = validator\n    this._selector = selector\n    this._handleSubscriptionKeyFn = subscriptionKeyFn\n\n    // Bind _onMessage function, which is called by pubsub.\n    this._onMessage = this._onMessage.bind(this)\n    this._pubsub.addEventListener('message', this._onMessage)\n  }\n\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   * @param {AbortOptions} [options]\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async put (key, val, options) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!(val instanceof Uint8Array)) {\n      const errMsg = 'received value is not a Uint8Array'\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_INVALID_VALUE_RECEIVED')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n\n    log(`publish value for topic ${stringifiedTopic}`)\n\n    // Publish record to pubsub\n    await this._pubsub.publish(stringifiedTopic, val)\n  }\n\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   * @param {AbortOptions} [options]\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async get (key, options) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n    const subscriptions = await this._pubsub.getTopics()\n\n    // If already subscribed, just try to get it\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key, options)\n    }\n\n    // subscribe\n    try {\n      await this._pubsub.subscribe(stringifiedTopic)\n    } catch (/** @type {any} */ err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_SUBSCRIBING_TOPIC')\n    }\n    log(`subscribed values for key ${stringifiedTopic}`)\n\n    return this._getLocal(key)\n  }\n\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n  unsubscribe (key) {\n    const stringifiedTopic = keyToTopic(key)\n\n    return this._pubsub.unsubscribe(stringifiedTopic)\n  }\n\n  /**\n   * Get record from local datastore\n   *\n   * @private\n   * @param {Uint8Array} key\n   * @param {AbortOptions} [options]\n   */\n  async _getLocal (key, options) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n    let dsVal\n\n    try {\n      dsVal = await this._datastore.get(routingKey, options)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`\n\n        log.error(errMsg)\n        throw new CodeError(errMsg, 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n      }\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_NOT_FOUND')\n    }\n\n    if (!(dsVal instanceof Uint8Array)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value'\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    return dsVal\n  }\n\n  /**\n   * handles pubsub subscription messages\n   *\n   * @param {CustomEvent<PubSubMessage>} evt\n   */\n  async _onMessage (evt) {\n    const msg = evt.detail\n\n    if (msg.type !== 'signed') {\n      log.error('unsigned message received, this module can only work with signed messages')\n      return\n    }\n\n    const { data, from, topic } = msg\n    let key\n    try {\n      key = topicToKey(topic)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      return\n    }\n\n    log(`message received for topic ${topic}`)\n\n    // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n    if (this._peerId.equals(from)) {\n      log('message discarded as it is from the same peer')\n      return\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key)\n      } catch (/** @type {any} */ err) {\n        log.error('message discarded by the subscriptionKeyFn')\n        return\n      }\n\n      key = res\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Store the received record if it is better than the current stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   * @param {AbortOptions} [options]\n   */\n  async _storeIfSubscriptionIsBetter (key, data, options) {\n    let isBetter = false\n\n    try {\n      isBetter = await this._isBetter(key, data)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(key, data, options)\n    }\n  }\n\n  /**\n   * Validate record according to the received validation function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   */\n  async _validateRecord (key, value) { // eslint-disable-line require-await\n    return this._validator(key, value)\n  }\n\n  /**\n   * Select the best record according to the received select function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array[]} records\n   */\n  async _selectRecord (key, records) {\n    const res = await this._selector(key, records)\n\n    // If the selected was the first (0), it should be stored (true)\n    return res === 0\n  }\n\n  /**\n   * Verify if the record received through pubsub is valid and better than the one currently stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} val\n   */\n  async _isBetter (key, val) {\n    try {\n      await this._validateRecord(key, val)\n    } catch (/** @type {any} */ err) {\n      // If not valid, it is not better than the one currently available\n      const errMsg = 'record received through pubsub is not valid'\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_NOT_VALID_RECORD')\n    }\n\n    // Get Local record\n    const dsKey = new Key(key)\n    let currentRecord\n\n    try {\n      currentRecord = await this._getLocal(dsKey.uint8Array())\n    } catch (/** @type {any} */ err) {\n      // if the old one is invalid, the new one is *always* better\n      return true\n    }\n\n    // if the same record, do not need to store\n    if (uint8ArrayEquals(currentRecord, val)) {\n      return false\n    }\n\n    // verify if the received record should replace the current one\n    return this._selectRecord(key, [currentRecord, val])\n  }\n\n  /**\n   * add record to datastore\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   * @param {AbortOptions} [options]\n   */\n  async _storeRecord (key, data, options) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n\n    await this._datastore.put(routingKey, data, options)\n    log(`record for ${keyToTopic(key)} was stored in the datastore`)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}