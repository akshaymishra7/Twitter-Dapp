{"ast":null,"code":"import { abortableSource } from 'abortable-iterator';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:stream:converter');\n/**\n * Convert a duplex iterable into a MultiaddrConnection.\n * https://github.com/libp2p/interface-transport#multiaddrconnection\n */\n\nexport function streamToMaConnection(props) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    stream,\n    remoteAddr\n  } = props;\n  const {\n    sink,\n    source\n  } = stream;\n\n  const mapSource = async function* () {\n    for await (const list of source) {\n      if (list instanceof Uint8Array) {\n        yield list;\n      } else {\n        yield* list;\n      }\n    }\n  }();\n\n  const maConn = {\n    async sink(source) {\n      if (options.signal != null) {\n        source = abortableSource(source, options.signal);\n      }\n\n      try {\n        await sink(source);\n        await close();\n      } catch (err) {\n        // If aborted we can safely ignore\n        if (err.type !== 'aborted') {\n          // If the source errored the socket will already have been destroyed by\n          // toIterable.duplex(). If the socket errored it will already be\n          // destroyed. There's nothing to do here except log the error & return.\n          log(err);\n        }\n      }\n    },\n\n    source: options.signal != null ? abortableSource(mapSource, options.signal) : mapSource,\n    remoteAddr,\n    timeline: {\n      open: Date.now(),\n      close: undefined\n    },\n\n    async close() {\n      await sink(async function* () {\n        yield new Uint8Array(0);\n      }());\n      await close();\n    }\n\n  };\n\n  async function close() {\n    if (maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now();\n    }\n\n    await Promise.resolve();\n  }\n\n  return maConn;\n}","map":{"version":3,"mappings":"AAAA,SAASA,eAAT,QAAgC,oBAAhC;AACA,SAASC,MAAT,QAAuB,gBAAvB;AAMA,MAAMC,GAAG,GAAGD,MAAM,CAAC,yBAAD,CAAlB;AA8BA;;;;;AAIA,OAAM,SAAUE,oBAAV,CAAgCC,KAAhC,EAAoF;AAAA,MAA3BC,OAA2B,uEAAF,EAAE;AACxF,QAAM;AAAEC,UAAF;AAAUC;AAAV,MAAyBH,KAA/B;AACA,QAAM;AAAEI,QAAF;AAAQC;AAAR,MAAmBH,MAAzB;;AAEA,QAAMI,SAAS,GAAI,mBAAgB;AACjC,eAAW,MAAMC,IAAjB,IAAyBF,MAAzB,EAAiC;AAC/B,UAAIE,IAAI,YAAYC,UAApB,EAAgC;AAC9B,cAAMD,IAAN;AACD,OAFD,MAEO;AACL,eAAQA,IAAR;AACD;AACF;AACF,GARkB,EAAnB;;AAUA,QAAME,MAAM,GAAwB;AAClC,UAAML,IAAN,CAAYC,MAAZ,EAAkB;AAChB,UAAIJ,OAAO,CAACS,MAAR,IAAkB,IAAtB,EAA4B;AAC1BL,cAAM,GAAGT,eAAe,CAACS,MAAD,EAASJ,OAAO,CAACS,MAAjB,CAAxB;AACD;;AAED,UAAI;AACF,cAAMN,IAAI,CAACC,MAAD,CAAV;AACA,cAAMM,KAAK,EAAX;AACD,OAHD,CAGE,OAAOC,GAAP,EAAiB;AACjB;AACA,YAAIA,GAAG,CAACC,IAAJ,KAAa,SAAjB,EAA4B;AAC1B;AACA;AACA;AACAf,aAAG,CAACc,GAAD,CAAH;AACD;AACF;AACF,KAlBiC;;AAmBlCP,UAAM,EAAGJ,OAAO,CAACS,MAAR,IAAkB,IAAnB,GAA2Bd,eAAe,CAACU,SAAD,EAAYL,OAAO,CAACS,MAApB,CAA1C,GAAwEJ,SAnB9C;AAoBlCH,cApBkC;AAqBlCW,YAAQ,EAAE;AAAEC,UAAI,EAAEC,IAAI,CAACC,GAAL,EAAR;AAAoBN,WAAK,EAAEO;AAA3B,KArBwB;;AAsBlC,UAAMP,KAAN,GAAW;AACT,YAAMP,IAAI,CAAC,mBAAgB;AACzB,cAAM,IAAII,UAAJ,CAAe,CAAf,CAAN;AACD,OAFU,EAAD,CAAV;AAGA,YAAMG,KAAK,EAAX;AACD;;AA3BiC,GAApC;;AA8BA,iBAAeA,KAAf,GAAoB;AAClB,QAAIF,MAAM,CAACK,QAAP,CAAgBH,KAAhB,IAAyB,IAA7B,EAAmC;AACjCF,YAAM,CAACK,QAAP,CAAgBH,KAAhB,GAAwBK,IAAI,CAACC,GAAL,EAAxB;AACD;;AACD,UAAME,OAAO,CAACC,OAAR,EAAN;AACD;;AAED,SAAOX,MAAP;AACD","names":["abortableSource","logger","log","streamToMaConnection","props","options","stream","remoteAddr","sink","source","mapSource","list","Uint8Array","maConn","signal","close","err","type","timeline","open","Date","now","undefined","Promise","resolve"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\utils\\src\\stream-to-ma-conn.ts"],"sourcesContent":["import { abortableSource } from 'abortable-iterator'\nimport { logger } from '@libp2p/logger'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { Duplex, Source } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst log = logger('libp2p:stream:converter')\n\nexport interface Timeline {\n  /**\n   * Connection opening timestamp\n   */\n  open: number\n\n  /**\n   * Connection upgraded timestamp\n   */\n  upgraded?: number\n\n  /**\n   * Connection closed timestamp\n   */\n  close?: number\n}\n\nexport interface StreamOptions {\n  signal?: AbortSignal\n\n}\n\nexport interface StreamProperties {\n  stream: Duplex<AsyncIterable<Uint8ArrayList>, Source<Uint8ArrayList | Uint8Array>>\n  remoteAddr: Multiaddr\n  localAddr: Multiaddr\n}\n\n/**\n * Convert a duplex iterable into a MultiaddrConnection.\n * https://github.com/libp2p/interface-transport#multiaddrconnection\n */\nexport function streamToMaConnection (props: StreamProperties, options: StreamOptions = {}): MultiaddrConnection {\n  const { stream, remoteAddr } = props\n  const { sink, source } = stream\n\n  const mapSource = (async function * () {\n    for await (const list of source) {\n      if (list instanceof Uint8Array) {\n        yield list\n      } else {\n        yield * list\n      }\n    }\n  }())\n\n  const maConn: MultiaddrConnection = {\n    async sink (source) {\n      if (options.signal != null) {\n        source = abortableSource(source, options.signal)\n      }\n\n      try {\n        await sink(source)\n        await close()\n      } catch (err: any) {\n        // If aborted we can safely ignore\n        if (err.type !== 'aborted') {\n          // If the source errored the socket will already have been destroyed by\n          // toIterable.duplex(). If the socket errored it will already be\n          // destroyed. There's nothing to do here except log the error & return.\n          log(err)\n        }\n      }\n    },\n    source: (options.signal != null) ? abortableSource(mapSource, options.signal) : mapSource,\n    remoteAddr,\n    timeline: { open: Date.now(), close: undefined },\n    async close () {\n      await sink(async function * () {\n        yield new Uint8Array(0)\n      }())\n      await close()\n    }\n  }\n\n  async function close (): Promise<void> {\n    if (maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now()\n    }\n    await Promise.resolve()\n  }\n\n  return maConn\n}\n"]},"metadata":{},"sourceType":"module"}