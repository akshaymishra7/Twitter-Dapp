{"ast":null,"code":"import { Uint8ArrayList } from 'uint8arraylist'; // @ts-ignore\n\nimport { create } from 'rabin-wasm';\nimport errcode from 'err-code';\n/**\n * @typedef {object} RabinOptions\n * @property {number} min\n * @property {number} max\n * @property {number} bits\n * @property {number} window\n * @property {number} polynomial\n */\n\n/**\n * @type {import('../types').Chunker}\n */\n\nasync function* rabinChunker(source, options) {\n  let min, max, avg;\n\n  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {\n    avg = options.avgChunkSize;\n    min = options.minChunkSize;\n    max = options.maxChunkSize;\n  } else if (!options.avgChunkSize) {\n    throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE');\n  } else {\n    avg = options.avgChunkSize;\n    min = avg / 3;\n    max = avg + avg / 2;\n  } // validate min/max/avg in the same way as go\n\n\n  if (min < 16) {\n    throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE');\n  }\n\n  if (max < min) {\n    max = min;\n  }\n\n  if (avg < min) {\n    avg = min;\n  }\n\n  const sizepow = Math.floor(Math.log2(avg));\n\n  for await (const chunk of rabin(source, {\n    min: min,\n    max: max,\n    bits: sizepow,\n    window: options.window,\n    polynomial: options.polynomial\n  })) {\n    yield chunk;\n  }\n}\n\nexport default rabinChunker;\n/**\n * @param {AsyncIterable<Uint8Array>} source\n * @param {RabinOptions} options\n */\n\nasync function* rabin(source, options) {\n  const r = await create(options.bits, options.min, options.max, options.window);\n  const buffers = new Uint8ArrayList();\n\n  for await (const chunk of source) {\n    buffers.append(chunk);\n    const sizes = r.fingerprint(chunk);\n\n    for (let i = 0; i < sizes.length; i++) {\n      const size = sizes[i];\n      const buf = buffers.slice(0, size);\n      buffers.consume(size);\n      yield buf;\n    }\n  }\n\n  if (buffers.length) {\n    yield buffers.subarray(0);\n  }\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-unixfs-importer/src/chunker/rabin.js"],"names":["Uint8ArrayList","create","errcode","rabinChunker","source","options","min","max","avg","minChunkSize","maxChunkSize","avgChunkSize","Error","sizepow","Math","floor","log2","chunk","rabin","bits","window","polynomial","r","buffers","append","sizes","fingerprint","i","length","size","buf","slice","consume","subarray"],"mappings":"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","sourcesContent":["import { Uint8ArrayList } from 'uint8arraylist'\n// @ts-ignore\nimport { create } from 'rabin-wasm'\nimport errcode from 'err-code'\n\n/**\n * @typedef {object} RabinOptions\n * @property {number} min\n * @property {number} max\n * @property {number} bits\n * @property {number} window\n * @property {number} polynomial\n */\n\n/**\n * @type {import('../types').Chunker}\n */\nasync function * rabinChunker (source, options) {\n  let min, max, avg\n\n  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {\n    avg = options.avgChunkSize\n    min = options.minChunkSize\n    max = options.maxChunkSize\n  } else if (!options.avgChunkSize) {\n    throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE')\n  } else {\n    avg = options.avgChunkSize\n    min = avg / 3\n    max = avg + (avg / 2)\n  }\n\n  // validate min/max/avg in the same way as go\n  if (min < 16) {\n    throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE')\n  }\n\n  if (max < min) {\n    max = min\n  }\n\n  if (avg < min) {\n    avg = min\n  }\n\n  const sizepow = Math.floor(Math.log2(avg))\n\n  for await (const chunk of rabin(source, {\n    min: min,\n    max: max,\n    bits: sizepow,\n    window: options.window,\n    polynomial: options.polynomial\n  })) {\n    yield chunk\n  }\n}\n\nexport default rabinChunker\n\n/**\n * @param {AsyncIterable<Uint8Array>} source\n * @param {RabinOptions} options\n */\nasync function * rabin (source, options) {\n  const r = await create(options.bits, options.min, options.max, options.window)\n  const buffers = new Uint8ArrayList()\n\n  for await (const chunk of source) {\n    buffers.append(chunk)\n\n    const sizes = r.fingerprint(chunk)\n\n    for (let i = 0; i < sizes.length; i++) {\n      const size = sizes[i]\n      const buf = buffers.slice(0, size)\n      buffers.consume(size)\n\n      yield buf\n    }\n  }\n\n  if (buffers.length) {\n    yield buffers.subarray(0)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}