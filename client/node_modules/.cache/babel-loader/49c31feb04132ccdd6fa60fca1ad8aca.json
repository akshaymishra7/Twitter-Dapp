{"ast":null,"code":"import { TimeCacheDuration } from '../constants.js';\nimport Denque from 'denque';\nexport var DeliveryRecordStatus;\n\n(function (DeliveryRecordStatus) {\n  /**\n   * we don't know (yet) if the message is valid\n   */\n  DeliveryRecordStatus[DeliveryRecordStatus[\"unknown\"] = 0] = \"unknown\";\n  /**\n   * we know the message is valid\n   */\n\n  DeliveryRecordStatus[DeliveryRecordStatus[\"valid\"] = 1] = \"valid\";\n  /**\n   * we know the message is invalid\n   */\n\n  DeliveryRecordStatus[DeliveryRecordStatus[\"invalid\"] = 2] = \"invalid\";\n  /**\n   * we were instructed by the validator to ignore the message\n   */\n\n  DeliveryRecordStatus[DeliveryRecordStatus[\"ignored\"] = 3] = \"ignored\";\n})(DeliveryRecordStatus || (DeliveryRecordStatus = {}));\n/**\n * Map of canonical message ID to DeliveryRecord\n *\n * Maintains an internal queue for efficient gc of old messages\n */\n\n\nexport class MessageDeliveries {\n  constructor() {\n    this.records = new Map();\n    this.queue = new Denque();\n  }\n\n  ensureRecord(msgIdStr) {\n    let drec = this.records.get(msgIdStr);\n\n    if (drec) {\n      return drec;\n    } // record doesn't exist yet\n    // create record\n\n\n    drec = {\n      status: DeliveryRecordStatus.unknown,\n      firstSeen: Date.now(),\n      validated: 0,\n      peers: new Set()\n    };\n    this.records.set(msgIdStr, drec); // and add msgId to the queue\n\n    const entry = {\n      msgId: msgIdStr,\n      expire: Date.now() + TimeCacheDuration\n    };\n    this.queue.push(entry);\n    return drec;\n  }\n\n  gc() {\n    const now = Date.now(); // queue is sorted by expiry time\n    // remove expired messages, remove from queue until first un-expired message found\n\n    let head = this.queue.peekFront();\n\n    while (head && head.expire < now) {\n      this.records.delete(head.msgId);\n      this.queue.shift();\n      head = this.queue.peekFront();\n    }\n  }\n\n  clear() {\n    this.records.clear();\n    this.queue.clear();\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,iBAAT,QAAkC,iBAAlC;AACA,OAAOC,MAAP,MAAmB,QAAnB;AAEA,WAAYC,oBAAZ;;AAAA,WAAYA,oBAAZ,EAAgC;AAC9B;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACA;;;;AAGAA;AACD,CAjBD,EAAYA,oBAAoB,KAApBA,oBAAoB,MAAhC;AA+BA;;;;;;;AAKA,OAAM,MAAOC,iBAAP,CAAwB;AAI5BC;AACE,SAAKC,OAAL,GAAe,IAAIC,GAAJ,EAAf;AACA,SAAKC,KAAL,GAAa,IAAIN,MAAJ,EAAb;AACD;;AAEDO,cAAY,CAACC,QAAD,EAAiB;AAC3B,QAAIC,IAAI,GAAG,KAAKL,OAAL,CAAaM,GAAb,CAAiBF,QAAjB,CAAX;;AACA,QAAIC,IAAJ,EAAU;AACR,aAAOA,IAAP;AACD,KAJ0B,CAM3B;AACA;;;AACAA,QAAI,GAAG;AACLE,YAAM,EAAEV,oBAAoB,CAACW,OADxB;AAELC,eAAS,EAAEC,IAAI,CAACC,GAAL,EAFN;AAGLC,eAAS,EAAE,CAHN;AAILC,WAAK,EAAE,IAAIC,GAAJ;AAJF,KAAP;AAMA,SAAKd,OAAL,CAAae,GAAb,CAAiBX,QAAjB,EAA2BC,IAA3B,EAd2B,CAgB3B;;AACA,UAAMW,KAAK,GAAuB;AAChCC,WAAK,EAAEb,QADyB;AAEhCc,YAAM,EAAER,IAAI,CAACC,GAAL,KAAahB;AAFW,KAAlC;AAIA,SAAKO,KAAL,CAAWiB,IAAX,CAAgBH,KAAhB;AAEA,WAAOX,IAAP;AACD;;AAEDe,IAAE;AACA,UAAMT,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAZ,CADA,CAEA;AACA;;AACA,QAAIU,IAAI,GAAG,KAAKnB,KAAL,CAAWoB,SAAX,EAAX;;AACA,WAAOD,IAAI,IAAIA,IAAI,CAACH,MAAL,GAAcP,GAA7B,EAAkC;AAChC,WAAKX,OAAL,CAAauB,MAAb,CAAoBF,IAAI,CAACJ,KAAzB;AACA,WAAKf,KAAL,CAAWsB,KAAX;AACAH,UAAI,GAAG,KAAKnB,KAAL,CAAWoB,SAAX,EAAP;AACD;AACF;;AAEDG,OAAK;AACH,SAAKzB,OAAL,CAAayB,KAAb;AACA,SAAKvB,KAAL,CAAWuB,KAAX;AACD;;AAlD2B","names":["TimeCacheDuration","Denque","DeliveryRecordStatus","MessageDeliveries","constructor","records","Map","queue","ensureRecord","msgIdStr","drec","get","status","unknown","firstSeen","Date","now","validated","peers","Set","set","entry","msgId","expire","push","gc","head","peekFront","delete","shift","clear"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\score\\message-deliveries.ts"],"sourcesContent":["import { TimeCacheDuration } from '../constants.js'\nimport Denque from 'denque'\n\nexport enum DeliveryRecordStatus {\n  /**\n   * we don't know (yet) if the message is valid\n   */\n  unknown,\n  /**\n   * we know the message is valid\n   */\n  valid,\n  /**\n   * we know the message is invalid\n   */\n  invalid,\n  /**\n   * we were instructed by the validator to ignore the message\n   */\n  ignored\n}\n\nexport interface DeliveryRecord {\n  status: DeliveryRecordStatus\n  firstSeen: number\n  validated: number\n  peers: Set<string>\n}\n\ninterface DeliveryQueueEntry {\n  msgId: string\n  expire: number\n}\n\n/**\n * Map of canonical message ID to DeliveryRecord\n *\n * Maintains an internal queue for efficient gc of old messages\n */\nexport class MessageDeliveries {\n  private records: Map<string, DeliveryRecord>\n  public queue: Denque<DeliveryQueueEntry>\n\n  constructor() {\n    this.records = new Map()\n    this.queue = new Denque()\n  }\n\n  ensureRecord(msgIdStr: string): DeliveryRecord {\n    let drec = this.records.get(msgIdStr)\n    if (drec) {\n      return drec\n    }\n\n    // record doesn't exist yet\n    // create record\n    drec = {\n      status: DeliveryRecordStatus.unknown,\n      firstSeen: Date.now(),\n      validated: 0,\n      peers: new Set()\n    }\n    this.records.set(msgIdStr, drec)\n\n    // and add msgId to the queue\n    const entry: DeliveryQueueEntry = {\n      msgId: msgIdStr,\n      expire: Date.now() + TimeCacheDuration\n    }\n    this.queue.push(entry)\n\n    return drec\n  }\n\n  gc(): void {\n    const now = Date.now()\n    // queue is sorted by expiry time\n    // remove expired messages, remove from queue until first un-expired message found\n    let head = this.queue.peekFront()\n    while (head && head.expire < now) {\n      this.records.delete(head.msgId)\n      this.queue.shift()\n      head = this.queue.peekFront()\n    }\n  }\n\n  clear(): void {\n    this.records.clear()\n    this.queue.clear()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}