{"ast":null,"code":"import { multiaddr, isName } from '@multiformats/multiaddr';\nexport function cleanUrlSIO(ma) {\n  const maStrSplit = ma.toString().split('/');\n  const tcpProto = ma.protos()[1].name;\n  const wsProto = ma.protos()[2].name;\n  const tcpPort = ma.stringTuples()[1][1];\n\n  if (tcpProto !== 'tcp' || wsProto !== 'ws' && wsProto !== 'wss') {\n    throw new Error(`invalid multiaddr: ${ma.toString()}`);\n  }\n\n  if (!isName(ma)) {\n    return `http://${maStrSplit[2]}:${maStrSplit[4]}`;\n  }\n\n  if (wsProto === 'ws') {\n    return `http://${maStrSplit[2]}${tcpPort == null || tcpPort === '80' ? '' : `:${tcpPort}`}`;\n  }\n\n  if (wsProto === 'wss') {\n    return `https://${maStrSplit[2]}${tcpPort == null || tcpPort === '443' ? '' : `:${tcpPort}`}`;\n  }\n\n  throw new Error('invalid multiaddr: ' + ma.toString());\n}\nexport function cleanMultiaddr(maStr) {\n  const legacy = '/libp2p-webrtc-star';\n\n  if (maStr.startsWith(legacy)) {\n    maStr = maStr.substring(legacy.length, maStr.length);\n    let ma = multiaddr(maStr);\n    const tuppleIPFS = ma.stringTuples().filter(tupple => {\n      return tupple[0] === 421; // ipfs code\n    })[0];\n\n    if (tuppleIPFS[1] == null) {\n      throw new Error('invalid multiaddr: ' + maStr);\n    }\n\n    ma = ma.decapsulate('p2p');\n    ma = ma.encapsulate('/p2p-webrtc-star');\n    ma = ma.encapsulate(`/p2p/${tuppleIPFS[1]}`);\n    maStr = ma.toString();\n  }\n\n  return maStr;\n}","map":{"version":3,"mappings":"AAAA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,yBAAlC;AAGA,OAAM,SAAUC,WAAV,CAAuBC,EAAvB,EAAoC;AACxC,QAAMC,UAAU,GAAGD,EAAE,CAACE,QAAH,GAAcC,KAAd,CAAoB,GAApB,CAAnB;AACA,QAAMC,QAAQ,GAAGJ,EAAE,CAACK,MAAH,GAAY,CAAZ,EAAeC,IAAhC;AACA,QAAMC,OAAO,GAAGP,EAAE,CAACK,MAAH,GAAY,CAAZ,EAAeC,IAA/B;AACA,QAAME,OAAO,GAAGR,EAAE,CAACS,YAAH,GAAkB,CAAlB,EAAqB,CAArB,CAAhB;;AAEA,MAAIL,QAAQ,KAAK,KAAb,IAAuBG,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAA3D,EAAmE;AACjE,UAAM,IAAIG,KAAJ,CAAU,sBAAsBV,EAAE,CAACE,QAAH,EAAa,EAA7C,CAAN;AACD;;AAED,MAAI,CAACJ,MAAM,CAACE,EAAD,CAAX,EAAiB;AACf,WAAO,UAAUC,UAAU,CAAC,CAAD,CAAG,IAAIA,UAAU,CAAC,CAAD,CAAG,EAA/C;AACD;;AAED,MAAIM,OAAO,KAAK,IAAhB,EAAsB;AACpB,WAAO,UAAUN,UAAU,CAAC,CAAD,CAAG,GAAGO,OAAO,IAAI,IAAX,IAAmBA,OAAO,KAAK,IAA/B,GAAsC,EAAtC,GAA2C,IAAIA,OAAO,EAAE,EAAzF;AACD;;AAED,MAAID,OAAO,KAAK,KAAhB,EAAuB;AACrB,WAAO,WAAWN,UAAU,CAAC,CAAD,CAAG,GAAGO,OAAO,IAAI,IAAX,IAAmBA,OAAO,KAAK,KAA/B,GAAuC,EAAvC,GAA4C,IAAIA,OAAO,EAAE,EAA3F;AACD;;AAED,QAAM,IAAIE,KAAJ,CAAU,wBAAwBV,EAAE,CAACE,QAAH,EAAlC,CAAN;AACD;AAED,OAAM,SAAUS,cAAV,CAA0BC,KAA1B,EAAuC;AAC3C,QAAMC,MAAM,GAAG,qBAAf;;AAEA,MAAID,KAAK,CAACE,UAAN,CAAiBD,MAAjB,CAAJ,EAA8B;AAC5BD,SAAK,GAAGA,KAAK,CAACG,SAAN,CAAgBF,MAAM,CAACG,MAAvB,EAA+BJ,KAAK,CAACI,MAArC,CAAR;AACA,QAAIhB,EAAE,GAAGH,SAAS,CAACe,KAAD,CAAlB;AACA,UAAMK,UAAU,GAAGjB,EAAE,CAACS,YAAH,GAAkBS,MAAlB,CAA0BC,MAAD,IAAW;AACrD,aAAOA,MAAM,CAAC,CAAD,CAAN,KAAc,GAArB,CADqD,CAC5B;AAC1B,KAFkB,EAEhB,CAFgB,CAAnB;;AAIA,QAAIF,UAAU,CAAC,CAAD,CAAV,IAAiB,IAArB,EAA2B;AACzB,YAAM,IAAIP,KAAJ,CAAU,wBAAwBE,KAAlC,CAAN;AACD;;AAEDZ,MAAE,GAAGA,EAAE,CAACoB,WAAH,CAAe,KAAf,CAAL;AACApB,MAAE,GAAGA,EAAE,CAACqB,WAAH,CAAe,kBAAf,CAAL;AACArB,MAAE,GAAGA,EAAE,CAACqB,WAAH,CAAe,QAAQJ,UAAU,CAAC,CAAD,CAAG,EAApC,CAAL;AACAL,SAAK,GAAGZ,EAAE,CAACE,QAAH,EAAR;AACD;;AAED,SAAOU,KAAP;AACD","names":["multiaddr","isName","cleanUrlSIO","ma","maStrSplit","toString","split","tcpProto","protos","name","wsProto","tcpPort","stringTuples","Error","cleanMultiaddr","maStr","legacy","startsWith","substring","length","tuppleIPFS","filter","tupple","decapsulate","encapsulate"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\webrtc-star\\src\\utils.ts"],"sourcesContent":["import { multiaddr, isName } from '@multiformats/multiaddr'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport function cleanUrlSIO (ma: Multiaddr) {\n  const maStrSplit = ma.toString().split('/')\n  const tcpProto = ma.protos()[1].name\n  const wsProto = ma.protos()[2].name\n  const tcpPort = ma.stringTuples()[1][1]\n\n  if (tcpProto !== 'tcp' || (wsProto !== 'ws' && wsProto !== 'wss')) {\n    throw new Error(`invalid multiaddr: ${ma.toString()}`)\n  }\n\n  if (!isName(ma)) {\n    return `http://${maStrSplit[2]}:${maStrSplit[4]}`\n  }\n\n  if (wsProto === 'ws') {\n    return `http://${maStrSplit[2]}${tcpPort == null || tcpPort === '80' ? '' : `:${tcpPort}`}`\n  }\n\n  if (wsProto === 'wss') {\n    return `https://${maStrSplit[2]}${tcpPort == null || tcpPort === '443' ? '' : `:${tcpPort}`}`\n  }\n\n  throw new Error('invalid multiaddr: ' + ma.toString())\n}\n\nexport function cleanMultiaddr (maStr: string) {\n  const legacy = '/libp2p-webrtc-star'\n\n  if (maStr.startsWith(legacy)) {\n    maStr = maStr.substring(legacy.length, maStr.length)\n    let ma = multiaddr(maStr)\n    const tuppleIPFS = ma.stringTuples().filter((tupple) => {\n      return tupple[0] === 421 // ipfs code\n    })[0]\n\n    if (tuppleIPFS[1] == null) {\n      throw new Error('invalid multiaddr: ' + maStr)\n    }\n\n    ma = ma.decapsulate('p2p')\n    ma = ma.encapsulate('/p2p-webrtc-star')\n    ma = ma.encapsulate(`/p2p/${tuppleIPFS[1]}`)\n    maStr = ma.toString()\n  }\n\n  return maStr\n}\n"]},"metadata":{},"sourceType":"module"}