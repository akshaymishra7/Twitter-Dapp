{"ast":null,"code":"const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\n\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterPostgres extends RateLimiterStoreAbstract {\n  /**\n   * @callback callback\n   * @param {Object} err\n   *\n   * @param {Object} opts\n   * @param {callback} cb\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: postgresClient,\n   *   storeType: 'knex', // required only for Knex instance\n   *   tableName: 'string',\n   * }\n   */\n  constructor(opts) {\n    let cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(opts);\n    this.client = opts.storeClient;\n    this.clientType = opts.storeType;\n    this.tableName = opts.tableName;\n    this.clearExpiredByTimeout = opts.clearExpiredByTimeout;\n    this.tableCreated = opts.tableCreated;\n\n    if (!this.tableCreated) {\n      this._createTable().then(() => {\n        this.tableCreated = true;\n\n        if (this.clearExpiredByTimeout) {\n          this._clearExpiredHourAgo();\n        }\n\n        if (typeof cb === 'function') {\n          cb();\n        }\n      }).catch(err => {\n        if (typeof cb === 'function') {\n          cb(err);\n        } else {\n          throw err;\n        }\n      });\n    } else {\n      if (typeof cb === 'function') {\n        cb();\n      }\n    }\n  }\n\n  clearExpired(expire) {\n    return new Promise(resolve => {\n      const q = {\n        name: 'rlflx-clear-expired',\n        text: `DELETE FROM ${this.tableName} WHERE expire < $1`,\n        values: [expire]\n      };\n\n      this._query(q).then(() => {\n        resolve();\n      }).catch(() => {\n        // Deleting expired query is not critical\n        resolve();\n      });\n    });\n  }\n  /**\n   * Delete all rows expired 1 hour ago once per 5 minutes\n   *\n   * @private\n   */\n\n\n  _clearExpiredHourAgo() {\n    if (this._clearExpiredTimeoutId) {\n      clearTimeout(this._clearExpiredTimeoutId);\n    }\n\n    this._clearExpiredTimeoutId = setTimeout(() => {\n      this.clearExpired(Date.now() - 3600000) // Never rejected\n      .then(() => {\n        this._clearExpiredHourAgo();\n      });\n    }, 300000);\n\n    this._clearExpiredTimeoutId.unref();\n  }\n  /**\n   *\n   * @return Promise<any>\n   * @private\n   */\n\n\n  _getConnection() {\n    switch (this.clientType) {\n      case 'pool':\n        return Promise.resolve(this.client);\n\n      case 'sequelize':\n        return this.client.connectionManager.getConnection();\n\n      case 'knex':\n        return this.client.client.acquireConnection();\n\n      case 'typeorm':\n        return Promise.resolve(this.client.driver.master);\n\n      default:\n        return Promise.resolve(this.client);\n    }\n  }\n\n  _releaseConnection(conn) {\n    switch (this.clientType) {\n      case 'pool':\n        return true;\n\n      case 'sequelize':\n        return this.client.connectionManager.releaseConnection(conn);\n\n      case 'knex':\n        return this.client.client.releaseConnection(conn);\n\n      case 'typeorm':\n        return true;\n\n      default:\n        return true;\n    }\n  }\n  /**\n   *\n   * @returns {Promise<any>}\n   * @private\n   */\n\n\n  _createTable() {\n    return new Promise((resolve, reject) => {\n      this._query({\n        text: this._getCreateTableStmt()\n      }).then(() => {\n        resolve();\n      }).catch(err => {\n        if (err.code === '23505') {\n          // Error: duplicate key value violates unique constraint \"pg_type_typname_nsp_index\"\n          // Postgres doesn't handle concurrent table creation\n          // It is supposed, that table is created by another worker\n          resolve();\n        } else {\n          reject(err);\n        }\n      });\n    });\n  }\n\n  _getCreateTableStmt() {\n    return `CREATE TABLE IF NOT EXISTS ${this.tableName} ( \n      key varchar(255) PRIMARY KEY,\n      points integer NOT NULL DEFAULT 0,\n      expire bigint\n    );`;\n  }\n\n  get clientType() {\n    return this._clientType;\n  }\n\n  set clientType(value) {\n    const constructorName = this.client.constructor.name;\n\n    if (typeof value === 'undefined') {\n      if (constructorName === 'Client') {\n        value = 'client';\n      } else if (constructorName === 'Pool' || constructorName === 'BoundPool') {\n        value = 'pool';\n      } else if (constructorName === 'Sequelize') {\n        value = 'sequelize';\n      } else {\n        throw new Error('storeType is not defined');\n      }\n    }\n\n    this._clientType = value.toLowerCase();\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get tableCreated() {\n    return this._tableCreated;\n  }\n\n  set tableCreated(value) {\n    this._tableCreated = typeof value === 'undefined' ? false : !!value;\n  }\n\n  get clearExpiredByTimeout() {\n    return this._clearExpiredByTimeout;\n  }\n\n  set clearExpiredByTimeout(value) {\n    this._clearExpiredByTimeout = typeof value === 'undefined' ? true : Boolean(value);\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    const row = result.rows[0];\n    res.isFirstInDuration = changedPoints === row.points;\n    res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;\n    return res;\n  }\n\n  _query(q) {\n    const prefix = this.tableName.toLowerCase();\n    const queryObj = {\n      name: `${prefix}:${q.name}`,\n      text: q.text,\n      values: q.values\n    };\n    return new Promise((resolve, reject) => {\n      this._getConnection().then(conn => {\n        conn.query(queryObj).then(res => {\n          resolve(res);\n\n          this._releaseConnection(conn);\n        }).catch(err => {\n          reject(err);\n\n          this._releaseConnection(conn);\n        });\n      }).catch(err => {\n        reject(err);\n      });\n    });\n  }\n\n  _upsert(key, points, msDuration) {\n    let forceExpire = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    const newExpire = msDuration > 0 ? Date.now() + msDuration : null;\n    const expireQ = forceExpire ? ' $3 ' : ` CASE\n             WHEN ${this.tableName}.expire <= $4 THEN $3\n             ELSE ${this.tableName}.expire\n            END `;\n    return this._query({\n      name: forceExpire ? 'rlflx-upsert-force' : 'rlflx-upsert',\n      text: `\n            INSERT INTO ${this.tableName} VALUES ($1, $2, $3)\n              ON CONFLICT(key) DO UPDATE SET\n                points = CASE\n                          WHEN (${this.tableName}.expire <= $4 OR 1=${forceExpire ? 1 : 0}) THEN $2\n                          ELSE ${this.tableName}.points + ($2)\n                         END,\n                expire = ${expireQ}\n            RETURNING points, expire;`,\n      values: [key, points, newExpire, Date.now()]\n    });\n  }\n\n  _get(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._query({\n        name: 'rlflx-get',\n        text: `\n            SELECT points, expire FROM ${this.tableName} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,\n        values: [rlKey, Date.now()]\n      }).then(res => {\n        if (res.rowCount === 0) {\n          res = null;\n        }\n\n        resolve(res);\n      }).catch(err => {\n        reject(err);\n      });\n    });\n  }\n\n  _delete(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return this._query({\n      name: 'rlflx-delete',\n      text: `DELETE FROM ${this.tableName} WHERE key = $1`,\n      values: [rlKey]\n    }).then(res => res.rowCount > 0);\n  }\n\n}\n\nmodule.exports = RateLimiterPostgres;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/rate-limiter-flexible/lib/RateLimiterPostgres.js"],"names":["RateLimiterStoreAbstract","require","RateLimiterRes","RateLimiterPostgres","constructor","opts","cb","client","storeClient","clientType","storeType","tableName","clearExpiredByTimeout","tableCreated","_createTable","then","_clearExpiredHourAgo","catch","err","clearExpired","expire","Promise","resolve","q","name","text","values","_query","_clearExpiredTimeoutId","clearTimeout","setTimeout","Date","now","unref","_getConnection","connectionManager","getConnection","acquireConnection","driver","master","_releaseConnection","conn","releaseConnection","reject","_getCreateTableStmt","code","_clientType","value","constructorName","Error","toLowerCase","_tableName","keyPrefix","_tableCreated","_clearExpiredByTimeout","Boolean","_getRateLimiterRes","rlKey","changedPoints","result","res","row","rows","isFirstInDuration","points","consumedPoints","remainingPoints","Math","max","msBeforeNext","prefix","queryObj","query","_upsert","key","msDuration","forceExpire","newExpire","expireQ","_get","rowCount","_delete","module","exports"],"mappings":"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","sourcesContent":["const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterPostgres extends RateLimiterStoreAbstract {\n  /**\n   * @callback callback\n   * @param {Object} err\n   *\n   * @param {Object} opts\n   * @param {callback} cb\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: postgresClient,\n   *   storeType: 'knex', // required only for Knex instance\n   *   tableName: 'string',\n   * }\n   */\n  constructor(opts, cb = null) {\n    super(opts);\n\n    this.client = opts.storeClient;\n    this.clientType = opts.storeType;\n\n    this.tableName = opts.tableName;\n\n    this.clearExpiredByTimeout = opts.clearExpiredByTimeout;\n\n    this.tableCreated = opts.tableCreated;\n    if (!this.tableCreated) {\n      this._createTable()\n        .then(() => {\n          this.tableCreated = true;\n          if (this.clearExpiredByTimeout) {\n            this._clearExpiredHourAgo();\n          }\n          if (typeof cb === 'function') {\n            cb();\n          }\n        })\n        .catch((err) => {\n          if (typeof cb === 'function') {\n            cb(err);\n          } else {\n            throw err;\n          }\n        });\n    } else {\n      if (typeof cb === 'function') {\n        cb();\n      }\n    }\n  }\n\n  clearExpired(expire) {\n    return new Promise((resolve) => {\n      const q = {\n        name: 'rlflx-clear-expired',\n        text: `DELETE FROM ${this.tableName} WHERE expire < $1`,\n        values: [expire],\n      };\n      this._query(q)\n        .then(() => {\n          resolve();\n        })\n        .catch(() => {\n          // Deleting expired query is not critical\n          resolve();\n        });\n    });\n  }\n\n  /**\n   * Delete all rows expired 1 hour ago once per 5 minutes\n   *\n   * @private\n   */\n  _clearExpiredHourAgo() {\n    if (this._clearExpiredTimeoutId) {\n      clearTimeout(this._clearExpiredTimeoutId);\n    }\n    this._clearExpiredTimeoutId = setTimeout(() => {\n      this.clearExpired(Date.now() - 3600000) // Never rejected\n        .then(() => {\n          this._clearExpiredHourAgo();\n        });\n    }, 300000);\n    this._clearExpiredTimeoutId.unref();\n  }\n\n  /**\n   *\n   * @return Promise<any>\n   * @private\n   */\n  _getConnection() {\n    switch (this.clientType) {\n      case 'pool':\n        return Promise.resolve(this.client);\n      case 'sequelize':\n        return this.client.connectionManager.getConnection();\n      case 'knex':\n        return this.client.client.acquireConnection();\n      case 'typeorm':\n        return Promise.resolve(this.client.driver.master);\n      default:\n        return Promise.resolve(this.client);\n    }\n  }\n\n  _releaseConnection(conn) {\n    switch (this.clientType) {\n      case 'pool':\n        return true;\n      case 'sequelize':\n        return this.client.connectionManager.releaseConnection(conn);\n      case 'knex':\n        return this.client.client.releaseConnection(conn);\n      case 'typeorm':\n        return true;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   * @private\n   */\n  _createTable() {\n    return new Promise((resolve, reject) => {\n      this._query({\n        text: this._getCreateTableStmt(),\n      })\n        .then(() => {\n          resolve();\n        })\n        .catch((err) => {\n          if (err.code === '23505') {\n            // Error: duplicate key value violates unique constraint \"pg_type_typname_nsp_index\"\n            // Postgres doesn't handle concurrent table creation\n            // It is supposed, that table is created by another worker\n            resolve();\n          } else {\n            reject(err);\n          }\n        });\n    });\n  }\n\n  _getCreateTableStmt() {\n    return `CREATE TABLE IF NOT EXISTS ${this.tableName} ( \n      key varchar(255) PRIMARY KEY,\n      points integer NOT NULL DEFAULT 0,\n      expire bigint\n    );`;\n  }\n\n  get clientType() {\n    return this._clientType;\n  }\n\n  set clientType(value) {\n    const constructorName = this.client.constructor.name;\n\n    if (typeof value === 'undefined') {\n      if (constructorName === 'Client') {\n        value = 'client';\n      } else if (\n        constructorName === 'Pool' ||\n        constructorName === 'BoundPool'\n      ) {\n        value = 'pool';\n      } else if (constructorName === 'Sequelize') {\n        value = 'sequelize';\n      } else {\n        throw new Error('storeType is not defined');\n      }\n    }\n\n    this._clientType = value.toLowerCase();\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get tableCreated() {\n    return this._tableCreated\n  }\n\n  set tableCreated(value) {\n    this._tableCreated = typeof value === 'undefined' ? false : !!value;\n  }\n\n  get clearExpiredByTimeout() {\n    return this._clearExpiredByTimeout;\n  }\n\n  set clearExpiredByTimeout(value) {\n    this._clearExpiredByTimeout = typeof value === 'undefined' ? true : Boolean(value);\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    const row = result.rows[0];\n\n    res.isFirstInDuration = changedPoints === row.points;\n    res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;\n\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = row.expire\n      ? Math.max(row.expire - Date.now(), 0)\n      : -1;\n\n    return res;\n  }\n\n  _query(q) {\n    const prefix = this.tableName.toLowerCase();\n    const queryObj = { name: `${prefix}:${q.name}`, text: q.text, values: q.values };\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(queryObj)\n            .then((res) => {\n              resolve(res);\n              this._releaseConnection(conn);\n            })\n            .catch((err) => {\n              reject(err);\n              this._releaseConnection(conn);\n            });\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _upsert(key, points, msDuration, forceExpire = false) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    const newExpire = msDuration > 0 ? Date.now() + msDuration : null;\n    const expireQ = forceExpire\n      ? ' $3 '\n      : ` CASE\n             WHEN ${this.tableName}.expire <= $4 THEN $3\n             ELSE ${this.tableName}.expire\n            END `;\n\n    return this._query({\n      name: forceExpire ? 'rlflx-upsert-force' : 'rlflx-upsert',\n      text: `\n            INSERT INTO ${this.tableName} VALUES ($1, $2, $3)\n              ON CONFLICT(key) DO UPDATE SET\n                points = CASE\n                          WHEN (${this.tableName}.expire <= $4 OR 1=${forceExpire ? 1 : 0}) THEN $2\n                          ELSE ${this.tableName}.points + ($2)\n                         END,\n                expire = ${expireQ}\n            RETURNING points, expire;`,\n      values: [key, points, newExpire, Date.now()],\n    });\n  }\n\n  _get(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._query({\n        name: 'rlflx-get',\n        text: `\n            SELECT points, expire FROM ${this.tableName} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,\n        values: [rlKey, Date.now()],\n      })\n        .then((res) => {\n          if (res.rowCount === 0) {\n            res = null;\n          }\n          resolve(res);\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _delete(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return this._query({\n      name: 'rlflx-delete',\n      text: `DELETE FROM ${this.tableName} WHERE key = $1`,\n      values: [rlKey],\n    })\n      .then(res => res.rowCount > 0);\n  }\n}\n\nmodule.exports = RateLimiterPostgres;\n"]},"metadata":{},"sourceType":"script"}