{"ast":null,"code":"import { CodeError } from '@libp2p/interfaces/errors';\nimport { sha256 } from 'multiformats/hashes/sha2'; // @ts-expect-error types are missing\n\nimport forge from 'node-forge/lib/forge.js';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport 'node-forge/lib/sha512.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { exporter } from './exporter.js';\nimport * as pbm from './keys.js';\nimport * as crypto from './rsa.js';\nexport class RsaPublicKey {\n  _key;\n\n  constructor(key) {\n    this._key = key;\n  }\n\n  async verify(data, sig) {\n    return crypto.hashAndVerify(this._key, sig, data);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkix(this._key);\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).subarray();\n  }\n\n  encrypt(bytes) {\n    return crypto.encrypt(this._key, bytes);\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    const {\n      bytes\n    } = await sha256.digest(this.bytes);\n    return bytes;\n  }\n\n}\nexport class RsaPrivateKey {\n  _key;\n  _publicKey;\n\n  constructor(key, publicKey) {\n    this._key = key;\n    this._publicKey = publicKey;\n  }\n\n  genSecret() {\n    return crypto.getRandomValues(16);\n  }\n\n  async sign(message) {\n    return crypto.hashAndSign(this._key, message);\n  }\n\n  get public() {\n    if (this._publicKey == null) {\n      throw new CodeError('public key not provided', 'ERR_PUBKEY_NOT_PROVIDED');\n    }\n\n    return new RsaPublicKey(this._publicKey);\n  }\n\n  decrypt(bytes) {\n    return crypto.decrypt(this._key, bytes);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkcs1(this._key);\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).subarray();\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    const {\n      bytes\n    } = await sha256.digest(this.bytes);\n    return bytes;\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   */\n\n\n  async id() {\n    const hash = await this.public.hash();\n    return uint8ArrayToString(hash, 'base58btc');\n  }\n  /**\n   * Exports the key into a password protected PEM format\n   */\n\n\n  async export(password) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'pkcs-8';\n\n    if (format === 'pkcs-8') {\n      const buffer = new forge.util.ByteBuffer(this.marshal());\n      const asn1 = forge.asn1.fromDer(buffer);\n      const privateKey = forge.pki.privateKeyFromAsn1(asn1);\n      const options = {\n        algorithm: 'aes256',\n        count: 10000,\n        saltSize: 128 / 8,\n        prfAlgorithm: 'sha512'\n      };\n      return forge.pki.encryptRsaPrivateKey(privateKey, password, options);\n    } else if (format === 'libp2p-key') {\n      return exporter(this.bytes, password);\n    } else {\n      throw new CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT');\n    }\n  }\n\n}\nexport async function unmarshalRsaPrivateKey(bytes) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes);\n  const keys = await crypto.unmarshalPrivateKey(jwk);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\nexport function unmarshalRsaPublicKey(bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes);\n  return new RsaPublicKey(jwk);\n}\nexport async function fromJwk(jwk) {\n  const keys = await crypto.unmarshalPrivateKey(jwk);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\nexport async function generateKeyPair(bits) {\n  const keys = await crypto.generateKey(bits);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}","map":{"version":3,"mappings":"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","names":["CodeError","sha256","forge","equals","uint8ArrayEquals","toString","uint8ArrayToString","exporter","pbm","crypto","RsaPublicKey","_key","constructor","key","verify","data","sig","hashAndVerify","marshal","utils","jwkToPkix","bytes","PublicKey","encode","Type","KeyType","RSA","Data","subarray","encrypt","hash","digest","RsaPrivateKey","_publicKey","publicKey","genSecret","getRandomValues","sign","message","hashAndSign","public","decrypt","jwkToPkcs1","PrivateKey","id","export","password","format","buffer","util","ByteBuffer","asn1","fromDer","privateKey","pki","privateKeyFromAsn1","options","algorithm","count","saltSize","prfAlgorithm","encryptRsaPrivateKey","unmarshalRsaPrivateKey","jwk","pkcs1ToJwk","keys","unmarshalPrivateKey","unmarshalRsaPublicKey","pkixToJwk","fromJwk","generateKeyPair","bits","generateKey"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\crypto\\src\\keys\\rsa-class.ts"],"sourcesContent":["\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { sha256 } from 'multiformats/hashes/sha2'\n// @ts-expect-error types are missing\nimport forge from 'node-forge/lib/forge.js'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport 'node-forge/lib/sha512.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { exporter } from './exporter.js'\nimport * as pbm from './keys.js'\nimport * as crypto from './rsa.js'\nimport type { Multibase } from 'multiformats'\n\nexport class RsaPublicKey {\n  private readonly _key: JsonWebKey\n\n  constructor (key: JsonWebKey) {\n    this._key = key\n  }\n\n  async verify (data: Uint8Array, sig: Uint8Array): Promise<boolean> { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal (): Uint8Array {\n    return crypto.utils.jwkToPkix(this._key)\n  }\n\n  get bytes (): Uint8Array {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).subarray()\n  }\n\n  encrypt (bytes: Uint8Array): Uint8Array {\n    return crypto.encrypt(this._key, bytes)\n  }\n\n  equals (key: any): boolean {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash (): Promise<Uint8Array> {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n}\n\nexport class RsaPrivateKey {\n  private readonly _key: JsonWebKey\n  private readonly _publicKey: JsonWebKey\n\n  constructor (key: JsonWebKey, publicKey: JsonWebKey) {\n    this._key = key\n    this._publicKey = publicKey\n  }\n\n  genSecret (): Uint8Array {\n    return crypto.getRandomValues(16)\n  }\n\n  async sign (message: Uint8Array): Promise<Uint8Array> { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public (): RsaPublicKey {\n    if (this._publicKey == null) {\n      throw new CodeError('public key not provided', 'ERR_PUBKEY_NOT_PROVIDED')\n    }\n\n    return new RsaPublicKey(this._publicKey)\n  }\n\n  decrypt (bytes: Uint8Array): Uint8Array {\n    return crypto.decrypt(this._key, bytes)\n  }\n\n  marshal (): Uint8Array {\n    return crypto.utils.jwkToPkcs1(this._key)\n  }\n\n  get bytes (): Uint8Array {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).subarray()\n  }\n\n  equals (key: any): boolean {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash (): Promise<Uint8Array> {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   */\n  async id (): Promise<string> {\n    const hash = await this.public.hash()\n    return uint8ArrayToString(hash, 'base58btc')\n  }\n\n  /**\n   * Exports the key into a password protected PEM format\n   */\n  async export (password: string, format = 'pkcs-8'): Promise<Multibase<'m'>> { // eslint-disable-line require-await\n    if (format === 'pkcs-8') {\n      const buffer = new forge.util.ByteBuffer(this.marshal())\n      const asn1 = forge.asn1.fromDer(buffer)\n      const privateKey = forge.pki.privateKeyFromAsn1(asn1)\n\n      const options = {\n        algorithm: 'aes256',\n        count: 10000,\n        saltSize: 128 / 8,\n        prfAlgorithm: 'sha512'\n      }\n      return forge.pki.encryptRsaPrivateKey(privateKey, password, options)\n    } else if (format === 'libp2p-key') {\n      return exporter(this.bytes, password)\n    } else {\n      throw new CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nexport async function unmarshalRsaPrivateKey (bytes: Uint8Array): Promise<RsaPrivateKey> {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes)\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nexport function unmarshalRsaPublicKey (bytes: Uint8Array): RsaPublicKey {\n  const jwk = crypto.utils.pkixToJwk(bytes)\n  return new RsaPublicKey(jwk)\n}\n\nexport async function fromJwk (jwk: JsonWebKey): Promise<RsaPrivateKey> {\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nexport async function generateKeyPair (bits: number): Promise<RsaPrivateKey> {\n  const keys = await crypto.generateKey(bits)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n"]},"metadata":{},"sourceType":"module"}