{"ast":null,"code":"/* eslint-disable import/export */\n\n/* eslint-disable complexity */\n\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var CircuitRelay;\n\n(function (CircuitRelay) {\n  let Status;\n\n  (function (Status) {\n    Status[\"SUCCESS\"] = \"SUCCESS\";\n    Status[\"HOP_SRC_ADDR_TOO_LONG\"] = \"HOP_SRC_ADDR_TOO_LONG\";\n    Status[\"HOP_DST_ADDR_TOO_LONG\"] = \"HOP_DST_ADDR_TOO_LONG\";\n    Status[\"HOP_SRC_MULTIADDR_INVALID\"] = \"HOP_SRC_MULTIADDR_INVALID\";\n    Status[\"HOP_DST_MULTIADDR_INVALID\"] = \"HOP_DST_MULTIADDR_INVALID\";\n    Status[\"HOP_NO_CONN_TO_DST\"] = \"HOP_NO_CONN_TO_DST\";\n    Status[\"HOP_CANT_DIAL_DST\"] = \"HOP_CANT_DIAL_DST\";\n    Status[\"HOP_CANT_OPEN_DST_STREAM\"] = \"HOP_CANT_OPEN_DST_STREAM\";\n    Status[\"HOP_CANT_SPEAK_RELAY\"] = \"HOP_CANT_SPEAK_RELAY\";\n    Status[\"HOP_CANT_RELAY_TO_SELF\"] = \"HOP_CANT_RELAY_TO_SELF\";\n    Status[\"STOP_SRC_ADDR_TOO_LONG\"] = \"STOP_SRC_ADDR_TOO_LONG\";\n    Status[\"STOP_DST_ADDR_TOO_LONG\"] = \"STOP_DST_ADDR_TOO_LONG\";\n    Status[\"STOP_SRC_MULTIADDR_INVALID\"] = \"STOP_SRC_MULTIADDR_INVALID\";\n    Status[\"STOP_DST_MULTIADDR_INVALID\"] = \"STOP_DST_MULTIADDR_INVALID\";\n    Status[\"STOP_RELAY_REFUSED\"] = \"STOP_RELAY_REFUSED\";\n    Status[\"MALFORMED_MESSAGE\"] = \"MALFORMED_MESSAGE\";\n  })(Status = CircuitRelay.Status || (CircuitRelay.Status = {}));\n\n  let __StatusValues;\n\n  (function (__StatusValues) {\n    __StatusValues[__StatusValues[\"SUCCESS\"] = 100] = \"SUCCESS\";\n    __StatusValues[__StatusValues[\"HOP_SRC_ADDR_TOO_LONG\"] = 220] = \"HOP_SRC_ADDR_TOO_LONG\";\n    __StatusValues[__StatusValues[\"HOP_DST_ADDR_TOO_LONG\"] = 221] = \"HOP_DST_ADDR_TOO_LONG\";\n    __StatusValues[__StatusValues[\"HOP_SRC_MULTIADDR_INVALID\"] = 250] = \"HOP_SRC_MULTIADDR_INVALID\";\n    __StatusValues[__StatusValues[\"HOP_DST_MULTIADDR_INVALID\"] = 251] = \"HOP_DST_MULTIADDR_INVALID\";\n    __StatusValues[__StatusValues[\"HOP_NO_CONN_TO_DST\"] = 260] = \"HOP_NO_CONN_TO_DST\";\n    __StatusValues[__StatusValues[\"HOP_CANT_DIAL_DST\"] = 261] = \"HOP_CANT_DIAL_DST\";\n    __StatusValues[__StatusValues[\"HOP_CANT_OPEN_DST_STREAM\"] = 262] = \"HOP_CANT_OPEN_DST_STREAM\";\n    __StatusValues[__StatusValues[\"HOP_CANT_SPEAK_RELAY\"] = 270] = \"HOP_CANT_SPEAK_RELAY\";\n    __StatusValues[__StatusValues[\"HOP_CANT_RELAY_TO_SELF\"] = 280] = \"HOP_CANT_RELAY_TO_SELF\";\n    __StatusValues[__StatusValues[\"STOP_SRC_ADDR_TOO_LONG\"] = 320] = \"STOP_SRC_ADDR_TOO_LONG\";\n    __StatusValues[__StatusValues[\"STOP_DST_ADDR_TOO_LONG\"] = 321] = \"STOP_DST_ADDR_TOO_LONG\";\n    __StatusValues[__StatusValues[\"STOP_SRC_MULTIADDR_INVALID\"] = 350] = \"STOP_SRC_MULTIADDR_INVALID\";\n    __StatusValues[__StatusValues[\"STOP_DST_MULTIADDR_INVALID\"] = 351] = \"STOP_DST_MULTIADDR_INVALID\";\n    __StatusValues[__StatusValues[\"STOP_RELAY_REFUSED\"] = 390] = \"STOP_RELAY_REFUSED\";\n    __StatusValues[__StatusValues[\"MALFORMED_MESSAGE\"] = 400] = \"MALFORMED_MESSAGE\";\n  })(__StatusValues || (__StatusValues = {}));\n\n  (function (Status) {\n    Status.codec = () => {\n      return enumeration(__StatusValues);\n    };\n  })(Status = CircuitRelay.Status || (CircuitRelay.Status = {}));\n\n  let Type;\n\n  (function (Type) {\n    Type[\"HOP\"] = \"HOP\";\n    Type[\"STOP\"] = \"STOP\";\n    Type[\"STATUS\"] = \"STATUS\";\n    Type[\"CAN_HOP\"] = \"CAN_HOP\";\n  })(Type = CircuitRelay.Type || (CircuitRelay.Type = {}));\n\n  let __TypeValues;\n\n  (function (__TypeValues) {\n    __TypeValues[__TypeValues[\"HOP\"] = 1] = \"HOP\";\n    __TypeValues[__TypeValues[\"STOP\"] = 2] = \"STOP\";\n    __TypeValues[__TypeValues[\"STATUS\"] = 3] = \"STATUS\";\n    __TypeValues[__TypeValues[\"CAN_HOP\"] = 4] = \"CAN_HOP\";\n  })(__TypeValues || (__TypeValues = {}));\n\n  (function (Type) {\n    Type.codec = () => {\n      return enumeration(__TypeValues);\n    };\n  })(Type = CircuitRelay.Type || (CircuitRelay.Type = {}));\n\n  let Peer;\n\n  (function (Peer) {\n    let _codec;\n\n    Peer.codec = () => {\n      if (_codec == null) {\n        _codec = message(function (obj, w) {\n          let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (opts.writeDefaults === true || obj.id != null && obj.id.byteLength > 0) {\n            w.uint32(10);\n            w.bytes(obj.id);\n          }\n\n          if (obj.addrs != null) {\n            for (const value of obj.addrs) {\n              w.uint32(18);\n              w.bytes(value);\n            }\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        }, (reader, length) => {\n          const obj = {\n            id: new Uint8Array(0),\n            addrs: []\n          };\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.id = reader.bytes();\n                break;\n\n              case 2:\n                obj.addrs.push(reader.bytes());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        });\n      }\n\n      return _codec;\n    };\n\n    Peer.encode = obj => {\n      return encodeMessage(obj, Peer.codec());\n    };\n\n    Peer.decode = buf => {\n      return decodeMessage(buf, Peer.codec());\n    };\n  })(Peer = CircuitRelay.Peer || (CircuitRelay.Peer = {}));\n\n  let _codec;\n\n  CircuitRelay.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.type != null) {\n          w.uint32(8);\n          CircuitRelay.Type.codec().encode(obj.type, w);\n        }\n\n        if (obj.srcPeer != null) {\n          w.uint32(18);\n          CircuitRelay.Peer.codec().encode(obj.srcPeer, w, {\n            writeDefaults: false\n          });\n        }\n\n        if (obj.dstPeer != null) {\n          w.uint32(26);\n          CircuitRelay.Peer.codec().encode(obj.dstPeer, w, {\n            writeDefaults: false\n          });\n        }\n\n        if (obj.code != null) {\n          w.uint32(32);\n          CircuitRelay.Status.codec().encode(obj.code, w);\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {};\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.type = CircuitRelay.Type.codec().decode(reader);\n              break;\n\n            case 2:\n              obj.srcPeer = CircuitRelay.Peer.codec().decode(reader, reader.uint32());\n              break;\n\n            case 3:\n              obj.dstPeer = CircuitRelay.Peer.codec().decode(reader, reader.uint32());\n              break;\n\n            case 4:\n              obj.code = CircuitRelay.Status.codec().decode(reader);\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  CircuitRelay.encode = obj => {\n    return encodeMessage(obj, CircuitRelay.codec());\n  };\n\n  CircuitRelay.decode = buf => {\n    return decodeMessage(buf, CircuitRelay.codec());\n  };\n})(CircuitRelay || (CircuitRelay = {}));","map":{"version":3,"mappings":"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","names":["enumeration","encodeMessage","decodeMessage","message","CircuitRelay","Status","__StatusValues","Type","__TypeValues","Peer","_codec","obj","w","opts","lengthDelimited","fork","writeDefaults","id","byteLength","uint32","bytes","addrs","value","ldelim","reader","length","Uint8Array","end","len","pos","tag","push","skipType","codec","buf","type","encode","srcPeer","dstPeer","code","decode"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\circuit\\pb\\index.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { Codec } from 'protons-runtime'\n\nexport interface CircuitRelay {\n  type?: CircuitRelay.Type\n  srcPeer?: CircuitRelay.Peer\n  dstPeer?: CircuitRelay.Peer\n  code?: CircuitRelay.Status\n}\n\nexport namespace CircuitRelay {\n  export enum Status {\n    SUCCESS = 'SUCCESS',\n    HOP_SRC_ADDR_TOO_LONG = 'HOP_SRC_ADDR_TOO_LONG',\n    HOP_DST_ADDR_TOO_LONG = 'HOP_DST_ADDR_TOO_LONG',\n    HOP_SRC_MULTIADDR_INVALID = 'HOP_SRC_MULTIADDR_INVALID',\n    HOP_DST_MULTIADDR_INVALID = 'HOP_DST_MULTIADDR_INVALID',\n    HOP_NO_CONN_TO_DST = 'HOP_NO_CONN_TO_DST',\n    HOP_CANT_DIAL_DST = 'HOP_CANT_DIAL_DST',\n    HOP_CANT_OPEN_DST_STREAM = 'HOP_CANT_OPEN_DST_STREAM',\n    HOP_CANT_SPEAK_RELAY = 'HOP_CANT_SPEAK_RELAY',\n    HOP_CANT_RELAY_TO_SELF = 'HOP_CANT_RELAY_TO_SELF',\n    STOP_SRC_ADDR_TOO_LONG = 'STOP_SRC_ADDR_TOO_LONG',\n    STOP_DST_ADDR_TOO_LONG = 'STOP_DST_ADDR_TOO_LONG',\n    STOP_SRC_MULTIADDR_INVALID = 'STOP_SRC_MULTIADDR_INVALID',\n    STOP_DST_MULTIADDR_INVALID = 'STOP_DST_MULTIADDR_INVALID',\n    STOP_RELAY_REFUSED = 'STOP_RELAY_REFUSED',\n    MALFORMED_MESSAGE = 'MALFORMED_MESSAGE'\n  }\n\n  enum __StatusValues {\n    SUCCESS = 100,\n    HOP_SRC_ADDR_TOO_LONG = 220,\n    HOP_DST_ADDR_TOO_LONG = 221,\n    HOP_SRC_MULTIADDR_INVALID = 250,\n    HOP_DST_MULTIADDR_INVALID = 251,\n    HOP_NO_CONN_TO_DST = 260,\n    HOP_CANT_DIAL_DST = 261,\n    HOP_CANT_OPEN_DST_STREAM = 262,\n    HOP_CANT_SPEAK_RELAY = 270,\n    HOP_CANT_RELAY_TO_SELF = 280,\n    STOP_SRC_ADDR_TOO_LONG = 320,\n    STOP_DST_ADDR_TOO_LONG = 321,\n    STOP_SRC_MULTIADDR_INVALID = 350,\n    STOP_DST_MULTIADDR_INVALID = 351,\n    STOP_RELAY_REFUSED = 390,\n    MALFORMED_MESSAGE = 400\n  }\n\n  export namespace Status {\n    export const codec = () => {\n      return enumeration<Status>(__StatusValues)\n    }\n  }\n\n  export enum Type {\n    HOP = 'HOP',\n    STOP = 'STOP',\n    STATUS = 'STATUS',\n    CAN_HOP = 'CAN_HOP'\n  }\n\n  enum __TypeValues {\n    HOP = 1,\n    STOP = 2,\n    STATUS = 3,\n    CAN_HOP = 4\n  }\n\n  export namespace Type {\n    export const codec = () => {\n      return enumeration<Type>(__TypeValues)\n    }\n  }\n\n  export interface Peer {\n    id: Uint8Array\n    addrs: Uint8Array[]\n  }\n\n  export namespace Peer {\n    let _codec: Codec<Peer>\n\n    export const codec = (): Codec<Peer> => {\n      if (_codec == null) {\n        _codec = message<Peer>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (opts.writeDefaults === true || (obj.id != null && obj.id.byteLength > 0)) {\n            w.uint32(10)\n            w.bytes(obj.id)\n          }\n\n          if (obj.addrs != null) {\n            for (const value of obj.addrs) {\n              w.uint32(18)\n              w.bytes(value)\n            }\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length) => {\n          const obj: any = {\n            id: new Uint8Array(0),\n            addrs: []\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.id = reader.bytes()\n                break\n              case 2:\n                obj.addrs.push(reader.bytes())\n                break\n              default:\n                reader.skipType(tag & 7)\n                break\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Peer): Uint8Array => {\n      return encodeMessage(obj, Peer.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList): Peer => {\n      return decodeMessage(buf, Peer.codec())\n    }\n  }\n\n  let _codec: Codec<CircuitRelay>\n\n  export const codec = (): Codec<CircuitRelay> => {\n    if (_codec == null) {\n      _codec = message<CircuitRelay>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.type != null) {\n          w.uint32(8)\n          CircuitRelay.Type.codec().encode(obj.type, w)\n        }\n\n        if (obj.srcPeer != null) {\n          w.uint32(18)\n          CircuitRelay.Peer.codec().encode(obj.srcPeer, w, {\n            writeDefaults: false\n          })\n        }\n\n        if (obj.dstPeer != null) {\n          w.uint32(26)\n          CircuitRelay.Peer.codec().encode(obj.dstPeer, w, {\n            writeDefaults: false\n          })\n        }\n\n        if (obj.code != null) {\n          w.uint32(32)\n          CircuitRelay.Status.codec().encode(obj.code, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.type = CircuitRelay.Type.codec().decode(reader)\n              break\n            case 2:\n              obj.srcPeer = CircuitRelay.Peer.codec().decode(reader, reader.uint32())\n              break\n            case 3:\n              obj.dstPeer = CircuitRelay.Peer.codec().decode(reader, reader.uint32())\n              break\n            case 4:\n              obj.code = CircuitRelay.Status.codec().decode(reader)\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: CircuitRelay): Uint8Array => {\n    return encodeMessage(obj, CircuitRelay.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): CircuitRelay => {\n    return decodeMessage(buf, CircuitRelay.codec())\n  }\n}\n"]},"metadata":{},"sourceType":"module"}