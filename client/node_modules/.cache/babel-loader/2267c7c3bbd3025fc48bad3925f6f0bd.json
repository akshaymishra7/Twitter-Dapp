{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { isMultiaddr } from '@multiformats/multiaddr';\nimport { codes } from './errors.js';\nimport { PeerRecord, RecordEnvelope } from '@libp2p/peer-record';\nimport { peerIdFromPeerId } from '@libp2p/peer-id';\nimport { CustomEvent } from '@libp2p/interfaces/events';\nconst log = logger('libp2p:peer-store:address-book');\nconst EVENT_NAME = 'change:multiaddrs';\n\nasync function allowAll() {\n  return true;\n}\n\nexport class PeerStoreAddressBook {\n  constructor(dispatchEvent, store, addressFilter) {\n    this.dispatchEvent = dispatchEvent;\n    this.store = store;\n    this.addressFilter = addressFilter ?? allowAll;\n  }\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   */\n\n\n  async consumePeerRecord(envelope) {\n    log.trace('consumePeerRecord await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('consumePeerRecord got write lock');\n    let peerId;\n    let peer;\n    let updatedPeer;\n\n    try {\n      let peerRecord;\n\n      try {\n        peerRecord = PeerRecord.createFromProtobuf(envelope.payload);\n      } catch (err) {\n        log.error('invalid peer record received');\n        return false;\n      }\n\n      peerId = peerRecord.peerId;\n      const multiaddrs = peerRecord.multiaddrs; // Verify peerId\n\n      if (!peerId.equals(envelope.peerId)) {\n        log('signing key does not match PeerId in the PeerRecord');\n        return false;\n      } // ensure the record has multiaddrs\n\n\n      if (multiaddrs == null || multiaddrs.length === 0) {\n        return false;\n      }\n\n      if (await this.store.has(peerId)) {\n        peer = await this.store.load(peerId);\n\n        if (peer.peerRecordEnvelope != null) {\n          const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);\n          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload); // ensure seq is greater than, or equal to, the last received\n\n          if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n            log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber);\n            return false;\n          }\n        }\n      }\n\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter, true); // Replace unsigned addresses by the new ones from the record\n      // TODO: Once we have ttls for the addresses, we should merge these in\n\n      updatedPeer = await this.store.patchOrCreate(peerId, {\n        addresses,\n        peerRecordEnvelope: envelope.marshal().subarray()\n      });\n      log('stored provided peer record for %p', peerRecord.peerId);\n    } finally {\n      log.trace('consumePeerRecord release write lock');\n      release();\n    }\n\n    this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n      detail: {\n        peerId,\n        multiaddrs: updatedPeer.addresses.map(_ref => {\n          let {\n            multiaddr\n          } = _ref;\n          return multiaddr;\n        }),\n        oldMultiaddrs: peer == null ? [] : peer.addresses.map(_ref2 => {\n          let {\n            multiaddr\n          } = _ref2;\n          return multiaddr;\n        })\n      }\n    }));\n    return true;\n  }\n\n  async getRawEnvelope(peerId) {\n    log.trace('getRawEnvelope await read lock');\n    const release = await this.store.lock.readLock();\n    log.trace('getRawEnvelope got read lock');\n\n    try {\n      const peer = await this.store.load(peerId);\n      return peer.peerRecordEnvelope;\n    } catch (err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log.trace('getRawEnvelope release read lock');\n      release();\n    }\n  }\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   */\n\n\n  async getPeerRecord(peerId) {\n    const raw = await this.getRawEnvelope(peerId);\n\n    if (raw == null) {\n      return undefined;\n    }\n\n    return await RecordEnvelope.createFromProtobuf(raw);\n  }\n\n  async get(peerId) {\n    peerId = peerIdFromPeerId(peerId);\n    log.trace('get wait for read lock');\n    const release = await this.store.lock.readLock();\n    log.trace('get got read lock');\n\n    try {\n      const peer = await this.store.load(peerId);\n      return peer.addresses;\n    } catch (err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log.trace('get release read lock');\n      release();\n    }\n\n    return [];\n  }\n\n  async set(peerId, multiaddrs) {\n    peerId = peerIdFromPeerId(peerId);\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs');\n      throw new CodeError('multiaddrs must be an array of Multiaddrs', codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log.trace('set await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('set got write lock');\n    let hasPeer = false;\n    let peer;\n    let updatedPeer;\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter); // No valid addresses found\n\n      if (addresses.length === 0) {\n        return;\n      }\n\n      try {\n        peer = await this.store.load(peerId);\n        hasPeer = true;\n\n        if (new Set([...addresses.map(_ref3 => {\n          let {\n            multiaddr\n          } = _ref3;\n          return multiaddr.toString();\n        }), ...peer.addresses.map(_ref4 => {\n          let {\n            multiaddr\n          } = _ref4;\n          return multiaddr.toString();\n        })]).size === peer.addresses.length && addresses.length === peer.addresses.length) {\n          // not changing anything, no need to update\n          return;\n        }\n      } catch (err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this.store.patchOrCreate(peerId, {\n        addresses\n      });\n      log('set multiaddrs for %p', peerId);\n    } finally {\n      log.trace('set multiaddrs for %p', peerId);\n      log('set release write lock');\n      release();\n    }\n\n    this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n      detail: {\n        peerId,\n        multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n        oldMultiaddrs: peer == null ? [] : peer.addresses.map(_ref5 => {\n          let {\n            multiaddr\n          } = _ref5;\n          return multiaddr;\n        })\n      }\n    })); // Notify the existence of a new peer\n\n    if (!hasPeer) {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: {\n          id: peerId,\n          multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n          protocols: updatedPeer.protocols\n        }\n      }));\n    }\n  }\n\n  async add(peerId, multiaddrs) {\n    peerId = peerIdFromPeerId(peerId);\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs');\n      throw new CodeError('multiaddrs must be an array of Multiaddrs', codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log.trace('add await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('add got write lock');\n    let hasPeer;\n    let peer;\n    let updatedPeer;\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter); // No valid addresses found\n\n      if (addresses.length === 0) {\n        return;\n      }\n\n      try {\n        peer = await this.store.load(peerId);\n        hasPeer = true;\n\n        if (new Set([...addresses.map(_ref6 => {\n          let {\n            multiaddr\n          } = _ref6;\n          return multiaddr.toString();\n        }), ...peer.addresses.map(_ref7 => {\n          let {\n            multiaddr\n          } = _ref7;\n          return multiaddr.toString();\n        })]).size === peer.addresses.length) {\n          return;\n        }\n      } catch (err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this.store.mergeOrCreate(peerId, {\n        addresses\n      });\n      log('added multiaddrs for %p', peerId);\n    } finally {\n      log.trace('set release write lock');\n      release();\n    }\n\n    this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n      detail: {\n        peerId,\n        multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n        oldMultiaddrs: peer == null ? [] : peer.addresses.map(_ref8 => {\n          let {\n            multiaddr\n          } = _ref8;\n          return multiaddr;\n        })\n      }\n    })); // Notify the existence of a new peer\n\n    if (hasPeer === true) {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: {\n          id: peerId,\n          multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n          protocols: updatedPeer.protocols\n        }\n      }));\n    }\n  }\n\n  async delete(peerId) {\n    peerId = peerIdFromPeerId(peerId);\n    log.trace('delete await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('delete got write lock');\n    let peer;\n\n    try {\n      try {\n        peer = await this.store.load(peerId);\n      } catch (err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      await this.store.patchOrCreate(peerId, {\n        addresses: []\n      });\n    } finally {\n      log.trace('delete release write lock');\n      release();\n    }\n\n    if (peer != null) {\n      this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n        detail: {\n          peerId,\n          multiaddrs: [],\n          oldMultiaddrs: peer == null ? [] : peer.addresses.map(_ref9 => {\n            let {\n              multiaddr\n            } = _ref9;\n            return multiaddr;\n          })\n        }\n      }));\n    }\n  }\n\n}\n\nasync function filterMultiaddrs(peerId, multiaddrs, addressFilter) {\n  let isCertified = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const output = [];\n  await Promise.all(multiaddrs.map(async multiaddr => {\n    if (!isMultiaddr(multiaddr)) {\n      log.error('multiaddr must be an instance of Multiaddr');\n      throw new CodeError('multiaddr must be an instance of Multiaddr', codes.ERR_INVALID_PARAMETERS);\n    }\n\n    const include = await addressFilter(peerId, multiaddr);\n\n    if (!include) {\n      return;\n    }\n\n    output.push({\n      multiaddr,\n      isCertified\n    });\n  }));\n  return output;\n}","map":{"version":3,"mappings":"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","names":["logger","CodeError","isMultiaddr","codes","PeerRecord","RecordEnvelope","peerIdFromPeerId","CustomEvent","log","EVENT_NAME","allowAll","PeerStoreAddressBook","constructor","dispatchEvent","store","addressFilter","consumePeerRecord","envelope","trace","release","lock","writeLock","peerId","peer","updatedPeer","peerRecord","createFromProtobuf","payload","err","error","multiaddrs","equals","length","has","load","peerRecordEnvelope","storedEnvelope","storedRecord","seqNumber","addresses","filterMultiaddrs","patchOrCreate","marshal","subarray","detail","map","multiaddr","oldMultiaddrs","getRawEnvelope","readLock","code","ERR_NOT_FOUND","getPeerRecord","raw","undefined","get","set","Array","isArray","ERR_INVALID_PARAMETERS","hasPeer","Set","toString","size","addr","id","protocols","add","mergeOrCreate","delete","isCertified","output","Promise","all","include","push"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\peer-store\\src\\address-book.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { isMultiaddr } from '@multiformats/multiaddr'\nimport { codes } from './errors.js'\nimport { PeerRecord, RecordEnvelope } from '@libp2p/peer-record'\nimport { peerIdFromPeerId } from '@libp2p/peer-id'\nimport { CustomEvent } from '@libp2p/interfaces/events'\nimport type { Address, AddressFilter, Peer, PeerMultiaddrsChangeData, PeerStore } from '@libp2p/interface-peer-store'\nimport type { Store } from './store.js'\nimport type { Envelope } from '@libp2p/interface-record'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst log = logger('libp2p:peer-store:address-book')\nconst EVENT_NAME = 'change:multiaddrs'\n\nasync function allowAll (): Promise<boolean> {\n  return true\n}\n\nexport class PeerStoreAddressBook {\n  private readonly dispatchEvent: PeerStore['dispatchEvent']\n  private readonly store: Store\n  private readonly addressFilter: AddressFilter\n\n  constructor (dispatchEvent: PeerStore['dispatchEvent'], store: Store, addressFilter?: AddressFilter) {\n    this.dispatchEvent = dispatchEvent\n    this.store = store\n    this.addressFilter = addressFilter ?? allowAll\n  }\n\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   */\n  async consumePeerRecord (envelope: Envelope): Promise<boolean> {\n    log.trace('consumePeerRecord await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('consumePeerRecord got write lock')\n\n    let peerId\n    let peer: Peer | undefined\n    let updatedPeer\n\n    try {\n      let peerRecord\n      try {\n        peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n      } catch (err: any) {\n        log.error('invalid peer record received')\n        return false\n      }\n\n      peerId = peerRecord.peerId\n      const multiaddrs = peerRecord.multiaddrs\n\n      // Verify peerId\n      if (!peerId.equals(envelope.peerId)) {\n        log('signing key does not match PeerId in the PeerRecord')\n        return false\n      }\n\n      // ensure the record has multiaddrs\n      if (multiaddrs == null || multiaddrs.length === 0) {\n        return false\n      }\n\n      if (await this.store.has(peerId)) {\n        peer = await this.store.load(peerId)\n\n        if (peer.peerRecordEnvelope != null) {\n          const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope)\n          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n          // ensure seq is greater than, or equal to, the last received\n          if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n            log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber)\n            return false\n          }\n        }\n      }\n\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter, true)\n\n      // Replace unsigned addresses by the new ones from the record\n      // TODO: Once we have ttls for the addresses, we should merge these in\n      updatedPeer = await this.store.patchOrCreate(peerId, {\n        addresses,\n        peerRecordEnvelope: envelope.marshal().subarray()\n      })\n\n      log('stored provided peer record for %p', peerRecord.peerId)\n    } finally {\n      log.trace('consumePeerRecord release write lock')\n      release()\n    }\n\n    this.dispatchEvent(new CustomEvent<PeerMultiaddrsChangeData>(EVENT_NAME, {\n      detail: {\n        peerId,\n        multiaddrs: updatedPeer.addresses.map(({ multiaddr }) => multiaddr),\n        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr }) => multiaddr)\n      }\n    }))\n\n    return true\n  }\n\n  async getRawEnvelope (peerId: PeerId): Promise<Uint8Array | undefined> {\n    log.trace('getRawEnvelope await read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('getRawEnvelope got read lock')\n\n    try {\n      const peer = await this.store.load(peerId)\n\n      return peer.peerRecordEnvelope\n    } catch (err: any) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log.trace('getRawEnvelope release read lock')\n      release()\n    }\n  }\n\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   */\n  async getPeerRecord (peerId: PeerId): Promise<RecordEnvelope | undefined> {\n    const raw = await this.getRawEnvelope(peerId)\n\n    if (raw == null) {\n      return undefined\n    }\n\n    return await RecordEnvelope.createFromProtobuf(raw)\n  }\n\n  async get (peerId: PeerId): Promise<Address[]> {\n    peerId = peerIdFromPeerId(peerId)\n\n    log.trace('get wait for read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('get got read lock')\n\n    try {\n      const peer = await this.store.load(peerId)\n\n      return peer.addresses\n    } catch (err: any) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log.trace('get release read lock')\n      release()\n    }\n\n    return []\n  }\n\n  async set (peerId: PeerId, multiaddrs: Multiaddr[]): Promise<void> {\n    peerId = peerIdFromPeerId(peerId)\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs')\n      throw new CodeError('multiaddrs must be an array of Multiaddrs', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log.trace('set await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('set got write lock')\n\n    let hasPeer = false\n    let peer: Peer | undefined\n    let updatedPeer\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter)\n\n      // No valid addresses found\n      if (addresses.length === 0) {\n        return\n      }\n\n      try {\n        peer = await this.store.load(peerId)\n        hasPeer = true\n\n        if (new Set([\n          ...addresses.map(({ multiaddr }) => multiaddr.toString()),\n          ...peer.addresses.map(({ multiaddr }) => multiaddr.toString())\n        ]).size === peer.addresses.length && addresses.length === peer.addresses.length) {\n          // not changing anything, no need to update\n          return\n        }\n      } catch (err: any) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this.store.patchOrCreate(peerId, { addresses })\n\n      log('set multiaddrs for %p', peerId)\n    } finally {\n      log.trace('set multiaddrs for %p', peerId)\n      log('set release write lock')\n      release()\n    }\n\n    this.dispatchEvent(new CustomEvent<PeerMultiaddrsChangeData>(EVENT_NAME, {\n      detail: {\n        peerId,\n        multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr }) => multiaddr)\n      }\n    }))\n\n    // Notify the existence of a new peer\n    if (!hasPeer) {\n      this.dispatchEvent(new CustomEvent<PeerInfo>('peer', {\n        detail: {\n          id: peerId,\n          multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n          protocols: updatedPeer.protocols\n        }\n      }))\n    }\n  }\n\n  async add (peerId: PeerId, multiaddrs: Multiaddr[]): Promise<void> {\n    peerId = peerIdFromPeerId(peerId)\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs')\n      throw new CodeError('multiaddrs must be an array of Multiaddrs', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log.trace('add await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('add got write lock')\n\n    let hasPeer\n    let peer: Peer | undefined\n    let updatedPeer\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter)\n\n      // No valid addresses found\n      if (addresses.length === 0) {\n        return\n      }\n\n      try {\n        peer = await this.store.load(peerId)\n        hasPeer = true\n\n        if (new Set([\n          ...addresses.map(({ multiaddr }) => multiaddr.toString()),\n          ...peer.addresses.map(({ multiaddr }) => multiaddr.toString())\n        ]).size === peer.addresses.length) {\n          return\n        }\n      } catch (err: any) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this.store.mergeOrCreate(peerId, { addresses })\n\n      log('added multiaddrs for %p', peerId)\n    } finally {\n      log.trace('set release write lock')\n      release()\n    }\n\n    this.dispatchEvent(new CustomEvent<PeerMultiaddrsChangeData>(EVENT_NAME, {\n      detail: {\n        peerId,\n        multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr }) => multiaddr)\n      }\n    }))\n\n    // Notify the existence of a new peer\n    if (hasPeer === true) {\n      this.dispatchEvent(new CustomEvent<PeerInfo>('peer', {\n        detail: {\n          id: peerId,\n          multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n          protocols: updatedPeer.protocols\n        }\n      }))\n    }\n  }\n\n  async delete (peerId: PeerId): Promise<void> {\n    peerId = peerIdFromPeerId(peerId)\n\n    log.trace('delete await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('delete got write lock')\n\n    let peer: Peer | undefined\n\n    try {\n      try {\n        peer = await this.store.load(peerId)\n      } catch (err: any) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      await this.store.patchOrCreate(peerId, {\n        addresses: []\n      })\n    } finally {\n      log.trace('delete release write lock')\n      release()\n    }\n\n    if (peer != null) {\n      this.dispatchEvent(new CustomEvent<PeerMultiaddrsChangeData>(EVENT_NAME, {\n        detail: {\n          peerId,\n          multiaddrs: [],\n          oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr }) => multiaddr)\n        }\n      }))\n    }\n  }\n}\n\nasync function filterMultiaddrs (peerId: PeerId, multiaddrs: Multiaddr[], addressFilter: AddressFilter, isCertified: boolean = false): Promise<Address[]> {\n  const output: Address[] = []\n\n  await Promise.all(\n    multiaddrs.map(async multiaddr => {\n      if (!isMultiaddr(multiaddr)) {\n        log.error('multiaddr must be an instance of Multiaddr')\n        throw new CodeError('multiaddr must be an instance of Multiaddr', codes.ERR_INVALID_PARAMETERS)\n      }\n\n      const include = await addressFilter(peerId, multiaddr)\n\n      if (!include) {\n        return\n      }\n\n      output.push({\n        multiaddr,\n        isCertified\n      })\n    })\n  )\n\n  return output\n}\n"]},"metadata":{},"sourceType":"module"}