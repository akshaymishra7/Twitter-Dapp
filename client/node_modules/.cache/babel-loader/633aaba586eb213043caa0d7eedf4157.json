{"ast":null,"code":"import * as dagPB from '@ipld/dag-pb';\nimport * as dagCBOR from '@ipld/dag-cbor';\nimport * as dagJSON from '@ipld/dag-json';\nimport * as raw from 'multiformats/codecs/raw';\nimport { CID } from 'multiformats/cid';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\n/**\n * @typedef {import('@ipld/dag-pb').PBLink} DAGLink\n */\n\n/**\n * @param {any} node\n * @param {DAGLink[]} [links]\n * @returns {DAGLink[]}\n */\n\nfunction findLinks(node) {\n  let links = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  for (const key in node) {\n    const val = node[key];\n\n    if (key === '/' && Object.keys(node).length === 1) {\n      try {\n        links.push({\n          Name: '',\n          Tsize: 0,\n          Hash: CID.parse(val)\n        });\n        continue;\n      } catch (\n      /** @type {any} */\n      _) {// not a CID\n      }\n    }\n\n    const cid = CID.asCID(val);\n\n    if (cid) {\n      links.push({\n        Name: '',\n        Tsize: 0,\n        Hash: cid\n      });\n      continue;\n    }\n\n    if (Array.isArray(val)) {\n      findLinks(val, links);\n    }\n\n    if (val && typeof val === 'object') {\n      findLinks(val, links);\n    }\n  }\n\n  return links;\n}\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n */\n\n\nexport function createLinks(_ref) {\n  let {\n    repo,\n    codecs\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/object').API<{}>[\"links\"]}\n   */\n  async function links(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const codec = await codecs.getCodec(cid.code);\n    const block = await repo.blocks.get(cid, options);\n    const node = codec.decode(block);\n\n    switch (cid.code) {\n      case raw.code:\n        return [];\n\n      case dagPB.code:\n        return node.Links;\n\n      case dagCBOR.code:\n      case dagJSON.code:\n        return findLinks(node);\n\n      default:\n        throw new Error(`Cannot resolve links from codec ${cid.code}`);\n    }\n  }\n\n  return withTimeoutOption(links);\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/object/links.js"],"names":["dagPB","dagCBOR","dagJSON","raw","CID","withTimeoutOption","findLinks","node","links","key","val","Object","keys","length","push","Name","Tsize","Hash","parse","_","cid","asCID","Array","isArray","createLinks","repo","codecs","options","codec","getCodec","code","block","blocks","get","decode","Links","Error"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,cAAvB;AACA,OAAO,KAAKC,OAAZ,MAAyB,gBAAzB;AACA,OAAO,KAAKC,OAAZ,MAAyB,gBAAzB;AACA,OAAO,KAAKC,GAAZ,MAAqB,yBAArB;AACA,SAASC,GAAT,QAAoB,kBAApB;AACA,SAASC,iBAAT,QAAkC,qCAAlC;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASC,SAAT,CAAoBC,IAApB,EAAsC;AAAA,MAAZC,KAAY,uEAAJ,EAAI;;AACpC,OAAK,MAAMC,GAAX,IAAkBF,IAAlB,EAAwB;AACtB,UAAMG,GAAG,GAAGH,IAAI,CAACE,GAAD,CAAhB;;AAEA,QAAIA,GAAG,KAAK,GAAR,IAAeE,MAAM,CAACC,IAAP,CAAYL,IAAZ,EAAkBM,MAAlB,KAA6B,CAAhD,EAAmD;AACjD,UAAI;AACFL,QAAAA,KAAK,CAACM,IAAN,CAAW;AACTC,UAAAA,IAAI,EAAE,EADG;AAETC,UAAAA,KAAK,EAAE,CAFE;AAGTC,UAAAA,IAAI,EAAEb,GAAG,CAACc,KAAJ,CAAUR,GAAV;AAHG,SAAX;AAKA;AACD,OAPD,CAOE;AAAO;AAAmBS,MAAAA,CAA1B,EAA6B,CAC7B;AACD;AACF;;AAED,UAAMC,GAAG,GAAGhB,GAAG,CAACiB,KAAJ,CAAUX,GAAV,CAAZ;;AAEA,QAAIU,GAAJ,EAAS;AACPZ,MAAAA,KAAK,CAACM,IAAN,CAAW;AACTC,QAAAA,IAAI,EAAE,EADG;AAETC,QAAAA,KAAK,EAAE,CAFE;AAGTC,QAAAA,IAAI,EAAEG;AAHG,OAAX;AAKA;AACD;;AAED,QAAIE,KAAK,CAACC,OAAN,CAAcb,GAAd,CAAJ,EAAwB;AACtBJ,MAAAA,SAAS,CAACI,GAAD,EAAMF,KAAN,CAAT;AACD;;AAED,QAAIE,GAAG,IAAI,OAAOA,GAAP,KAAe,QAA1B,EAAoC;AAClCJ,MAAAA,SAAS,CAACI,GAAD,EAAMF,KAAN,CAAT;AACD;AACF;;AAED,SAAOA,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASgB,WAAT,OAAwC;AAAA,MAAlB;AAAEC,IAAAA,IAAF;AAAQC,IAAAA;AAAR,GAAkB;;AAC7C;AACF;AACA;AACE,iBAAelB,KAAf,CAAsBY,GAAtB,EAAyC;AAAA,QAAdO,OAAc,uEAAJ,EAAI;AACvC,UAAMC,KAAK,GAAG,MAAMF,MAAM,CAACG,QAAP,CAAgBT,GAAG,CAACU,IAApB,CAApB;AACA,UAAMC,KAAK,GAAG,MAAMN,IAAI,CAACO,MAAL,CAAYC,GAAZ,CAAgBb,GAAhB,EAAqBO,OAArB,CAApB;AACA,UAAMpB,IAAI,GAAGqB,KAAK,CAACM,MAAN,CAAaH,KAAb,CAAb;;AAEA,YAAQX,GAAG,CAACU,IAAZ;AACE,WAAK3B,GAAG,CAAC2B,IAAT;AACE,eAAO,EAAP;;AACF,WAAK9B,KAAK,CAAC8B,IAAX;AACE,eAAOvB,IAAI,CAAC4B,KAAZ;;AACF,WAAKlC,OAAO,CAAC6B,IAAb;AACA,WAAK5B,OAAO,CAAC4B,IAAb;AACE,eAAOxB,SAAS,CAACC,IAAD,CAAhB;;AACF;AACE,cAAM,IAAI6B,KAAJ,CAAW,mCAAkChB,GAAG,CAACU,IAAK,EAAtD,CAAN;AATJ;AAWD;;AAED,SAAOzB,iBAAiB,CAACG,KAAD,CAAxB;AACD","sourcesContent":["import * as dagPB from '@ipld/dag-pb'\nimport * as dagCBOR from '@ipld/dag-cbor'\nimport * as dagJSON from '@ipld/dag-json'\nimport * as raw from 'multiformats/codecs/raw'\nimport { CID } from 'multiformats/cid'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\n/**\n * @typedef {import('@ipld/dag-pb').PBLink} DAGLink\n */\n\n/**\n * @param {any} node\n * @param {DAGLink[]} [links]\n * @returns {DAGLink[]}\n */\nfunction findLinks (node, links = []) {\n  for (const key in node) {\n    const val = node[key]\n\n    if (key === '/' && Object.keys(node).length === 1) {\n      try {\n        links.push({\n          Name: '',\n          Tsize: 0,\n          Hash: CID.parse(val)\n        })\n        continue\n      } catch (/** @type {any} */ _) {\n        // not a CID\n      }\n    }\n\n    const cid = CID.asCID(val)\n\n    if (cid) {\n      links.push({\n        Name: '',\n        Tsize: 0,\n        Hash: cid\n      })\n      continue\n    }\n\n    if (Array.isArray(val)) {\n      findLinks(val, links)\n    }\n\n    if (val && typeof val === 'object') {\n      findLinks(val, links)\n    }\n  }\n\n  return links\n}\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n */\nexport function createLinks ({ repo, codecs }) {\n  /**\n   * @type {import('ipfs-core-types/src/object').API<{}>[\"links\"]}\n   */\n  async function links (cid, options = {}) {\n    const codec = await codecs.getCodec(cid.code)\n    const block = await repo.blocks.get(cid, options)\n    const node = codec.decode(block)\n\n    switch (cid.code) {\n      case raw.code:\n        return []\n      case dagPB.code:\n        return node.Links\n      case dagCBOR.code:\n      case dagJSON.code:\n        return findLinks(node)\n      default:\n        throw new Error(`Cannot resolve links from codec ${cid.code}`)\n    }\n  }\n\n  return withTimeoutOption(links)\n}\n"]},"metadata":{},"sourceType":"module"}