{"ast":null,"code":"const RateLimiterRes = require(\"./RateLimiterRes\");\n/**\n * Bursty rate limiter exposes only msBeforeNext time and doesn't expose points from bursty limiter by default\n * @type {BurstyRateLimiter}\n */\n\n\nmodule.exports = class BurstyRateLimiter {\n  constructor(rateLimiter, burstLimiter) {\n    this._rateLimiter = rateLimiter;\n    this._burstLimiter = burstLimiter;\n  }\n  /**\n   * Merge rate limiter response objects. Responses can be null\n   *\n   * @param {RateLimiterRes} [rlRes] Rate limiter response\n   * @param {RateLimiterRes} [blRes] Bursty limiter response\n   */\n\n\n  _combineRes(rlRes, blRes) {\n    return new RateLimiterRes(rlRes.remainingPoints, Math.min(rlRes.msBeforeNext, blRes.msBeforeNext), rlRes.consumedPoints, rlRes.isFirstInDuration);\n  }\n  /**\n   * @param key\n   * @param pointsToConsume\n   * @param options\n   * @returns {Promise<any>}\n   */\n\n\n  consume(key) {\n    let pointsToConsume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this._rateLimiter.consume(key, pointsToConsume, options).catch(rlRej => {\n      if (rlRej instanceof RateLimiterRes) {\n        return this._burstLimiter.consume(key, pointsToConsume, options).then(blRes => {\n          return Promise.resolve(this._combineRes(rlRej, blRes));\n        }).catch(blRej => {\n          if (blRej instanceof RateLimiterRes) {\n            return Promise.reject(this._combineRes(rlRej, blRej));\n          } else {\n            return Promise.reject(blRej);\n          }\n        });\n      } else {\n        return Promise.reject(rlRej);\n      }\n    });\n  }\n  /**\n   * It doesn't expose available points from burstLimiter\n   *\n   * @param key\n   * @returns {Promise<RateLimiterRes>}\n   */\n\n\n  get(key) {\n    return Promise.all([this._rateLimiter.get(key), this._burstLimiter.get(key)]).then(_ref => {\n      let [rlRes, blRes] = _ref;\n      return this._combineRes(rlRes, blRes);\n    });\n  }\n\n  get points() {\n    return this._rateLimiter.points;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/rate-limiter-flexible/lib/BurstyRateLimiter.js"],"names":["RateLimiterRes","require","module","exports","BurstyRateLimiter","constructor","rateLimiter","burstLimiter","_rateLimiter","_burstLimiter","_combineRes","rlRes","blRes","remainingPoints","Math","min","msBeforeNext","consumedPoints","isFirstInDuration","consume","key","pointsToConsume","options","catch","rlRej","then","Promise","resolve","blRej","reject","get","all","points"],"mappings":"AAAA,MAAMA,cAAc,GAAGC,OAAO,CAAC,kBAAD,CAA9B;AAEA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,MAAMC,iBAAN,CAAwB;AACvCC,EAAAA,WAAW,CAACC,WAAD,EAAcC,YAAd,EAA4B;AACrC,SAAKC,YAAL,GAAoBF,WAApB;AACA,SAAKG,aAAL,GAAqBF,YAArB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEG,EAAAA,WAAW,CAACC,KAAD,EAAQC,KAAR,EAAe;AACxB,WAAO,IAAIZ,cAAJ,CACLW,KAAK,CAACE,eADD,EAELC,IAAI,CAACC,GAAL,CAASJ,KAAK,CAACK,YAAf,EAA6BJ,KAAK,CAACI,YAAnC,CAFK,EAGLL,KAAK,CAACM,cAHD,EAILN,KAAK,CAACO,iBAJD,CAAP;AAMD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,OAAO,CAACC,GAAD,EAAyC;AAAA,QAAnCC,eAAmC,uEAAjB,CAAiB;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAC9C,WAAO,KAAKd,YAAL,CAAkBW,OAAlB,CAA0BC,GAA1B,EAA+BC,eAA/B,EAAgDC,OAAhD,EACJC,KADI,CACGC,KAAD,IAAW;AAChB,UAAIA,KAAK,YAAYxB,cAArB,EAAqC;AACnC,eAAO,KAAKS,aAAL,CAAmBU,OAAnB,CAA2BC,GAA3B,EAAgCC,eAAhC,EAAiDC,OAAjD,EACJG,IADI,CACEb,KAAD,IAAW;AACf,iBAAOc,OAAO,CAACC,OAAR,CAAgB,KAAKjB,WAAL,CAAiBc,KAAjB,EAAwBZ,KAAxB,CAAhB,CAAP;AACD,SAHI,EAIJW,KAJI,CAIGK,KAAD,IAAW;AACd,cAAIA,KAAK,YAAY5B,cAArB,EAAqC;AACnC,mBAAO0B,OAAO,CAACG,MAAR,CAAe,KAAKnB,WAAL,CAAiBc,KAAjB,EAAwBI,KAAxB,CAAf,CAAP;AACD,WAFD,MAEO;AACL,mBAAOF,OAAO,CAACG,MAAR,CAAeD,KAAf,CAAP;AACD;AACF,SAVE,CAAP;AAYD,OAbD,MAaO;AACL,eAAOF,OAAO,CAACG,MAAR,CAAeL,KAAf,CAAP;AACD;AACF,KAlBI,CAAP;AAmBD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEM,EAAAA,GAAG,CAACV,GAAD,EAAM;AACP,WAAOM,OAAO,CAACK,GAAR,CAAY,CACjB,KAAKvB,YAAL,CAAkBsB,GAAlB,CAAsBV,GAAtB,CADiB,EAEjB,KAAKX,aAAL,CAAmBqB,GAAnB,CAAuBV,GAAvB,CAFiB,CAAZ,EAGJK,IAHI,CAGC,QAAoB;AAAA,UAAnB,CAACd,KAAD,EAAQC,KAAR,CAAmB;AAC1B,aAAO,KAAKF,WAAL,CAAiBC,KAAjB,EAAwBC,KAAxB,CAAP;AACD,KALM,CAAP;AAMD;;AAES,MAANoB,MAAM,GAAG;AACX,WAAO,KAAKxB,YAAL,CAAkBwB,MAAzB;AACD;;AAlEsC,CAAzC","sourcesContent":["const RateLimiterRes = require(\"./RateLimiterRes\");\n\n/**\n * Bursty rate limiter exposes only msBeforeNext time and doesn't expose points from bursty limiter by default\n * @type {BurstyRateLimiter}\n */\nmodule.exports = class BurstyRateLimiter {\n  constructor(rateLimiter, burstLimiter) {\n    this._rateLimiter = rateLimiter;\n    this._burstLimiter = burstLimiter\n  }\n\n  /**\n   * Merge rate limiter response objects. Responses can be null\n   *\n   * @param {RateLimiterRes} [rlRes] Rate limiter response\n   * @param {RateLimiterRes} [blRes] Bursty limiter response\n   */\n  _combineRes(rlRes, blRes) {\n    return new RateLimiterRes(\n      rlRes.remainingPoints,\n      Math.min(rlRes.msBeforeNext, blRes.msBeforeNext),\n      rlRes.consumedPoints,\n      rlRes.isFirstInDuration\n    )\n  }\n\n  /**\n   * @param key\n   * @param pointsToConsume\n   * @param options\n   * @returns {Promise<any>}\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return this._rateLimiter.consume(key, pointsToConsume, options)\n      .catch((rlRej) => {\n        if (rlRej instanceof RateLimiterRes) {\n          return this._burstLimiter.consume(key, pointsToConsume, options)\n            .then((blRes) => {\n              return Promise.resolve(this._combineRes(rlRej, blRes))\n            })\n            .catch((blRej) => {\n                if (blRej instanceof RateLimiterRes) {\n                  return Promise.reject(this._combineRes(rlRej, blRej))\n                } else {\n                  return Promise.reject(blRej)\n                }\n              }\n            )\n        } else {\n          return Promise.reject(rlRej)\n        }\n      })\n  }\n\n  /**\n   * It doesn't expose available points from burstLimiter\n   *\n   * @param key\n   * @returns {Promise<RateLimiterRes>}\n   */\n  get(key) {\n    return Promise.all([\n      this._rateLimiter.get(key),\n      this._burstLimiter.get(key),\n    ]).then(([rlRes, blRes]) => {\n      return this._combineRes(rlRes, blRes);\n    });\n  }\n\n  get points() {\n    return this._rateLimiter.points;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}