{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport * as multistream from './multistream.js';\nimport { handshake } from 'it-handshake';\nimport { PROTOCOL_ID } from './constants.js';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { Uint8ArrayList } from 'uint8arraylist';\nconst log = logger('libp2p:mss:handle');\nexport async function handle(stream, protocols, options) {\n  protocols = Array.isArray(protocols) ? protocols : [protocols];\n  const {\n    writer,\n    reader,\n    rest,\n    stream: shakeStream\n  } = handshake(stream);\n\n  while (true) {\n    const protocol = await multistream.readString(reader, options);\n    log.trace('read \"%s\"', protocol);\n\n    if (protocol === PROTOCOL_ID) {\n      log.trace('respond with \"%s\" for \"%s\"', PROTOCOL_ID, protocol);\n      multistream.write(writer, uint8ArrayFromString(PROTOCOL_ID), options);\n      continue;\n    }\n\n    if (protocols.includes(protocol)) {\n      multistream.write(writer, uint8ArrayFromString(protocol), options);\n      log.trace('respond with \"%s\" for \"%s\"', protocol, protocol);\n      rest();\n      return {\n        stream: shakeStream,\n        protocol\n      };\n    }\n\n    if (protocol === 'ls') {\n      // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\\n\n      multistream.write(writer, new Uint8ArrayList(...protocols.map(p => multistream.encode(uint8ArrayFromString(p)))), options); // multistream.writeAll(writer, protocols.map(p => uint8ArrayFromString(p)))\n\n      log.trace('respond with \"%s\" for %s', protocols, protocol);\n      continue;\n    }\n\n    multistream.write(writer, uint8ArrayFromString('na'), options);\n    log('respond with \"na\" for \"%s\"', protocol);\n  }\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,QAAuB,gBAAvB;AACA,OAAO,KAAKC,WAAZ,MAA6B,kBAA7B;AACA,SAASC,SAAT,QAA0B,cAA1B;AACA,SAASC,WAAT,QAA4B,gBAA5B;AACA,SAASC,UAAU,IAAIC,oBAAvB,QAAmD,yBAAnD;AACA,SAASC,cAAT,QAA+B,gBAA/B;AAIA,MAAMC,GAAG,GAAGP,MAAM,CAAC,mBAAD,CAAlB;AAkDA,OAAO,eAAeQ,MAAf,CAAuBC,MAAvB,EAAoCC,SAApC,EAAkEC,OAAlE,EAAiG;AACtGD,WAAS,GAAGE,KAAK,CAACC,OAAN,CAAcH,SAAd,IAA2BA,SAA3B,GAAuC,CAACA,SAAD,CAAnD;AACA,QAAM;AAAEI,UAAF;AAAUC,UAAV;AAAkBC,QAAlB;AAAwBP,UAAM,EAAEQ;AAAhC,MAAgDf,SAAS,CAACO,MAAD,CAA/D;;AAEA,SAAO,IAAP,EAAa;AACX,UAAMS,QAAQ,GAAG,MAAMjB,WAAW,CAACkB,UAAZ,CAAuBJ,MAAvB,EAA+BJ,OAA/B,CAAvB;AACAJ,OAAG,CAACa,KAAJ,CAAU,WAAV,EAAuBF,QAAvB;;AAEA,QAAIA,QAAQ,KAAKf,WAAjB,EAA8B;AAC5BI,SAAG,CAACa,KAAJ,CAAU,4BAAV,EAAwCjB,WAAxC,EAAqDe,QAArD;AACAjB,iBAAW,CAACoB,KAAZ,CAAkBP,MAAlB,EAA0BT,oBAAoB,CAACF,WAAD,CAA9C,EAA6DQ,OAA7D;AACA;AACD;;AAED,QAAID,SAAS,CAACY,QAAV,CAAmBJ,QAAnB,CAAJ,EAAkC;AAChCjB,iBAAW,CAACoB,KAAZ,CAAkBP,MAAlB,EAA0BT,oBAAoB,CAACa,QAAD,CAA9C,EAA0DP,OAA1D;AACAJ,SAAG,CAACa,KAAJ,CAAU,4BAAV,EAAwCF,QAAxC,EAAkDA,QAAlD;AACAF,UAAI;AACJ,aAAO;AAAEP,cAAM,EAAEQ,WAAV;AAAuBC;AAAvB,OAAP;AACD;;AAED,QAAIA,QAAQ,KAAK,IAAjB,EAAuB;AACrB;AACAjB,iBAAW,CAACoB,KAAZ,CAAkBP,MAAlB,EAA0B,IAAIR,cAAJ,CAAmB,GAAGI,SAAS,CAACa,GAAV,CAAcC,CAAC,IAAIvB,WAAW,CAACwB,MAAZ,CAAmBpB,oBAAoB,CAACmB,CAAD,CAAvC,CAAnB,CAAtB,CAA1B,EAAkHb,OAAlH,EAFqB,CAGrB;;AACAJ,SAAG,CAACa,KAAJ,CAAU,0BAAV,EAAsCV,SAAtC,EAAiDQ,QAAjD;AACA;AACD;;AAEDjB,eAAW,CAACoB,KAAZ,CAAkBP,MAAlB,EAA0BT,oBAAoB,CAAC,IAAD,CAA9C,EAAsDM,OAAtD;AACAJ,OAAG,CAAC,4BAAD,EAA+BW,QAA/B,CAAH;AACD;AACF","names":["logger","multistream","handshake","PROTOCOL_ID","fromString","uint8ArrayFromString","Uint8ArrayList","log","handle","stream","protocols","options","Array","isArray","writer","reader","rest","shakeStream","protocol","readString","trace","write","includes","map","p","encode"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\multistream-select\\src\\handle.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport * as multistream from './multistream.js'\nimport { handshake } from 'it-handshake'\nimport { PROTOCOL_ID } from './constants.js'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport type { Duplex, Source } from 'it-stream-types'\nimport type { ByteArrayInit, ByteListInit, MultistreamSelectInit, ProtocolStream } from './index.js'\n\nconst log = logger('libp2p:mss:handle')\n\n/**\n * Handle multistream protocol selections for the given list of protocols.\n *\n * Note that after a protocol is handled `listener` can no longer be used.\n *\n * @param stream - A duplex iterable stream to listen on\n * @param protocols - A list of protocols (or single protocol) that this listener is able to speak.\n * @param options - an options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`\n * @example\n *\n * ```js\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex({\n *   async onStream (muxedStream) {\n *   // mss.handle(handledProtocols)\n *   // Returns selected stream and protocol\n *   const { stream, protocol } = await mss.handle(muxedStream, [\n *     '/ipfs-dht/1.0.0',\n *     '/ipfs-bitswap/1.0.0'\n *   ])\n *\n *   // Typically here we'd call the handler function that was registered in\n *   // libp2p for the given protocol:\n *   // e.g. handlers[protocol].handler(stream)\n *   //\n *   // If protocol was /ipfs-dht/1.0.0 it might do something like this:\n *   // try {\n *   //   await pipe(\n *   //     dhtStream,\n *   //     source => (async function * () {\n *   //       for await (const chunk of source)\n *   //         // Incoming DHT data -> process and yield to respond\n *   //     })(),\n *   //     dhtStream\n *   //   )\n *   // } catch (err) {\n *   //   // Error in stream\n *   // }\n *   }\n * })\n * ```\n */\nexport async function handle (stream: Duplex<Source<Uint8Array>, Source<Uint8Array>>, protocols: string | string[], options: ByteArrayInit): Promise<ProtocolStream<Uint8Array>>\nexport async function handle (stream: Duplex<Source<Uint8ArrayList | Uint8Array>, Source<Uint8ArrayList | Uint8Array>>, protocols: string | string[], options?: ByteListInit): Promise<ProtocolStream<Uint8ArrayList, Uint8ArrayList | Uint8Array>>\nexport async function handle (stream: any, protocols: string | string[], options?: MultistreamSelectInit): Promise<ProtocolStream<any>> {\n  protocols = Array.isArray(protocols) ? protocols : [protocols]\n  const { writer, reader, rest, stream: shakeStream } = handshake(stream)\n\n  while (true) {\n    const protocol = await multistream.readString(reader, options)\n    log.trace('read \"%s\"', protocol)\n\n    if (protocol === PROTOCOL_ID) {\n      log.trace('respond with \"%s\" for \"%s\"', PROTOCOL_ID, protocol)\n      multistream.write(writer, uint8ArrayFromString(PROTOCOL_ID), options)\n      continue\n    }\n\n    if (protocols.includes(protocol)) {\n      multistream.write(writer, uint8ArrayFromString(protocol), options)\n      log.trace('respond with \"%s\" for \"%s\"', protocol, protocol)\n      rest()\n      return { stream: shakeStream, protocol }\n    }\n\n    if (protocol === 'ls') {\n      // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\\n\n      multistream.write(writer, new Uint8ArrayList(...protocols.map(p => multistream.encode(uint8ArrayFromString(p)))), options)\n      // multistream.writeAll(writer, protocols.map(p => uint8ArrayFromString(p)))\n      log.trace('respond with \"%s\" for %s', protocols, protocol)\n      continue\n    }\n\n    multistream.write(writer, uint8ArrayFromString('na'), options)\n    log('respond with \"na\" for \"%s\"', protocol)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}