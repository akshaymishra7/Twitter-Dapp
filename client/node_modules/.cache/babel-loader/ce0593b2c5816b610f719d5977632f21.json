{"ast":null,"code":"import { Libp2pRecord } from '@libp2p/record';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { Message, MESSAGE_TYPE } from '../../message/index.js';\nimport { MAX_RECORD_AGE } from '../../constants.js';\nimport { bufferToRecordKey, isPublicKeyKey, fromPublicKeyKey } from '../../utils.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:kad-dht:rpc:handlers:get-value');\nexport class GetValueHandler {\n  constructor(components, init) {\n    const {\n      peerRouting\n    } = init;\n    this.components = components;\n    this.peerRouting = peerRouting;\n  }\n\n  async handle(peerId, msg) {\n    const key = msg.key;\n    log('%p asked for key %b', peerId, key);\n\n    if (key == null || key.length === 0) {\n      throw new CodeError('Invalid key', 'ERR_INVALID_KEY');\n    }\n\n    const response = new Message(MESSAGE_TYPE.GET_VALUE, key, msg.clusterLevel);\n\n    if (isPublicKeyKey(key)) {\n      log('is public key');\n      const idFromKey = fromPublicKeyKey(key);\n      let pubKey;\n\n      try {\n        const key = await this.components.peerStore.keyBook.get(idFromKey);\n\n        if (key == null) {\n          throw new CodeError('No public key found in key book', 'ERR_NOT_FOUND');\n        }\n\n        pubKey = key;\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n      }\n\n      if (pubKey != null) {\n        log('returning found public key');\n        response.record = new Libp2pRecord(key, pubKey, new Date());\n        return response;\n      }\n    }\n\n    const [record, closer] = await Promise.all([this._checkLocalDatastore(key), this.peerRouting.getCloserPeersOffline(msg.key, peerId)]);\n\n    if (record != null) {\n      log('had record for %b in local datastore', key);\n      response.record = record;\n    }\n\n    if (closer.length > 0) {\n      log('had %s closer peers in routing table', closer.length);\n      response.closerPeers = closer;\n    }\n\n    return response;\n  }\n  /**\n   * Try to fetch a given record by from the local datastore.\n   * Returns the record if it is still valid, meaning\n   * - it was either authored by this node, or\n   * - it was received less than `MAX_RECORD_AGE` ago.\n   */\n\n\n  async _checkLocalDatastore(key) {\n    log('checkLocalDatastore looking for %b', key);\n    const dsKey = bufferToRecordKey(key); // Fetch value from ds\n\n    let rawRecord;\n\n    try {\n      rawRecord = await this.components.datastore.get(dsKey);\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        return undefined;\n      }\n\n      throw err;\n    } // Create record from the returned bytes\n\n\n    const record = Libp2pRecord.deserialize(rawRecord);\n\n    if (record == null) {\n      throw new CodeError('Invalid record', 'ERR_INVALID_RECORD');\n    } // Check validity: compare time received with max record age\n\n\n    if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {\n      // If record is bad delete it and return\n      await this.components.datastore.delete(dsKey);\n      return undefined;\n    } // Record is valid\n\n\n    return record;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Libp2pRecord","CodeError","Message","MESSAGE_TYPE","MAX_RECORD_AGE","bufferToRecordKey","isPublicKeyKey","fromPublicKeyKey","logger","log","GetValueHandler","constructor","components","init","peerRouting","handle","peerId","msg","key","length","response","GET_VALUE","clusterLevel","idFromKey","pubKey","peerStore","keyBook","get","err","code","record","Date","closer","Promise","all","_checkLocalDatastore","getCloserPeersOffline","closerPeers","dsKey","rawRecord","datastore","undefined","deserialize","timeReceived","now","getTime","delete"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\rpc\\handlers\\get-value.ts"],"sourcesContent":["import { Libp2pRecord } from '@libp2p/record'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { Message, MESSAGE_TYPE } from '../../message/index.js'\nimport {\n  MAX_RECORD_AGE\n} from '../../constants.js'\nimport { bufferToRecordKey, isPublicKeyKey, fromPublicKeyKey } from '../../utils.js'\nimport { logger } from '@libp2p/logger'\nimport type { DHTMessageHandler } from '../index.js'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { PeerRouting } from '../../peer-routing/index.js'\nimport type { PeerStore } from '@libp2p/interface-peer-store'\nimport type { Datastore } from 'interface-datastore'\n\nconst log = logger('libp2p:kad-dht:rpc:handlers:get-value')\n\nexport interface GetValueHandlerInit {\n  peerRouting: PeerRouting\n}\n\nexport interface GetValueHandlerComponents {\n  peerStore: PeerStore\n  datastore: Datastore\n}\n\nexport class GetValueHandler implements DHTMessageHandler {\n  private readonly components: GetValueHandlerComponents\n  private readonly peerRouting: PeerRouting\n\n  constructor (components: GetValueHandlerComponents, init: GetValueHandlerInit) {\n    const { peerRouting } = init\n\n    this.components = components\n    this.peerRouting = peerRouting\n  }\n\n  async handle (peerId: PeerId, msg: Message): Promise<Message> {\n    const key = msg.key\n\n    log('%p asked for key %b', peerId, key)\n\n    if (key == null || key.length === 0) {\n      throw new CodeError('Invalid key', 'ERR_INVALID_KEY')\n    }\n\n    const response = new Message(MESSAGE_TYPE.GET_VALUE, key, msg.clusterLevel)\n\n    if (isPublicKeyKey(key)) {\n      log('is public key')\n      const idFromKey = fromPublicKeyKey(key)\n      let pubKey: Uint8Array | undefined\n\n      try {\n        const key = await this.components.peerStore.keyBook.get(idFromKey)\n\n        if (key == null) {\n          throw new CodeError('No public key found in key book', 'ERR_NOT_FOUND')\n        }\n\n        pubKey = key\n      } catch (err: any) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n\n      if (pubKey != null) {\n        log('returning found public key')\n        response.record = new Libp2pRecord(key, pubKey, new Date())\n        return response\n      }\n    }\n\n    const [record, closer] = await Promise.all([\n      this._checkLocalDatastore(key),\n      this.peerRouting.getCloserPeersOffline(msg.key, peerId)\n    ])\n\n    if (record != null) {\n      log('had record for %b in local datastore', key)\n      response.record = record\n    }\n\n    if (closer.length > 0) {\n      log('had %s closer peers in routing table', closer.length)\n      response.closerPeers = closer\n    }\n\n    return response\n  }\n\n  /**\n   * Try to fetch a given record by from the local datastore.\n   * Returns the record if it is still valid, meaning\n   * - it was either authored by this node, or\n   * - it was received less than `MAX_RECORD_AGE` ago.\n   */\n  async _checkLocalDatastore (key: Uint8Array): Promise<Libp2pRecord | undefined> {\n    log('checkLocalDatastore looking for %b', key)\n    const dsKey = bufferToRecordKey(key)\n\n    // Fetch value from ds\n    let rawRecord\n    try {\n      rawRecord = await this.components.datastore.get(dsKey)\n    } catch (err: any) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        return undefined\n      }\n      throw err\n    }\n\n    // Create record from the returned bytes\n    const record = Libp2pRecord.deserialize(rawRecord)\n\n    if (record == null) {\n      throw new CodeError('Invalid record', 'ERR_INVALID_RECORD')\n    }\n\n    // Check validity: compare time received with max record age\n    if (record.timeReceived == null ||\n      Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {\n      // If record is bad delete it and return\n      await this.components.datastore.delete(dsKey)\n      return undefined\n    }\n\n    // Record is valid\n    return record\n  }\n}\n"]},"metadata":{},"sourceType":"module"}