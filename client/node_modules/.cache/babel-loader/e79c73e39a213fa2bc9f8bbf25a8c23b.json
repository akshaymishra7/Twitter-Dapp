{"ast":null,"code":"import { LongBits } from 'longbits';\nimport { allocUnsafe } from 'uint8arrays/alloc';\nconst N1 = Math.pow(2, 7);\nconst N2 = Math.pow(2, 14);\nconst N3 = Math.pow(2, 21);\nconst N4 = Math.pow(2, 28);\nconst N5 = Math.pow(2, 35);\nconst N6 = Math.pow(2, 42);\nconst N7 = Math.pow(2, 49);\nconst N8 = Math.pow(2, 56);\nconst N9 = Math.pow(2, 63);\nexport const unsigned = {\n  encodingLength(value) {\n    if (value < N1) {\n      return 1;\n    }\n\n    if (value < N2) {\n      return 2;\n    }\n\n    if (value < N3) {\n      return 3;\n    }\n\n    if (value < N4) {\n      return 4;\n    }\n\n    if (value < N5) {\n      return 5;\n    }\n\n    if (value < N6) {\n      return 6;\n    }\n\n    if (value < N7) {\n      return 7;\n    }\n\n    if (value < N8) {\n      return 8;\n    }\n\n    if (value < N9) {\n      return 9;\n    }\n\n    return 10;\n  },\n\n  encode(value, buf) {\n    let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError('Could not encode varint');\n    }\n\n    if (buf == null) {\n      buf = allocUnsafe(unsigned.encodingLength(value));\n    }\n\n    LongBits.fromNumber(value).toBytes(buf, offset);\n    return buf;\n  },\n\n  decode(buf) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return LongBits.fromBytes(buf, offset).toNumber(true);\n  }\n\n};\nexport const signed = {\n  encodingLength(value) {\n    if (value < 0) {\n      return 10; // 10 bytes per spec - https://developers.google.com/protocol-buffers/docs/encoding#signed-ints\n    }\n\n    return unsigned.encodingLength(value);\n  },\n\n  encode(value, buf, offset) {\n    if (buf == null) {\n      buf = allocUnsafe(signed.encodingLength(value));\n    }\n\n    if (value < 0) {\n      LongBits.fromNumber(value).toBytes(buf, offset);\n      return buf;\n    }\n\n    return unsigned.encode(value, buf, offset);\n  },\n\n  decode(buf) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return LongBits.fromBytes(buf, offset).toNumber(false);\n  }\n\n};\nexport const zigzag = {\n  encodingLength(value) {\n    return unsigned.encodingLength(value >= 0 ? value * 2 : value * -2 - 1);\n  },\n\n  // @ts-expect-error\n  encode(value, buf, offset) {\n    value = value >= 0 ? value * 2 : value * -2 - 1;\n    return unsigned.encode(value, buf, offset);\n  },\n\n  decode(buf) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const value = unsigned.decode(buf, offset);\n    return (value & 1) !== 0 ? (value + 1) / -2 : value / 2;\n  }\n\n};","map":{"version":3,"mappings":"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","names":["LongBits","allocUnsafe","N1","Math","pow","N2","N3","N4","N5","N6","N7","N8","N9","unsigned","encodingLength","value","encode","buf","offset","Number","MAX_SAFE_INTEGER","RangeError","fromNumber","toBytes","decode","fromBytes","toNumber","signed","zigzag"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\uint8-varint\\src\\index.ts"],"sourcesContent":["import type { Uint8ArrayList } from 'uint8arraylist'\nimport { LongBits } from 'longbits'\nimport { allocUnsafe } from 'uint8arrays/alloc'\n\nconst N1 = Math.pow(2, 7)\nconst N2 = Math.pow(2, 14)\nconst N3 = Math.pow(2, 21)\nconst N4 = Math.pow(2, 28)\nconst N5 = Math.pow(2, 35)\nconst N6 = Math.pow(2, 42)\nconst N7 = Math.pow(2, 49)\nconst N8 = Math.pow(2, 56)\nconst N9 = Math.pow(2, 63)\n\ninterface VarintCodec {\n  encodingLength: (value: number) => number\n  encode: ((value: number) => Uint8Array) & ((value: number, buf: Uint8Array, offset?: number) => Uint8Array) & ((value: number, buf: Uint8ArrayList, offset?: number) => Uint8ArrayList)\n  decode: (buf: Uint8ArrayList | Uint8Array, offset?: number) => number\n}\n\nexport const unsigned: VarintCodec = {\n  encodingLength  (value: number): number {\n    if (value < N1) {\n      return 1\n    }\n\n    if (value < N2) {\n      return 2\n    }\n\n    if (value < N3) {\n      return 3\n    }\n\n    if (value < N4) {\n      return 4\n    }\n\n    if (value < N5) {\n      return 5\n    }\n\n    if (value < N6) {\n      return 6\n    }\n\n    if (value < N7) {\n      return 7\n    }\n\n    if (value < N8) {\n      return 8\n    }\n\n    if (value < N9) {\n      return 9\n    }\n\n    return 10\n  },\n\n  encode (value: number, buf?: any, offset: number = 0) {\n    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError('Could not encode varint')\n    }\n\n    if (buf == null) {\n      buf = allocUnsafe(unsigned.encodingLength(value))\n    }\n\n    LongBits.fromNumber(value).toBytes(buf, offset)\n\n    return buf\n  },\n\n  decode (buf: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    return LongBits.fromBytes(buf, offset).toNumber(true)\n  }\n}\n\nexport const signed: VarintCodec = {\n  encodingLength (value: number): number {\n    if (value < 0) {\n      return 10 // 10 bytes per spec - https://developers.google.com/protocol-buffers/docs/encoding#signed-ints\n    }\n\n    return unsigned.encodingLength(value)\n  },\n\n  encode (value: any, buf?: any, offset?: any) {\n    if (buf == null) {\n      buf = allocUnsafe(signed.encodingLength(value))\n    }\n\n    if (value < 0) {\n      LongBits.fromNumber(value).toBytes(buf, offset)\n\n      return buf\n    }\n\n    return unsigned.encode(value, buf, offset)\n  },\n\n  decode (buf: Uint8ArrayList | Uint8Array, offset = 0): number {\n    return LongBits.fromBytes(buf, offset).toNumber(false)\n  }\n}\n\nexport const zigzag: VarintCodec = {\n  encodingLength (value: number): number {\n    return unsigned.encodingLength(value >= 0 ? value * 2 : value * -2 - 1)\n  },\n\n  // @ts-expect-error\n  encode (value: any, buf?: any, offset?: any) {\n    value = value >= 0 ? value * 2 : (value * -2) - 1\n\n    return unsigned.encode(value, buf, offset)\n  },\n\n  decode (buf: Uint8ArrayList | Uint8Array, offset = 0): number {\n    const value = unsigned.decode(buf, offset)\n\n    return (value & 1) !== 0 ? (value + 1) / -2 : value / 2\n  }\n}\n"]},"metadata":{},"sourceType":"module"}