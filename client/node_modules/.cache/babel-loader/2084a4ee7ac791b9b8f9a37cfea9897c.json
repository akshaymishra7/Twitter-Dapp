{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';\nimport errCode from 'err-code';\nimport randombytes from 'iso-random-stream/src/random.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { pushable } from 'it-pushable';\nimport defer from 'p-defer';\nimport { WebRTCDataChannel } from './channel.js';\nimport delay from 'delay'; // const ICECOMPLETE_TIMEOUT = 5 * 1000\n\nconst DEFAULT_PEER_CONNECTION_CONFIG = {\n  iceServers: [{\n    urls: ['stun:stun.l.google.com:19302', 'stun:global.stun.twilio.com:3478']\n  }]\n};\n\nfunction getBrowserRTC() {\n  if (typeof globalThis === 'undefined') {\n    throw errCode(new Error('No WebRTC support detected'), 'ERR_WEBRTC_SUPPORT');\n  }\n\n  const wrtc = {\n    // @ts-expect-error browser-specific properties\n    RTCPeerConnection: globalThis.RTCPeerConnection ?? globalThis.mozRTCPeerConnection ?? globalThis.webkitRTCPeerConnection,\n    // @ts-expect-error browser-specific properties\n    RTCSessionDescription: globalThis.RTCSessionDescription ?? globalThis.mozRTCSessionDescription ?? globalThis.webkitRTCSessionDescription,\n    // @ts-expect-error browser-specific properties\n    RTCIceCandidate: globalThis.RTCIceCandidate ?? globalThis.mozRTCIceCandidate ?? globalThis.webkitRTCIceCandidate\n  };\n\n  if (wrtc.RTCPeerConnection == null) {\n    throw errCode(new Error('No WebRTC support detected'), 'ERR_WEBRTC_SUPPORT');\n  }\n\n  return wrtc;\n}\n\nexport class WebRTCPeer extends EventEmitter {\n  constructor(opts) {\n    super();\n    this.id = opts.id ?? uint8ArrayToString(randombytes(4), 'hex').slice(0, 7);\n    this.log = logger(`libp2p:webrtc-peer:${opts.logPrefix}:${this.id}`);\n    this.wrtc = opts.wrtc ?? getBrowserRTC();\n    this.peerConnection = new this.wrtc.RTCPeerConnection(Object.assign({}, DEFAULT_PEER_CONNECTION_CONFIG, opts.peerConnectionConfig));\n    this.closed = false;\n    this.connected = defer(); // duplex properties\n\n    this.source = pushable();\n\n    this.sink = async source => {\n      await this.connected.promise;\n\n      if (this.channel == null) {\n        throw errCode(new Error('Connected but no channel?!'), 'ERR_DATA_CHANNEL');\n      }\n\n      for await (const buf of source) {\n        await this.channel.send(buf);\n      }\n\n      await this.close();\n    };\n  }\n\n  handleDataChannelEvent(event) {\n    const dataChannel = event.channel;\n\n    if (dataChannel == null) {\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n      // which is invalid behavior. Handle it gracefully.\n      // See: https://github.com/feross/simple-peer/issues/163\n      this.close(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL')).catch(err => {\n        this.log('Error closing after event channel was found to be null', err);\n      });\n      return;\n    }\n\n    this.channel = new WebRTCDataChannel(dataChannel, {\n      log: this.log,\n      onMessage: event => {\n        this.source.push(new Uint8Array(event.data));\n      },\n      onOpen: () => {\n        this.connected.resolve();\n        this.dispatchEvent(new CustomEvent('ready'));\n      },\n      onClose: () => {\n        this.close().catch(err => {\n          this.log('error closing connection after channel close', err);\n        });\n      },\n      onError: err => {\n        this.close(err).catch(err => {\n          this.log('error closing connection after channel error', err);\n        });\n      }\n    });\n  }\n\n  async close(err) {\n    this.closed = true;\n\n    if (err == null && this.channel != null) {\n      // wait for the channel to flush all data before closing the channel\n      while (this.channel.bufferedAmount > 0) {\n        await delay(100);\n      }\n    }\n\n    this.channel?.close();\n    this.peerConnection.close();\n    this.source.end(err);\n    this.dispatchEvent(new CustomEvent('close'));\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","EventEmitter","CustomEvent","errCode","randombytes","toString","uint8ArrayToString","pushable","defer","WebRTCDataChannel","delay","DEFAULT_PEER_CONNECTION_CONFIG","iceServers","urls","getBrowserRTC","globalThis","Error","wrtc","RTCPeerConnection","mozRTCPeerConnection","webkitRTCPeerConnection","RTCSessionDescription","mozRTCSessionDescription","webkitRTCSessionDescription","RTCIceCandidate","mozRTCIceCandidate","webkitRTCIceCandidate","WebRTCPeer","constructor","opts","id","slice","log","logPrefix","peerConnection","Object","assign","peerConnectionConfig","closed","connected","source","sink","promise","channel","buf","send","close","handleDataChannelEvent","event","dataChannel","catch","err","onMessage","push","Uint8Array","data","onOpen","resolve","dispatchEvent","onClose","onError","bufferedAmount","end"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\webrtc-peer\\src\\peer.ts"],"sourcesContent":["import { Logger, logger } from '@libp2p/logger'\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events'\nimport errCode from 'err-code'\nimport randombytes from 'iso-random-stream/src/random.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { Pushable, pushable } from 'it-pushable'\nimport defer, { DeferredPromise } from 'p-defer'\nimport { WebRTCDataChannel } from './channel.js'\nimport delay from 'delay'\nimport type { WebRTCPeerInit, WebRTCPeerEvents, WRTC } from './index.js'\nimport type { Duplex, Sink } from 'it-stream-types'\n\n// const ICECOMPLETE_TIMEOUT = 5 * 1000\n\nconst DEFAULT_PEER_CONNECTION_CONFIG: RTCConfiguration = {\n  iceServers: [{\n    urls: [\n      'stun:stun.l.google.com:19302',\n      'stun:global.stun.twilio.com:3478'\n    ]\n  }]\n}\n\nfunction getBrowserRTC (): WRTC {\n  if (typeof globalThis === 'undefined') {\n    throw errCode(new Error('No WebRTC support detected'), 'ERR_WEBRTC_SUPPORT')\n  }\n\n  const wrtc: WRTC = {\n    // @ts-expect-error browser-specific properties\n    RTCPeerConnection: globalThis.RTCPeerConnection ?? globalThis.mozRTCPeerConnection ?? globalThis.webkitRTCPeerConnection,\n    // @ts-expect-error browser-specific properties\n    RTCSessionDescription: globalThis.RTCSessionDescription ?? globalThis.mozRTCSessionDescription ?? globalThis.webkitRTCSessionDescription,\n    // @ts-expect-error browser-specific properties\n    RTCIceCandidate: globalThis.RTCIceCandidate ?? globalThis.mozRTCIceCandidate ?? globalThis.webkitRTCIceCandidate\n  }\n\n  if (wrtc.RTCPeerConnection == null) {\n    throw errCode(new Error('No WebRTC support detected'), 'ERR_WEBRTC_SUPPORT')\n  }\n\n  return wrtc\n}\n\nexport class WebRTCPeer extends EventEmitter<WebRTCPeerEvents> implements Duplex<Uint8Array> {\n  public id: string\n  public source: Pushable<Uint8Array>\n  public sink: Sink<Uint8Array>\n  public closed: boolean\n  protected wrtc: WRTC\n  protected peerConnection: RTCPeerConnection\n  protected channel?: WebRTCDataChannel\n  protected log: Logger\n  private readonly connected: DeferredPromise<void>\n\n  constructor (opts: WebRTCPeerInit & { logPrefix: string }) {\n    super()\n\n    this.id = opts.id ?? uint8ArrayToString(randombytes(4), 'hex').slice(0, 7)\n    this.log = logger(`libp2p:webrtc-peer:${opts.logPrefix}:${this.id}`)\n    this.wrtc = opts.wrtc ?? getBrowserRTC()\n    this.peerConnection = new this.wrtc.RTCPeerConnection(\n      Object.assign({}, DEFAULT_PEER_CONNECTION_CONFIG, opts.peerConnectionConfig)\n    )\n    this.closed = false\n    this.connected = defer()\n\n    // duplex properties\n    this.source = pushable()\n    this.sink = async (source) => {\n      await this.connected.promise\n\n      if (this.channel == null) {\n        throw errCode(new Error('Connected but no channel?!'), 'ERR_DATA_CHANNEL')\n      }\n\n      for await (const buf of source) {\n        await this.channel.send(buf)\n      }\n\n      await this.close()\n    }\n  }\n\n  protected handleDataChannelEvent (event: { channel?: RTCDataChannel}) {\n    const dataChannel = event.channel\n\n    if (dataChannel == null) {\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n      // which is invalid behavior. Handle it gracefully.\n      // See: https://github.com/feross/simple-peer/issues/163\n      this.close(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))\n        .catch(err => {\n          this.log('Error closing after event channel was found to be null', err)\n        })\n\n      return\n    }\n\n    this.channel = new WebRTCDataChannel(dataChannel, {\n      log: this.log,\n      onMessage: (event) => {\n        this.source.push(new Uint8Array(event.data))\n      },\n      onOpen: () => {\n        this.connected.resolve()\n        this.dispatchEvent(new CustomEvent('ready'))\n      },\n      onClose: () => {\n        this.close().catch(err => {\n          this.log('error closing connection after channel close', err)\n        })\n      },\n      onError: (err) => {\n        this.close(err).catch(err => {\n          this.log('error closing connection after channel error', err)\n        })\n      }\n    })\n  }\n\n  async close (err?: Error) {\n    this.closed = true\n\n    if (err == null && this.channel != null) {\n      // wait for the channel to flush all data before closing the channel\n      while (this.channel.bufferedAmount > 0) {\n        await delay(100)\n      }\n    }\n\n    this.channel?.close()\n    this.peerConnection.close()\n    this.source.end(err)\n    this.dispatchEvent(new CustomEvent('close'))\n  }\n}\n"]},"metadata":{},"sourceType":"module"}