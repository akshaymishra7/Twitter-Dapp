{"ast":null,"code":"import varint from 'varint';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { allocUnsafe } from './alloc-unsafe.js';\nimport { MessageTypes } from './message-types.js';\nimport batchedBytes from 'it-batched-bytes';\nconst POOL_SIZE = 10 * 1024;\n\nclass Encoder {\n  constructor() {\n    this._pool = allocUnsafe(POOL_SIZE);\n    this._poolOffset = 0;\n  }\n  /**\n   * Encodes the given message and adds it to the passed list\n   */\n\n\n  write(msg, list) {\n    const pool = this._pool;\n    let offset = this._poolOffset;\n    varint.encode(msg.id << 3 | msg.type, pool, offset);\n    offset += varint.encode.bytes ?? 0;\n\n    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {\n      varint.encode(msg.data.length, pool, offset);\n    } else {\n      varint.encode(0, pool, offset);\n    }\n\n    offset += varint.encode.bytes ?? 0;\n    const header = pool.subarray(this._poolOffset, offset);\n\n    if (POOL_SIZE - offset < 100) {\n      this._pool = allocUnsafe(POOL_SIZE);\n      this._poolOffset = 0;\n    } else {\n      this._poolOffset = offset;\n    }\n\n    list.append(header);\n\n    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {\n      list.append(msg.data);\n    }\n  }\n\n}\n\nconst encoder = new Encoder();\n/**\n * Encode and yield one or more messages\n */\n\nexport async function* encode(source) {\n  let minSendBytes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  if (minSendBytes == null || minSendBytes === 0) {\n    // just send the messages\n    for await (const messages of source) {\n      const list = new Uint8ArrayList();\n\n      for (const msg of messages) {\n        encoder.write(msg, list);\n      }\n\n      yield list.subarray();\n    }\n\n    return;\n  } // batch messages up for sending\n\n\n  yield* batchedBytes(source, {\n    size: minSendBytes,\n    serialize: (obj, list) => {\n      for (const m of obj) {\n        encoder.write(m, list);\n      }\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["varint","Uint8ArrayList","allocUnsafe","MessageTypes","batchedBytes","POOL_SIZE","Encoder","constructor","_pool","_poolOffset","write","msg","list","pool","offset","encode","id","type","bytes","NEW_STREAM","MESSAGE_INITIATOR","MESSAGE_RECEIVER","data","length","header","subarray","append","encoder","source","minSendBytes","messages","size","serialize","obj","m"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\mplex\\src\\encode.ts"],"sourcesContent":["import type { Source } from 'it-stream-types'\nimport varint from 'varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { allocUnsafe } from './alloc-unsafe.js'\nimport { Message, MessageTypes } from './message-types.js'\nimport batchedBytes from 'it-batched-bytes'\n\nconst POOL_SIZE = 10 * 1024\n\nclass Encoder {\n  private _pool: Uint8Array\n  private _poolOffset: number\n\n  constructor () {\n    this._pool = allocUnsafe(POOL_SIZE)\n    this._poolOffset = 0\n  }\n\n  /**\n   * Encodes the given message and adds it to the passed list\n   */\n  write (msg: Message, list: Uint8ArrayList): void {\n    const pool = this._pool\n    let offset = this._poolOffset\n\n    varint.encode(msg.id << 3 | msg.type, pool, offset)\n    offset += varint.encode.bytes ?? 0\n\n    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {\n      varint.encode(msg.data.length, pool, offset)\n    } else {\n      varint.encode(0, pool, offset)\n    }\n\n    offset += varint.encode.bytes ?? 0\n\n    const header = pool.subarray(this._poolOffset, offset)\n\n    if (POOL_SIZE - offset < 100) {\n      this._pool = allocUnsafe(POOL_SIZE)\n      this._poolOffset = 0\n    } else {\n      this._poolOffset = offset\n    }\n\n    list.append(header)\n\n    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {\n      list.append(msg.data)\n    }\n  }\n}\n\nconst encoder = new Encoder()\n\n/**\n * Encode and yield one or more messages\n */\nexport async function * encode (source: Source<Message[]>, minSendBytes: number = 0): AsyncGenerator<Uint8Array, void, undefined> {\n  if (minSendBytes == null || minSendBytes === 0) {\n    // just send the messages\n    for await (const messages of source) {\n      const list = new Uint8ArrayList()\n\n      for (const msg of messages) {\n        encoder.write(msg, list)\n      }\n\n      yield list.subarray()\n    }\n\n    return\n  }\n\n  // batch messages up for sending\n  yield * batchedBytes(source, {\n    size: minSendBytes,\n    serialize: (obj, list) => {\n      for (const m of obj) {\n        encoder.write(m, list)\n      }\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"module"}