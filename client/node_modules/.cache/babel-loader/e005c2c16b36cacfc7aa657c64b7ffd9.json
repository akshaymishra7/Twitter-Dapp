{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;\n\nimport EventEmitter from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nThe error thrown by `queue.add()` when a job is aborted before it is run. See `signal`.\n*/\n\nexport class AbortError extends Error {}\n/**\nPromise queue with concurrency control.\n*/\n\nexport default class PQueue extends EventEmitter {\n  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n  constructor(options) {\n    var _a, _b, _c, _d;\n\n    super();\n\n    _PQueue_instances.add(this);\n\n    _PQueue_carryoverConcurrencyCount.set(this, void 0);\n\n    _PQueue_isIntervalIgnored.set(this, void 0);\n\n    _PQueue_intervalCount.set(this, 0);\n\n    _PQueue_intervalCap.set(this, void 0);\n\n    _PQueue_interval.set(this, void 0);\n\n    _PQueue_intervalEnd.set(this, 0);\n\n    _PQueue_intervalId.set(this, void 0);\n\n    _PQueue_timeoutId.set(this, void 0);\n\n    _PQueue_queue.set(this, void 0);\n\n    _PQueue_queueClass.set(this, void 0);\n\n    _PQueue_pending.set(this, 0); // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n\n\n    _PQueue_concurrency.set(this, void 0);\n\n    _PQueue_isPaused.set(this, void 0);\n\n    _PQueue_throwOnTimeout.set(this, void 0);\n    /**\n    Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n         Applies to each future operation.\n    */\n\n\n    Object.defineProperty(this, \"timeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    }); // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\n    options = {\n      carryoverConcurrencyCount: false,\n      intervalCap: Number.POSITIVE_INFINITY,\n      interval: 0,\n      concurrency: Number.POSITIVE_INFINITY,\n      autoStart: true,\n      queueClass: PriorityQueue,\n      ...options\n    };\n\n    if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n      throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n    }\n\n    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n      throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n    }\n\n    __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, \"f\");\n\n    __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, \"f\");\n\n    __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, \"f\");\n\n    __classPrivateFieldSet(this, _PQueue_interval, options.interval, \"f\");\n\n    __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), \"f\");\n\n    __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, \"f\");\n\n    this.concurrency = options.concurrency;\n    this.timeout = options.timeout;\n\n    __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, \"f\");\n\n    __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, \"f\");\n  }\n\n  get concurrency() {\n    return __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n  }\n\n  set concurrency(newConcurrency) {\n    if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n      throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n    }\n\n    __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, \"f\");\n\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n  }\n\n  async add(function_) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options = {\n      timeout: this.timeout,\n      throwOnTimeout: __classPrivateFieldGet(this, _PQueue_throwOnTimeout, \"f\"),\n      ...options\n    };\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldGet(this, _PQueue_queue, \"f\").enqueue(async () => {\n        var _a;\n\n        var _b, _c;\n\n        __classPrivateFieldSet(this, _PQueue_pending, (_b = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _b++, _b), \"f\");\n\n        __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\"), _c++, _c), \"f\");\n\n        try {\n          // TODO: Use options.signal?.throwIfAborted() when targeting Node.js 18\n          if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n            // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n            throw new AbortError('The task was aborted.');\n          }\n\n          let operation = function_({\n            signal: options.signal\n          });\n\n          if (options.timeout) {\n            operation = pTimeout(Promise.resolve(operation), options.timeout);\n          }\n\n          if (options.signal) {\n            operation = Promise.race([operation, __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_throwOnAbort).call(this, options.signal)]);\n          }\n\n          const result = await operation;\n          resolve(result);\n          this.emit('completed', result);\n        } catch (error) {\n          if (error instanceof TimeoutError && !options.throwOnTimeout) {\n            resolve();\n            return;\n          }\n\n          reject(error);\n          this.emit('error', error);\n        } finally {\n          __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_next).call(this);\n        }\n      }, options);\n\n      this.emit('add');\n\n      __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n    });\n  }\n\n  async addAll(functions, options) {\n    return Promise.all(functions.map(async function_ => this.add(function_, options)));\n  }\n  /**\n  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n  */\n\n\n  start() {\n    if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n      return this;\n    }\n\n    __classPrivateFieldSet(this, _PQueue_isPaused, false, \"f\");\n\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n\n    return this;\n  }\n  /**\n  Put queue execution on hold.\n  */\n\n\n  pause() {\n    __classPrivateFieldSet(this, _PQueue_isPaused, true, \"f\");\n  }\n  /**\n  Clear the queue.\n  */\n\n\n  clear() {\n    __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, \"f\"))(), \"f\");\n  }\n  /**\n  Can be called multiple times. Useful if you for example add additional items at a later time.\n   @returns A promise that settles when the queue becomes empty.\n  */\n\n\n  async onEmpty() {\n    // Instantly resolve if the queue is empty\n    if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n      return;\n    }\n\n    await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'empty');\n  }\n  /**\n  @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n   If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n   Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n  */\n\n\n  async onSizeLessThan(limit) {\n    // Instantly resolve if the queue is empty.\n    if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit) {\n      return;\n    }\n\n    await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'next', () => __classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit);\n  }\n  /**\n  The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n   @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n  */\n\n\n  async onIdle() {\n    // Instantly resolve if none pending and if nothing else is queued\n    if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n      return;\n    }\n\n    await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'idle');\n  }\n  /**\n  Size of the queue, the number of queued items waiting to run.\n  */\n\n\n  get size() {\n    return __classPrivateFieldGet(this, _PQueue_queue, \"f\").size;\n  }\n  /**\n  Size of the queue, filtered by the given options.\n   For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n  */\n\n\n  sizeBy(options) {\n    // eslint-disable-next-line unicorn/no-array-callback-reference\n    return __classPrivateFieldGet(this, _PQueue_queue, \"f\").filter(options).length;\n  }\n  /**\n  Number of running items (no longer in the queue).\n  */\n\n\n  get pending() {\n    return __classPrivateFieldGet(this, _PQueue_pending, \"f\");\n  }\n  /**\n  Whether the queue is currently paused.\n  */\n\n\n  get isPaused() {\n    return __classPrivateFieldGet(this, _PQueue_isPaused, \"f\");\n  }\n\n}\n_PQueue_carryoverConcurrencyCount = new WeakMap(), _PQueue_isIntervalIgnored = new WeakMap(), _PQueue_intervalCount = new WeakMap(), _PQueue_intervalCap = new WeakMap(), _PQueue_interval = new WeakMap(), _PQueue_intervalEnd = new WeakMap(), _PQueue_intervalId = new WeakMap(), _PQueue_timeoutId = new WeakMap(), _PQueue_queue = new WeakMap(), _PQueue_queueClass = new WeakMap(), _PQueue_pending = new WeakMap(), _PQueue_concurrency = new WeakMap(), _PQueue_isPaused = new WeakMap(), _PQueue_throwOnTimeout = new WeakMap(), _PQueue_instances = new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get() {\n  return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") < __classPrivateFieldGet(this, _PQueue_intervalCap, \"f\");\n}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get() {\n  return __classPrivateFieldGet(this, _PQueue_pending, \"f\") < __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n}, _PQueue_next = function _PQueue_next() {\n  var _a;\n\n  __classPrivateFieldSet(this, _PQueue_pending, (_a = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _a--, _a), \"f\");\n\n  __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n\n  this.emit('next');\n}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval() {\n  __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n\n  __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n\n  __classPrivateFieldSet(this, _PQueue_timeoutId, undefined, \"f\");\n}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get() {\n  const now = Date.now();\n\n  if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\") === undefined) {\n    const delay = __classPrivateFieldGet(this, _PQueue_intervalEnd, \"f\") - now;\n\n    if (delay < 0) {\n      // Act as the interval was done\n      // We don't need to resume it here because it will be resumed on line 160\n      __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\") ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n    } else {\n      // Act as the interval is pending\n      if (__classPrivateFieldGet(this, _PQueue_timeoutId, \"f\") === undefined) {\n        __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {\n          __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onResumeInterval).call(this);\n        }, delay), \"f\");\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother() {\n  if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n    // We can clear the interval (\"pause\")\n    // Because we can redo it later (\"resume\")\n    if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n      clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n    }\n\n    __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n\n    this.emit('empty');\n\n    if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0) {\n      this.emit('idle');\n    }\n\n    return false;\n  }\n\n  if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n    const canInitializeInterval = !__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_isIntervalPaused_get);\n\n    if (__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesConcurrentAllowAnother_get)) {\n      const job = __classPrivateFieldGet(this, _PQueue_queue, \"f\").dequeue();\n\n      if (!job) {\n        return false;\n      }\n\n      this.emit('active');\n      job();\n\n      if (canInitializeInterval) {\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded() {\n  if (__classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalId, \"f\") !== undefined) {\n    return;\n  }\n\n  __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n  }, __classPrivateFieldGet(this, _PQueue_interval, \"f\")), \"f\");\n\n  __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, \"f\"), \"f\");\n}, _PQueue_onInterval = function _PQueue_onInterval() {\n  if (__classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n    clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n\n    __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n  }\n\n  __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\") ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n\n  __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n}, _PQueue_processQueue = function _PQueue_processQueue() {\n  // eslint-disable-next-line no-empty\n  while (__classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this)) {}\n}, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort(signal) {\n  return new Promise((_resolve, reject) => {\n    signal.addEventListener('abort', () => {\n      // TODO: Reject with signal.throwIfAborted() when targeting Node.js 18\n      // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n      reject(new AbortError('The task was aborted.'));\n    }, {\n      once: true\n    });\n  });\n}, _PQueue_onEvent = async function _PQueue_onEvent(event, filter) {\n  return new Promise(resolve => {\n    const listener = () => {\n      if (filter && !filter()) {\n        return;\n      }\n\n      this.off(event, listener);\n      resolve();\n    };\n\n    this.on(event, listener);\n  });\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/p-queue/dist/index.js"],"names":["__classPrivateFieldSet","receiver","state","value","kind","f","TypeError","has","call","set","__classPrivateFieldGet","get","_PQueue_instances","_PQueue_carryoverConcurrencyCount","_PQueue_isIntervalIgnored","_PQueue_intervalCount","_PQueue_intervalCap","_PQueue_interval","_PQueue_intervalEnd","_PQueue_intervalId","_PQueue_timeoutId","_PQueue_queue","_PQueue_queueClass","_PQueue_pending","_PQueue_concurrency","_PQueue_isPaused","_PQueue_throwOnTimeout","_PQueue_doesIntervalAllowAnother_get","_PQueue_doesConcurrentAllowAnother_get","_PQueue_next","_PQueue_onResumeInterval","_PQueue_isIntervalPaused_get","_PQueue_tryToStartAnother","_PQueue_initializeIntervalIfNeeded","_PQueue_onInterval","_PQueue_processQueue","_PQueue_throwOnAbort","_PQueue_onEvent","EventEmitter","pTimeout","TimeoutError","PriorityQueue","AbortError","Error","PQueue","constructor","options","_a","_b","_c","_d","add","Object","defineProperty","enumerable","configurable","writable","carryoverConcurrencyCount","intervalCap","Number","POSITIVE_INFINITY","interval","concurrency","autoStart","queueClass","toString","undefined","isFinite","timeout","throwOnTimeout","newConcurrency","function_","Promise","resolve","reject","enqueue","signal","aborted","operation","race","result","emit","error","addAll","functions","all","map","start","pause","clear","onEmpty","size","onSizeLessThan","limit","onIdle","sizeBy","filter","length","pending","isPaused","WeakMap","WeakSet","now","Date","delay","setTimeout","clearInterval","canInitializeInterval","job","dequeue","setInterval","_resolve","addEventListener","once","event","listener","off","on"],"mappings":"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","sourcesContent":["var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;\nimport EventEmitter from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nThe error thrown by `queue.add()` when a job is aborted before it is run. See `signal`.\n*/\nexport class AbortError extends Error {\n}\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        _PQueue_instances.add(this);\n        _PQueue_carryoverConcurrencyCount.set(this, void 0);\n        _PQueue_isIntervalIgnored.set(this, void 0);\n        _PQueue_intervalCount.set(this, 0);\n        _PQueue_intervalCap.set(this, void 0);\n        _PQueue_interval.set(this, void 0);\n        _PQueue_intervalEnd.set(this, 0);\n        _PQueue_intervalId.set(this, void 0);\n        _PQueue_timeoutId.set(this, void 0);\n        _PQueue_queue.set(this, void 0);\n        _PQueue_queueClass.set(this, void 0);\n        _PQueue_pending.set(this, 0);\n        // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n        _PQueue_concurrency.set(this, void 0);\n        _PQueue_isPaused.set(this, void 0);\n        _PQueue_throwOnTimeout.set(this, void 0);\n        /**\n        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n    \n        Applies to each future operation.\n        */\n        Object.defineProperty(this, \"timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, \"f\");\n        __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, \"f\");\n        __classPrivateFieldSet(this, _PQueue_interval, options.interval, \"f\");\n        __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), \"f\");\n        __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, \"f\");\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, \"f\");\n    }\n    get concurrency() {\n        return __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n    }\n    async add(function_, options = {}) {\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: __classPrivateFieldGet(this, _PQueue_throwOnTimeout, \"f\"),\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldGet(this, _PQueue_queue, \"f\").enqueue(async () => {\n                var _a;\n                var _b, _c;\n                __classPrivateFieldSet(this, _PQueue_pending, (_b = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _b++, _b), \"f\");\n                __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\"), _c++, _c), \"f\");\n                try {\n                    // TODO: Use options.signal?.throwIfAborted() when targeting Node.js 18\n                    if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                        // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n                        throw new AbortError('The task was aborted.');\n                    }\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), options.timeout);\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_throwOnAbort).call(this, options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_next).call(this);\n                }\n            }, options);\n            this.emit('add');\n            __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n            return this;\n        }\n        __classPrivateFieldSet(this, _PQueue_isPaused, false, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        __classPrivateFieldSet(this, _PQueue_isPaused, true, \"f\");\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, \"f\"))(), \"f\");\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'next', () => __classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'idle');\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return __classPrivateFieldGet(this, _PQueue_pending, \"f\");\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return __classPrivateFieldGet(this, _PQueue_isPaused, \"f\");\n    }\n}\n_PQueue_carryoverConcurrencyCount = new WeakMap(), _PQueue_isIntervalIgnored = new WeakMap(), _PQueue_intervalCount = new WeakMap(), _PQueue_intervalCap = new WeakMap(), _PQueue_interval = new WeakMap(), _PQueue_intervalEnd = new WeakMap(), _PQueue_intervalId = new WeakMap(), _PQueue_timeoutId = new WeakMap(), _PQueue_queue = new WeakMap(), _PQueue_queueClass = new WeakMap(), _PQueue_pending = new WeakMap(), _PQueue_concurrency = new WeakMap(), _PQueue_isPaused = new WeakMap(), _PQueue_throwOnTimeout = new WeakMap(), _PQueue_instances = new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") < __classPrivateFieldGet(this, _PQueue_intervalCap, \"f\");\n}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_pending, \"f\") < __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n}, _PQueue_next = function _PQueue_next() {\n    var _a;\n    __classPrivateFieldSet(this, _PQueue_pending, (_a = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _a--, _a), \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n    this.emit('next');\n}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval() {\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n    __classPrivateFieldSet(this, _PQueue_timeoutId, undefined, \"f\");\n}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get() {\n    const now = Date.now();\n    if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\") === undefined) {\n        const delay = __classPrivateFieldGet(this, _PQueue_intervalEnd, \"f\") - now;\n        if (delay < 0) {\n            // Act as the interval was done\n            // We don't need to resume it here because it will be resumed on line 160\n            __classPrivateFieldSet(this, _PQueue_intervalCount, (__classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\")) ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n        }\n        else {\n            // Act as the interval is pending\n            if (__classPrivateFieldGet(this, _PQueue_timeoutId, \"f\") === undefined) {\n                __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onResumeInterval).call(this);\n                }, delay), \"f\");\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother() {\n    if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n        // We can clear the interval (\"pause\")\n        // Because we can redo it later (\"resume\")\n        if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n            clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        }\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n        this.emit('empty');\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0) {\n            this.emit('idle');\n        }\n        return false;\n    }\n    if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n        const canInitializeInterval = !__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_isIntervalPaused_get);\n        if (__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesConcurrentAllowAnother_get)) {\n            const job = __classPrivateFieldGet(this, _PQueue_queue, \"f\").dequeue();\n            if (!job) {\n                return false;\n            }\n            this.emit('active');\n            job();\n            if (canInitializeInterval) {\n                __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded() {\n    if (__classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalId, \"f\") !== undefined) {\n        return;\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    }, __classPrivateFieldGet(this, _PQueue_interval, \"f\")), \"f\");\n    __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, \"f\"), \"f\");\n}, _PQueue_onInterval = function _PQueue_onInterval() {\n    if (__classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n        clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\") ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n}, _PQueue_processQueue = function _PQueue_processQueue() {\n    // eslint-disable-next-line no-empty\n    while (__classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this)) { }\n}, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort(signal) {\n    return new Promise((_resolve, reject) => {\n        signal.addEventListener('abort', () => {\n            // TODO: Reject with signal.throwIfAborted() when targeting Node.js 18\n            // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n            reject(new AbortError('The task was aborted.'));\n        }, { once: true });\n    });\n}, _PQueue_onEvent = async function _PQueue_onEvent(event, filter) {\n    return new Promise(resolve => {\n        const listener = () => {\n            if (filter && !filter()) {\n                return;\n            }\n            this.off(event, listener);\n            resolve();\n        };\n        this.on(event, listener);\n    });\n};\n"]},"metadata":{},"sourceType":"module"}