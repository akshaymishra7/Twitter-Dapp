{"ast":null,"code":"import errCode from 'err-code';\nimport { CID } from 'multiformats/cid';\nimport resolve from './resolvers/index.js';\nimport last from 'it-last';\n/**\n * @typedef {import('ipfs-unixfs').UnixFS} UnixFS\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').ExporterOptions} ExporterOptions\n * @typedef {import('./types').UnixFSFile} UnixFSFile\n * @typedef {import('./types').UnixFSDirectory} UnixFSDirectory\n * @typedef {import('./types').ObjectNode} ObjectNode\n * @typedef {import('./types').RawNode} RawNode\n * @typedef {import('./types').IdentityNode} IdentityNode\n * @typedef {import('./types').UnixFSEntry} UnixFSEntry\n */\n\nconst toPathComponents = function () {\n  let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  // split on / unless escaped with \\\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\n/**\n * @param {string|Uint8Array|CID} path\n */\n\n\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    };\n  }\n\n  const cid = CID.asCID(path);\n\n  if (cid) {\n    return {\n      cid,\n      toResolve: []\n    };\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n\n    const output = toPathComponents(path);\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH');\n};\n/**\n * @param {string | CID} path\n * @param {Blockstore} blockstore\n * @param {ExporterOptions} [options]\n */\n\n\nexport async function* walkPath(path, blockstore) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path);\n  let name = cid.toString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n    }\n\n    if (result.entry) {\n      yield result.entry;\n    }\n\n    if (!result.next) {\n      return;\n    } // resolve further parts\n\n\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n}\n/**\n * @param {string | CID} path\n * @param {Blockstore} blockstore\n * @param {ExporterOptions} [options]\n */\n\nexport async function exporter(path, blockstore) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const result = await last(walkPath(path, blockstore, options));\n\n  if (!result) {\n    throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n  }\n\n  return result;\n}\n/**\n * @param {string | CID} path\n * @param {Blockstore} blockstore\n * @param {ExporterOptions} [options]\n */\n\nexport async function* recursive(path, blockstore) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const node = await exporter(path, blockstore, options);\n\n  if (!node) {\n    return;\n  }\n\n  yield node;\n\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n  /**\n   * @param {UnixFSDirectory} node\n   * @param {ExporterOptions} options\n   * @returns {AsyncGenerator<UnixFSEntry, void, any>}\n   */\n\n\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n\n      if (file instanceof Uint8Array) {\n        continue;\n      }\n\n      if (file.type === 'directory') {\n        yield* recurse(file, options);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-unixfs-exporter/src/index.js"],"names":["errCode","CID","resolve","last","toPathComponents","path","trim","match","filter","Boolean","cidAndRest","Uint8Array","cid","decode","toResolve","asCID","indexOf","substring","output","parse","slice","Error","walkPath","blockstore","options","name","toString","entryPath","startingDepth","length","result","entry","next","exporter","recursive","node","type","child","recurse","file","content"],"mappings":"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","sourcesContent":["import errCode from 'err-code'\nimport { CID } from 'multiformats/cid'\nimport resolve from './resolvers/index.js'\nimport last from 'it-last'\n\n/**\n * @typedef {import('ipfs-unixfs').UnixFS} UnixFS\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').ExporterOptions} ExporterOptions\n * @typedef {import('./types').UnixFSFile} UnixFSFile\n * @typedef {import('./types').UnixFSDirectory} UnixFSDirectory\n * @typedef {import('./types').ObjectNode} ObjectNode\n * @typedef {import('./types').RawNode} RawNode\n * @typedef {import('./types').IdentityNode} IdentityNode\n * @typedef {import('./types').UnixFSEntry} UnixFSEntry\n */\n\nconst toPathComponents = (path = '') => {\n  // split on / unless escaped with \\\n  return (path\n    .trim()\n    .match(/([^\\\\^/]|\\\\\\/)+/g) || [])\n    .filter(Boolean)\n}\n\n/**\n * @param {string|Uint8Array|CID} path\n */\nconst cidAndRest = (path) => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    }\n  }\n\n  const cid = CID.asCID(path)\n  if (cid) {\n    return {\n      cid,\n      toResolve: []\n    }\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6)\n    }\n\n    const output = toPathComponents(path)\n\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    }\n  }\n\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH')\n}\n\n/**\n * @param {string | CID} path\n * @param {Blockstore} blockstore\n * @param {ExporterOptions} [options]\n */\nexport async function * walkPath (path, blockstore, options = {}) {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path)\n  let name = cid.toString()\n  let entryPath = name\n  const startingDepth = toResolve.length\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options)\n\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND')\n    }\n\n    if (result.entry) {\n      yield result.entry\n    }\n\n    if (!result.next) {\n      return\n    }\n\n    // resolve further parts\n    toResolve = result.next.toResolve\n    cid = result.next.cid\n    name = result.next.name\n    entryPath = result.next.path\n  }\n}\n\n/**\n * @param {string | CID} path\n * @param {Blockstore} blockstore\n * @param {ExporterOptions} [options]\n */\nexport async function exporter (path, blockstore, options = {}) {\n  const result = await last(walkPath(path, blockstore, options))\n\n  if (!result) {\n    throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND')\n  }\n\n  return result\n}\n\n/**\n * @param {string | CID} path\n * @param {Blockstore} blockstore\n * @param {ExporterOptions} [options]\n */\nexport async function * recursive (path, blockstore, options = {}) {\n  const node = await exporter(path, blockstore, options)\n\n  if (!node) {\n    return\n  }\n\n  yield node\n\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child\n    }\n  }\n\n  /**\n   * @param {UnixFSDirectory} node\n   * @param {ExporterOptions} options\n   * @returns {AsyncGenerator<UnixFSEntry, void, any>}\n   */\n  async function * recurse (node, options) {\n    for await (const file of node.content(options)) {\n      yield file\n\n      if (file instanceof Uint8Array) {\n        continue\n      }\n\n      if (file.type === 'directory') {\n        yield * recurse(file, options)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}