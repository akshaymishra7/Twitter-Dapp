{"ast":null,"code":"import protobuf from 'protobufjs/minimal.js';\nexport const defaultDecodeRpcLimits = {\n  maxSubscriptions: Infinity,\n  maxMessages: Infinity,\n  maxIhaveMessageIDs: Infinity,\n  maxIwantMessageIDs: Infinity,\n  maxControlMessages: Infinity,\n  maxPeerInfos: Infinity\n};\n/**\n * Copied code from src/message/rpc.cjs but with decode limits to prevent OOM attacks\n */\n\nexport function decodeRpc(bytes, opts) {\n  // Mutate to use the option as stateful counter. Must limit the total count of messageIDs across all IWANT, IHAVE\n  // else one count put 100 messageIDs into each 100 IWANT and \"get around\" the limit\n  opts = { ...opts\n  };\n  const r = protobuf.Reader.create(bytes);\n  const l = bytes.length;\n  const c = l === undefined ? r.len : r.pos + l;\n  const m = {};\n\n  while (r.pos < c) {\n    const t = r.uint32();\n\n    switch (t >>> 3) {\n      case 1:\n        if (!(m.subscriptions && m.subscriptions.length)) m.subscriptions = [];\n        if (m.subscriptions.length < opts.maxSubscriptions) m.subscriptions.push(decodeSubOpts(r, r.uint32()));else r.skipType(t & 7);\n        break;\n\n      case 2:\n        if (!(m.messages && m.messages.length)) m.messages = [];\n        if (m.messages.length < opts.maxMessages) m.messages.push(decodeMessage(r, r.uint32()));else r.skipType(t & 7);\n        break;\n\n      case 3:\n        m.control = decodeControlMessage(r, r.uint32(), opts);\n        break;\n\n      default:\n        r.skipType(t & 7);\n        break;\n    }\n  }\n\n  return m;\n}\n\nfunction decodeSubOpts(r, l) {\n  const c = l === undefined ? r.len : r.pos + l;\n  const m = {};\n\n  while (r.pos < c) {\n    const t = r.uint32();\n\n    switch (t >>> 3) {\n      case 1:\n        m.subscribe = r.bool();\n        break;\n\n      case 2:\n        m.topic = r.string();\n        break;\n\n      default:\n        r.skipType(t & 7);\n        break;\n    }\n  }\n\n  return m;\n}\n\nfunction decodeMessage(r, l) {\n  const c = l === undefined ? r.len : r.pos + l;\n  const m = {};\n\n  while (r.pos < c) {\n    const t = r.uint32();\n\n    switch (t >>> 3) {\n      case 1:\n        m.from = r.bytes();\n        break;\n\n      case 2:\n        m.data = r.bytes();\n        break;\n\n      case 3:\n        m.seqno = r.bytes();\n        break;\n\n      case 4:\n        m.topic = r.string();\n        break;\n\n      case 5:\n        m.signature = r.bytes();\n        break;\n\n      case 6:\n        m.key = r.bytes();\n        break;\n\n      default:\n        r.skipType(t & 7);\n        break;\n    }\n  }\n\n  if (!m.topic) throw Error(\"missing required 'topic'\");\n  return m;\n}\n\nfunction decodeControlMessage(r, l, opts) {\n  const c = l === undefined ? r.len : r.pos + l;\n  const m = {};\n\n  while (r.pos < c) {\n    const t = r.uint32();\n\n    switch (t >>> 3) {\n      case 1:\n        if (!(m.ihave && m.ihave.length)) m.ihave = [];\n        if (m.ihave.length < opts.maxControlMessages) m.ihave.push(decodeControlIHave(r, r.uint32(), opts));else r.skipType(t & 7);\n        break;\n\n      case 2:\n        if (!(m.iwant && m.iwant.length)) m.iwant = [];\n        if (m.iwant.length < opts.maxControlMessages) m.iwant.push(decodeControlIWant(r, r.uint32(), opts));else r.skipType(t & 7);\n        break;\n\n      case 3:\n        if (!(m.graft && m.graft.length)) m.graft = [];\n        if (m.graft.length < opts.maxControlMessages) m.graft.push(decodeControlGraft(r, r.uint32()));else r.skipType(t & 7);\n        break;\n\n      case 4:\n        if (!(m.prune && m.prune.length)) m.prune = [];\n        if (m.prune.length < opts.maxControlMessages) m.prune.push(decodeControlPrune(r, r.uint32(), opts));else r.skipType(t & 7);\n        break;\n\n      default:\n        r.skipType(t & 7);\n        break;\n    }\n  }\n\n  return m;\n}\n\nfunction decodeControlIHave(r, l, opts) {\n  const c = l === undefined ? r.len : r.pos + l;\n  const m = {};\n\n  while (r.pos < c) {\n    const t = r.uint32();\n\n    switch (t >>> 3) {\n      case 1:\n        m.topicID = r.string();\n        break;\n\n      case 2:\n        if (!(m.messageIDs && m.messageIDs.length)) m.messageIDs = [];\n        if (opts.maxIhaveMessageIDs-- > 0) m.messageIDs.push(r.bytes());else r.skipType(t & 7);\n        break;\n\n      default:\n        r.skipType(t & 7);\n        break;\n    }\n  }\n\n  return m;\n}\n\nfunction decodeControlIWant(r, l, opts) {\n  const c = l === undefined ? r.len : r.pos + l;\n  const m = {};\n\n  while (r.pos < c) {\n    const t = r.uint32();\n\n    switch (t >>> 3) {\n      case 1:\n        if (!(m.messageIDs && m.messageIDs.length)) m.messageIDs = [];\n        if (opts.maxIwantMessageIDs-- > 0) m.messageIDs.push(r.bytes());else r.skipType(t & 7);\n        break;\n\n      default:\n        r.skipType(t & 7);\n        break;\n    }\n  }\n\n  return m;\n}\n\nfunction decodeControlGraft(r, l) {\n  const c = l === undefined ? r.len : r.pos + l;\n  const m = {};\n\n  while (r.pos < c) {\n    const t = r.uint32();\n\n    switch (t >>> 3) {\n      case 1:\n        m.topicID = r.string();\n        break;\n\n      default:\n        r.skipType(t & 7);\n        break;\n    }\n  }\n\n  return m;\n}\n\nfunction decodeControlPrune(r, l, opts) {\n  const c = l === undefined ? r.len : r.pos + l;\n  const m = {};\n\n  while (r.pos < c) {\n    const t = r.uint32();\n\n    switch (t >>> 3) {\n      case 1:\n        m.topicID = r.string();\n        break;\n\n      case 2:\n        if (!(m.peers && m.peers.length)) m.peers = [];\n        if (opts.maxPeerInfos-- > 0) m.peers.push(decodePeerInfo(r, r.uint32()));else r.skipType(t & 7);\n        break;\n\n      case 3:\n        m.backoff = r.uint64();\n        break;\n\n      default:\n        r.skipType(t & 7);\n        break;\n    }\n  }\n\n  return m;\n}\n\nfunction decodePeerInfo(r, l) {\n  const c = l === undefined ? r.len : r.pos + l;\n  const m = {};\n\n  while (r.pos < c) {\n    const t = r.uint32();\n\n    switch (t >>> 3) {\n      case 1:\n        m.peerID = r.bytes();\n        break;\n\n      case 2:\n        m.signedPeerRecord = r.bytes();\n        break;\n\n      default:\n        r.skipType(t & 7);\n        break;\n    }\n  }\n\n  return m;\n}","map":{"version":3,"mappings":"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","names":["protobuf","defaultDecodeRpcLimits","maxSubscriptions","Infinity","maxMessages","maxIhaveMessageIDs","maxIwantMessageIDs","maxControlMessages","maxPeerInfos","decodeRpc","bytes","opts","r","Reader","create","l","length","c","undefined","len","pos","m","t","uint32","subscriptions","push","decodeSubOpts","skipType","messages","decodeMessage","control","decodeControlMessage","subscribe","bool","topic","string","from","data","seqno","signature","key","Error","ihave","decodeControlIHave","iwant","decodeControlIWant","graft","decodeControlGraft","prune","decodeControlPrune","topicID","messageIDs","peers","decodePeerInfo","backoff","uint64","peerID","signedPeerRecord"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\message\\decodeRpc.ts"],"sourcesContent":["import type { IRPC, RPC } from './rpc.js'\nimport protobuf from 'protobufjs/minimal.js'\n\nexport type DecodeRPCLimits = {\n  maxSubscriptions: number\n  maxMessages: number\n  maxIhaveMessageIDs: number\n  maxIwantMessageIDs: number\n  maxControlMessages: number\n  maxPeerInfos: number\n}\n\nexport const defaultDecodeRpcLimits: DecodeRPCLimits = {\n  maxSubscriptions: Infinity,\n  maxMessages: Infinity,\n  maxIhaveMessageIDs: Infinity,\n  maxIwantMessageIDs: Infinity,\n  maxControlMessages: Infinity,\n  maxPeerInfos: Infinity\n}\n\n/**\n * Copied code from src/message/rpc.cjs but with decode limits to prevent OOM attacks\n */\nexport function decodeRpc(bytes: Uint8Array, opts: DecodeRPCLimits): IRPC {\n  // Mutate to use the option as stateful counter. Must limit the total count of messageIDs across all IWANT, IHAVE\n  // else one count put 100 messageIDs into each 100 IWANT and \"get around\" the limit\n  opts = { ...opts }\n\n  const r = protobuf.Reader.create(bytes)\n  const l = bytes.length\n\n  const c = l === undefined ? r.len : r.pos + l\n  const m: IRPC = {}\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        if (!(m.subscriptions && m.subscriptions.length)) m.subscriptions = []\n        if (m.subscriptions.length < opts.maxSubscriptions) m.subscriptions.push(decodeSubOpts(r, r.uint32()))\n        else r.skipType(t & 7)\n        break\n      case 2:\n        if (!(m.messages && m.messages.length)) m.messages = []\n        if (m.messages.length < opts.maxMessages) m.messages.push(decodeMessage(r, r.uint32()))\n        else r.skipType(t & 7)\n        break\n      case 3:\n        m.control = decodeControlMessage(r, r.uint32(), opts)\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeSubOpts(r: protobuf.Reader, l: number) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m: RPC.ISubOpts = {}\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.subscribe = r.bool()\n        break\n      case 2:\n        m.topic = r.string()\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeMessage(r: protobuf.Reader, l: number) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IMessage\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.from = r.bytes()\n        break\n      case 2:\n        m.data = r.bytes()\n        break\n      case 3:\n        m.seqno = r.bytes()\n        break\n      case 4:\n        m.topic = r.string()\n        break\n      case 5:\n        m.signature = r.bytes()\n        break\n      case 6:\n        m.key = r.bytes()\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  if (!m.topic) throw Error(\"missing required 'topic'\")\n  return m\n}\n\nfunction decodeControlMessage(r: protobuf.Reader, l: number, opts: DecodeRPCLimits) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IControlMessage\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        if (!(m.ihave && m.ihave.length)) m.ihave = []\n        if (m.ihave.length < opts.maxControlMessages) m.ihave.push(decodeControlIHave(r, r.uint32(), opts))\n        else r.skipType(t & 7)\n        break\n      case 2:\n        if (!(m.iwant && m.iwant.length)) m.iwant = []\n        if (m.iwant.length < opts.maxControlMessages) m.iwant.push(decodeControlIWant(r, r.uint32(), opts))\n        else r.skipType(t & 7)\n        break\n      case 3:\n        if (!(m.graft && m.graft.length)) m.graft = []\n        if (m.graft.length < opts.maxControlMessages) m.graft.push(decodeControlGraft(r, r.uint32()))\n        else r.skipType(t & 7)\n        break\n      case 4:\n        if (!(m.prune && m.prune.length)) m.prune = []\n        if (m.prune.length < opts.maxControlMessages) m.prune.push(decodeControlPrune(r, r.uint32(), opts))\n        else r.skipType(t & 7)\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeControlIHave(r: protobuf.Reader, l: number, opts: DecodeRPCLimits) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IControlIHave\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.topicID = r.string()\n        break\n      case 2:\n        if (!(m.messageIDs && m.messageIDs.length)) m.messageIDs = []\n        if (opts.maxIhaveMessageIDs-- > 0) m.messageIDs.push(r.bytes())\n        else r.skipType(t & 7)\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeControlIWant(r: protobuf.Reader, l: number, opts: DecodeRPCLimits) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IControlIWant\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        if (!(m.messageIDs && m.messageIDs.length)) m.messageIDs = []\n        if (opts.maxIwantMessageIDs-- > 0) m.messageIDs.push(r.bytes())\n        else r.skipType(t & 7)\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeControlGraft(r: protobuf.Reader, l: number) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IControlGraft\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.topicID = r.string()\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeControlPrune(r: protobuf.Reader, l: number, opts: DecodeRPCLimits) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IControlPrune\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.topicID = r.string()\n        break\n      case 2:\n        if (!(m.peers && m.peers.length)) m.peers = []\n        if (opts.maxPeerInfos-- > 0) m.peers.push(decodePeerInfo(r, r.uint32()))\n        else r.skipType(t & 7)\n        break\n      case 3:\n        m.backoff = r.uint64() as unknown as number\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodePeerInfo(r: protobuf.Reader, l: number) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IPeerInfo\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.peerID = r.bytes()\n        break\n      case 2:\n        m.signedPeerRecord = r.bytes()\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n"]},"metadata":{},"sourceType":"module"}