{"ast":null,"code":"/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\n\nconst _0n = BigInt(0);\n\nconst _1n = BigInt(1);\n\nconst _2n = BigInt(2);\n\nconst _8n = BigInt(8);\n\nconst CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');\nconst CURVE = Object.freeze({\n  a: BigInt(-1),\n  d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n  P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),\n  l: CU_O,\n  n: CU_O,\n  h: BigInt(8),\n  Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n  Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960')\n});\nexport { CURVE };\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n\nclass ExtendedPoint {\n  constructor(x, y, z, t) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.t = t;\n  }\n\n  static fromAffine(p) {\n    if (!(p instanceof Point)) {\n      throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n    }\n\n    if (p.equals(Point.ZERO)) return ExtendedPoint.ZERO;\n    return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n  }\n\n  static toAffineBatch(points) {\n    const toInv = invertBatch(points.map(p => p.z));\n    return points.map((p, i) => p.toAffine(toInv[i]));\n  }\n\n  static normalizeZ(points) {\n    return this.toAffineBatch(points).map(this.fromAffine);\n  }\n\n  equals(other) {\n    assertExtPoint(other);\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2\n    } = other;\n    const X1Z2 = mod(X1 * Z2);\n    const X2Z1 = mod(X2 * Z1);\n    const Y1Z2 = mod(Y1 * Z2);\n    const Y2Z1 = mod(Y2 * Z1);\n    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n  }\n\n  negate() {\n    return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n  }\n\n  double() {\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      a\n    } = CURVE;\n    const A = mod(X1 * X1);\n    const B = mod(Y1 * Y1);\n    const C = mod(_2n * mod(Z1 * Z1));\n    const D = mod(a * A);\n    const x1y1 = X1 + Y1;\n    const E = mod(mod(x1y1 * x1y1) - A - B);\n    const G = D + B;\n    const F = G - C;\n    const H = D - B;\n    const X3 = mod(E * F);\n    const Y3 = mod(G * H);\n    const T3 = mod(E * H);\n    const Z3 = mod(F * G);\n    return new ExtendedPoint(X3, Y3, Z3, T3);\n  }\n\n  add(other) {\n    assertExtPoint(other);\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1,\n      t: T1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2,\n      t: T2\n    } = other;\n    const A = mod((Y1 - X1) * (Y2 + X2));\n    const B = mod((Y1 + X1) * (Y2 - X2));\n    const F = mod(B - A);\n    if (F === _0n) return this.double();\n    const C = mod(Z1 * _2n * T2);\n    const D = mod(T1 * _2n * Z2);\n    const E = D + C;\n    const G = B + A;\n    const H = D - C;\n    const X3 = mod(E * F);\n    const Y3 = mod(G * H);\n    const T3 = mod(E * H);\n    const Z3 = mod(F * G);\n    return new ExtendedPoint(X3, Y3, Z3, T3);\n  }\n\n  subtract(other) {\n    return this.add(other.negate());\n  }\n\n  precomputeWindow(W) {\n    const windows = 1 + 256 / W;\n    const points = [];\n    let p = this;\n    let base = p;\n\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n\n      for (let i = 1; i < 2 ** (W - 1); i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n\n      p = base.double();\n    }\n\n    return points;\n  }\n\n  wNAF(n, affinePoint) {\n    if (!affinePoint && this.equals(ExtendedPoint.BASE)) affinePoint = Point.BASE;\n    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n\n    if (256 % W) {\n      throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n    }\n\n    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n\n    if (!precomputes) {\n      precomputes = this.precomputeWindow(W);\n\n      if (affinePoint && W !== 1) {\n        precomputes = ExtendedPoint.normalizeZ(precomputes);\n        pointPrecomputes.set(affinePoint, precomputes);\n      }\n    }\n\n    let p = ExtendedPoint.ZERO;\n    let f = ExtendedPoint.BASE;\n    const windows = 1 + 256 / W;\n    const windowSize = 2 ** (W - 1);\n    const mask = BigInt(2 ** W - 1);\n    const maxNumber = 2 ** W;\n    const shiftBy = BigInt(W);\n\n    for (let window = 0; window < windows; window++) {\n      const offset = window * windowSize;\n      let wbits = Number(n & mask);\n      n >>= shiftBy;\n\n      if (wbits > windowSize) {\n        wbits -= maxNumber;\n        n += _1n;\n      }\n\n      const offset1 = offset;\n      const offset2 = offset + Math.abs(wbits) - 1;\n      const cond1 = window % 2 !== 0;\n      const cond2 = wbits < 0;\n\n      if (wbits === 0) {\n        f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n      } else {\n        p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n      }\n    }\n\n    return ExtendedPoint.normalizeZ([p, f])[0];\n  }\n\n  multiply(scalar, affinePoint) {\n    return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n  }\n\n  multiplyUnsafe(scalar) {\n    let n = normalizeScalar(scalar, CURVE.l, false);\n    const G = ExtendedPoint.BASE;\n    const P0 = ExtendedPoint.ZERO;\n    if (n === _0n) return P0;\n    if (this.equals(P0) || n === _1n) return this;\n    if (this.equals(G)) return this.wNAF(n);\n    let p = P0;\n    let d = this;\n\n    while (n > _0n) {\n      if (n & _1n) p = p.add(d);\n      d = d.double();\n      n >>= _1n;\n    }\n\n    return p;\n  }\n\n  isSmallOrder() {\n    return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n  }\n\n  isTorsionFree() {\n    let p = this.multiplyUnsafe(CURVE.l / _2n).double();\n    if (CURVE.l % _2n) p = p.add(this);\n    return p.equals(ExtendedPoint.ZERO);\n  }\n\n  toAffine(invZ) {\n    const {\n      x,\n      y,\n      z\n    } = this;\n    const is0 = this.equals(ExtendedPoint.ZERO);\n    if (invZ == null) invZ = is0 ? _8n : invert(z);\n    const ax = mod(x * invZ);\n    const ay = mod(y * invZ);\n    const zz = mod(z * invZ);\n    if (is0) return Point.ZERO;\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return new Point(ax, ay);\n  }\n\n  fromRistrettoBytes() {\n    legacyRist();\n  }\n\n  toRistrettoBytes() {\n    legacyRist();\n  }\n\n  fromRistrettoHash() {\n    legacyRist();\n  }\n\n}\n\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\n\nfunction constTimeNegate(condition, item) {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\nfunction assertExtPoint(other) {\n  if (!(other instanceof ExtendedPoint)) throw new TypeError('ExtendedPoint expected');\n}\n\nfunction assertRstPoint(other) {\n  if (!(other instanceof RistrettoPoint)) throw new TypeError('RistrettoPoint expected');\n}\n\nfunction legacyRist() {\n  throw new Error('Legacy method: switch to RistrettoPoint');\n}\n\nclass RistrettoPoint {\n  constructor(ep) {\n    this.ep = ep;\n  }\n\n  static calcElligatorRistrettoMap(r0) {\n    const {\n      d\n    } = CURVE;\n    const r = mod(SQRT_M1 * r0 * r0);\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n    let c = BigInt(-1);\n    const D = mod((c - d * r) * mod(r + d));\n    let {\n      isValid: Ns_D_is_sq,\n      value: s\n    } = uvRatio(Ns, D);\n    let s_ = mod(s * r0);\n    if (!edIsNegative(s_)) s_ = mod(-s_);\n    if (!Ns_D_is_sq) s = s_;\n    if (!Ns_D_is_sq) c = r;\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n    const s2 = s * s;\n    const W0 = mod((s + s) * D);\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n    const W2 = mod(_1n - s2);\n    const W3 = mod(_1n + s2);\n    return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n  }\n\n  static hashToCurve(hex) {\n    hex = ensureBytes(hex, 64);\n    const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n    const R1 = this.calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n    const R2 = this.calcElligatorRistrettoMap(r2);\n    return new RistrettoPoint(R1.add(R2));\n  }\n\n  static fromHex(hex) {\n    hex = ensureBytes(hex, 32);\n    const {\n      a,\n      d\n    } = CURVE;\n    const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n    const s = bytes255ToNumberLE(hex);\n    if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2);\n    const u2 = mod(_1n - a * s2);\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2);\n    const {\n      isValid,\n      value: I\n    } = invertSqrt(mod(v * u2_2));\n    const Dx = mod(I * u2);\n    const Dy = mod(I * Dx * v);\n    let x = mod((s + s) * Dx);\n    if (edIsNegative(x)) x = mod(-x);\n    const y = mod(u1 * Dy);\n    const t = mod(x * y);\n    if (!isValid || edIsNegative(t) || y === _0n) throw new Error(emsg);\n    return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n  }\n\n  toRawBytes() {\n    let {\n      x,\n      y,\n      z,\n      t\n    } = this.ep;\n    const u1 = mod(mod(z + y) * mod(z - y));\n    const u2 = mod(x * y);\n    const u2sq = mod(u2 * u2);\n    const {\n      value: invsqrt\n    } = invertSqrt(mod(u1 * u2sq));\n    const D1 = mod(invsqrt * u1);\n    const D2 = mod(invsqrt * u2);\n    const zInv = mod(D1 * D2 * t);\n    let D;\n\n    if (edIsNegative(t * zInv)) {\n      let _x = mod(y * SQRT_M1);\n\n      let _y = mod(x * SQRT_M1);\n\n      x = _x;\n      y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2;\n    }\n\n    if (edIsNegative(x * zInv)) y = mod(-y);\n    let s = mod((z - y) * D);\n    if (edIsNegative(s)) s = mod(-s);\n    return numberTo32BytesLE(s);\n  }\n\n  toHex() {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toString() {\n    return this.toHex();\n  }\n\n  equals(other) {\n    assertRstPoint(other);\n    const a = this.ep;\n    const b = other.ep;\n    const one = mod(a.x * b.y) === mod(a.y * b.x);\n    const two = mod(a.y * b.y) === mod(a.x * b.x);\n    return one || two;\n  }\n\n  add(other) {\n    assertRstPoint(other);\n    return new RistrettoPoint(this.ep.add(other.ep));\n  }\n\n  subtract(other) {\n    assertRstPoint(other);\n    return new RistrettoPoint(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar) {\n    return new RistrettoPoint(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar) {\n    return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n  }\n\n}\n\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\n\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  _setWindowSize(windowSize) {\n    this._WINDOW_SIZE = windowSize;\n    pointPrecomputes.delete(this);\n  }\n\n  static fromHex(hex) {\n    let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const {\n      d,\n      P\n    } = CURVE;\n    hex = ensureBytes(hex, 32);\n    const normed = hex.slice();\n    normed[31] = hex[31] & ~0x80;\n    const y = bytesToNumberLE(normed);\n    if (strict && y >= P) throw new Error('Expected 0 < hex < P');\n    if (!strict && y >= POW_2_256) throw new Error('Expected 0 < hex < 2**256');\n    const y2 = mod(y * y);\n    const u = mod(y2 - _1n);\n    const v = mod(d * y2 + _1n);\n    let {\n      isValid,\n      value: x\n    } = uvRatio(u, v);\n    if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n    const isXOdd = (x & _1n) === _1n;\n    const isLastByteOdd = (hex[31] & 0x80) !== 0;\n\n    if (isLastByteOdd !== isXOdd) {\n      x = mod(-x);\n    }\n\n    return new Point(x, y);\n  }\n\n  static async fromPrivateKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).point;\n  }\n\n  toRawBytes() {\n    const bytes = numberTo32BytesLE(this.y);\n    bytes[31] |= this.x & _1n ? 0x80 : 0;\n    return bytes;\n  }\n\n  toHex() {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toX25519() {\n    const {\n      y\n    } = this;\n    const u = mod((_1n + y) * invert(_1n - y));\n    return numberTo32BytesLE(u);\n  }\n\n  isTorsionFree() {\n    return ExtendedPoint.fromAffine(this).isTorsionFree();\n  }\n\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n\n  negate() {\n    return new Point(mod(-this.x), this.y);\n  }\n\n  add(other) {\n    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n  }\n\n  subtract(other) {\n    return this.add(other.negate());\n  }\n\n  multiply(scalar) {\n    return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n  }\n\n}\n\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\n\nclass Signature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex, 64);\n    const r = Point.fromHex(bytes.slice(0, 32), false);\n    const s = bytesToNumberLE(bytes.slice(32, 64));\n    return new Signature(r, s);\n  }\n\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!(r instanceof Point)) throw new Error('Expected Point instance');\n    normalizeScalar(s, CURVE.l, false);\n    return this;\n  }\n\n  toRawBytes() {\n    const u8 = new Uint8Array(64);\n    u8.set(this.r.toRawBytes());\n    u8.set(numberTo32BytesLE(this.s), 32);\n    return u8;\n  }\n\n  toHex() {\n    return bytesToHex(this.toRawBytes());\n  }\n\n}\n\nexport { ExtendedPoint, RistrettoPoint, Point, Signature };\n\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Expected Uint8Array list');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n\n  return result;\n}\n\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n\n  return hex;\n}\n\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n\n  return array;\n}\n\nfunction numberTo32BytesBE(num) {\n  const length = 32;\n  const hex = num.toString(16).padStart(length * 2, '0');\n  return hexToBytes(hex);\n}\n\nfunction numberTo32BytesLE(num) {\n  return numberTo32BytesBE(num).reverse();\n}\n\nfunction edIsNegative(num) {\n  return (mod(num) & _1n) === _1n;\n}\n\nfunction bytesToNumberLE(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\n\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n\nfunction bytes255ToNumberLE(bytes) {\n  return mod(bytesToNumberLE(bytes) & MAX_255B);\n}\n\nfunction mod(a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const res = a % b;\n  return res >= _0n ? res : b + res;\n}\n\nfunction invert(number) {\n  let modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n\n  let a = mod(number, modulo);\n  let b = modulo;\n  let x = _0n,\n      y = _1n,\n      u = _1n,\n      v = _0n;\n\n  while (a !== _0n) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction invertBatch(nums) {\n  let p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const tmp = new Array(nums.length);\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (num === _0n) return acc;\n    tmp[i] = acc;\n    return mod(acc * num, p);\n  }, _1n);\n  const inverted = invert(lastMultiplied, p);\n  nums.reduceRight((acc, num, i) => {\n    if (num === _0n) return acc;\n    tmp[i] = mod(acc * tmp[i], p);\n    return mod(acc * num, p);\n  }, inverted);\n  return tmp;\n}\n\nfunction pow2(x, power) {\n  const {\n    P\n  } = CURVE;\n  let res = x;\n\n  while (power-- > _0n) {\n    res *= res;\n    res %= P;\n  }\n\n  return res;\n}\n\nfunction pow_2_252_3(x) {\n  const {\n    P\n  } = CURVE;\n\n  const _5n = BigInt(5);\n\n  const _10n = BigInt(10);\n\n  const _20n = BigInt(20);\n\n  const _40n = BigInt(40);\n\n  const _80n = BigInt(80);\n\n  const x2 = x * x % P;\n  const b2 = x2 * x % P;\n  const b4 = pow2(b2, _2n) * b2 % P;\n  const b5 = pow2(b4, _1n) * x % P;\n  const b10 = pow2(b5, _5n) * b5 % P;\n  const b20 = pow2(b10, _10n) * b10 % P;\n  const b40 = pow2(b20, _20n) * b20 % P;\n  const b80 = pow2(b40, _40n) * b40 % P;\n  const b160 = pow2(b80, _80n) * b80 % P;\n  const b240 = pow2(b160, _80n) * b80 % P;\n  const b250 = pow2(b240, _10n) * b10 % P;\n  const pow_p_5_8 = pow2(b250, _2n) * x % P;\n  return {\n    pow_p_5_8,\n    b2\n  };\n}\n\nfunction uvRatio(u, v) {\n  const v3 = mod(v * v * v);\n  const v7 = mod(v3 * v3 * v);\n  const pow = pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow);\n  const vx2 = mod(v * x * x);\n  const root1 = x;\n  const root2 = mod(x * SQRT_M1);\n  const useRoot1 = vx2 === u;\n  const useRoot2 = vx2 === mod(-u);\n  const noRoot = vx2 === mod(-u * SQRT_M1);\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2;\n  if (edIsNegative(x)) x = mod(-x);\n  return {\n    isValid: useRoot1 || useRoot2,\n    value: x\n  };\n}\n\nfunction invertSqrt(number) {\n  return uvRatio(_1n, number);\n}\n\nfunction modlLE(hash) {\n  return mod(bytesToNumberLE(hash), CURVE.l);\n}\n\nfunction equalBytes(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] !== b2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction ensureBytes(hex, expectedLength) {\n  const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n  if (typeof expectedLength === 'number' && bytes.length !== expectedLength) throw new Error(`Expected ${expectedLength} bytes`);\n  return bytes;\n}\n\nfunction normalizeScalar(num, max) {\n  let strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!max) throw new TypeError('Specify max value');\n  if (typeof num === 'number' && Number.isSafeInteger(num)) num = BigInt(num);\n\n  if (typeof num === 'bigint' && num < max) {\n    if (strict) {\n      if (_0n < num) return num;\n    } else {\n      if (_0n <= num) return num;\n    }\n  }\n\n  throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\n\nfunction adjustBytes25519(bytes) {\n  bytes[0] &= 248;\n  bytes[31] &= 127;\n  bytes[31] |= 64;\n  return bytes;\n}\n\nfunction decodeScalar25519(n) {\n  return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\n\nfunction checkPrivateKey(key) {\n  key = typeof key === 'bigint' || typeof key === 'number' ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);\n  if (key.length !== 32) throw new Error(`Expected 32 bytes`);\n  return key;\n}\n\nfunction getKeyFromHash(hashed) {\n  const head = adjustBytes25519(hashed.slice(0, 32));\n  const prefix = hashed.slice(32, 64);\n  const scalar = modlLE(head);\n  const point = Point.BASE.multiply(scalar);\n  const pointBytes = point.toRawBytes();\n  return {\n    head,\n    prefix,\n    scalar,\n    point,\n    pointBytes\n  };\n}\n\nlet _sha512Sync;\n\nfunction sha512s() {\n  if (typeof _sha512Sync !== 'function') throw new Error('utils.sha512Sync must be set to use sync methods');\n  return _sha512Sync(...arguments);\n}\n\nasync function getExtendedPublicKey(key) {\n  return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));\n}\n\nfunction getExtendedPublicKeySync(key) {\n  return getKeyFromHash(sha512s(checkPrivateKey(key)));\n}\n\nexport async function getPublicKey(privateKey) {\n  return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\n\nfunction getPublicKeySync(privateKey) {\n  return getExtendedPublicKeySync(privateKey).pointBytes;\n}\n\nexport async function sign(message, privateKey) {\n  message = ensureBytes(message);\n  const {\n    prefix,\n    scalar,\n    pointBytes\n  } = await getExtendedPublicKey(privateKey);\n  const r = modlLE(await utils.sha512(prefix, message));\n  const R = Point.BASE.multiply(r);\n  const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));\n  const s = mod(r + k * scalar, CURVE.l);\n  return new Signature(R, s).toRawBytes();\n}\n\nfunction signSync(message, privateKey) {\n  message = ensureBytes(message);\n  const {\n    prefix,\n    scalar,\n    pointBytes\n  } = getExtendedPublicKeySync(privateKey);\n  const r = modlLE(sha512s(prefix, message));\n  const R = Point.BASE.multiply(r);\n  const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));\n  const s = mod(r + k * scalar, CURVE.l);\n  return new Signature(R, s).toRawBytes();\n}\n\nfunction prepareVerification(sig, message, publicKey) {\n  message = ensureBytes(message);\n  if (!(publicKey instanceof Point)) publicKey = Point.fromHex(publicKey, false);\n  const {\n    r,\n    s\n  } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n  const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n  return {\n    r,\n    s,\n    SB,\n    pub: publicKey,\n    msg: message\n  };\n}\n\nfunction finishVerification(publicKey, r, SB, hashed) {\n  const k = modlLE(hashed);\n  const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n  const RkA = ExtendedPoint.fromAffine(r).add(kA);\n  return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\n\nexport async function verify(sig, message, publicKey) {\n  const {\n    r,\n    SB,\n    msg,\n    pub\n  } = prepareVerification(sig, message, publicKey);\n  const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);\n  return finishVerification(pub, r, SB, hashed);\n}\n\nfunction verifySync(sig, message, publicKey) {\n  const {\n    r,\n    SB,\n    msg,\n    pub\n  } = prepareVerification(sig, message, publicKey);\n  const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);\n  return finishVerification(pub, r, SB, hashed);\n}\n\nexport const sync = {\n  getExtendedPublicKey: getExtendedPublicKeySync,\n  getPublicKey: getPublicKeySync,\n  sign: signSync,\n  verify: verifySync\n};\nexport async function getSharedSecret(privateKey, publicKey) {\n  const {\n    head\n  } = await getExtendedPublicKey(privateKey);\n  const u = Point.fromHex(publicKey).toX25519();\n  return curve25519.scalarMult(head, u);\n}\n\nPoint.BASE._setWindowSize(8);\n\nfunction cswap(swap, x_2, x_3) {\n  const dummy = mod(swap * (x_2 - x_3));\n  x_2 = mod(x_2 - dummy);\n  x_3 = mod(x_3 + dummy);\n  return [x_2, x_3];\n}\n\nfunction montgomeryLadder(pointU, scalar) {\n  const {\n    P\n  } = CURVE;\n  const u = normalizeScalar(pointU, P);\n  const k = normalizeScalar(scalar, P);\n  const a24 = BigInt(121665);\n  const x_1 = u;\n  let x_2 = _1n;\n  let z_2 = _0n;\n  let x_3 = u;\n  let z_3 = _1n;\n  let swap = _0n;\n  let sw;\n\n  for (let t = BigInt(255 - 1); t >= _0n; t--) {\n    const k_t = k >> t & _1n;\n    swap ^= k_t;\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    swap = k_t;\n    const A = x_2 + z_2;\n    const AA = mod(A * A);\n    const B = x_2 - z_2;\n    const BB = mod(B * B);\n    const E = AA - BB;\n    const C = x_3 + z_3;\n    const D = x_3 - z_3;\n    const DA = mod(D * A);\n    const CB = mod(C * B);\n    const dacb = DA + CB;\n    const da_cb = DA - CB;\n    x_3 = mod(dacb * dacb);\n    z_3 = mod(x_1 * mod(da_cb * da_cb));\n    x_2 = mod(AA * BB);\n    z_2 = mod(E * (AA + mod(a24 * E)));\n  }\n\n  sw = cswap(swap, x_2, x_3);\n  x_2 = sw[0];\n  x_3 = sw[1];\n  sw = cswap(swap, z_2, z_3);\n  z_2 = sw[0];\n  z_3 = sw[1];\n  const {\n    pow_p_5_8,\n    b2\n  } = pow_2_252_3(z_2);\n  const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n  return mod(x_2 * xp2);\n}\n\nfunction encodeUCoordinate(u) {\n  return numberTo32BytesLE(mod(u, CURVE.P));\n}\n\nfunction decodeUCoordinate(uEnc) {\n  const u = ensureBytes(uEnc, 32);\n  u[31] &= 127;\n  return bytesToNumberLE(u);\n}\n\nexport const curve25519 = {\n  BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n\n  scalarMult(privateKey, publicKey) {\n    const u = decodeUCoordinate(publicKey);\n    const p = decodeScalar25519(privateKey);\n    const pu = montgomeryLadder(u, p);\n    if (pu === _0n) throw new Error('Invalid private or public key received');\n    return encodeUCoordinate(pu);\n  },\n\n  scalarMultBase(privateKey) {\n    return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n  }\n\n};\nconst crypto = {\n  node: nodeCrypto,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\nexport const utils = {\n  bytesToHex,\n  hexToBytes,\n  concatBytes,\n  getExtendedPublicKey,\n  mod,\n  invert,\n  TORSION_SUBGROUP: ['0100000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a', '0000000000000000000000000000000000000000000000000000000000000080', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05', 'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85', '0000000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa'],\n  hashToPrivateScalar: hash => {\n    hash = ensureBytes(hash);\n    if (hash.length < 40 || hash.length > 1024) throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n    return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;\n  },\n  randomBytes: function () {\n    let bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      const {\n        randomBytes\n      } = crypto.node;\n      return new Uint8Array(randomBytes(bytesLength).buffer);\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: () => {\n    return utils.randomBytes(32);\n  },\n  sha512: async function () {\n    const message = concatBytes(...arguments);\n\n    if (crypto.web) {\n      const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n      return new Uint8Array(buffer);\n    } else if (crypto.node) {\n      return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n    } else {\n      throw new Error(\"The environment doesn't have sha512 function\");\n    }\n  },\n\n  precompute() {\n    let windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n    const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n\n    cached._setWindowSize(windowSize);\n\n    cached.multiply(_2n);\n    return cached;\n  },\n\n  sha512Sync: undefined\n};\nObject.defineProperties(utils, {\n  sha512Sync: {\n    configurable: false,\n\n    get() {\n      return _sha512Sync;\n    },\n\n    set(val) {\n      if (!_sha512Sync) _sha512Sync = val;\n    }\n\n  }\n});","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/@noble/ed25519/lib/esm/index.js"],"names":["nodeCrypto","_0n","BigInt","_1n","_2n","_8n","CU_O","CURVE","Object","freeze","a","d","P","l","n","h","Gx","Gy","POW_2_256","SQRT_M1","SQRT_D","SQRT_AD_MINUS_ONE","INVSQRT_A_MINUS_D","ONE_MINUS_D_SQ","D_MINUS_ONE_SQ","ExtendedPoint","constructor","x","y","z","t","fromAffine","p","Point","TypeError","equals","ZERO","mod","toAffineBatch","points","toInv","invertBatch","map","i","toAffine","normalizeZ","other","assertExtPoint","X1","Y1","Z1","X2","Y2","Z2","X1Z2","X2Z1","Y1Z2","Y2Z1","negate","double","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","add","T1","T2","subtract","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","BASE","_WINDOW_SIZE","Error","precomputes","pointPrecomputes","get","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","offset1","offset2","Math","abs","cond1","cond2","constTimeNegate","multiply","scalar","normalizeScalar","multiplyUnsafe","P0","isSmallOrder","isTorsionFree","invZ","is0","invert","ax","ay","zz","fromRistrettoBytes","legacyRist","toRistrettoBytes","fromRistrettoHash","condition","item","neg","assertRstPoint","RistrettoPoint","ep","calcElligatorRistrettoMap","r0","r","Ns","c","isValid","Ns_D_is_sq","value","s","uvRatio","s_","edIsNegative","Nt","s2","W0","W1","W2","W3","hashToCurve","hex","ensureBytes","r1","bytes255ToNumberLE","slice","R1","r2","R2","fromHex","emsg","equalBytes","numberTo32BytesLE","u1","u2","u1_2","u2_2","v","I","invertSqrt","Dx","Dy","toRawBytes","u2sq","invsqrt","D1","D2","zInv","_x","_y","toHex","bytesToHex","toString","b","one","two","WeakMap","_setWindowSize","delete","strict","normed","bytesToNumberLE","y2","u","isXOdd","isLastByteOdd","fromPrivateKey","privateKey","getExtendedPublicKey","point","bytes","toX25519","Signature","assertValidity","u8","Uint8Array","concatBytes","arrays","every","length","reduce","arr","result","pad","hexes","Array","from","padStart","uint8a","hexToBytes","array","j","hexByte","byte","parseInt","isNaN","numberTo32BytesBE","num","reverse","MAX_255B","res","number","modulo","q","m","gcd","nums","tmp","lastMultiplied","acc","inverted","reduceRight","pow2","power","pow_2_252_3","_5n","_10n","_20n","_40n","_80n","x2","b2","b4","b5","b10","b20","b40","b80","b160","b240","b250","pow_p_5_8","v3","v7","pow","vx2","root1","root2","useRoot1","useRoot2","noRoot","modlLE","hash","b1","expectedLength","max","isSafeInteger","adjustBytes25519","decodeScalar25519","checkPrivateKey","key","getKeyFromHash","hashed","head","prefix","pointBytes","_sha512Sync","sha512s","utils","sha512","getExtendedPublicKeySync","getPublicKey","getPublicKeySync","sign","message","R","k","signSync","prepareVerification","sig","publicKey","SB","pub","msg","finishVerification","kA","RkA","verify","verifySync","sync","getSharedSecret","curve25519","scalarMult","cswap","swap","x_2","x_3","dummy","montgomeryLadder","pointU","a24","x_1","z_2","z_3","sw","k_t","AA","BB","DA","CB","dacb","da_cb","xp2","encodeUCoordinate","decodeUCoordinate","uEnc","BASE_POINT_U","pu","scalarMultBase","crypto","node","web","self","undefined","TORSION_SUBGROUP","hashToPrivateScalar","randomBytes","bytesLength","getRandomValues","buffer","randomPrivateKey","subtle","digest","createHash","update","precompute","cached","sha512Sync","defineProperties","configurable","val"],"mappings":"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","sourcesContent":["/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _8n = BigInt(8);\nconst CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');\nconst CURVE = Object.freeze({\n    a: BigInt(-1),\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),\n    l: CU_O,\n    n: CU_O,\n    h: BigInt(8),\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n});\nexport { CURVE };\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\nclass ExtendedPoint {\n    constructor(x, y, z, t) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    equals(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const X1Z2 = mod(X1 * Z2);\n        const X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2);\n        const Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { a } = CURVE;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(_2n * mod(Z1 * Z1));\n        const D = mod(a * A);\n        const x1y1 = X1 + Y1;\n        const E = mod(mod(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1, t: T1 } = this;\n        const { x: X2, y: Y2, z: Z2, t: T2 } = other;\n        const A = mod((Y1 - X1) * (Y2 + X2));\n        const B = mod((Y1 + X1) * (Y2 - X2));\n        const F = mod(B - A);\n        if (F === _0n)\n            return this.double();\n        const C = mod(Z1 * _2n * T2);\n        const D = mod(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    precomputeWindow(W) {\n        const windows = 1 + 256 / W;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.BASE;\n        const windows = 1 + 256 / W;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return ExtendedPoint.normalizeZ([p, f])[0];\n    }\n    multiply(scalar, affinePoint) {\n        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar, CURVE.l, false);\n        const G = ExtendedPoint.BASE;\n        const P0 = ExtendedPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (this.equals(P0) || n === _1n)\n            return this;\n        if (this.equals(G))\n            return this.wNAF(n);\n        let p = P0;\n        let d = this;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    isSmallOrder() {\n        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n    isTorsionFree() {\n        let p = this.multiplyUnsafe(CURVE.l / _2n).double();\n        if (CURVE.l % _2n)\n            p = p.add(this);\n        return p.equals(ExtendedPoint.ZERO);\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(ExtendedPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const ax = mod(x * invZ);\n        const ay = mod(y * invZ);\n        const zz = mod(z * invZ);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n    fromRistrettoBytes() {\n        legacyRist();\n    }\n    toRistrettoBytes() {\n        legacyRist();\n    }\n    fromRistrettoHash() {\n        legacyRist();\n    }\n}\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction assertExtPoint(other) {\n    if (!(other instanceof ExtendedPoint))\n        throw new TypeError('ExtendedPoint expected');\n}\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistrettoPoint))\n        throw new TypeError('RistrettoPoint expected');\n}\nfunction legacyRist() {\n    throw new Error('Legacy method: switch to RistrettoPoint');\n}\nclass RistrettoPoint {\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n        let c = BigInt(-1);\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_))\n            s_ = mod(-s_);\n        if (!Ns_D_is_sq)\n            s = s_;\n        if (!Ns_D_is_sq)\n            c = r;\n        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(_1n - s2);\n        const W3 = mod(_1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static hashToCurve(hex) {\n        hex = ensureBytes(hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return new RistrettoPoint(R1.add(R2));\n    }\n    static fromHex(hex) {\n        hex = ensureBytes(hex, 32);\n        const { a, d } = CURVE;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2);\n        const u2 = mod(_1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x))\n            x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === _0n)\n            throw new Error(emsg);\n        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n    toRawBytes() {\n        let { x, y, z, t } = this.ep;\n        const u1 = mod(mod(z + y) * mod(z - y));\n        const u2 = mod(x * y);\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv))\n            y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s))\n            s = mod(-s);\n        return numberTo32BytesLE(s);\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    equals(other) {\n        assertRstPoint(other);\n        const a = this.ep;\n        const b = other.ep;\n        const one = mod(a.x * b.y) === mod(a.y * b.x);\n        const two = mod(a.y * b.y) === mod(a.x * b.x);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n}\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hex, strict = true) {\n        const { d, P } = CURVE;\n        hex = ensureBytes(hex, 32);\n        const normed = hex.slice();\n        normed[31] = hex[31] & ~0x80;\n        const y = bytesToNumberLE(normed);\n        if (strict && y >= P)\n            throw new Error('Expected 0 < hex < P');\n        if (!strict && y >= POW_2_256)\n            throw new Error('Expected 0 < hex < 2**256');\n        const y2 = mod(y * y);\n        const u = mod(y2 - _1n);\n        const v = mod(d * y2 + _1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid)\n            throw new Error('Point.fromHex: invalid y coordinate');\n        const isXOdd = (x & _1n) === _1n;\n        const isLastByteOdd = (hex[31] & 0x80) !== 0;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n        const bytes = numberTo32BytesLE(this.y);\n        bytes[31] |= this.x & _1n ? 0x80 : 0;\n        return bytes;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        const { y } = this;\n        const u = mod((_1n + y) * invert(_1n - y));\n        return numberTo32BytesLE(u);\n    }\n    isTorsionFree() {\n        return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex, 64);\n        const r = Point.fromHex(bytes.slice(0, 32), false);\n        const s = bytesToNumberLE(bytes.slice(32, 64));\n        return new Signature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!(r instanceof Point))\n            throw new Error('Expected Point instance');\n        normalizeScalar(s, CURVE.l, false);\n        return this;\n    }\n    toRawBytes() {\n        const u8 = new Uint8Array(64);\n        u8.set(this.r.toRawBytes());\n        u8.set(numberTo32BytesLE(this.s), 32);\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\nexport { ExtendedPoint, RistrettoPoint, Point, Signature };\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array list');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction numberTo32BytesBE(num) {\n    const length = 32;\n    const hex = num.toString(16).padStart(length * 2, '0');\n    return hexToBytes(hex);\n}\nfunction numberTo32BytesLE(num) {\n    return numberTo32BytesBE(num).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & MAX_255B);\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = mod(acc * tmp[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return tmp;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P;\n    const b4 = (pow2(b2, _2n) * b2) % P;\n    const b5 = (pow2(b4, _1n) * x) % P;\n    const b10 = (pow2(b5, _5n) * b5) % P;\n    const b20 = (pow2(b10, _10n) * b10) % P;\n    const b40 = (pow2(b20, _20n) * b20) % P;\n    const b80 = (pow2(b40, _40n) * b40) % P;\n    const b160 = (pow2(b80, _80n) * b80) % P;\n    const b240 = (pow2(b160, _80n) * b80) % P;\n    const b250 = (pow2(b240, _10n) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n) * x) % P;\n    return { pow_p_5_8, b2 };\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2;\n    if (edIsNegative(x))\n        x = mod(-x);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nfunction invertSqrt(number) {\n    return uvRatio(_1n, number);\n}\nfunction modlLE(hash) {\n    return mod(bytesToNumberLE(hash), CURVE.l);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === 'number' && bytes.length !== expectedLength)\n        throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n    if (!max)\n        throw new TypeError('Specify max value');\n    if (typeof num === 'number' && Number.isSafeInteger(num))\n        num = BigInt(num);\n    if (typeof num === 'bigint' && num < max) {\n        if (strict) {\n            if (_0n < num)\n                return num;\n        }\n        else {\n            if (_0n <= num)\n                return num;\n        }\n    }\n    throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\nfunction adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n}\nfunction decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nfunction checkPrivateKey(key) {\n    key =\n        typeof key === 'bigint' || typeof key === 'number'\n            ? numberTo32BytesBE(normalizeScalar(key, POW_2_256))\n            : ensureBytes(key);\n    if (key.length !== 32)\n        throw new Error(`Expected 32 bytes`);\n    return key;\n}\nfunction getKeyFromHash(hashed) {\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = modlLE(head);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return { head, prefix, scalar, point, pointBytes };\n}\nlet _sha512Sync;\nfunction sha512s(...m) {\n    if (typeof _sha512Sync !== 'function')\n        throw new Error('utils.sha512Sync must be set to use sync methods');\n    return _sha512Sync(...m);\n}\nasync function getExtendedPublicKey(key) {\n    return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));\n}\nfunction getExtendedPublicKeySync(key) {\n    return getKeyFromHash(sha512s(checkPrivateKey(key)));\n}\nexport async function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nfunction getPublicKeySync(privateKey) {\n    return getExtendedPublicKeySync(privateKey).pointBytes;\n}\nexport async function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);\n    const r = modlLE(await utils.sha512(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction signSync(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);\n    const r = modlLE(sha512s(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction prepareVerification(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point))\n        publicKey = Point.fromHex(publicKey, false);\n    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n    return { r, s, SB, pub: publicKey, msg: message };\n}\nfunction finishVerification(publicKey, r, SB, hashed) {\n    const k = modlLE(hashed);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nexport async function verify(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nfunction verifySync(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nexport const sync = {\n    getExtendedPublicKey: getExtendedPublicKeySync,\n    getPublicKey: getPublicKeySync,\n    sign: signSync,\n    verify: verifySync,\n};\nexport async function getSharedSecret(privateKey, publicKey) {\n    const { head } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return curve25519.scalarMult(head, u);\n}\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [x_2, x_3];\n}\nfunction montgomeryLadder(pointU, scalar) {\n    const { P } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(255 - 1); t >= _0n; t--) {\n        const k_t = (k >> t) & _1n;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = mod(A * A);\n        const B = x_2 - z_2;\n        const BB = mod(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = mod(D * A);\n        const CB = mod(C * B);\n        const dacb = DA + CB;\n        const da_cb = DA - CB;\n        x_3 = mod(dacb * dacb);\n        z_3 = mod(x_1 * mod(da_cb * da_cb));\n        x_2 = mod(AA * BB);\n        z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n    return numberTo32BytesLE(mod(u, CURVE.P));\n}\nfunction decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n}\nexport const curve25519 = {\n    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n    scalarMult(privateKey, publicKey) {\n        const u = decodeUCoordinate(publicKey);\n        const p = decodeScalar25519(privateKey);\n        const pu = montgomeryLadder(u, p);\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    },\n    scalarMultBase(privateKey) {\n        return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n    },\n};\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nexport const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    getExtendedPublicKey,\n    mod,\n    invert,\n    TORSION_SUBGROUP: [\n        '0100000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n        '0000000000000000000000000000000000000000000000000000000000000080',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n        '0000000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n    ],\n    hashToPrivateScalar: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.randomBytes(32);\n    },\n    sha512: async (...messages) => {\n        const message = concatBytes(...messages);\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_2n);\n        return cached;\n    },\n    sha512Sync: undefined,\n};\nObject.defineProperties(utils, {\n    sha512Sync: {\n        configurable: false,\n        get() {\n            return _sha512Sync;\n        },\n        set(val) {\n            if (!_sha512Sync)\n                _sha512Sync = val;\n        },\n    },\n});\n"]},"metadata":{},"sourceType":"module"}