{"ast":null,"code":"import { findLevelJs } from '../../utils.js';\nimport { fromString } from 'uint8arrays/from-string';\nimport { toString } from 'uint8arrays/to-string';\n/**\n * @typedef {import('../../types').Migration} Migration\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('../../types').MigrationProgressCallback} MigrationProgressCallback\n *\n * @typedef {{ type: 'del', key: string | Uint8Array } | { type: 'put', key: string | Uint8Array, value: Uint8Array }} Operation\n * @typedef {function (string, Uint8Array): Operation[]} UpgradeFunction\n * @typedef {function (Uint8Array, Uint8Array): Operation[]} DowngradeFunction\n */\n\n/**\n * @param {string} name\n * @param {Datastore} store\n * @param {(message: string) => void} onProgress\n */\n\nasync function keysToBinary(name, store) {\n  let onProgress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};\n  const db = findLevelJs(store); // only interested in level-js\n\n  if (!db) {\n    onProgress(`${name} did not need an upgrade`);\n    return;\n  }\n\n  onProgress(`Upgrading ${name}`);\n  /**\n   * @type {UpgradeFunction}\n   */\n\n  const upgrade = (key, value) => {\n    return [{\n      type: 'del',\n      key: key\n    }, {\n      type: 'put',\n      key: fromString(key),\n      value: value\n    }];\n  };\n\n  await withEach(db, upgrade);\n}\n/**\n * @param {string} name\n * @param {Datastore} store\n * @param {(message: string) => void} onProgress\n */\n\n\nasync function keysToStrings(name, store) {\n  let onProgress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};\n  const db = findLevelJs(store); // only interested in level-js\n\n  if (!db) {\n    onProgress(`${name} did not need a downgrade`);\n    return;\n  }\n\n  onProgress(`Downgrading ${name}`);\n  /**\n   * @type {DowngradeFunction}\n   */\n\n  const downgrade = (key, value) => {\n    return [{\n      type: 'del',\n      key: key\n    }, {\n      type: 'put',\n      key: toString(key),\n      value: value\n    }];\n  };\n\n  await withEach(db, downgrade);\n}\n/**\n * @param {any} store\n * @returns {Datastore}\n */\n\n\nfunction unwrap(store) {\n  if (store.child) {\n    return unwrap(store.child);\n  }\n\n  return store;\n}\n/**\n * @param {import('../../types').Backends} backends\n * @param {MigrationProgressCallback} onProgress\n * @param {*} fn\n */\n\n\nasync function process(backends, onProgress, fn) {\n  /**\n   * @type {{ name: string, store: Datastore }[]}\n   */\n  const datastores = Object.entries(backends).map(_ref => {\n    let [key, backend] = _ref;\n    return {\n      key,\n      backend: unwrap(backend)\n    };\n  }).filter(_ref2 => {\n    let {\n      key,\n      backend\n    } = _ref2;\n    return backend.constructor.name === 'LevelDatastore';\n  }).map(_ref3 => {\n    let {\n      key,\n      backend\n    } = _ref3;\n    return {\n      name: key,\n      store: backend\n    };\n  });\n  onProgress(0, `Migrating ${datastores.length} dbs`);\n  let migrated = 0;\n  /**\n   * @param {string} message\n   */\n\n  const progress = message => {\n    onProgress(Math.round(migrated / datastores.length * 100), message);\n  };\n\n  for (const {\n    name,\n    store\n  } of datastores) {\n    await store.open();\n\n    try {\n      await fn(name, store, progress);\n    } finally {\n      migrated++;\n      await store.close();\n    }\n  }\n\n  onProgress(100, `Migrated ${datastores.length} dbs`);\n}\n/** @type {Migration} */\n\n\nexport const migration = {\n  version: 10,\n  description: 'Migrates datastore-level keys to binary',\n  migrate: function (backends) {\n    let onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n    return process(backends, onProgress, keysToBinary);\n  },\n  revert: function (backends) {\n    let onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n    return process(backends, onProgress, keysToStrings);\n  }\n};\n/**\n * Uses the upgrade strategy from level-js@5.x.x - note we can't call the `.upgrade` command\n * directly because it will be removed in level-js@6.x.x and we can't guarantee users will\n * have migrated by then - e.g. they may jump from level-js@4.x.x straight to level-js@6.x.x\n * so we have to duplicate the code here.\n *\n * @param {any} db\n * @param {UpgradeFunction | DowngradeFunction} fn\n * @returns {Promise<void>}\n */\n\nfunction withEach(db, fn) {\n  /**\n   * @param {Operation[]} operations\n   * @param {(error?: Error) => void} next\n   */\n  function batch(operations, next) {\n    const store = db.store('readwrite');\n    const transaction = store.transaction;\n    let index = 0;\n    /** @type {Error | undefined} */\n\n    let error;\n\n    transaction.onabort = () => next(error || transaction.error || new Error('aborted by user'));\n\n    transaction.oncomplete = () => next();\n\n    function loop() {\n      const op = operations[index++];\n      const key = op.key;\n      let req;\n\n      try {\n        req = op.type === 'del' ? store.delete(key) : store.put(op.value, key);\n      } catch (\n      /** @type {any} */\n      err) {\n        error = err;\n        transaction.abort();\n        return;\n      }\n\n      if (index < operations.length) {\n        req.onsuccess = loop;\n      }\n    }\n\n    loop();\n  }\n\n  return new Promise((resolve, reject) => {\n    const it = db.iterator(); // raw keys and values only\n\n    /**\n     * @template T\n     * @param {T} data\n     */\n\n    const id = data => data;\n\n    it._deserializeKey = it._deserializeValue = id;\n    next();\n\n    function next() {\n      /**\n       * @param {Error | undefined} err\n       * @param {string | undefined} key\n       * @param {Uint8Array} value\n       */\n      const handleNext = (err, key, value) => {\n        if (err || key === undefined) {\n          /**\n           * @param {Error | undefined} err2\n           */\n          const handleEnd = err2 => {\n            if (err2) {\n              reject(err2);\n              return;\n            }\n\n            resolve();\n          };\n\n          it.end(handleEnd);\n          return;\n        } // @ts-ignore\n\n\n        batch(fn(key, value), next);\n      };\n\n      it.next(handleNext);\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-repo-migrations/src/migrations/migration-10/index.js"],"names":["findLevelJs","fromString","toString","keysToBinary","name","store","onProgress","db","upgrade","key","value","type","withEach","keysToStrings","downgrade","unwrap","child","process","backends","fn","datastores","Object","entries","map","backend","filter","constructor","length","migrated","progress","message","Math","round","open","close","migration","version","description","migrate","revert","batch","operations","next","transaction","index","error","onabort","Error","oncomplete","loop","op","req","delete","put","err","abort","onsuccess","Promise","resolve","reject","it","iterator","id","data","_deserializeKey","_deserializeValue","handleNext","undefined","handleEnd","err2","end"],"mappings":"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","sourcesContent":["\nimport { findLevelJs } from '../../utils.js'\nimport { fromString } from 'uint8arrays/from-string'\nimport { toString } from 'uint8arrays/to-string'\n\n/**\n * @typedef {import('../../types').Migration} Migration\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('../../types').MigrationProgressCallback} MigrationProgressCallback\n *\n * @typedef {{ type: 'del', key: string | Uint8Array } | { type: 'put', key: string | Uint8Array, value: Uint8Array }} Operation\n * @typedef {function (string, Uint8Array): Operation[]} UpgradeFunction\n * @typedef {function (Uint8Array, Uint8Array): Operation[]} DowngradeFunction\n */\n\n/**\n * @param {string} name\n * @param {Datastore} store\n * @param {(message: string) => void} onProgress\n */\nasync function keysToBinary (name, store, onProgress = () => {}) {\n  const db = findLevelJs(store)\n\n  // only interested in level-js\n  if (!db) {\n    onProgress(`${name} did not need an upgrade`)\n\n    return\n  }\n\n  onProgress(`Upgrading ${name}`)\n\n  /**\n   * @type {UpgradeFunction}\n   */\n  const upgrade = (key, value) => {\n    return [\n      { type: 'del', key: key },\n      { type: 'put', key: fromString(key), value: value }\n    ]\n  }\n\n  await withEach(db, upgrade)\n}\n\n/**\n * @param {string} name\n * @param {Datastore} store\n * @param {(message: string) => void} onProgress\n */\nasync function keysToStrings (name, store, onProgress = () => {}) {\n  const db = findLevelJs(store)\n\n  // only interested in level-js\n  if (!db) {\n    onProgress(`${name} did not need a downgrade`)\n\n    return\n  }\n\n  onProgress(`Downgrading ${name}`)\n\n  /**\n   * @type {DowngradeFunction}\n   */\n  const downgrade = (key, value) => {\n    return [\n      { type: 'del', key: key },\n      { type: 'put', key: toString(key), value: value }\n    ]\n  }\n\n  await withEach(db, downgrade)\n}\n\n/**\n * @param {any} store\n * @returns {Datastore}\n */\nfunction unwrap (store) {\n  if (store.child) {\n    return unwrap(store.child)\n  }\n\n  return store\n}\n\n/**\n * @param {import('../../types').Backends} backends\n * @param {MigrationProgressCallback} onProgress\n * @param {*} fn\n */\nasync function process (backends, onProgress, fn) {\n  /**\n   * @type {{ name: string, store: Datastore }[]}\n   */\n  const datastores = Object.entries(backends)\n    .map(([key, backend]) => ({ key, backend: unwrap(backend) }))\n    .filter(({ key, backend }) => backend.constructor.name === 'LevelDatastore')\n    .map(({ key, backend }) => ({\n      name: key,\n      store: backend\n    }))\n\n  onProgress(0, `Migrating ${datastores.length} dbs`)\n  let migrated = 0\n\n  /**\n   * @param {string} message\n   */\n  const progress = (message) => {\n    onProgress(Math.round((migrated / datastores.length) * 100), message)\n  }\n\n  for (const { name, store } of datastores) {\n    await store.open()\n\n    try {\n      await fn(name, store, progress)\n    } finally {\n      migrated++\n      await store.close()\n    }\n  }\n\n  onProgress(100, `Migrated ${datastores.length} dbs`)\n}\n\n/** @type {Migration} */\nexport const migration = {\n  version: 10,\n  description: 'Migrates datastore-level keys to binary',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keysToBinary)\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keysToStrings)\n  }\n}\n\n/**\n * Uses the upgrade strategy from level-js@5.x.x - note we can't call the `.upgrade` command\n * directly because it will be removed in level-js@6.x.x and we can't guarantee users will\n * have migrated by then - e.g. they may jump from level-js@4.x.x straight to level-js@6.x.x\n * so we have to duplicate the code here.\n *\n * @param {any} db\n * @param {UpgradeFunction | DowngradeFunction} fn\n * @returns {Promise<void>}\n */\nfunction withEach (db, fn) {\n  /**\n   * @param {Operation[]} operations\n   * @param {(error?: Error) => void} next\n   */\n  function batch (operations, next) {\n    const store = db.store('readwrite')\n    const transaction = store.transaction\n    let index = 0\n    /** @type {Error | undefined} */\n    let error\n\n    transaction.onabort = () => next(error || transaction.error || new Error('aborted by user'))\n    transaction.oncomplete = () => next()\n\n    function loop () {\n      const op = operations[index++]\n      const key = op.key\n      let req\n\n      try {\n        req = op.type === 'del' ? store.delete(key) : store.put(op.value, key)\n      } catch (/** @type {any} */ err) {\n        error = err\n        transaction.abort()\n        return\n      }\n\n      if (index < operations.length) {\n        req.onsuccess = loop\n      }\n    }\n\n    loop()\n  }\n\n  return new Promise((resolve, reject) => {\n    const it = db.iterator()\n    // raw keys and values only\n    /**\n     * @template T\n     * @param {T} data\n     */\n    const id = (data) => data\n    it._deserializeKey = it._deserializeValue = id\n    next()\n\n    function next () {\n      /**\n       * @param {Error | undefined} err\n       * @param {string | undefined} key\n       * @param {Uint8Array} value\n       */\n      const handleNext = (err, key, value) => {\n        if (err || key === undefined) {\n          /**\n           * @param {Error | undefined} err2\n           */\n          const handleEnd = (err2) => {\n            if (err2) {\n              reject(err2)\n              return\n            }\n\n            resolve()\n          }\n\n          it.end(handleEnd)\n\n          return\n        }\n\n        // @ts-ignore\n        batch(fn(key, value), next)\n      }\n      it.next(handleNext)\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"module"}