{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errcode from 'err-code';\nimport { AbortError } from 'abortable-iterator';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport * as mafmt from '@multiformats/mafmt';\nimport { CODE_CIRCUIT } from './constants.js';\nimport { createListener } from './listener.js';\nimport { toMultiaddrConnection } from './socket-to-conn.js';\nimport { cleanMultiaddr, cleanUrlSIO } from './utils.js';\nimport { WebRTCInitiator } from '@libp2p/webrtc-peer';\nimport randomBytes from 'iso-random-stream/src/random.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays';\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { symbol } from '@libp2p/interface-transport';\nimport { symbol as peerDiscoverySymbol } from '@libp2p/interface-peer-discovery';\nconst webrtcSupport = ('RTCPeerConnection' in globalThis);\nconst log = logger('libp2p:webrtc-star');\n\nconst noop = () => {};\n\nexport class WebRTCStarDiscovery extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.started = false;\n  }\n\n  get [peerDiscoverySymbol]() {\n    return true;\n  }\n\n  get [Symbol.toStringTag]() {\n    return '@libp2p/webrtc-star-discovery';\n  }\n\n  isStarted() {\n    return this.started;\n  }\n\n  async start() {\n    this.started = true;\n  }\n\n  async stop() {\n    this.started = false;\n  }\n\n  dispatchEvent(event) {\n    if (!this.isStarted()) {\n      return false;\n    }\n\n    return super.dispatchEvent(event);\n  }\n\n}\n/**\n * @class WebRTCStar\n */\n\nexport class WebRTCStar {\n  constructor(init) {\n    if (init?.wrtc != null) {\n      this.wrtc = init.wrtc;\n    } // Keep Signalling references\n\n\n    this.sigServers = new Map(); // Discovery\n\n    this._discovery = new WebRTCStarDiscovery();\n\n    this.discovery = () => this._discovery;\n\n    this.peerDiscovered = this.peerDiscovered.bind(this);\n  }\n\n  get [symbol]() {\n    return true;\n  }\n\n  get [Symbol.toStringTag]() {\n    return '@libp2p/webrtc-star';\n  }\n\n  async dial(ma, options) {\n    const rawConn = await this._connect(ma, options);\n    const maConn = toMultiaddrConnection(rawConn, {\n      remoteAddr: ma,\n      signal: options.signal\n    });\n    log('new outbound connection %s', maConn.remoteAddr);\n    const conn = await options.upgrader.upgradeOutbound(maConn);\n    log('outbound connection %s upgraded', maConn.remoteAddr);\n    return conn;\n  }\n\n  async _connect(ma, options) {\n    if (options.signal?.aborted === true) {\n      throw new AbortError();\n    }\n\n    const channelOptions = { ...(options.channelOptions ?? {})\n    }; // Use custom WebRTC implementation\n\n    if (this.wrtc != null) {\n      channelOptions.wrtc = this.wrtc;\n    }\n\n    const cOpts = ma.toOptions();\n    const intentId = uint8ArrayToString(randomBytes(36), 'hex');\n    return await new Promise((resolve, reject) => {\n      const sio = this.sigServers.get(cleanUrlSIO(ma));\n\n      if (sio?.socket == null) {\n        return reject(errcode(new Error('unknown signal server to use'), 'ERR_UNKNOWN_SIGNAL_SERVER'));\n      }\n\n      let connected = false;\n      log('dialing %s:%s', cOpts.host, cOpts.port);\n      const channel = new WebRTCInitiator(channelOptions);\n\n      const onError = evt => {\n        const err = evt.detail;\n\n        if (!connected) {\n          const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err.message}`;\n          log.error(msg);\n          done(err);\n        }\n      };\n\n      const onReady = () => {\n        connected = true;\n        log('connection opened %s:%s', cOpts.host, cOpts.port);\n        done();\n      };\n\n      const onAbort = () => {\n        log.error('connection aborted %s:%s', cOpts.host, cOpts.port);\n        channel.close().finally(() => {\n          done(new AbortError());\n        });\n      };\n\n      const done = err => {\n        channel.removeEventListener('ready', onReady);\n        options.signal?.removeEventListener('abort', onAbort);\n\n        if (err == null) {\n          resolve(channel);\n        } else {\n          reject(err);\n        }\n      };\n\n      channel.addEventListener('ready', onReady, {\n        once: true\n      });\n      channel.addEventListener('close', () => {\n        channel.removeEventListener('error', onError);\n      });\n      options.signal?.addEventListener('abort', onAbort);\n      channel.addEventListener('signal', evt => {\n        const signal = evt.detail;\n        sio.socket.emit('ss-handshake', {\n          intentId: intentId,\n          srcMultiaddr: sio.signallingAddr.toString(),\n          dstMultiaddr: ma.toString(),\n          signal: signal\n        });\n      });\n      sio.socket.on('ws-handshake', offer => {\n        if (offer.intentId === intentId && offer.err != null) {\n          channel.close().finally(() => {\n            reject(errcode(new Error(offer.err), 'ERR_SIGNALLING_FAILED'));\n          });\n        }\n\n        if (offer.intentId !== intentId || offer.answer == null || channel.closed) {\n          return;\n        }\n\n        channel.handleSignal(offer.signal);\n      });\n    });\n  }\n  /**\n   * Creates a WebrtcStar listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   */\n\n\n  createListener(options) {\n    if (!webrtcSupport && this.wrtc == null) {\n      throw errcode(new Error('no WebRTC support'), 'ERR_NO_WEBRTC_SUPPORT');\n    }\n\n    options.channelOptions = options.channelOptions ?? {};\n\n    if (this.wrtc != null) {\n      options.channelOptions.wrtc = this.wrtc;\n    }\n\n    if (this.peerId == null) {\n      throw errcode(new Error('PeerId not set'), 'ERR_MISSING_PEER_ID');\n    }\n\n    return createListener(options.upgrader, options.handler ?? noop, this.peerId, this, options);\n  }\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid TCP addresses\n   */\n\n\n  filter(multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n    return multiaddrs.filter(ma => {\n      if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n        return false;\n      }\n\n      return mafmt.WebRTCStar.matches(ma);\n    });\n  }\n\n  peerDiscovered(maStr) {\n    log('peer discovered: %s', maStr);\n    maStr = cleanMultiaddr(maStr);\n    const ma = multiaddr(maStr);\n    const peerIdStr = ma.getPeerId();\n\n    if (peerIdStr == null) {\n      return;\n    }\n\n    const peerId = peerIdFromString(peerIdStr);\n\n    this._discovery.dispatchEvent(new CustomEvent('peer', {\n      detail: {\n        id: peerId,\n        multiaddrs: [ma],\n        protocols: []\n      }\n    }));\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","errcode","AbortError","multiaddr","mafmt","CODE_CIRCUIT","createListener","toMultiaddrConnection","cleanMultiaddr","cleanUrlSIO","WebRTCInitiator","randomBytes","toString","uint8ArrayToString","EventEmitter","CustomEvent","peerIdFromString","symbol","peerDiscoverySymbol","webrtcSupport","globalThis","log","noop","WebRTCStarDiscovery","constructor","Symbol","toStringTag","isStarted","started","start","stop","dispatchEvent","event","WebRTCStar","init","wrtc","sigServers","Map","_discovery","discovery","peerDiscovered","bind","dial","ma","options","rawConn","_connect","maConn","remoteAddr","signal","conn","upgrader","upgradeOutbound","aborted","channelOptions","cOpts","toOptions","intentId","Promise","resolve","reject","sio","get","socket","Error","connected","host","port","channel","onError","evt","err","detail","msg","message","error","done","onReady","onAbort","close","finally","removeEventListener","addEventListener","once","emit","srcMultiaddr","signallingAddr","dstMultiaddr","on","offer","answer","closed","handleSignal","peerId","handler","filter","multiaddrs","Array","isArray","protoCodes","includes","matches","maStr","peerIdStr","getPeerId","id","protocols"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\webrtc-star\\src\\transport.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errcode from 'err-code'\nimport { AbortError } from 'abortable-iterator'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport * as mafmt from '@multiformats/mafmt'\nimport { CODE_CIRCUIT } from './constants.js'\nimport { createListener } from './listener.js'\nimport { toMultiaddrConnection } from './socket-to-conn.js'\nimport { cleanMultiaddr, cleanUrlSIO } from './utils.js'\nimport { WebRTCInitiator } from '@libp2p/webrtc-peer'\nimport randomBytes from 'iso-random-stream/src/random.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays'\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { symbol } from '@libp2p/interface-transport'\nimport type { WRTC, WebRTCInitiatorInit, WebRTCReceiver, WebRTCReceiverInit } from '@libp2p/webrtc-peer'\nimport type { Connection, MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { Transport, Listener, DialOptions, CreateListenerOptions } from '@libp2p/interface-transport'\nimport type { PeerDiscovery, PeerDiscoveryEvents } from '@libp2p/interface-peer-discovery'\nimport type { WebRTCStarSocket, HandshakeSignal } from '@libp2p/webrtc-star-protocol'\nimport { symbol as peerDiscoverySymbol } from '@libp2p/interface-peer-discovery'\nimport type { PeerId } from '@libp2p/interface-peer-id'\n\nconst webrtcSupport = 'RTCPeerConnection' in globalThis\nconst log = logger('libp2p:webrtc-star')\n\nconst noop = () => {}\n\nexport class WebRTCStarDiscovery extends EventEmitter<PeerDiscoveryEvents> implements PeerDiscovery, Startable {\n  private started = false\n\n  get [peerDiscoverySymbol] (): true {\n    return true\n  }\n\n  get [Symbol.toStringTag] () {\n    return '@libp2p/webrtc-star-discovery'\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  async start () {\n    this.started = true\n  }\n\n  async stop () {\n    this.started = false\n  }\n\n  dispatchEvent (event: CustomEvent) {\n    if (!this.isStarted()) {\n      return false\n    }\n\n    return super.dispatchEvent(event)\n  }\n}\n\nexport interface WebRTCStarInit {\n  wrtc?: WRTC\n}\n\nexport interface WebRTCStarDialOptions extends DialOptions {\n  channelOptions?: WebRTCInitiatorInit\n}\n\nexport interface WebRTCStarListenerOptions extends CreateListenerOptions, WebRTCInitiatorInit {\n  channelOptions?: WebRTCReceiverInit\n}\n\nexport interface SignalServerServerEvents {\n  'error': CustomEvent<Error>\n  'listening': CustomEvent\n  'peer': CustomEvent<string>\n  'connection': CustomEvent<Connection>\n  'disconnect': CustomEvent\n  'reconnect': CustomEvent\n}\n\nexport interface SignalServer extends EventEmitter<SignalServerServerEvents> {\n  signallingAddr: Multiaddr\n  socket: WebRTCStarSocket\n  connections: MultiaddrConnection[]\n  channels: Map<string, WebRTCReceiver>\n  pendingSignals: Map<string, HandshakeSignal[]>\n  close: () => Promise<void>\n}\n\nexport interface WebRTCStarComponents {\n  peerId: PeerId\n}\n\n/**\n * @class WebRTCStar\n */\nexport class WebRTCStar implements Transport {\n  public wrtc?: WRTC\n  public discovery: () => PeerDiscovery & Startable\n  public sigServers: Map<string, SignalServer>\n  private readonly _discovery: WebRTCStarDiscovery\n  public peerId?: PeerId\n\n  constructor (init?: WebRTCStarInit) {\n    if (init?.wrtc != null) {\n      this.wrtc = init.wrtc\n    }\n\n    // Keep Signalling references\n    this.sigServers = new Map()\n\n    // Discovery\n    this._discovery = new WebRTCStarDiscovery()\n    this.discovery = () => this._discovery\n    this.peerDiscovered = this.peerDiscovered.bind(this)\n  }\n\n  get [symbol] (): true {\n    return true\n  }\n\n  get [Symbol.toStringTag] () {\n    return '@libp2p/webrtc-star'\n  }\n\n  async dial (ma: Multiaddr, options: WebRTCStarDialOptions) {\n    const rawConn = await this._connect(ma, options)\n    const maConn = toMultiaddrConnection(rawConn, { remoteAddr: ma, signal: options.signal })\n    log('new outbound connection %s', maConn.remoteAddr)\n    const conn = await options.upgrader.upgradeOutbound(maConn)\n    log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  async _connect (ma: Multiaddr, options: WebRTCStarDialOptions) {\n    if (options.signal?.aborted === true) {\n      throw new AbortError()\n    }\n\n    const channelOptions = {\n      ...(options.channelOptions ?? {})\n    }\n\n    // Use custom WebRTC implementation\n    if (this.wrtc != null) {\n      channelOptions.wrtc = this.wrtc\n    }\n\n    const cOpts = ma.toOptions()\n    const intentId = uint8ArrayToString(randomBytes(36), 'hex')\n\n    return await new Promise<WebRTCInitiator>((resolve, reject) => {\n      const sio = this.sigServers.get(cleanUrlSIO(ma))\n\n      if (sio?.socket == null) {\n        return reject(errcode(new Error('unknown signal server to use'), 'ERR_UNKNOWN_SIGNAL_SERVER'))\n      }\n\n      let connected: boolean = false\n\n      log('dialing %s:%s', cOpts.host, cOpts.port)\n      const channel = new WebRTCInitiator(channelOptions)\n\n      const onError = (evt: CustomEvent<Error>) => {\n        const err = evt.detail\n\n        if (!connected) {\n          const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err.message}`\n          log.error(msg)\n          done(err)\n        }\n      }\n\n      const onReady = () => {\n        connected = true\n\n        log('connection opened %s:%s', cOpts.host, cOpts.port)\n        done()\n      }\n\n      const onAbort = () => {\n        log.error('connection aborted %s:%s', cOpts.host, cOpts.port)\n        channel.close().finally(() => {\n          done(new AbortError())\n        })\n      }\n\n      const done = (err?: Error) => {\n        channel.removeEventListener('ready', onReady)\n        options.signal?.removeEventListener('abort', onAbort)\n\n        if (err == null) {\n          resolve(channel)\n        } else {\n          reject(err)\n        }\n      }\n\n      channel.addEventListener('ready', onReady, {\n        once: true\n      })\n      channel.addEventListener('close', () => {\n        channel.removeEventListener('error', onError)\n      })\n      options.signal?.addEventListener('abort', onAbort)\n\n      channel.addEventListener('signal', (evt) => {\n        const signal = evt.detail\n\n        sio.socket.emit('ss-handshake', {\n          intentId: intentId,\n          srcMultiaddr: sio.signallingAddr.toString(),\n          dstMultiaddr: ma.toString(),\n          signal: signal\n        })\n      })\n\n      sio.socket.on('ws-handshake', (offer) => {\n        if (offer.intentId === intentId && offer.err != null) {\n          channel.close().finally(() => {\n            reject(errcode(new Error(offer.err), 'ERR_SIGNALLING_FAILED'))\n          })\n        }\n\n        if (offer.intentId !== intentId || offer.answer == null || channel.closed) {\n          return\n        }\n\n        channel.handleSignal(offer.signal)\n      })\n    })\n  }\n\n  /**\n   * Creates a WebrtcStar listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   */\n  createListener (options: WebRTCStarListenerOptions): Listener {\n    if (!webrtcSupport && this.wrtc == null) {\n      throw errcode(new Error('no WebRTC support'), 'ERR_NO_WEBRTC_SUPPORT')\n    }\n\n    options.channelOptions = options.channelOptions ?? {}\n\n    if (this.wrtc != null) {\n      options.channelOptions.wrtc = this.wrtc\n    }\n\n    if (this.peerId == null) {\n      throw errcode(new Error('PeerId not set'), 'ERR_MISSING_PEER_ID')\n    }\n\n    return createListener(options.upgrader, options.handler ?? noop, this.peerId, this, options)\n  }\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid TCP addresses\n   */\n  filter (multiaddrs: Multiaddr[]) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    return multiaddrs.filter((ma) => {\n      if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n        return false\n      }\n\n      return mafmt.WebRTCStar.matches(ma)\n    })\n  }\n\n  peerDiscovered (maStr: string) {\n    log('peer discovered: %s', maStr)\n    maStr = cleanMultiaddr(maStr)\n\n    const ma = multiaddr(maStr)\n    const peerIdStr = ma.getPeerId()\n\n    if (peerIdStr == null) {\n      return\n    }\n\n    const peerId = peerIdFromString(peerIdStr)\n\n    this._discovery.dispatchEvent(new CustomEvent('peer', {\n      detail: {\n        id: peerId,\n        multiaddrs: [ma],\n        protocols: []\n      }\n    }))\n  }\n}\n"]},"metadata":{},"sourceType":"module"}