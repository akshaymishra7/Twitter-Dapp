{"ast":null,"code":"import { TimeoutController } from 'timeout-abort-controller';\nimport { anySignal } from 'any-signal';\nimport { ALPHA, K, DEFAULT_QUERY_TIMEOUT } from '../constants.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { queryPath } from './query-path.js';\nimport merge from 'it-merge';\nimport { setMaxListeners } from 'events';\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';\nimport { logger } from '@libp2p/logger';\nimport { PeerSet } from '@libp2p/peer-collections';\n/**\n * Keeps track of all running queries\n */\n\nexport class QueryManager {\n  constructor(components, init) {\n    const {\n      lan = false,\n      disjointPaths = K,\n      alpha = ALPHA\n    } = init;\n    this.components = components;\n    this.disjointPaths = disjointPaths ?? K;\n    this.controllers = new Set();\n    this.running = false;\n    this.alpha = alpha ?? ALPHA;\n    this.lan = lan;\n    this.queries = 0;\n  }\n\n  isStarted() {\n    return this.running;\n  }\n  /**\n   * Starts the query manager\n   */\n\n\n  async start() {\n    this.running = true;\n\n    if (this.components.metrics != null && this.metrics == null) {\n      this.metrics = {\n        runningQueries: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? 'lan' : 'wan'}_running_queries`),\n        queryTime: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? 'lan' : 'wan'}_query_time_seconds`)\n      };\n    }\n  }\n  /**\n   * Stops all queries\n   */\n\n\n  async stop() {\n    this.running = false;\n\n    for (const controller of this.controllers) {\n      controller.abort();\n    }\n\n    this.controllers.clear();\n  }\n\n  async *run(key, peers, queryFunc) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    if (!this.running) {\n      throw new Error('QueryManager not started');\n    }\n\n    const stopQueryTimer = this.metrics?.queryTime.timer();\n    let timeoutController;\n\n    if (options.signal == null) {\n      // don't let queries run forever\n      timeoutController = new TimeoutController(DEFAULT_QUERY_TIMEOUT);\n      options.signal = timeoutController.signal; // this signal will get listened to for network requests, etc\n      // so make sure we don't make a lot of noise in the logs\n\n      try {\n        if (setMaxListeners != null) {\n          setMaxListeners(Infinity, timeoutController.signal);\n        }\n      } catch {} // fails on node < 15.4\n\n    } // allow us to stop queries on shut down\n\n\n    const abortController = new AbortController();\n    this.controllers.add(abortController);\n    const signals = [abortController.signal];\n\n    if (options.signal != null) {\n      signals.push(options.signal);\n    }\n\n    const signal = anySignal(signals); // this signal will get listened to for every invocation of queryFunc\n    // so make sure we don't make a lot of noise in the logs\n\n    try {\n      if (setMaxListeners != null) {\n        setMaxListeners(Infinity, signal);\n      }\n    } catch {} // fails on node < 15.4\n\n\n    const log = logger(`libp2p:kad-dht:${this.lan ? 'lan' : 'wan'}:query:` + uint8ArrayToString(key, 'base58btc')); // query a subset of peers up to `kBucketSize / 2` in length\n\n    const peersToQuery = peers.slice(0, Math.min(this.disjointPaths, peers.length));\n    const startTime = Date.now();\n    const cleanUp = new EventEmitter();\n\n    try {\n      log('query:start');\n      this.queries++;\n      this.metrics?.runningQueries.update(this.queries);\n\n      if (peers.length === 0) {\n        log.error('Running query with no peers');\n        return;\n      } // make sure we don't get trapped in a loop\n\n\n      const peersSeen = new PeerSet(); // Create query paths from the starting peers\n\n      const paths = peersToQuery.map((peer, index) => {\n        return queryPath({\n          key,\n          startingPeer: peer,\n          ourPeerId: this.components.peerId,\n          signal,\n          query: queryFunc,\n          pathIndex: index,\n          numPaths: peersToQuery.length,\n          alpha: this.alpha,\n          cleanUp,\n          queryFuncTimeout: options.queryFuncTimeout,\n          log,\n          peersSeen\n        });\n      }); // Execute the query along each disjoint path and yield their results as they become available\n\n      for await (const event of merge(...paths)) {\n        yield event;\n\n        if (event.name === 'QUERY_ERROR') {\n          log('error', event.error);\n        }\n      }\n    } catch (err) {\n      if (!this.running && err.code === 'ERR_QUERY_ABORTED') {// ignore query aborted errors that were thrown during query manager shutdown\n      } else {\n        throw err;\n      }\n    } finally {\n      this.controllers.delete(abortController);\n\n      if (timeoutController != null) {\n        timeoutController.clear();\n      }\n\n      this.queries--;\n      this.metrics?.runningQueries.update(this.queries);\n\n      if (stopQueryTimer != null) {\n        stopQueryTimer();\n      }\n\n      cleanUp.dispatchEvent(new CustomEvent('cleanup'));\n      log('query:done in %dms', Date.now() - startTime);\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["TimeoutController","anySignal","ALPHA","K","DEFAULT_QUERY_TIMEOUT","toString","uint8ArrayToString","queryPath","merge","setMaxListeners","EventEmitter","CustomEvent","logger","PeerSet","QueryManager","constructor","components","init","lan","disjointPaths","alpha","controllers","Set","running","queries","isStarted","start","metrics","runningQueries","registerMetric","queryTime","stop","controller","abort","clear","run","key","peers","queryFunc","options","Error","stopQueryTimer","timer","timeoutController","signal","Infinity","abortController","AbortController","add","signals","push","log","peersToQuery","slice","Math","min","length","startTime","Date","now","cleanUp","update","error","peersSeen","paths","map","peer","index","startingPeer","ourPeerId","peerId","query","pathIndex","numPaths","queryFuncTimeout","event","name","err","code","delete","dispatchEvent"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\query\\manager.ts"],"sourcesContent":["import { TimeoutController } from 'timeout-abort-controller'\nimport { anySignal } from 'any-signal'\nimport {\n  ALPHA, K, DEFAULT_QUERY_TIMEOUT\n} from '../constants.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { queryPath } from './query-path.js'\nimport merge from 'it-merge'\nimport { setMaxListeners } from 'events'\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events'\nimport { logger } from '@libp2p/logger'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { QueryFunc } from './types.js'\nimport type { QueryEvent, QueryOptions } from '@libp2p/interface-dht'\nimport { PeerSet } from '@libp2p/peer-collections'\nimport type { Metric, Metrics } from '@libp2p/interface-metrics'\n\nexport interface CleanUpEvents {\n  'cleanup': CustomEvent\n}\n\nexport interface QueryManagerInit {\n  lan?: boolean\n  disjointPaths?: number\n  alpha?: number\n}\n\nexport interface QueryManagerComponents {\n  peerId: PeerId\n  metrics?: Metrics\n}\n\n/**\n * Keeps track of all running queries\n */\nexport class QueryManager implements Startable {\n  private readonly components: QueryManagerComponents\n  private readonly lan: boolean\n  public disjointPaths: number\n  private readonly alpha: number\n  private readonly controllers: Set<AbortController>\n  private running: boolean\n  private queries: number\n  private metrics?: {\n    runningQueries: Metric\n    queryTime: Metric\n  }\n\n  constructor (components: QueryManagerComponents, init: QueryManagerInit) {\n    const { lan = false, disjointPaths = K, alpha = ALPHA } = init\n\n    this.components = components\n    this.disjointPaths = disjointPaths ?? K\n    this.controllers = new Set()\n    this.running = false\n    this.alpha = alpha ?? ALPHA\n    this.lan = lan\n    this.queries = 0\n  }\n\n  isStarted (): boolean {\n    return this.running\n  }\n\n  /**\n   * Starts the query manager\n   */\n  async start (): Promise<void> {\n    this.running = true\n\n    if (this.components.metrics != null && this.metrics == null) {\n      this.metrics = {\n        runningQueries: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? 'lan' : 'wan'}_running_queries`),\n        queryTime: this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan ? 'lan' : 'wan'}_query_time_seconds`)\n      }\n    }\n  }\n\n  /**\n   * Stops all queries\n   */\n  async stop (): Promise<void> {\n    this.running = false\n\n    for (const controller of this.controllers) {\n      controller.abort()\n    }\n\n    this.controllers.clear()\n  }\n\n  async * run (key: Uint8Array, peers: PeerId[], queryFunc: QueryFunc, options: QueryOptions = {}): AsyncGenerator<QueryEvent> {\n    if (!this.running) {\n      throw new Error('QueryManager not started')\n    }\n\n    const stopQueryTimer = this.metrics?.queryTime.timer()\n    let timeoutController\n\n    if (options.signal == null) {\n      // don't let queries run forever\n      timeoutController = new TimeoutController(DEFAULT_QUERY_TIMEOUT)\n      options.signal = timeoutController.signal\n\n      // this signal will get listened to for network requests, etc\n      // so make sure we don't make a lot of noise in the logs\n      try {\n        if (setMaxListeners != null) {\n          setMaxListeners(Infinity, timeoutController.signal)\n        }\n      } catch {} // fails on node < 15.4\n    }\n\n    // allow us to stop queries on shut down\n    const abortController = new AbortController()\n    this.controllers.add(abortController)\n    const signals = [abortController.signal]\n\n    if (options.signal != null) {\n      signals.push(options.signal)\n    }\n\n    const signal = anySignal(signals)\n\n    // this signal will get listened to for every invocation of queryFunc\n    // so make sure we don't make a lot of noise in the logs\n    try {\n      if (setMaxListeners != null) {\n        setMaxListeners(Infinity, signal)\n      }\n    } catch {} // fails on node < 15.4\n\n    const log = logger(`libp2p:kad-dht:${this.lan ? 'lan' : 'wan'}:query:` + uint8ArrayToString(key, 'base58btc'))\n\n    // query a subset of peers up to `kBucketSize / 2` in length\n    const peersToQuery = peers.slice(0, Math.min(this.disjointPaths, peers.length))\n    const startTime = Date.now()\n    const cleanUp = new EventEmitter<CleanUpEvents>()\n\n    try {\n      log('query:start')\n      this.queries++\n      this.metrics?.runningQueries.update(this.queries)\n\n      if (peers.length === 0) {\n        log.error('Running query with no peers')\n        return\n      }\n\n      // make sure we don't get trapped in a loop\n      const peersSeen = new PeerSet()\n\n      // Create query paths from the starting peers\n      const paths = peersToQuery.map((peer, index) => {\n        return queryPath({\n          key,\n          startingPeer: peer,\n          ourPeerId: this.components.peerId,\n          signal,\n          query: queryFunc,\n          pathIndex: index,\n          numPaths: peersToQuery.length,\n          alpha: this.alpha,\n          cleanUp,\n          queryFuncTimeout: options.queryFuncTimeout,\n          log,\n          peersSeen\n        })\n      })\n\n      // Execute the query along each disjoint path and yield their results as they become available\n      for await (const event of merge(...paths)) {\n        yield event\n\n        if (event.name === 'QUERY_ERROR') {\n          log('error', event.error)\n        }\n      }\n    } catch (err: any) {\n      if (!this.running && err.code === 'ERR_QUERY_ABORTED') {\n        // ignore query aborted errors that were thrown during query manager shutdown\n      } else {\n        throw err\n      }\n    } finally {\n      this.controllers.delete(abortController)\n\n      if (timeoutController != null) {\n        timeoutController.clear()\n      }\n\n      this.queries--\n      this.metrics?.runningQueries.update(this.queries)\n\n      if (stopQueryTimer != null) {\n        stopQueryTimer()\n      }\n\n      cleanUp.dispatchEvent(new CustomEvent('cleanup'))\n      log('query:done in %dms', Date.now() - startTime)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}