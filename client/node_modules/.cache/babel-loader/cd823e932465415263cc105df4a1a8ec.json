{"ast":null,"code":"import { xor as uint8ArrayXor } from 'uint8arrays/xor';\nimport GENERATED_PREFIXES from './generated-prefix-list.js';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { randomBytes } from '@libp2p/crypto';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport { logger } from '@libp2p/logger';\nimport length from 'it-length';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { TABLE_REFRESH_INTERVAL, TABLE_REFRESH_QUERY_TIMEOUT } from '../constants.js';\n/**\n * Cannot generate random KadIds longer than this + 1\n */\n\nconst MAX_COMMON_PREFIX_LENGTH = 15;\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\n\nexport class RoutingTableRefresh {\n  constructor(init) {\n    const {\n      peerRouting,\n      routingTable,\n      refreshInterval,\n      refreshQueryTimeout,\n      lan\n    } = init;\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:routing-table:refresh`);\n    this.peerRouting = peerRouting;\n    this.routingTable = routingTable;\n    this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;\n    this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;\n    this.commonPrefixLengthRefreshedAt = [];\n    this.refreshTable = this.refreshTable.bind(this);\n  }\n\n  async start() {\n    this.log(`refreshing routing table every ${this.refreshInterval}ms`);\n    this.refreshTable(true);\n  }\n\n  async stop() {\n    if (this.refreshTimeoutId != null) {\n      clearTimeout(this.refreshTimeoutId);\n    }\n  }\n  /**\n   * To speed lookups, we seed the table with random PeerIds. This means\n   * when we are asked to locate a peer on the network, we can find a KadId\n   * that is close to the requested peer ID and query that, then network\n   * peers will tell us who they know who is close to the fake ID\n   */\n\n\n  refreshTable() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.log('refreshing routing table');\n\n    const prefixLength = this._maxCommonPrefix();\n\n    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);\n\n    this.log(`max common prefix length ${prefixLength}`);\n    this.log(`tracked CPLs [ ${refreshCpls.map(date => date.toISOString()).join(', ')} ]`);\n    /**\n     * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n     * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n     * is smaller.\n     *\n     * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n     * before a very high max Cpl for which we do have peers in the network.\n     *\n     * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n     * the programmer had paid more attention in the Math classes at university.\n     *\n     * So, please be patient and a doc explaining it will be published soon.\n     *\n     * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n     */\n\n    Promise.all(refreshCpls.map(async (lastRefresh, index) => {\n      try {\n        await this._refreshCommonPrefixLength(index, lastRefresh, force);\n\n        if (this._numPeersForCpl(prefixLength) === 0) {\n          const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);\n\n          for (let n = index + 1; n < lastCpl + 1; n++) {\n            try {\n              await this._refreshCommonPrefixLength(n, lastRefresh, force);\n            } catch (err) {\n              this.log.error(err);\n            }\n          }\n        }\n      } catch (err) {\n        this.log.error(err);\n      }\n    })).catch(err => {\n      this.log.error(err);\n    }).then(() => {\n      this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);\n\n      if (this.refreshTimeoutId.unref != null) {\n        this.refreshTimeoutId.unref();\n      }\n    }).catch(err => {\n      this.log.error(err);\n    });\n  }\n\n  async _refreshCommonPrefixLength(cpl, lastRefresh, force) {\n    if (!force && lastRefresh.getTime() > Date.now() - this.refreshInterval) {\n      this.log('not running refresh for cpl %s as time since last refresh not above interval', cpl);\n      return;\n    } // gen a key for the query to refresh the cpl\n\n\n    const peerId = await this._generateRandomPeerId(cpl);\n    this.log('starting refreshing cpl %s with key %p (routing table size was %s)', cpl, peerId, this.routingTable.size);\n    const controller = new TimeoutController(this.refreshQueryTimeout);\n\n    try {\n      const peers = await length(this.peerRouting.getClosestPeers(peerId.toBytes(), {\n        signal: controller.signal\n      }));\n      this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId);\n      this.log('finished refreshing cpl %s with key %p (routing table size is now %s)', cpl, peerId, this.routingTable.size);\n    } finally {\n      controller.clear();\n    }\n  }\n\n  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {\n    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;\n    }\n\n    const dates = [];\n\n    for (let i = 0; i <= maxCommonPrefix; i++) {\n      // defaults to the zero value if we haven't refreshed it yet.\n      dates[i] = this.commonPrefixLengthRefreshedAt[i] ?? new Date();\n    }\n\n    return dates;\n  }\n\n  async _generateRandomPeerId(targetCommonPrefixLength) {\n    if (this.routingTable.kb == null) {\n      throw new Error('Routing table not started');\n    }\n\n    const randomData = randomBytes(2);\n    const randomUint16 = (randomData[1] << 8) + randomData[0];\n    const key = await this._makePeerId(this.routingTable.kb.localNodeId, randomUint16, targetCommonPrefixLength);\n    return peerIdFromBytes(key);\n  }\n\n  async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {\n    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {\n      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);\n    }\n\n    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);\n    const localPrefix = view.getUint16(0, false); // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n    // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n    // to our randomly generated prefix.\n\n    const toggledLocalPrefix = localPrefix ^ 0x8000 >> targetCommonPrefixLength; // Combine the toggled local prefix and the random bits at the correct offset\n    // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n\n    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);\n    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask; // Convert to a known peer ID.\n\n    const keyPrefix = GENERATED_PREFIXES[targetPrefix];\n    const keyBuffer = new ArrayBuffer(34);\n    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);\n    keyView.setUint8(0, sha256.code);\n    keyView.setUint8(1, 32);\n    keyView.setUint32(2, keyPrefix, false);\n    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);\n  }\n  /**\n   * returns the maximum common prefix length between any peer in the table\n   * and the current peer\n   */\n\n\n  _maxCommonPrefix() {\n    // xor our KadId with every KadId in the k-bucket tree,\n    // return the longest id prefix that is the same\n    let prefixLength = 0;\n\n    for (const length of this._prefixLengths()) {\n      if (length > prefixLength) {\n        prefixLength = length;\n      }\n    }\n\n    return prefixLength;\n  }\n  /**\n   * Returns the number of peers in the table with a given prefix length\n   */\n\n\n  _numPeersForCpl(prefixLength) {\n    let count = 0;\n\n    for (const length of this._prefixLengths()) {\n      if (length === prefixLength) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n  /**\n   * Yields the common prefix length of every peer in the table\n   */\n\n\n  *_prefixLengths() {\n    if (this.routingTable.kb == null) {\n      return;\n    }\n\n    for (const {\n      id\n    } of this.routingTable.kb.toIterable()) {\n      const distance = uint8ArrayXor(this.routingTable.kb.localNodeId, id);\n      let leadingZeros = 0;\n\n      for (const byte of distance) {\n        if (byte === 0) {\n          leadingZeros++;\n        } else {\n          break;\n        }\n      }\n\n      yield leadingZeros;\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["xor","uint8ArrayXor","GENERATED_PREFIXES","sha256","randomBytes","peerIdFromBytes","logger","length","TimeoutController","TABLE_REFRESH_INTERVAL","TABLE_REFRESH_QUERY_TIMEOUT","MAX_COMMON_PREFIX_LENGTH","RoutingTableRefresh","constructor","init","peerRouting","routingTable","refreshInterval","refreshQueryTimeout","lan","log","commonPrefixLengthRefreshedAt","refreshTable","bind","start","stop","refreshTimeoutId","clearTimeout","force","prefixLength","_maxCommonPrefix","refreshCpls","_getTrackedCommonPrefixLengthsForRefresh","map","date","toISOString","join","Promise","all","lastRefresh","index","_refreshCommonPrefixLength","_numPeersForCpl","lastCpl","Math","min","n","err","error","catch","then","setTimeout","unref","cpl","getTime","Date","now","peerId","_generateRandomPeerId","size","controller","peers","getClosestPeers","toBytes","signal","clear","maxCommonPrefix","dates","i","targetCommonPrefixLength","kb","Error","randomData","randomUint16","key","_makePeerId","localNodeId","localKadId","randomPrefix","view","DataView","buffer","byteOffset","byteLength","localPrefix","getUint16","toggledLocalPrefix","mask","targetPrefix","keyPrefix","keyBuffer","ArrayBuffer","keyView","setUint8","code","setUint32","Uint8Array","_prefixLengths","count","id","toIterable","distance","leadingZeros","byte"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\routing-table\\refresh.ts"],"sourcesContent":["import { xor as uint8ArrayXor } from 'uint8arrays/xor'\nimport GENERATED_PREFIXES from './generated-prefix-list.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { randomBytes } from '@libp2p/crypto'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport { logger } from '@libp2p/logger'\nimport length from 'it-length'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { TABLE_REFRESH_INTERVAL, TABLE_REFRESH_QUERY_TIMEOUT } from '../constants.js'\nimport type { RoutingTable } from './index.js'\nimport type { Logger } from '@libp2p/logger'\nimport type { PeerRouting } from '../peer-routing/index.js'\nimport type { PeerId } from '@libp2p/interface-peer-id'\n\n/**\n * Cannot generate random KadIds longer than this + 1\n */\nconst MAX_COMMON_PREFIX_LENGTH = 15\n\nexport interface RoutingTableRefreshInit {\n  peerRouting: PeerRouting\n  routingTable: RoutingTable\n  lan: boolean\n  refreshInterval?: number\n  refreshQueryTimeout?: number\n}\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nexport class RoutingTableRefresh {\n  private readonly log: Logger\n  private readonly peerRouting: PeerRouting\n  private readonly routingTable: RoutingTable\n  private readonly refreshInterval: number\n  private readonly refreshQueryTimeout: number\n  private readonly commonPrefixLengthRefreshedAt: Date[]\n  private refreshTimeoutId?: NodeJS.Timer\n\n  constructor (init: RoutingTableRefreshInit) {\n    const { peerRouting, routingTable, refreshInterval, refreshQueryTimeout, lan } = init\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:routing-table:refresh`)\n    this.peerRouting = peerRouting\n    this.routingTable = routingTable\n    this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL\n    this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT\n    this.commonPrefixLengthRefreshedAt = []\n\n    this.refreshTable = this.refreshTable.bind(this)\n  }\n\n  async start (): Promise<void> {\n    this.log(`refreshing routing table every ${this.refreshInterval}ms`)\n    this.refreshTable(true)\n  }\n\n  async stop (): Promise<void> {\n    if (this.refreshTimeoutId != null) {\n      clearTimeout(this.refreshTimeoutId)\n    }\n  }\n\n  /**\n   * To speed lookups, we seed the table with random PeerIds. This means\n   * when we are asked to locate a peer on the network, we can find a KadId\n   * that is close to the requested peer ID and query that, then network\n   * peers will tell us who they know who is close to the fake ID\n   */\n  refreshTable (force: boolean = false): void {\n    this.log('refreshing routing table')\n\n    const prefixLength = this._maxCommonPrefix()\n    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength)\n\n    this.log(`max common prefix length ${prefixLength}`)\n    this.log(`tracked CPLs [ ${refreshCpls.map(date => date.toISOString()).join(', ')} ]`)\n\n    /**\n     * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n     * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n     * is smaller.\n     *\n     * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n     * before a very high max Cpl for which we do have peers in the network.\n     *\n     * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n     * the programmer had paid more attention in the Math classes at university.\n     *\n     * So, please be patient and a doc explaining it will be published soon.\n     *\n     * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n     */\n    Promise.all(\n      refreshCpls.map(async (lastRefresh, index) => {\n        try {\n          await this._refreshCommonPrefixLength(index, lastRefresh, force)\n\n          if (this._numPeersForCpl(prefixLength) === 0) {\n            const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1)\n\n            for (let n = index + 1; n < lastCpl + 1; n++) {\n              try {\n                await this._refreshCommonPrefixLength(n, lastRefresh, force)\n              } catch (err: any) {\n                this.log.error(err)\n              }\n            }\n          }\n        } catch (err: any) {\n          this.log.error(err)\n        }\n      })\n    ).catch(err => {\n      this.log.error(err)\n    }).then(() => {\n      this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval)\n\n      if (this.refreshTimeoutId.unref != null) {\n        this.refreshTimeoutId.unref()\n      }\n    }).catch(err => {\n      this.log.error(err)\n    })\n  }\n\n  async _refreshCommonPrefixLength (cpl: number, lastRefresh: Date, force: boolean): Promise<void> {\n    if (!force && lastRefresh.getTime() > (Date.now() - this.refreshInterval)) {\n      this.log('not running refresh for cpl %s as time since last refresh not above interval', cpl)\n      return\n    }\n\n    // gen a key for the query to refresh the cpl\n    const peerId = await this._generateRandomPeerId(cpl)\n\n    this.log('starting refreshing cpl %s with key %p (routing table size was %s)', cpl, peerId, this.routingTable.size)\n\n    const controller = new TimeoutController(this.refreshQueryTimeout)\n\n    try {\n      const peers = await length(this.peerRouting.getClosestPeers(peerId.toBytes(), { signal: controller.signal }))\n\n      this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId)\n      this.log('finished refreshing cpl %s with key %p (routing table size is now %s)', cpl, peerId, this.routingTable.size)\n    } finally {\n      controller.clear()\n    }\n  }\n\n  _getTrackedCommonPrefixLengthsForRefresh (maxCommonPrefix: number): Date[] {\n    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH\n    }\n\n    const dates = []\n\n    for (let i = 0; i <= maxCommonPrefix; i++) {\n      // defaults to the zero value if we haven't refreshed it yet.\n      dates[i] = this.commonPrefixLengthRefreshedAt[i] ?? new Date()\n    }\n\n    return dates\n  }\n\n  async _generateRandomPeerId (targetCommonPrefixLength: number): Promise<PeerId> {\n    if (this.routingTable.kb == null) {\n      throw new Error('Routing table not started')\n    }\n\n    const randomData = randomBytes(2)\n    const randomUint16 = (randomData[1] << 8) + randomData[0]\n\n    const key = await this._makePeerId(this.routingTable.kb.localNodeId, randomUint16, targetCommonPrefixLength)\n\n    return peerIdFromBytes(key)\n  }\n\n  async _makePeerId (localKadId: Uint8Array, randomPrefix: number, targetCommonPrefixLength: number): Promise<Uint8Array> {\n    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {\n      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`)\n    }\n\n    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength)\n    const localPrefix = view.getUint16(0, false)\n\n    // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n    // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n    // to our randomly generated prefix.\n    const toggledLocalPrefix = localPrefix ^ (0x8000 >> targetCommonPrefixLength)\n\n    // Combine the toggled local prefix and the random bits at the correct offset\n    // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n    const mask = 65535 << (16 - (targetCommonPrefixLength + 1))\n    const targetPrefix = (toggledLocalPrefix & mask) | (randomPrefix & ~mask)\n\n    // Convert to a known peer ID.\n    const keyPrefix = GENERATED_PREFIXES[targetPrefix]\n\n    const keyBuffer = new ArrayBuffer(34)\n    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength)\n    keyView.setUint8(0, sha256.code)\n    keyView.setUint8(1, 32)\n    keyView.setUint32(2, keyPrefix, false)\n\n    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength)\n  }\n\n  /**\n   * returns the maximum common prefix length between any peer in the table\n   * and the current peer\n   */\n  _maxCommonPrefix (): number {\n    // xor our KadId with every KadId in the k-bucket tree,\n    // return the longest id prefix that is the same\n    let prefixLength = 0\n\n    for (const length of this._prefixLengths()) {\n      if (length > prefixLength) {\n        prefixLength = length\n      }\n    }\n\n    return prefixLength\n  }\n\n  /**\n   * Returns the number of peers in the table with a given prefix length\n   */\n  _numPeersForCpl (prefixLength: number): number {\n    let count = 0\n\n    for (const length of this._prefixLengths()) {\n      if (length === prefixLength) {\n        count++\n      }\n    }\n\n    return count\n  }\n\n  /**\n   * Yields the common prefix length of every peer in the table\n   */\n  * _prefixLengths (): Generator<number> {\n    if (this.routingTable.kb == null) {\n      return\n    }\n\n    for (const { id } of this.routingTable.kb.toIterable()) {\n      const distance = uint8ArrayXor(this.routingTable.kb.localNodeId, id)\n      let leadingZeros = 0\n\n      for (const byte of distance) {\n        if (byte === 0) {\n          leadingZeros++\n        } else {\n          break\n        }\n      }\n\n      yield leadingZeros\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}