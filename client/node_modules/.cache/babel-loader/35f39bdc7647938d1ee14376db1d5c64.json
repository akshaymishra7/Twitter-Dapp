{"ast":null,"code":"/* eslint max-depth: [\"error\", 6] */\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { unsigned } from 'uint8-varint';\nimport errCode from 'err-code'; // Maximum length of the length section of the message\n\nexport const MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\n\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4;\nvar ReadMode;\n\n(function (ReadMode) {\n  ReadMode[ReadMode[\"LENGTH\"] = 0] = \"LENGTH\";\n  ReadMode[ReadMode[\"DATA\"] = 1] = \"DATA\";\n})(ReadMode || (ReadMode = {}));\n\nconst defaultDecoder = buf => {\n  const length = unsigned.decode(buf);\n  defaultDecoder.bytes = unsigned.encodingLength(length);\n  return length;\n};\n\ndefaultDecoder.bytes = 0;\nexport function decode(options) {\n  const decoder = async function* (source) {\n    const buffer = new Uint8ArrayList();\n    let mode = ReadMode.LENGTH;\n    let dataLength = -1;\n    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;\n    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;\n    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;\n\n    for await (const buf of source) {\n      buffer.append(buf);\n\n      while (buffer.byteLength > 0) {\n        if (mode === ReadMode.LENGTH) {\n          // read length, ignore errors for short reads\n          try {\n            dataLength = lengthDecoder(buffer);\n\n            if (dataLength < 0) {\n              throw errCode(new Error('invalid message length'), 'ERR_INVALID_MSG_LENGTH');\n            }\n\n            if (dataLength > maxDataLength) {\n              throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG');\n            }\n\n            const dataLengthLength = lengthDecoder.bytes;\n            buffer.consume(dataLengthLength);\n\n            if (options?.onLength != null) {\n              options.onLength(dataLength);\n            }\n\n            mode = ReadMode.DATA;\n          } catch (err) {\n            if (err instanceof RangeError) {\n              if (buffer.byteLength > maxLengthLength) {\n                throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG');\n              }\n\n              break;\n            }\n\n            throw err;\n          }\n        }\n\n        if (mode === ReadMode.DATA) {\n          if (buffer.byteLength < dataLength) {\n            // not enough data, wait for more\n            break;\n          }\n\n          const data = buffer.sublist(0, dataLength);\n          buffer.consume(dataLength);\n\n          if (options?.onData != null) {\n            options.onData(data);\n          }\n\n          yield data;\n          mode = ReadMode.LENGTH;\n        }\n      }\n    }\n\n    if (buffer.byteLength > 0) {\n      throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n    }\n  };\n\n  return decoder;\n}\n/**\n * @param {*} reader\n * @param {import('./types').DecoderOptions} [options]\n * @returns\n */\n\ndecode.fromReader = (reader, options) => {\n  let byteLength = 1; // Read single byte chunks until the length is known\n\n  const varByteSource = async function* () {\n    while (true) {\n      try {\n        const {\n          done,\n          value\n        } = await reader.next(byteLength);\n\n        if (done === true) {\n          return;\n        }\n\n        if (value != null) {\n          yield value;\n        }\n      } catch (err) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return {\n            done: true,\n            value: null\n          };\n        }\n\n        throw err;\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1;\n      }\n    }\n  }();\n  /**\n   * Once the length has been parsed, read chunk for that length\n   */\n\n\n  const onLength = l => {\n    byteLength = l;\n  };\n\n  return decode({ ...(options ?? {}),\n    onLength\n  })(varByteSource);\n};","map":{"version":3,"mappings":"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","names":["Uint8ArrayList","unsigned","errCode","MAX_LENGTH_LENGTH","MAX_DATA_LENGTH","ReadMode","defaultDecoder","buf","length","decode","bytes","encodingLength","options","decoder","source","buffer","mode","LENGTH","dataLength","lengthDecoder","maxLengthLength","maxDataLength","append","byteLength","Error","dataLengthLength","consume","onLength","DATA","err","RangeError","data","sublist","onData","fromReader","reader","varByteSource","done","value","next","code","l"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-length-prefixed\\src\\decode.ts"],"sourcesContent":["/* eslint max-depth: [\"error\", 6] */\n\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { unsigned } from 'uint8-varint'\nimport errCode from 'err-code'\nimport type { LengthDecoderFunction } from './index.js'\nimport type { Reader } from 'it-reader'\nimport type { Source, Transform } from 'it-stream-types'\n\nexport interface ReadState {\n  dataLength: number\n}\n\nexport interface DecoderOptions {\n  lengthDecoder?: LengthDecoderFunction\n  onData?: (data: Uint8ArrayList) => void\n  onLength?: (length: number) => void\n  maxLengthLength?: number\n  maxDataLength?: number\n}\n\nexport interface ReadResult {\n  mode: string\n  chunk?: Uint8ArrayList\n  buffer: Uint8ArrayList\n  state?: ReadState\n  data?: Uint8ArrayList\n}\n\n// Maximum length of the length section of the message\nexport const MAX_LENGTH_LENGTH = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4\n\nenum ReadMode {\n  LENGTH,\n  DATA\n}\n\nconst defaultDecoder: LengthDecoderFunction = (buf) => {\n  const length = unsigned.decode(buf)\n  defaultDecoder.bytes = unsigned.encodingLength(length)\n\n  return length\n}\ndefaultDecoder.bytes = 0\n\nexport function decode (options?: DecoderOptions): Transform<Uint8ArrayList | Uint8Array, Uint8ArrayList> {\n  const decoder = async function * (source: Source<Uint8ArrayList | Uint8Array>): Source<Uint8ArrayList> {\n    const buffer = new Uint8ArrayList()\n    let mode = ReadMode.LENGTH\n    let dataLength = -1\n\n    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder\n    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH\n    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n    for await (const buf of source) {\n      buffer.append(buf)\n\n      while (buffer.byteLength > 0) {\n        if (mode === ReadMode.LENGTH) {\n          // read length, ignore errors for short reads\n          try {\n            dataLength = lengthDecoder(buffer)\n\n            if (dataLength < 0) {\n              throw errCode(new Error('invalid message length'), 'ERR_INVALID_MSG_LENGTH')\n            }\n\n            if (dataLength > maxDataLength) {\n              throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG')\n            }\n\n            const dataLengthLength = lengthDecoder.bytes\n            buffer.consume(dataLengthLength)\n\n            if (options?.onLength != null) {\n              options.onLength(dataLength)\n            }\n\n            mode = ReadMode.DATA\n          } catch (err: any) {\n            if (err instanceof RangeError) {\n              if (buffer.byteLength > maxLengthLength) {\n                throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG')\n              }\n\n              break\n            }\n\n            throw err\n          }\n        }\n\n        if (mode === ReadMode.DATA) {\n          if (buffer.byteLength < dataLength) {\n            // not enough data, wait for more\n            break\n          }\n\n          const data = buffer.sublist(0, dataLength)\n          buffer.consume(dataLength)\n\n          if (options?.onData != null) {\n            options.onData(data)\n          }\n\n          yield data\n\n          mode = ReadMode.LENGTH\n        }\n      }\n    }\n\n    if (buffer.byteLength > 0) {\n      throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF')\n    }\n  }\n\n  return decoder\n}\n\n/**\n * @param {*} reader\n * @param {import('./types').DecoderOptions} [options]\n * @returns\n */\ndecode.fromReader = (reader: Reader, options?: DecoderOptions) => {\n  let byteLength = 1 // Read single byte chunks until the length is known\n\n  const varByteSource = (async function * () {\n    while (true) {\n      try {\n        const { done, value } = await reader.next(byteLength)\n\n        if (done === true) {\n          return\n        }\n\n        if (value != null) {\n          yield value\n        }\n      } catch (err: any) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return { done: true, value: null }\n        }\n        throw err\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1\n      }\n    }\n  }())\n\n  /**\n   * Once the length has been parsed, read chunk for that length\n   */\n  const onLength = (l: number) => { byteLength = l }\n  return decode({\n    ...(options ?? {}),\n    onLength\n  })(varByteSource)\n}\n"]},"metadata":{},"sourceType":"module"}