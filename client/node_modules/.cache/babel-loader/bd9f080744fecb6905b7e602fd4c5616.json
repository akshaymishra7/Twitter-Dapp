{"ast":null,"code":"import errCode from 'err-code';\nimport { updateTree } from './utils/update-tree.js';\nimport { updateMfsRoot } from './utils/update-mfs-root.js';\nimport { removeLink } from './utils/remove-link.js';\nimport { toMfsPath } from './utils/to-mfs-path.js';\nimport { toTrail } from './utils/to-trail.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport mergeOpts from 'merge-options';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\n/**\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} recursive\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\nconst defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  shardSplitThreshold: 1000\n};\n/**\n * @param {MfsContext} context\n */\n\nexport function createRm(context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"rm\"]}\n   */\n  async function mfsRm(paths) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /** @type {DefaultOptions} */\n    const options = mergeOptions(defaultOptions, opts);\n\n    if (!Array.isArray(paths)) {\n      paths = [paths];\n    }\n\n    const sources = await Promise.all(paths.map(path => toMfsPath(context, path, options)));\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS');\n    }\n\n    sources.forEach(source => {\n      if (source.path === '/') {\n        throw errCode(new Error('Cannot delete root'), 'ERR_INVALID_PARAMS');\n      }\n    });\n\n    for (const source of sources) {\n      await removePath(context, source.path, options);\n    }\n  }\n\n  return withTimeoutOption(mfsRm);\n}\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {DefaultOptions} options\n */\n\nconst removePath = async (context, path, options) => {\n  const mfsPath = await toMfsPath(context, path, options);\n  const trail = await toTrail(context, mfsPath.mfsPath);\n  const child = trail[trail.length - 1];\n  trail.pop();\n  const parent = trail[trail.length - 1];\n\n  if (!parent) {\n    throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND');\n  }\n\n  if (child.type === 'directory' && !options.recursive) {\n    throw errCode(new Error(`${path} is a directory, use -r to remove directories`), 'ERR_WAS_DIR');\n  }\n\n  const {\n    cid\n  } = await removeLink(context, {\n    parentCid: parent.cid,\n    name: child.name,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  });\n  parent.cid = cid; // update the tree with the new child\n\n  const newRootCid = await updateTree(context, trail, options); // Update the MFS record with the new CID for the root of the tree\n\n  await updateMfsRoot(context, newRootCid, options);\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/files/rm.js"],"names":["errCode","updateTree","updateMfsRoot","removeLink","toMfsPath","toTrail","withTimeoutOption","mergeOpts","mergeOptions","bind","ignoreUndefined","defaultOptions","recursive","cidVersion","hashAlg","flush","shardSplitThreshold","createRm","context","mfsRm","paths","opts","options","Array","isArray","sources","Promise","all","map","path","length","Error","forEach","source","removePath","mfsPath","trail","child","pop","parent","type","cid","parentCid","name","newRootCid"],"mappings":"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","sourcesContent":["import errCode from 'err-code'\nimport { updateTree } from './utils/update-tree.js'\nimport { updateMfsRoot } from './utils/update-mfs-root.js'\nimport { removeLink } from './utils/remove-link.js'\nimport { toMfsPath } from './utils/to-mfs-path.js'\nimport { toTrail } from './utils/to-trail.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport mergeOpts from 'merge-options'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\n\n/**\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} recursive\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  shardSplitThreshold: 1000\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createRm (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"rm\"]}\n   */\n  async function mfsRm (paths, opts = {}) {\n    /** @type {DefaultOptions} */\n    const options = mergeOptions(defaultOptions, opts)\n\n    if (!Array.isArray(paths)) {\n      paths = [paths]\n    }\n\n    const sources = await Promise.all(\n      paths.map(path => toMfsPath(context, path, options))\n    )\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS')\n    }\n\n    sources.forEach(source => {\n      if (source.path === '/') {\n        throw errCode(new Error('Cannot delete root'), 'ERR_INVALID_PARAMS')\n      }\n    })\n\n    for (const source of sources) {\n      await removePath(context, source.path, options)\n    }\n  }\n\n  return withTimeoutOption(mfsRm)\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {DefaultOptions} options\n */\nconst removePath = async (context, path, options) => {\n  const mfsPath = await toMfsPath(context, path, options)\n  const trail = await toTrail(context, mfsPath.mfsPath)\n  const child = trail[trail.length - 1]\n  trail.pop()\n  const parent = trail[trail.length - 1]\n\n  if (!parent) {\n    throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND')\n  }\n\n  if (child.type === 'directory' && !options.recursive) {\n    throw errCode(new Error(`${path} is a directory, use -r to remove directories`), 'ERR_WAS_DIR')\n  }\n\n  const {\n    cid\n  } = await removeLink(context, {\n    parentCid: parent.cid,\n    name: child.name,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  })\n\n  parent.cid = cid\n\n  // update the tree with the new child\n  const newRootCid = await updateTree(context, trail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options)\n}\n"]},"metadata":{},"sourceType":"module"}