{"ast":null,"code":"'use strict';\n\nconst {\n  fromCallback\n} = require('catering');\n\nconst ModuleError = require('module-error');\n\nconst {\n  getCallback,\n  getOptions\n} = require('./lib/common');\n\nconst kPromise = Symbol('promise');\nconst kStatus = Symbol('status');\nconst kOperations = Symbol('operations');\nconst kFinishClose = Symbol('finishClose');\nconst kCloseCallbacks = Symbol('closeCallbacks');\n\nclass AbstractChainedBatch {\n  constructor(db) {\n    if (typeof db !== 'object' || db === null) {\n      const hint = db === null ? 'null' : typeof db;\n      throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);\n    }\n\n    this[kOperations] = [];\n    this[kCloseCallbacks] = [];\n    this[kStatus] = 'open';\n    this[kFinishClose] = this[kFinishClose].bind(this);\n    this.db = db;\n    this.db.attachResource(this);\n    this.nextTick = db.nextTick;\n  }\n\n  get length() {\n    return this[kOperations].length;\n  }\n\n  put(key, value, options) {\n    if (this[kStatus] !== 'open') {\n      throw new ModuleError('Batch is not open: cannot call put() after write() or close()', {\n        code: 'LEVEL_BATCH_NOT_OPEN'\n      });\n    }\n\n    const err = this.db._checkKey(key) || this.db._checkValue(value);\n\n    if (err) throw err;\n    const db = options && options.sublevel != null ? options.sublevel : this.db;\n    const original = options;\n    const keyEncoding = db.keyEncoding(options && options.keyEncoding);\n    const valueEncoding = db.valueEncoding(options && options.valueEncoding);\n    const keyFormat = keyEncoding.format; // Forward encoding options\n\n    options = { ...options,\n      keyEncoding: keyFormat,\n      valueEncoding: valueEncoding.format\n    }; // Prevent double prefixing\n\n    if (db !== this.db) {\n      options.sublevel = null;\n    }\n\n    const mappedKey = db.prefixKey(keyEncoding.encode(key), keyFormat);\n    const mappedValue = valueEncoding.encode(value);\n\n    this._put(mappedKey, mappedValue, options);\n\n    this[kOperations].push({ ...original,\n      type: 'put',\n      key,\n      value\n    });\n    return this;\n  }\n\n  _put(key, value, options) {}\n\n  del(key, options) {\n    if (this[kStatus] !== 'open') {\n      throw new ModuleError('Batch is not open: cannot call del() after write() or close()', {\n        code: 'LEVEL_BATCH_NOT_OPEN'\n      });\n    }\n\n    const err = this.db._checkKey(key);\n\n    if (err) throw err;\n    const db = options && options.sublevel != null ? options.sublevel : this.db;\n    const original = options;\n    const keyEncoding = db.keyEncoding(options && options.keyEncoding);\n    const keyFormat = keyEncoding.format; // Forward encoding options\n\n    options = { ...options,\n      keyEncoding: keyFormat\n    }; // Prevent double prefixing\n\n    if (db !== this.db) {\n      options.sublevel = null;\n    }\n\n    this._del(db.prefixKey(keyEncoding.encode(key), keyFormat), options);\n\n    this[kOperations].push({ ...original,\n      type: 'del',\n      key\n    });\n    return this;\n  }\n\n  _del(key, options) {}\n\n  clear() {\n    if (this[kStatus] !== 'open') {\n      throw new ModuleError('Batch is not open: cannot call clear() after write() or close()', {\n        code: 'LEVEL_BATCH_NOT_OPEN'\n      });\n    }\n\n    this._clear();\n\n    this[kOperations] = [];\n    return this;\n  }\n\n  _clear() {}\n\n  write(options, callback) {\n    callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = getOptions(options);\n\n    if (this[kStatus] !== 'open') {\n      this.nextTick(callback, new ModuleError('Batch is not open: cannot call write() after write() or close()', {\n        code: 'LEVEL_BATCH_NOT_OPEN'\n      }));\n    } else if (this.length === 0) {\n      this.close(callback);\n    } else {\n      this[kStatus] = 'writing';\n\n      this._write(options, err => {\n        this[kStatus] = 'closing';\n        this[kCloseCallbacks].push(() => callback(err)); // Emit after setting 'closing' status, because event may trigger a\n        // db close which in turn triggers (idempotently) closing this batch.\n\n        if (!err) this.db.emit('batch', this[kOperations]);\n\n        this._close(this[kFinishClose]);\n      });\n    }\n\n    return callback[kPromise];\n  }\n\n  _write(options, callback) {}\n\n  close(callback) {\n    callback = fromCallback(callback, kPromise);\n\n    if (this[kStatus] === 'closing') {\n      this[kCloseCallbacks].push(callback);\n    } else if (this[kStatus] === 'closed') {\n      this.nextTick(callback);\n    } else {\n      this[kCloseCallbacks].push(callback);\n\n      if (this[kStatus] !== 'writing') {\n        this[kStatus] = 'closing';\n\n        this._close(this[kFinishClose]);\n      }\n    }\n\n    return callback[kPromise];\n  }\n\n  _close(callback) {\n    this.nextTick(callback);\n  }\n\n  [kFinishClose]() {\n    this[kStatus] = 'closed';\n    this.db.detachResource(this);\n    const callbacks = this[kCloseCallbacks];\n    this[kCloseCallbacks] = [];\n\n    for (const cb of callbacks) {\n      cb();\n    }\n  }\n\n}\n\nexports.AbstractChainedBatch = AbstractChainedBatch;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/abstract-level/abstract-chained-batch.js"],"names":["fromCallback","require","ModuleError","getCallback","getOptions","kPromise","Symbol","kStatus","kOperations","kFinishClose","kCloseCallbacks","AbstractChainedBatch","constructor","db","hint","TypeError","bind","attachResource","nextTick","length","put","key","value","options","code","err","_checkKey","_checkValue","sublevel","original","keyEncoding","valueEncoding","keyFormat","format","mappedKey","prefixKey","encode","mappedValue","_put","push","type","del","_del","clear","_clear","write","callback","close","_write","emit","_close","detachResource","callbacks","cb","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { fromCallback } = require('catering')\nconst ModuleError = require('module-error')\nconst { getCallback, getOptions } = require('./lib/common')\n\nconst kPromise = Symbol('promise')\nconst kStatus = Symbol('status')\nconst kOperations = Symbol('operations')\nconst kFinishClose = Symbol('finishClose')\nconst kCloseCallbacks = Symbol('closeCallbacks')\n\nclass AbstractChainedBatch {\n  constructor (db) {\n    if (typeof db !== 'object' || db === null) {\n      const hint = db === null ? 'null' : typeof db\n      throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`)\n    }\n\n    this[kOperations] = []\n    this[kCloseCallbacks] = []\n    this[kStatus] = 'open'\n    this[kFinishClose] = this[kFinishClose].bind(this)\n\n    this.db = db\n    this.db.attachResource(this)\n    this.nextTick = db.nextTick\n  }\n\n  get length () {\n    return this[kOperations].length\n  }\n\n  put (key, value, options) {\n    if (this[kStatus] !== 'open') {\n      throw new ModuleError('Batch is not open: cannot call put() after write() or close()', {\n        code: 'LEVEL_BATCH_NOT_OPEN'\n      })\n    }\n\n    const err = this.db._checkKey(key) || this.db._checkValue(value)\n    if (err) throw err\n\n    const db = options && options.sublevel != null ? options.sublevel : this.db\n    const original = options\n    const keyEncoding = db.keyEncoding(options && options.keyEncoding)\n    const valueEncoding = db.valueEncoding(options && options.valueEncoding)\n    const keyFormat = keyEncoding.format\n\n    // Forward encoding options\n    options = { ...options, keyEncoding: keyFormat, valueEncoding: valueEncoding.format }\n\n    // Prevent double prefixing\n    if (db !== this.db) {\n      options.sublevel = null\n    }\n\n    const mappedKey = db.prefixKey(keyEncoding.encode(key), keyFormat)\n    const mappedValue = valueEncoding.encode(value)\n\n    this._put(mappedKey, mappedValue, options)\n    this[kOperations].push({ ...original, type: 'put', key, value })\n\n    return this\n  }\n\n  _put (key, value, options) {}\n\n  del (key, options) {\n    if (this[kStatus] !== 'open') {\n      throw new ModuleError('Batch is not open: cannot call del() after write() or close()', {\n        code: 'LEVEL_BATCH_NOT_OPEN'\n      })\n    }\n\n    const err = this.db._checkKey(key)\n    if (err) throw err\n\n    const db = options && options.sublevel != null ? options.sublevel : this.db\n    const original = options\n    const keyEncoding = db.keyEncoding(options && options.keyEncoding)\n    const keyFormat = keyEncoding.format\n\n    // Forward encoding options\n    options = { ...options, keyEncoding: keyFormat }\n\n    // Prevent double prefixing\n    if (db !== this.db) {\n      options.sublevel = null\n    }\n\n    this._del(db.prefixKey(keyEncoding.encode(key), keyFormat), options)\n    this[kOperations].push({ ...original, type: 'del', key })\n\n    return this\n  }\n\n  _del (key, options) {}\n\n  clear () {\n    if (this[kStatus] !== 'open') {\n      throw new ModuleError('Batch is not open: cannot call clear() after write() or close()', {\n        code: 'LEVEL_BATCH_NOT_OPEN'\n      })\n    }\n\n    this._clear()\n    this[kOperations] = []\n\n    return this\n  }\n\n  _clear () {}\n\n  write (options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options)\n\n    if (this[kStatus] !== 'open') {\n      this.nextTick(callback, new ModuleError('Batch is not open: cannot call write() after write() or close()', {\n        code: 'LEVEL_BATCH_NOT_OPEN'\n      }))\n    } else if (this.length === 0) {\n      this.close(callback)\n    } else {\n      this[kStatus] = 'writing'\n      this._write(options, (err) => {\n        this[kStatus] = 'closing'\n        this[kCloseCallbacks].push(() => callback(err))\n\n        // Emit after setting 'closing' status, because event may trigger a\n        // db close which in turn triggers (idempotently) closing this batch.\n        if (!err) this.db.emit('batch', this[kOperations])\n\n        this._close(this[kFinishClose])\n      })\n    }\n\n    return callback[kPromise]\n  }\n\n  _write (options, callback) {}\n\n  close (callback) {\n    callback = fromCallback(callback, kPromise)\n\n    if (this[kStatus] === 'closing') {\n      this[kCloseCallbacks].push(callback)\n    } else if (this[kStatus] === 'closed') {\n      this.nextTick(callback)\n    } else {\n      this[kCloseCallbacks].push(callback)\n\n      if (this[kStatus] !== 'writing') {\n        this[kStatus] = 'closing'\n        this._close(this[kFinishClose])\n      }\n    }\n\n    return callback[kPromise]\n  }\n\n  _close (callback) {\n    this.nextTick(callback)\n  }\n\n  [kFinishClose] () {\n    this[kStatus] = 'closed'\n    this.db.detachResource(this)\n\n    const callbacks = this[kCloseCallbacks]\n    this[kCloseCallbacks] = []\n\n    for (const cb of callbacks) {\n      cb()\n    }\n  }\n}\n\nexports.AbstractChainedBatch = AbstractChainedBatch\n"]},"metadata":{},"sourceType":"script"}