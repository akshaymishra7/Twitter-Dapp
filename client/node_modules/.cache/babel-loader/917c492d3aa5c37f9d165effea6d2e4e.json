{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';\nimport { isStartable } from '@libp2p/interfaces/startable';\nimport { isMultiaddr } from '@multiformats/multiaddr';\nimport { MemoryDatastore } from 'datastore-core/memory';\nimport { DefaultPeerRouting } from './peer-routing.js';\nimport { CompoundContentRouting } from './content-routing/index.js';\nimport { codes } from './errors.js';\nimport { DefaultAddressManager } from './address-manager/index.js';\nimport { DefaultConnectionManager } from './connection-manager/index.js';\nimport { AutoDialler } from './connection-manager/auto-dialler.js';\nimport { Circuit } from './circuit/transport.js';\nimport { Relay } from './circuit/index.js';\nimport { KeyChain } from './keychain/index.js';\nimport { DefaultTransportManager } from './transport-manager.js';\nimport { DefaultUpgrader } from './upgrader.js';\nimport { DefaultRegistrar } from './registrar.js';\nimport { IdentifyService } from './identify/index.js';\nimport { FetchService } from './fetch/index.js';\nimport { PingService } from './ping/index.js';\nimport { NatManager } from './nat-manager.js';\nimport { PeerRecordUpdater } from './peer-record-updater.js';\nimport { DHTPeerRouting } from './dht/dht-peer-routing.js';\nimport { PersistentPeerStore } from '@libp2p/peer-store';\nimport { DHTContentRouting } from './dht/dht-content-routing.js';\nimport { DefaultComponents } from './components.js';\nimport { validateConfig } from './config.js';\nimport { createEd25519PeerId } from '@libp2p/peer-id-factory';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport errCode from 'err-code';\nimport { unmarshalPublicKey } from '@libp2p/crypto/keys';\nimport { DummyDHT } from './dht/dummy-dht.js';\nimport { DummyPubSub } from './pubsub/dummy-pubsub.js';\nimport { PeerSet } from '@libp2p/peer-collections';\nimport { DefaultDialer } from './connection-manager/dialer/index.js';\nimport { peerIdFromString } from '@libp2p/peer-id';\nconst log = logger('libp2p');\nexport class Libp2pNode extends EventEmitter {\n  constructor(init) {\n    super();\n    this.started = false;\n    this.peerId = init.peerId;\n    const components = this.components = new DefaultComponents({\n      peerId: init.peerId,\n      datastore: init.datastore ?? new MemoryDatastore(),\n      connectionGater: {\n        denyDialPeer: async () => await Promise.resolve(false),\n        denyDialMultiaddr: async () => await Promise.resolve(false),\n        denyInboundConnection: async () => await Promise.resolve(false),\n        denyOutboundConnection: async () => await Promise.resolve(false),\n        denyInboundEncryptedConnection: async () => await Promise.resolve(false),\n        denyOutboundEncryptedConnection: async () => await Promise.resolve(false),\n        denyInboundUpgradedConnection: async () => await Promise.resolve(false),\n        denyOutboundUpgradedConnection: async () => await Promise.resolve(false),\n        filterMultiaddrForPeer: async () => await Promise.resolve(true),\n        ...init.connectionGater\n      }\n    });\n    components.peerStore = new PersistentPeerStore(components, {\n      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,\n      ...init.peerStore\n    });\n    this.services = [components]; // Create Metrics\n\n    if (init.metrics != null) {\n      this.metrics = this.components.metrics = this.configureComponent(init.metrics(this.components));\n    }\n\n    this.peerStore = this.components.peerStore;\n    this.peerStore.addEventListener('peer', evt => {\n      const {\n        detail: peerData\n      } = evt;\n      this.dispatchEvent(new CustomEvent('peer:discovery', {\n        detail: peerData\n      }));\n    }); // Set up connection protector if configured\n\n    if (init.connectionProtector != null) {\n      this.components.connectionProtector = init.connectionProtector(components);\n    } // Set up the Upgrader\n\n\n    this.components.upgrader = new DefaultUpgrader(this.components, {\n      connectionEncryption: (init.connectionEncryption ?? []).map(fn => this.configureComponent(fn(this.components))),\n      muxers: (init.streamMuxers ?? []).map(fn => this.configureComponent(fn(this.components))),\n      inboundUpgradeTimeout: init.connectionManager.inboundUpgradeTimeout\n    }); // Create the dialer\n\n    this.components.dialer = new DefaultDialer(this.components, init.connectionManager); // Create the Connection Manager\n\n    this.connectionManager = this.components.connectionManager = new DefaultConnectionManager(this.components, init.connectionManager); // forward connection manager events\n\n    this.components.connectionManager.addEventListener('peer:disconnect', event => {\n      this.dispatchEvent(new CustomEvent('peer:disconnect', {\n        detail: event.detail\n      }));\n    });\n    this.components.connectionManager.addEventListener('peer:connect', event => {\n      this.dispatchEvent(new CustomEvent('peer:connect', {\n        detail: event.detail\n      }));\n    }); // Create the Registrar\n\n    this.registrar = this.components.registrar = new DefaultRegistrar(this.components); // Setup the transport manager\n\n    this.components.transportManager = new DefaultTransportManager(this.components, init.transportManager); // Addresses {listen, announce, noAnnounce}\n\n    this.components.addressManager = new DefaultAddressManager(this.components, init.addresses); // update our peer record when addresses change\n\n    this.configureComponent(new PeerRecordUpdater(this.components));\n    this.configureComponent(new AutoDialler(this.components, {\n      enabled: init.connectionManager.autoDial,\n      minConnections: init.connectionManager.minConnections,\n      autoDialInterval: init.connectionManager.autoDialInterval\n    })); // Create keychain\n\n    const keychainOpts = KeyChain.generateOptions();\n    this.keychain = this.configureComponent(new KeyChain(this.components, { ...keychainOpts,\n      ...init.keychain\n    })); // Create the Nat Manager\n\n    this.services.push(new NatManager(this.components, init.nat));\n    init.transports.forEach(fn => {\n      this.components.transportManager.add(this.configureComponent(fn(this.components)));\n    }); // Add the identify service\n\n    this.identifyService = new IdentifyService(this.components, { ...init.identify\n    });\n    this.configureComponent(this.identifyService); // dht provided components (peerRouting, contentRouting, dht)\n\n    if (init.dht != null) {\n      this.dht = this.components.dht = init.dht(this.components);\n    } else {\n      this.dht = new DummyDHT();\n    } // Create pubsub if provided\n\n\n    if (init.pubsub != null) {\n      this.pubsub = this.components.pubsub = init.pubsub(this.components);\n    } else {\n      this.pubsub = new DummyPubSub();\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    const peerRouters = (init.peerRouters ?? []).map(fn => this.configureComponent(fn(this.components)));\n\n    if (init.dht != null) {\n      // add dht to routers\n      peerRouters.push(this.configureComponent(new DHTPeerRouting(this.dht))); // use dht for peer discovery\n\n      this.dht.addEventListener('peer', evt => {\n        this.onDiscoveryPeer(evt);\n      });\n    }\n\n    this.peerRouting = this.components.peerRouting = this.configureComponent(new DefaultPeerRouting(this.components, { ...init.peerRouting,\n      routers: peerRouters\n    }));\n    const contentRouters = (init.contentRouters ?? []).map(fn => this.configureComponent(fn(this.components)));\n\n    if (init.dht != null) {\n      // add dht to routers\n      contentRouters.push(this.configureComponent(new DHTContentRouting(this.dht)));\n    }\n\n    this.contentRouting = this.components.contentRouting = this.configureComponent(new CompoundContentRouting(this.components, {\n      routers: contentRouters\n    }));\n\n    if (init.relay.enabled) {\n      this.components.transportManager.add(this.configureComponent(new Circuit(this.components, init.relay)));\n      this.configureComponent(new Relay(this.components, {\n        addressSorter: init.connectionManager.addressSorter,\n        ...init.relay\n      }));\n    }\n\n    this.fetchService = this.configureComponent(new FetchService(this.components, { ...init.fetch\n    }));\n    this.pingService = this.configureComponent(new PingService(this.components, { ...init.ping\n    })); // Discovery modules\n\n    for (const fn of init.peerDiscovery ?? []) {\n      const service = this.configureComponent(fn(this.components));\n      service.addEventListener('peer', evt => {\n        this.onDiscoveryPeer(evt);\n      });\n    }\n  }\n\n  configureComponent(component) {\n    if (isStartable(component)) {\n      this.services.push(component);\n    }\n\n    return component;\n  }\n  /**\n   * Starts the libp2p node and all its subsystems\n   */\n\n\n  async start() {\n    if (this.started) {\n      return;\n    }\n\n    this.started = true;\n    log('libp2p is starting');\n\n    try {\n      await Promise.all(this.services.map(async service => {\n        if (service.beforeStart != null) {\n          await service.beforeStart();\n        }\n      })); // start any startables\n\n      await Promise.all(this.services.map(service => service.start()));\n      await Promise.all(this.services.map(async service => {\n        if (service.afterStart != null) {\n          await service.afterStart();\n        }\n      }));\n      log('libp2p has started');\n    } catch (err) {\n      log.error('An error occurred starting libp2p', err);\n      await this.stop();\n      throw err;\n    }\n  }\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   */\n\n\n  async stop() {\n    if (!this.started) {\n      return;\n    }\n\n    log('libp2p is stopping');\n    this.started = false;\n    await Promise.all(this.services.map(async service => {\n      if (service.beforeStop != null) {\n        await service.beforeStop();\n      }\n    }));\n    await Promise.all(this.services.map(service => service.stop()));\n    await Promise.all(this.services.map(async service => {\n      if (service.afterStop != null) {\n        await service.afterStop();\n      }\n    }));\n    log('libp2p has stopped');\n  }\n\n  isStarted() {\n    return this.started;\n  }\n\n  getConnections(peerId) {\n    return this.components.connectionManager.getConnections(peerId);\n  }\n\n  getPeers() {\n    const peerSet = new PeerSet();\n\n    for (const conn of this.components.connectionManager.getConnections()) {\n      peerSet.add(conn.remotePeer);\n    }\n\n    return Array.from(peerSet);\n  }\n\n  async dial(peer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return await this.components.connectionManager.openConnection(peer, options);\n  }\n\n  async dialProtocol(peer, protocols) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (protocols == null) {\n      throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);\n    }\n\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n\n    if (protocols.length === 0) {\n      throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);\n    }\n\n    const connection = await this.dial(peer, options);\n    return await connection.newStream(protocols, options);\n  }\n\n  getMultiaddrs() {\n    return this.components.addressManager.getAddresses();\n  }\n\n  getProtocols() {\n    return this.components.registrar.getProtocols();\n  }\n\n  async hangUp(peer) {\n    if (isMultiaddr(peer)) {\n      peer = peerIdFromString(peer.getPeerId() ?? '');\n    }\n\n    await this.components.connectionManager.closeConnections(peer);\n  }\n  /**\n   * Get the public key for the given peer id\n   */\n\n\n  async getPublicKey(peer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    log('getPublicKey %p', peer);\n\n    if (peer.publicKey != null) {\n      return peer.publicKey;\n    }\n\n    const peerInfo = await this.peerStore.get(peer);\n\n    if (peerInfo.pubKey != null) {\n      return peerInfo.pubKey;\n    }\n\n    if (this.dht == null) {\n      throw errCode(new Error('Public key was not in the peer store and the DHT is not enabled'), codes.ERR_NO_ROUTERS_AVAILABLE);\n    }\n\n    const peerKey = uint8ArrayConcat([uint8ArrayFromString('/pk/'), peer.multihash.digest]); // search the dht\n\n    for await (const event of this.dht.get(peerKey, options)) {\n      if (event.name === 'VALUE') {\n        const key = unmarshalPublicKey(event.value);\n        await this.peerStore.keyBook.set(peer, event.value);\n        return key.bytes;\n      }\n    }\n\n    throw errCode(new Error(`Node not responding with its public key: ${peer.toString()}`), codes.ERR_INVALID_RECORD);\n  }\n\n  async fetch(peer, key) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (isMultiaddr(peer)) {\n      const peerId = peerIdFromString(peer.getPeerId() ?? '');\n      await this.components.peerStore.addressBook.add(peerId, [peer]);\n      peer = peerId;\n    }\n\n    return await this.fetchService.fetch(peer, key, options);\n  }\n\n  async ping(peer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (isMultiaddr(peer)) {\n      const peerId = peerIdFromString(peer.getPeerId() ?? '');\n      await this.components.peerStore.addressBook.add(peerId, [peer]);\n      peer = peerId;\n    }\n\n    return await this.pingService.ping(peer, options);\n  }\n\n  async handle(protocols, handler, options) {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols];\n    }\n\n    await Promise.all(protocols.map(async protocol => {\n      await this.components.registrar.handle(protocol, handler, options);\n    }));\n  }\n\n  async unhandle(protocols) {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols];\n    }\n\n    await Promise.all(protocols.map(async protocol => {\n      await this.components.registrar.unhandle(protocol);\n    }));\n  }\n\n  async register(protocol, topology) {\n    return await this.registrar.register(protocol, topology);\n  }\n\n  unregister(id) {\n    this.registrar.unregister(id);\n  }\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   */\n\n\n  onDiscoveryPeer(evt) {\n    const {\n      detail: peer\n    } = evt;\n\n    if (peer.id.toString() === this.peerId.toString()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF));\n      return;\n    }\n\n    if (peer.multiaddrs.length > 0) {\n      void this.components.peerStore.addressBook.add(peer.id, peer.multiaddrs).catch(err => log.error(err));\n    }\n\n    if (peer.protocols.length > 0) {\n      void this.components.peerStore.protoBook.set(peer.id, peer.protocols).catch(err => log.error(err));\n    }\n\n    this.dispatchEvent(new CustomEvent('peer:discovery', {\n      detail: peer\n    }));\n  }\n\n}\n/**\n * Returns a new Libp2pNode instance - this exposes more of the internals than the\n * libp2p interface and is useful for testing and debugging.\n */\n\nexport async function createLibp2pNode(options) {\n  if (options.peerId == null) {\n    const datastore = options.datastore;\n\n    if (datastore != null) {\n      try {\n        // try load the peer id from the keychain\n        // @ts-expect-error missing the peer id property\n        const keyChain = new KeyChain({\n          datastore\n        }, { ...KeyChain.generateOptions(),\n          ...(options.keychain ?? {})\n        });\n        options.peerId = await keyChain.exportPeerId('self');\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n      }\n    }\n  }\n\n  if (options.peerId == null) {\n    // no peer id in the keychain, create a new peer id\n    options.peerId = await createEd25519PeerId();\n  }\n\n  return new Libp2pNode(validateConfig(options));\n}","map":{"version":3,"mappings":"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","names":["logger","EventEmitter","CustomEvent","isStartable","isMultiaddr","MemoryDatastore","DefaultPeerRouting","CompoundContentRouting","codes","DefaultAddressManager","DefaultConnectionManager","AutoDialler","Circuit","Relay","KeyChain","DefaultTransportManager","DefaultUpgrader","DefaultRegistrar","IdentifyService","FetchService","PingService","NatManager","PeerRecordUpdater","DHTPeerRouting","PersistentPeerStore","DHTContentRouting","DefaultComponents","validateConfig","createEd25519PeerId","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","errCode","unmarshalPublicKey","DummyDHT","DummyPubSub","PeerSet","DefaultDialer","peerIdFromString","log","Libp2pNode","constructor","init","started","peerId","components","datastore","connectionGater","denyDialPeer","Promise","resolve","denyDialMultiaddr","denyInboundConnection","denyOutboundConnection","denyInboundEncryptedConnection","denyOutboundEncryptedConnection","denyInboundUpgradedConnection","denyOutboundUpgradedConnection","filterMultiaddrForPeer","peerStore","addressFilter","services","metrics","configureComponent","addEventListener","evt","detail","peerData","dispatchEvent","connectionProtector","upgrader","connectionEncryption","map","fn","muxers","streamMuxers","inboundUpgradeTimeout","connectionManager","dialer","event","registrar","transportManager","addressManager","addresses","enabled","autoDial","minConnections","autoDialInterval","keychainOpts","generateOptions","keychain","push","nat","transports","forEach","add","identifyService","identify","dht","pubsub","peerRouters","onDiscoveryPeer","peerRouting","routers","contentRouters","contentRouting","relay","addressSorter","fetchService","fetch","pingService","ping","peerDiscovery","service","component","start","all","beforeStart","afterStart","err","error","stop","beforeStop","afterStop","isStarted","getConnections","getPeers","peerSet","conn","remotePeer","Array","from","dial","peer","options","openConnection","dialProtocol","protocols","Error","ERR_INVALID_PROTOCOLS_FOR_STREAM","isArray","length","connection","newStream","getMultiaddrs","getAddresses","getProtocols","hangUp","getPeerId","closeConnections","getPublicKey","publicKey","peerInfo","get","pubKey","ERR_NO_ROUTERS_AVAILABLE","peerKey","multihash","digest","name","key","value","keyBook","set","bytes","toString","ERR_INVALID_RECORD","addressBook","handle","handler","protocol","unhandle","register","topology","unregister","id","ERR_DISCOVERED_SELF","multiaddrs","catch","protoBook","createLibp2pNode","keyChain","exportPeerId","code"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\libp2p.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events'\nimport { Startable, isStartable } from '@libp2p/interfaces/startable'\nimport { isMultiaddr, Multiaddr } from '@multiformats/multiaddr'\nimport { MemoryDatastore } from 'datastore-core/memory'\nimport { DefaultPeerRouting } from './peer-routing.js'\nimport { CompoundContentRouting } from './content-routing/index.js'\nimport { codes } from './errors.js'\nimport { DefaultAddressManager } from './address-manager/index.js'\nimport { DefaultConnectionManager } from './connection-manager/index.js'\nimport { AutoDialler } from './connection-manager/auto-dialler.js'\nimport { Circuit } from './circuit/transport.js'\nimport { Relay } from './circuit/index.js'\nimport { KeyChain } from './keychain/index.js'\nimport { DefaultTransportManager } from './transport-manager.js'\nimport { DefaultUpgrader } from './upgrader.js'\nimport { DefaultRegistrar } from './registrar.js'\nimport { IdentifyService } from './identify/index.js'\nimport { FetchService } from './fetch/index.js'\nimport { PingService } from './ping/index.js'\nimport { NatManager } from './nat-manager.js'\nimport { PeerRecordUpdater } from './peer-record-updater.js'\nimport { DHTPeerRouting } from './dht/dht-peer-routing.js'\nimport { PersistentPeerStore } from '@libp2p/peer-store'\nimport { DHTContentRouting } from './dht/dht-content-routing.js'\nimport { DefaultComponents } from './components.js'\nimport type { Components } from './components.js'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Connection } from '@libp2p/interface-connection'\nimport type { PeerRouting } from '@libp2p/interface-peer-routing'\nimport type { ContentRouting } from '@libp2p/interface-content-routing'\nimport type { PubSub } from '@libp2p/interface-pubsub'\nimport type { Registrar, StreamHandler, StreamHandlerOptions, Topology } from '@libp2p/interface-registrar'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { Libp2p, Libp2pEvents, Libp2pInit, Libp2pOptions } from './index.js'\nimport { validateConfig } from './config.js'\nimport { createEd25519PeerId } from '@libp2p/peer-id-factory'\nimport type { PeerStore } from '@libp2p/interface-peer-store'\nimport type { DualDHT } from '@libp2p/interface-dht'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport errCode from 'err-code'\nimport { unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport type { Metrics } from '@libp2p/interface-metrics'\nimport { DummyDHT } from './dht/dummy-dht.js'\nimport { DummyPubSub } from './pubsub/dummy-pubsub.js'\nimport { PeerSet } from '@libp2p/peer-collections'\nimport { DefaultDialer } from './connection-manager/dialer/index.js'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport type { Datastore } from 'interface-datastore'\n\nconst log = logger('libp2p')\n\nexport class Libp2pNode extends EventEmitter<Libp2pEvents> implements Libp2p {\n  public peerId: PeerId\n  public dht: DualDHT\n  public pubsub: PubSub\n  public identifyService: IdentifyService\n  public fetchService: FetchService\n  public pingService: PingService\n  public components: Components\n  public peerStore: PeerStore\n  public contentRouting: ContentRouting\n  public peerRouting: PeerRouting\n  public keychain: KeyChain\n  public connectionManager: ConnectionManager\n  public registrar: Registrar\n  public metrics?: Metrics\n\n  private started: boolean\n  private readonly services: Startable[]\n\n  constructor (init: Libp2pInit) {\n    super()\n\n    this.started = false\n    this.peerId = init.peerId\n    const components = this.components = new DefaultComponents({\n      peerId: init.peerId,\n      datastore: init.datastore ?? new MemoryDatastore(),\n      connectionGater: {\n        denyDialPeer: async () => await Promise.resolve(false),\n        denyDialMultiaddr: async () => await Promise.resolve(false),\n        denyInboundConnection: async () => await Promise.resolve(false),\n        denyOutboundConnection: async () => await Promise.resolve(false),\n        denyInboundEncryptedConnection: async () => await Promise.resolve(false),\n        denyOutboundEncryptedConnection: async () => await Promise.resolve(false),\n        denyInboundUpgradedConnection: async () => await Promise.resolve(false),\n        denyOutboundUpgradedConnection: async () => await Promise.resolve(false),\n        filterMultiaddrForPeer: async () => await Promise.resolve(true),\n        ...init.connectionGater\n      }\n    })\n    components.peerStore = new PersistentPeerStore(components, {\n      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,\n      ...init.peerStore\n    })\n\n    this.services = [\n      components\n    ]\n\n    // Create Metrics\n    if (init.metrics != null) {\n      this.metrics = this.components.metrics = this.configureComponent(init.metrics(this.components))\n    }\n\n    this.peerStore = this.components.peerStore\n\n    this.peerStore.addEventListener('peer', evt => {\n      const { detail: peerData } = evt\n\n      this.dispatchEvent(new CustomEvent<PeerInfo>('peer:discovery', { detail: peerData }))\n    })\n\n    // Set up connection protector if configured\n    if (init.connectionProtector != null) {\n      this.components.connectionProtector = init.connectionProtector(components)\n    }\n\n    // Set up the Upgrader\n    this.components.upgrader = new DefaultUpgrader(this.components, {\n      connectionEncryption: (init.connectionEncryption ?? []).map(fn => this.configureComponent(fn(this.components))),\n      muxers: (init.streamMuxers ?? []).map(fn => this.configureComponent(fn(this.components))),\n      inboundUpgradeTimeout: init.connectionManager.inboundUpgradeTimeout\n    })\n\n    // Create the dialer\n    this.components.dialer = new DefaultDialer(this.components, init.connectionManager)\n\n    // Create the Connection Manager\n    this.connectionManager = this.components.connectionManager = new DefaultConnectionManager(this.components, init.connectionManager)\n\n    // forward connection manager events\n    this.components.connectionManager.addEventListener('peer:disconnect', (event) => {\n      this.dispatchEvent(new CustomEvent<Connection>('peer:disconnect', { detail: event.detail }))\n    })\n    this.components.connectionManager.addEventListener('peer:connect', (event) => {\n      this.dispatchEvent(new CustomEvent<Connection>('peer:connect', { detail: event.detail }))\n    })\n\n    // Create the Registrar\n    this.registrar = this.components.registrar = new DefaultRegistrar(this.components)\n\n    // Setup the transport manager\n    this.components.transportManager = new DefaultTransportManager(this.components, init.transportManager)\n\n    // Addresses {listen, announce, noAnnounce}\n    this.components.addressManager = new DefaultAddressManager(this.components, init.addresses)\n\n    // update our peer record when addresses change\n    this.configureComponent(new PeerRecordUpdater(this.components))\n\n    this.configureComponent(new AutoDialler(this.components, {\n      enabled: init.connectionManager.autoDial,\n      minConnections: init.connectionManager.minConnections,\n      autoDialInterval: init.connectionManager.autoDialInterval\n    }))\n\n    // Create keychain\n    const keychainOpts = KeyChain.generateOptions()\n    this.keychain = this.configureComponent(new KeyChain(this.components, {\n      ...keychainOpts,\n      ...init.keychain\n    }))\n\n    // Create the Nat Manager\n    this.services.push(new NatManager(this.components, init.nat))\n\n    init.transports.forEach((fn) => {\n      this.components.transportManager.add(this.configureComponent(fn(this.components)))\n    })\n\n    // Add the identify service\n    this.identifyService = new IdentifyService(this.components, {\n      ...init.identify\n    })\n    this.configureComponent(this.identifyService)\n\n    // dht provided components (peerRouting, contentRouting, dht)\n    if (init.dht != null) {\n      this.dht = this.components.dht = init.dht(this.components)\n    } else {\n      this.dht = new DummyDHT()\n    }\n\n    // Create pubsub if provided\n    if (init.pubsub != null) {\n      this.pubsub = this.components.pubsub = init.pubsub(this.components)\n    } else {\n      this.pubsub = new DummyPubSub()\n    }\n\n    // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n    const peerRouters: PeerRouting[] = (init.peerRouters ?? []).map(fn => this.configureComponent(fn(this.components)))\n\n    if (init.dht != null) {\n      // add dht to routers\n      peerRouters.push(this.configureComponent(new DHTPeerRouting(this.dht)))\n\n      // use dht for peer discovery\n      this.dht.addEventListener('peer', (evt) => {\n        this.onDiscoveryPeer(evt)\n      })\n    }\n\n    this.peerRouting = this.components.peerRouting = this.configureComponent(new DefaultPeerRouting(this.components, {\n      ...init.peerRouting,\n      routers: peerRouters\n    }))\n\n    const contentRouters: ContentRouting[] = (init.contentRouters ?? []).map(fn => this.configureComponent(fn(this.components)))\n\n    if (init.dht != null) {\n      // add dht to routers\n      contentRouters.push(this.configureComponent(new DHTContentRouting(this.dht)))\n    }\n\n    this.contentRouting = this.components.contentRouting = this.configureComponent(new CompoundContentRouting(this.components, {\n      routers: contentRouters\n    }))\n\n    if (init.relay.enabled) {\n      this.components.transportManager.add(this.configureComponent(new Circuit(this.components, init.relay)))\n\n      this.configureComponent(new Relay(this.components, {\n        addressSorter: init.connectionManager.addressSorter,\n        ...init.relay\n      }))\n    }\n\n    this.fetchService = this.configureComponent(new FetchService(this.components, {\n      ...init.fetch\n    }))\n\n    this.pingService = this.configureComponent(new PingService(this.components, {\n      ...init.ping\n    }))\n\n    // Discovery modules\n    for (const fn of init.peerDiscovery ?? []) {\n      const service = this.configureComponent(fn(this.components))\n\n      service.addEventListener('peer', (evt) => {\n        this.onDiscoveryPeer(evt)\n      })\n    }\n  }\n\n  private configureComponent <T> (component: T): T {\n    if (isStartable(component)) {\n      this.services.push(component)\n    }\n\n    return component\n  }\n\n  /**\n   * Starts the libp2p node and all its subsystems\n   */\n  async start () {\n    if (this.started) {\n      return\n    }\n\n    this.started = true\n\n    log('libp2p is starting')\n\n    try {\n      await Promise.all(\n        this.services.map(async service => {\n          if (service.beforeStart != null) {\n            await service.beforeStart()\n          }\n        })\n      )\n\n      // start any startables\n      await Promise.all(\n        this.services.map(service => service.start())\n      )\n\n      await Promise.all(\n        this.services.map(async service => {\n          if (service.afterStart != null) {\n            await service.afterStart()\n          }\n        })\n      )\n\n      log('libp2p has started')\n    } catch (err: any) {\n      log.error('An error occurred starting libp2p', err)\n      await this.stop()\n      throw err\n    }\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   */\n  async stop () {\n    if (!this.started) {\n      return\n    }\n\n    log('libp2p is stopping')\n\n    this.started = false\n\n    await Promise.all(\n      this.services.map(async service => {\n        if (service.beforeStop != null) {\n          await service.beforeStop()\n        }\n      })\n    )\n\n    await Promise.all(\n      this.services.map(service => service.stop())\n    )\n\n    await Promise.all(\n      this.services.map(async service => {\n        if (service.afterStop != null) {\n          await service.afterStop()\n        }\n      })\n    )\n\n    log('libp2p has stopped')\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  getConnections (peerId?: PeerId): Connection[] {\n    return this.components.connectionManager.getConnections(peerId)\n  }\n\n  getPeers (): PeerId[] {\n    const peerSet = new PeerSet()\n\n    for (const conn of this.components.connectionManager.getConnections()) {\n      peerSet.add(conn.remotePeer)\n    }\n\n    return Array.from(peerSet)\n  }\n\n  async dial (peer: PeerId | Multiaddr, options: AbortOptions = {}): Promise<Connection> {\n    return await this.components.connectionManager.openConnection(peer, options)\n  }\n\n  async dialProtocol (peer: PeerId | Multiaddr, protocols: string | string[], options: AbortOptions = {}) {\n    if (protocols == null) {\n      throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM)\n    }\n\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n\n    if (protocols.length === 0) {\n      throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM)\n    }\n\n    const connection = await this.dial(peer, options)\n\n    return await connection.newStream(protocols, options)\n  }\n\n  getMultiaddrs (): Multiaddr[] {\n    return this.components.addressManager.getAddresses()\n  }\n\n  getProtocols (): string[] {\n    return this.components.registrar.getProtocols()\n  }\n\n  async hangUp (peer: PeerId | Multiaddr): Promise<void> {\n    if (isMultiaddr(peer)) {\n      peer = peerIdFromString(peer.getPeerId() ?? '')\n    }\n\n    await this.components.connectionManager.closeConnections(peer)\n  }\n\n  /**\n   * Get the public key for the given peer id\n   */\n  async getPublicKey (peer: PeerId, options: AbortOptions = {}): Promise<Uint8Array> {\n    log('getPublicKey %p', peer)\n\n    if (peer.publicKey != null) {\n      return peer.publicKey\n    }\n\n    const peerInfo = await this.peerStore.get(peer)\n\n    if (peerInfo.pubKey != null) {\n      return peerInfo.pubKey\n    }\n\n    if (this.dht == null) {\n      throw errCode(new Error('Public key was not in the peer store and the DHT is not enabled'), codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    const peerKey = uint8ArrayConcat([\n      uint8ArrayFromString('/pk/'),\n      peer.multihash.digest\n    ])\n\n    // search the dht\n    for await (const event of this.dht.get(peerKey, options)) {\n      if (event.name === 'VALUE') {\n        const key = unmarshalPublicKey(event.value)\n\n        await this.peerStore.keyBook.set(peer, event.value)\n\n        return key.bytes\n      }\n    }\n\n    throw errCode(new Error(`Node not responding with its public key: ${peer.toString()}`), codes.ERR_INVALID_RECORD)\n  }\n\n  async fetch (peer: PeerId | Multiaddr, key: string, options: AbortOptions = {}): Promise<Uint8Array | null> {\n    if (isMultiaddr(peer)) {\n      const peerId = peerIdFromString(peer.getPeerId() ?? '')\n      await this.components.peerStore.addressBook.add(peerId, [peer])\n      peer = peerId\n    }\n\n    return await this.fetchService.fetch(peer, key, options)\n  }\n\n  async ping (peer: PeerId | Multiaddr, options: AbortOptions = {}): Promise<number> {\n    if (isMultiaddr(peer)) {\n      const peerId = peerIdFromString(peer.getPeerId() ?? '')\n      await this.components.peerStore.addressBook.add(peerId, [peer])\n      peer = peerId\n    }\n\n    return await this.pingService.ping(peer, options)\n  }\n\n  async handle (protocols: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void> {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    await Promise.all(\n      protocols.map(async protocol => {\n        await this.components.registrar.handle(protocol, handler, options)\n      })\n    )\n  }\n\n  async unhandle (protocols: string[] | string): Promise<void> {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    await Promise.all(\n      protocols.map(async protocol => {\n        await this.components.registrar.unhandle(protocol)\n      })\n    )\n  }\n\n  async register (protocol: string, topology: Topology): Promise<string> {\n    return await this.registrar.register(protocol, topology)\n  }\n\n  unregister (id: string) {\n    this.registrar.unregister(id)\n  }\n\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   */\n  onDiscoveryPeer (evt: CustomEvent<PeerInfo>) {\n    const { detail: peer } = evt\n\n    if (peer.id.toString() === this.peerId.toString()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF))\n      return\n    }\n\n    if (peer.multiaddrs.length > 0) {\n      void this.components.peerStore.addressBook.add(peer.id, peer.multiaddrs).catch(err => log.error(err))\n    }\n\n    if (peer.protocols.length > 0) {\n      void this.components.peerStore.protoBook.set(peer.id, peer.protocols).catch(err => log.error(err))\n    }\n\n    this.dispatchEvent(new CustomEvent<PeerInfo>('peer:discovery', { detail: peer }))\n  }\n}\n\n/**\n * Returns a new Libp2pNode instance - this exposes more of the internals than the\n * libp2p interface and is useful for testing and debugging.\n */\nexport async function createLibp2pNode (options: Libp2pOptions): Promise<Libp2pNode> {\n  if (options.peerId == null) {\n    const datastore = options.datastore as Datastore | undefined\n\n    if (datastore != null) {\n      try {\n        // try load the peer id from the keychain\n        // @ts-expect-error missing the peer id property\n        const keyChain = new KeyChain({\n          datastore\n        }, {\n          ...KeyChain.generateOptions(),\n          ...(options.keychain ?? {})\n        })\n\n        options.peerId = await keyChain.exportPeerId('self')\n      } catch (err: any) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n    }\n  }\n\n  if (options.peerId == null) {\n    // no peer id in the keychain, create a new peer id\n    options.peerId = await createEd25519PeerId()\n  }\n\n  return new Libp2pNode(validateConfig(options))\n}\n"]},"metadata":{},"sourceType":"module"}