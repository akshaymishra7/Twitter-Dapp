{"ast":null,"code":"'use strict';\n\nconst {\n  AbstractIterator\n} = require('abstract-level');\n\nconst createKeyRange = require('./util/key-range');\n\nconst deserialize = require('./util/deserialize');\n\nconst kCache = Symbol('cache');\nconst kFinished = Symbol('finished');\nconst kOptions = Symbol('options');\nconst kCurrentOptions = Symbol('currentOptions');\nconst kPosition = Symbol('position');\nconst kLocation = Symbol('location');\nconst kFirst = Symbol('first');\nconst emptyOptions = {};\n\nclass Iterator extends AbstractIterator {\n  constructor(db, location, options) {\n    super(db, options);\n    this[kCache] = [];\n    this[kFinished] = this.limit === 0;\n    this[kOptions] = options;\n    this[kCurrentOptions] = { ...options\n    };\n    this[kPosition] = undefined;\n    this[kLocation] = location;\n    this[kFirst] = true;\n  } // Note: if called by _all() then size can be Infinity. This is an internal\n  // detail; by design AbstractIterator.nextv() does not support Infinity.\n\n\n  _nextv(size, options, callback) {\n    this[kFirst] = false;\n\n    if (this[kFinished]) {\n      return this.nextTick(callback, null, []);\n    } else if (this[kCache].length > 0) {\n      // TODO: mixing next and nextv is not covered by test suite\n      size = Math.min(size, this[kCache].length);\n      return this.nextTick(callback, null, this[kCache].splice(0, size));\n    } // Adjust range by what we already visited\n\n\n    if (this[kPosition] !== undefined) {\n      if (this[kOptions].reverse) {\n        this[kCurrentOptions].lt = this[kPosition];\n        this[kCurrentOptions].lte = undefined;\n      } else {\n        this[kCurrentOptions].gt = this[kPosition];\n        this[kCurrentOptions].gte = undefined;\n      }\n    }\n\n    let keyRange;\n\n    try {\n      keyRange = createKeyRange(this[kCurrentOptions]);\n    } catch (_) {\n      // The lower key is greater than the upper key.\n      // IndexedDB throws an error, but we'll just return 0 results.\n      this[kFinished] = true;\n      return this.nextTick(callback, null, []);\n    }\n\n    const transaction = this.db.db.transaction([this[kLocation]], 'readonly');\n    const store = transaction.objectStore(this[kLocation]);\n    const entries = [];\n\n    if (!this[kOptions].reverse) {\n      let keys;\n      let values;\n\n      const complete = () => {\n        // Wait for both requests to complete\n        if (keys === undefined || values === undefined) return;\n        const length = Math.max(keys.length, values.length);\n\n        if (length === 0 || size === Infinity) {\n          this[kFinished] = true;\n        } else {\n          this[kPosition] = keys[length - 1];\n        } // Resize\n\n\n        entries.length = length; // Merge keys and values\n\n        for (let i = 0; i < length; i++) {\n          const key = keys[i];\n          const value = values[i];\n          entries[i] = [this[kOptions].keys && key !== undefined ? deserialize(key) : undefined, this[kOptions].values && value !== undefined ? deserialize(value) : undefined];\n        }\n\n        maybeCommit(transaction);\n      }; // If keys were not requested and size is Infinity, we don't have to keep\n      // track of position and can thus skip getting keys.\n\n\n      if (this[kOptions].keys || size < Infinity) {\n        store.getAllKeys(keyRange, size < Infinity ? size : undefined).onsuccess = ev => {\n          keys = ev.target.result;\n          complete();\n        };\n      } else {\n        keys = [];\n        this.nextTick(complete);\n      }\n\n      if (this[kOptions].values) {\n        store.getAll(keyRange, size < Infinity ? size : undefined).onsuccess = ev => {\n          values = ev.target.result;\n          complete();\n        };\n      } else {\n        values = [];\n        this.nextTick(complete);\n      }\n    } else {\n      // Can't use getAll() in reverse, so use a slower cursor that yields one item at a time\n      // TODO: test if all target browsers support openKeyCursor\n      const method = !this[kOptions].values && store.openKeyCursor ? 'openKeyCursor' : 'openCursor';\n\n      store[method](keyRange, 'prev').onsuccess = ev => {\n        const cursor = ev.target.result;\n\n        if (cursor) {\n          const {\n            key,\n            value\n          } = cursor;\n          this[kPosition] = key;\n          entries.push([this[kOptions].keys && key !== undefined ? deserialize(key) : undefined, this[kOptions].values && value !== undefined ? deserialize(value) : undefined]);\n\n          if (entries.length < size) {\n            cursor.continue();\n          } else {\n            maybeCommit(transaction);\n          }\n        } else {\n          this[kFinished] = true;\n        }\n      };\n    } // If an error occurs (on the request), the transaction will abort.\n\n\n    transaction.onabort = () => {\n      callback(transaction.error || new Error('aborted by user'));\n      callback = null;\n    };\n\n    transaction.oncomplete = () => {\n      callback(null, entries);\n      callback = null;\n    };\n  }\n\n  _next(callback) {\n    if (this[kCache].length > 0) {\n      const [key, value] = this[kCache].shift();\n      this.nextTick(callback, null, key, value);\n    } else if (this[kFinished]) {\n      this.nextTick(callback);\n    } else {\n      let size = Math.min(100, this.limit - this.count);\n\n      if (this[kFirst]) {\n        // It's common to only want one entry initially or after a seek()\n        this[kFirst] = false;\n        size = 1;\n      }\n\n      this._nextv(size, emptyOptions, (err, entries) => {\n        if (err) return callback(err);\n        this[kCache] = entries;\n\n        this._next(callback);\n      });\n    }\n  }\n\n  _all(options, callback) {\n    this[kFirst] = false; // TODO: mixing next and all is not covered by test suite\n\n    const cache = this[kCache].splice(0, this[kCache].length);\n    const size = this.limit - this.count - cache.length;\n\n    if (size <= 0) {\n      return this.nextTick(callback, null, cache);\n    }\n\n    this._nextv(size, emptyOptions, (err, entries) => {\n      if (err) return callback(err);\n      if (cache.length > 0) entries = cache.concat(entries);\n      callback(null, entries);\n    });\n  }\n\n  _seek(target, options) {\n    this[kFirst] = true;\n    this[kCache] = [];\n    this[kFinished] = false;\n    this[kPosition] = undefined; // TODO: not covered by test suite\n\n    this[kCurrentOptions] = { ...this[kOptions]\n    };\n    let keyRange;\n\n    try {\n      keyRange = createKeyRange(this[kOptions]);\n    } catch (_) {\n      this[kFinished] = true;\n      return;\n    }\n\n    if (keyRange !== null && !keyRange.includes(target)) {\n      this[kFinished] = true;\n    } else if (this[kOptions].reverse) {\n      this[kCurrentOptions].lte = target;\n    } else {\n      this[kCurrentOptions].gte = target;\n    }\n  }\n\n}\n\nexports.Iterator = Iterator;\n\nfunction maybeCommit(transaction) {\n  // Commit (meaning close) now instead of waiting for auto-commit\n  if (typeof transaction.commit === 'function') {\n    transaction.commit();\n  }\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/browser-level/iterator.js"],"names":["AbstractIterator","require","createKeyRange","deserialize","kCache","Symbol","kFinished","kOptions","kCurrentOptions","kPosition","kLocation","kFirst","emptyOptions","Iterator","constructor","db","location","options","limit","undefined","_nextv","size","callback","nextTick","length","Math","min","splice","reverse","lt","lte","gt","gte","keyRange","_","transaction","store","objectStore","entries","keys","values","complete","max","Infinity","i","key","value","maybeCommit","getAllKeys","onsuccess","ev","target","result","getAll","method","openKeyCursor","cursor","push","continue","onabort","error","Error","oncomplete","_next","shift","count","err","_all","cache","concat","_seek","includes","exports","commit"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { AbstractIterator } = require('abstract-level')\nconst createKeyRange = require('./util/key-range')\nconst deserialize = require('./util/deserialize')\n\nconst kCache = Symbol('cache')\nconst kFinished = Symbol('finished')\nconst kOptions = Symbol('options')\nconst kCurrentOptions = Symbol('currentOptions')\nconst kPosition = Symbol('position')\nconst kLocation = Symbol('location')\nconst kFirst = Symbol('first')\nconst emptyOptions = {}\n\nclass Iterator extends AbstractIterator {\n  constructor (db, location, options) {\n    super(db, options)\n\n    this[kCache] = []\n    this[kFinished] = this.limit === 0\n    this[kOptions] = options\n    this[kCurrentOptions] = { ...options }\n    this[kPosition] = undefined\n    this[kLocation] = location\n    this[kFirst] = true\n  }\n\n  // Note: if called by _all() then size can be Infinity. This is an internal\n  // detail; by design AbstractIterator.nextv() does not support Infinity.\n  _nextv (size, options, callback) {\n    this[kFirst] = false\n\n    if (this[kFinished]) {\n      return this.nextTick(callback, null, [])\n    } else if (this[kCache].length > 0) {\n      // TODO: mixing next and nextv is not covered by test suite\n      size = Math.min(size, this[kCache].length)\n      return this.nextTick(callback, null, this[kCache].splice(0, size))\n    }\n\n    // Adjust range by what we already visited\n    if (this[kPosition] !== undefined) {\n      if (this[kOptions].reverse) {\n        this[kCurrentOptions].lt = this[kPosition]\n        this[kCurrentOptions].lte = undefined\n      } else {\n        this[kCurrentOptions].gt = this[kPosition]\n        this[kCurrentOptions].gte = undefined\n      }\n    }\n\n    let keyRange\n\n    try {\n      keyRange = createKeyRange(this[kCurrentOptions])\n    } catch (_) {\n      // The lower key is greater than the upper key.\n      // IndexedDB throws an error, but we'll just return 0 results.\n      this[kFinished] = true\n      return this.nextTick(callback, null, [])\n    }\n\n    const transaction = this.db.db.transaction([this[kLocation]], 'readonly')\n    const store = transaction.objectStore(this[kLocation])\n    const entries = []\n\n    if (!this[kOptions].reverse) {\n      let keys\n      let values\n\n      const complete = () => {\n        // Wait for both requests to complete\n        if (keys === undefined || values === undefined) return\n\n        const length = Math.max(keys.length, values.length)\n\n        if (length === 0 || size === Infinity) {\n          this[kFinished] = true\n        } else {\n          this[kPosition] = keys[length - 1]\n        }\n\n        // Resize\n        entries.length = length\n\n        // Merge keys and values\n        for (let i = 0; i < length; i++) {\n          const key = keys[i]\n          const value = values[i]\n\n          entries[i] = [\n            this[kOptions].keys && key !== undefined ? deserialize(key) : undefined,\n            this[kOptions].values && value !== undefined ? deserialize(value) : undefined\n          ]\n        }\n\n        maybeCommit(transaction)\n      }\n\n      // If keys were not requested and size is Infinity, we don't have to keep\n      // track of position and can thus skip getting keys.\n      if (this[kOptions].keys || size < Infinity) {\n        store.getAllKeys(keyRange, size < Infinity ? size : undefined).onsuccess = (ev) => {\n          keys = ev.target.result\n          complete()\n        }\n      } else {\n        keys = []\n        this.nextTick(complete)\n      }\n\n      if (this[kOptions].values) {\n        store.getAll(keyRange, size < Infinity ? size : undefined).onsuccess = (ev) => {\n          values = ev.target.result\n          complete()\n        }\n      } else {\n        values = []\n        this.nextTick(complete)\n      }\n    } else {\n      // Can't use getAll() in reverse, so use a slower cursor that yields one item at a time\n      // TODO: test if all target browsers support openKeyCursor\n      const method = !this[kOptions].values && store.openKeyCursor ? 'openKeyCursor' : 'openCursor'\n\n      store[method](keyRange, 'prev').onsuccess = (ev) => {\n        const cursor = ev.target.result\n\n        if (cursor) {\n          const { key, value } = cursor\n          this[kPosition] = key\n\n          entries.push([\n            this[kOptions].keys && key !== undefined ? deserialize(key) : undefined,\n            this[kOptions].values && value !== undefined ? deserialize(value) : undefined\n          ])\n\n          if (entries.length < size) {\n            cursor.continue()\n          } else {\n            maybeCommit(transaction)\n          }\n        } else {\n          this[kFinished] = true\n        }\n      }\n    }\n\n    // If an error occurs (on the request), the transaction will abort.\n    transaction.onabort = () => {\n      callback(transaction.error || new Error('aborted by user'))\n      callback = null\n    }\n\n    transaction.oncomplete = () => {\n      callback(null, entries)\n      callback = null\n    }\n  }\n\n  _next (callback) {\n    if (this[kCache].length > 0) {\n      const [key, value] = this[kCache].shift()\n      this.nextTick(callback, null, key, value)\n    } else if (this[kFinished]) {\n      this.nextTick(callback)\n    } else {\n      let size = Math.min(100, this.limit - this.count)\n\n      if (this[kFirst]) {\n        // It's common to only want one entry initially or after a seek()\n        this[kFirst] = false\n        size = 1\n      }\n\n      this._nextv(size, emptyOptions, (err, entries) => {\n        if (err) return callback(err)\n        this[kCache] = entries\n        this._next(callback)\n      })\n    }\n  }\n\n  _all (options, callback) {\n    this[kFirst] = false\n\n    // TODO: mixing next and all is not covered by test suite\n    const cache = this[kCache].splice(0, this[kCache].length)\n    const size = this.limit - this.count - cache.length\n\n    if (size <= 0) {\n      return this.nextTick(callback, null, cache)\n    }\n\n    this._nextv(size, emptyOptions, (err, entries) => {\n      if (err) return callback(err)\n      if (cache.length > 0) entries = cache.concat(entries)\n      callback(null, entries)\n    })\n  }\n\n  _seek (target, options) {\n    this[kFirst] = true\n    this[kCache] = []\n    this[kFinished] = false\n    this[kPosition] = undefined\n\n    // TODO: not covered by test suite\n    this[kCurrentOptions] = { ...this[kOptions] }\n\n    let keyRange\n\n    try {\n      keyRange = createKeyRange(this[kOptions])\n    } catch (_) {\n      this[kFinished] = true\n      return\n    }\n\n    if (keyRange !== null && !keyRange.includes(target)) {\n      this[kFinished] = true\n    } else if (this[kOptions].reverse) {\n      this[kCurrentOptions].lte = target\n    } else {\n      this[kCurrentOptions].gte = target\n    }\n  }\n}\n\nexports.Iterator = Iterator\n\nfunction maybeCommit (transaction) {\n  // Commit (meaning close) now instead of waiting for auto-commit\n  if (typeof transaction.commit === 'function') {\n    transaction.commit()\n  }\n}\n"]},"metadata":{},"sourceType":"script"}