{"ast":null,"code":"/* global indexedDB */\n'use strict';\n\nconst {\n  AbstractLevel\n} = require('abstract-level');\n\nconst ModuleError = require('module-error');\n\nconst parallel = require('run-parallel-limit');\n\nconst {\n  fromCallback\n} = require('catering');\n\nconst {\n  Iterator\n} = require('./iterator');\n\nconst deserialize = require('./util/deserialize');\n\nconst clear = require('./util/clear');\n\nconst createKeyRange = require('./util/key-range'); // Keep as-is for compatibility with existing level-js databases\n\n\nconst DEFAULT_PREFIX = 'level-js-';\nconst kIDB = Symbol('idb');\nconst kNamePrefix = Symbol('namePrefix');\nconst kLocation = Symbol('location');\nconst kVersion = Symbol('version');\nconst kStore = Symbol('store');\nconst kOnComplete = Symbol('onComplete');\nconst kPromise = Symbol('promise');\n\nclass BrowserLevel extends AbstractLevel {\n  constructor(location, options, _) {\n    // To help migrating to abstract-level\n    if (typeof options === 'function' || typeof _ === 'function') {\n      throw new ModuleError('The levelup-style callback argument has been removed', {\n        code: 'LEVEL_LEGACY'\n      });\n    }\n\n    const {\n      prefix,\n      version,\n      ...forward\n    } = options || {};\n    super({\n      encodings: {\n        view: true\n      },\n      snapshots: false,\n      createIfMissing: false,\n      errorIfExists: false,\n      seek: true\n    }, forward);\n\n    if (typeof location !== 'string') {\n      throw new Error('constructor requires a location string argument');\n    } // TODO (next major): remove default prefix\n\n\n    this[kLocation] = location;\n    this[kNamePrefix] = prefix == null ? DEFAULT_PREFIX : prefix;\n    this[kVersion] = parseInt(version || 1, 10);\n    this[kIDB] = null;\n  }\n\n  get location() {\n    return this[kLocation];\n  }\n\n  get namePrefix() {\n    return this[kNamePrefix];\n  }\n\n  get version() {\n    return this[kVersion];\n  } // Exposed for backwards compat and unit tests\n\n\n  get db() {\n    return this[kIDB];\n  }\n\n  get type() {\n    return 'browser-level';\n  }\n\n  _open(options, callback) {\n    const req = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion]);\n\n    req.onerror = function () {\n      callback(req.error || new Error('unknown error'));\n    };\n\n    req.onsuccess = () => {\n      this[kIDB] = req.result;\n      callback();\n    };\n\n    req.onupgradeneeded = ev => {\n      const db = ev.target.result;\n\n      if (!db.objectStoreNames.contains(this[kLocation])) {\n        db.createObjectStore(this[kLocation]);\n      }\n    };\n  }\n\n  [kStore](mode) {\n    const transaction = this[kIDB].transaction([this[kLocation]], mode);\n    return transaction.objectStore(this[kLocation]);\n  }\n\n  [kOnComplete](request, callback) {\n    const transaction = request.transaction; // Take advantage of the fact that a non-canceled request error aborts\n    // the transaction. I.e. no need to listen for \"request.onerror\".\n\n    transaction.onabort = function () {\n      callback(transaction.error || new Error('aborted by user'));\n    };\n\n    transaction.oncomplete = function () {\n      callback(null, request.result);\n    };\n  }\n\n  _get(key, options, callback) {\n    const store = this[kStore]('readonly');\n    let req;\n\n    try {\n      req = store.get(key);\n    } catch (err) {\n      return this.nextTick(callback, err);\n    }\n\n    this[kOnComplete](req, function (err, value) {\n      if (err) return callback(err);\n\n      if (value === undefined) {\n        return callback(new ModuleError('Entry not found', {\n          code: 'LEVEL_NOT_FOUND'\n        }));\n      }\n\n      callback(null, deserialize(value));\n    });\n  }\n\n  _getMany(keys, options, callback) {\n    const store = this[kStore]('readonly');\n    const tasks = keys.map(key => next => {\n      let request;\n\n      try {\n        request = store.get(key);\n      } catch (err) {\n        return next(err);\n      }\n\n      request.onsuccess = () => {\n        const value = request.result;\n        next(null, value === undefined ? value : deserialize(value));\n      };\n\n      request.onerror = ev => {\n        ev.stopPropagation();\n        next(request.error);\n      };\n    });\n    parallel(tasks, 16, callback);\n  }\n\n  _del(key, options, callback) {\n    const store = this[kStore]('readwrite');\n    let req;\n\n    try {\n      req = store.delete(key);\n    } catch (err) {\n      return this.nextTick(callback, err);\n    }\n\n    this[kOnComplete](req, callback);\n  }\n\n  _put(key, value, options, callback) {\n    const store = this[kStore]('readwrite');\n    let req;\n\n    try {\n      // Will throw a DataError or DataCloneError if the environment\n      // does not support serializing the key or value respectively.\n      req = store.put(value, key);\n    } catch (err) {\n      return this.nextTick(callback, err);\n    }\n\n    this[kOnComplete](req, callback);\n  } // TODO: implement key and value iterators\n\n\n  _iterator(options) {\n    return new Iterator(this, this[kLocation], options);\n  }\n\n  _batch(operations, options, callback) {\n    const store = this[kStore]('readwrite');\n    const transaction = store.transaction;\n    let index = 0;\n    let error;\n\n    transaction.onabort = function () {\n      callback(error || transaction.error || new Error('aborted by user'));\n    };\n\n    transaction.oncomplete = function () {\n      callback();\n    }; // Wait for a request to complete before making the next, saving CPU.\n\n\n    function loop() {\n      const op = operations[index++];\n      const key = op.key;\n      let req;\n\n      try {\n        req = op.type === 'del' ? store.delete(key) : store.put(op.value, key);\n      } catch (err) {\n        error = err;\n        transaction.abort();\n        return;\n      }\n\n      if (index < operations.length) {\n        req.onsuccess = loop;\n      } else if (typeof transaction.commit === 'function') {\n        // Commit now instead of waiting for auto-commit\n        transaction.commit();\n      }\n    }\n\n    loop();\n  }\n\n  _clear(options, callback) {\n    let keyRange;\n    let req;\n\n    try {\n      keyRange = createKeyRange(options);\n    } catch (e) {\n      // The lower key is greater than the upper key.\n      // IndexedDB throws an error, but we'll just do nothing.\n      return this.nextTick(callback);\n    }\n\n    if (options.limit >= 0) {\n      // IDBObjectStore#delete(range) doesn't have such an option.\n      // Fall back to cursor-based implementation.\n      return clear(this, this[kLocation], keyRange, options, callback);\n    }\n\n    try {\n      const store = this[kStore]('readwrite');\n      req = keyRange ? store.delete(keyRange) : store.clear();\n    } catch (err) {\n      return this.nextTick(callback, err);\n    }\n\n    this[kOnComplete](req, callback);\n  }\n\n  _close(callback) {\n    this[kIDB].close();\n    this.nextTick(callback);\n  }\n\n}\n\nBrowserLevel.destroy = function (location, prefix, callback) {\n  if (typeof prefix === 'function') {\n    callback = prefix;\n    prefix = DEFAULT_PREFIX;\n  }\n\n  callback = fromCallback(callback, kPromise);\n  const request = indexedDB.deleteDatabase(prefix + location);\n\n  request.onsuccess = function () {\n    callback();\n  };\n\n  request.onerror = function (err) {\n    callback(err);\n  };\n\n  return callback[kPromise];\n};\n\nexports.BrowserLevel = BrowserLevel;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/browser-level/index.js"],"names":["AbstractLevel","require","ModuleError","parallel","fromCallback","Iterator","deserialize","clear","createKeyRange","DEFAULT_PREFIX","kIDB","Symbol","kNamePrefix","kLocation","kVersion","kStore","kOnComplete","kPromise","BrowserLevel","constructor","location","options","_","code","prefix","version","forward","encodings","view","snapshots","createIfMissing","errorIfExists","seek","Error","parseInt","namePrefix","db","type","_open","callback","req","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","ev","target","objectStoreNames","contains","createObjectStore","mode","transaction","objectStore","request","onabort","oncomplete","_get","key","store","get","err","nextTick","value","undefined","_getMany","keys","tasks","map","next","stopPropagation","_del","delete","_put","put","_iterator","_batch","operations","index","loop","op","abort","length","commit","_clear","keyRange","e","limit","_close","close","destroy","deleteDatabase","exports"],"mappings":"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","sourcesContent":["/* global indexedDB */\n\n'use strict'\n\nconst { AbstractLevel } = require('abstract-level')\nconst ModuleError = require('module-error')\nconst parallel = require('run-parallel-limit')\nconst { fromCallback } = require('catering')\nconst { Iterator } = require('./iterator')\nconst deserialize = require('./util/deserialize')\nconst clear = require('./util/clear')\nconst createKeyRange = require('./util/key-range')\n\n// Keep as-is for compatibility with existing level-js databases\nconst DEFAULT_PREFIX = 'level-js-'\n\nconst kIDB = Symbol('idb')\nconst kNamePrefix = Symbol('namePrefix')\nconst kLocation = Symbol('location')\nconst kVersion = Symbol('version')\nconst kStore = Symbol('store')\nconst kOnComplete = Symbol('onComplete')\nconst kPromise = Symbol('promise')\n\nclass BrowserLevel extends AbstractLevel {\n  constructor (location, options, _) {\n    // To help migrating to abstract-level\n    if (typeof options === 'function' || typeof _ === 'function') {\n      throw new ModuleError('The levelup-style callback argument has been removed', {\n        code: 'LEVEL_LEGACY'\n      })\n    }\n\n    const { prefix, version, ...forward } = options || {}\n\n    super({\n      encodings: { view: true },\n      snapshots: false,\n      createIfMissing: false,\n      errorIfExists: false,\n      seek: true\n    }, forward)\n\n    if (typeof location !== 'string') {\n      throw new Error('constructor requires a location string argument')\n    }\n\n    // TODO (next major): remove default prefix\n    this[kLocation] = location\n    this[kNamePrefix] = prefix == null ? DEFAULT_PREFIX : prefix\n    this[kVersion] = parseInt(version || 1, 10)\n    this[kIDB] = null\n  }\n\n  get location () {\n    return this[kLocation]\n  }\n\n  get namePrefix () {\n    return this[kNamePrefix]\n  }\n\n  get version () {\n    return this[kVersion]\n  }\n\n  // Exposed for backwards compat and unit tests\n  get db () {\n    return this[kIDB]\n  }\n\n  get type () {\n    return 'browser-level'\n  }\n\n  _open (options, callback) {\n    const req = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion])\n\n    req.onerror = function () {\n      callback(req.error || new Error('unknown error'))\n    }\n\n    req.onsuccess = () => {\n      this[kIDB] = req.result\n      callback()\n    }\n\n    req.onupgradeneeded = (ev) => {\n      const db = ev.target.result\n\n      if (!db.objectStoreNames.contains(this[kLocation])) {\n        db.createObjectStore(this[kLocation])\n      }\n    }\n  }\n\n  [kStore] (mode) {\n    const transaction = this[kIDB].transaction([this[kLocation]], mode)\n    return transaction.objectStore(this[kLocation])\n  }\n\n  [kOnComplete] (request, callback) {\n    const transaction = request.transaction\n\n    // Take advantage of the fact that a non-canceled request error aborts\n    // the transaction. I.e. no need to listen for \"request.onerror\".\n    transaction.onabort = function () {\n      callback(transaction.error || new Error('aborted by user'))\n    }\n\n    transaction.oncomplete = function () {\n      callback(null, request.result)\n    }\n  }\n\n  _get (key, options, callback) {\n    const store = this[kStore]('readonly')\n    let req\n\n    try {\n      req = store.get(key)\n    } catch (err) {\n      return this.nextTick(callback, err)\n    }\n\n    this[kOnComplete](req, function (err, value) {\n      if (err) return callback(err)\n\n      if (value === undefined) {\n        return callback(new ModuleError('Entry not found', {\n          code: 'LEVEL_NOT_FOUND'\n        }))\n      }\n\n      callback(null, deserialize(value))\n    })\n  }\n\n  _getMany (keys, options, callback) {\n    const store = this[kStore]('readonly')\n    const tasks = keys.map((key) => (next) => {\n      let request\n\n      try {\n        request = store.get(key)\n      } catch (err) {\n        return next(err)\n      }\n\n      request.onsuccess = () => {\n        const value = request.result\n        next(null, value === undefined ? value : deserialize(value))\n      }\n\n      request.onerror = (ev) => {\n        ev.stopPropagation()\n        next(request.error)\n      }\n    })\n\n    parallel(tasks, 16, callback)\n  }\n\n  _del (key, options, callback) {\n    const store = this[kStore]('readwrite')\n    let req\n\n    try {\n      req = store.delete(key)\n    } catch (err) {\n      return this.nextTick(callback, err)\n    }\n\n    this[kOnComplete](req, callback)\n  }\n\n  _put (key, value, options, callback) {\n    const store = this[kStore]('readwrite')\n    let req\n\n    try {\n      // Will throw a DataError or DataCloneError if the environment\n      // does not support serializing the key or value respectively.\n      req = store.put(value, key)\n    } catch (err) {\n      return this.nextTick(callback, err)\n    }\n\n    this[kOnComplete](req, callback)\n  }\n\n  // TODO: implement key and value iterators\n  _iterator (options) {\n    return new Iterator(this, this[kLocation], options)\n  }\n\n  _batch (operations, options, callback) {\n    const store = this[kStore]('readwrite')\n    const transaction = store.transaction\n    let index = 0\n    let error\n\n    transaction.onabort = function () {\n      callback(error || transaction.error || new Error('aborted by user'))\n    }\n\n    transaction.oncomplete = function () {\n      callback()\n    }\n\n    // Wait for a request to complete before making the next, saving CPU.\n    function loop () {\n      const op = operations[index++]\n      const key = op.key\n\n      let req\n\n      try {\n        req = op.type === 'del' ? store.delete(key) : store.put(op.value, key)\n      } catch (err) {\n        error = err\n        transaction.abort()\n        return\n      }\n\n      if (index < operations.length) {\n        req.onsuccess = loop\n      } else if (typeof transaction.commit === 'function') {\n        // Commit now instead of waiting for auto-commit\n        transaction.commit()\n      }\n    }\n\n    loop()\n  }\n\n  _clear (options, callback) {\n    let keyRange\n    let req\n\n    try {\n      keyRange = createKeyRange(options)\n    } catch (e) {\n      // The lower key is greater than the upper key.\n      // IndexedDB throws an error, but we'll just do nothing.\n      return this.nextTick(callback)\n    }\n\n    if (options.limit >= 0) {\n      // IDBObjectStore#delete(range) doesn't have such an option.\n      // Fall back to cursor-based implementation.\n      return clear(this, this[kLocation], keyRange, options, callback)\n    }\n\n    try {\n      const store = this[kStore]('readwrite')\n      req = keyRange ? store.delete(keyRange) : store.clear()\n    } catch (err) {\n      return this.nextTick(callback, err)\n    }\n\n    this[kOnComplete](req, callback)\n  }\n\n  _close (callback) {\n    this[kIDB].close()\n    this.nextTick(callback)\n  }\n}\n\nBrowserLevel.destroy = function (location, prefix, callback) {\n  if (typeof prefix === 'function') {\n    callback = prefix\n    prefix = DEFAULT_PREFIX\n  }\n\n  callback = fromCallback(callback, kPromise)\n  const request = indexedDB.deleteDatabase(prefix + location)\n\n  request.onsuccess = function () {\n    callback()\n  }\n\n  request.onerror = function (err) {\n    callback(err)\n  }\n\n  return callback[kPromise]\n}\n\nexports.BrowserLevel = BrowserLevel\n"]},"metadata":{},"sourceType":"script"}