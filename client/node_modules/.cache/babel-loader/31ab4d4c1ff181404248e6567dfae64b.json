{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport * as mafmt from '@multiformats/mafmt';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { CircuitRelay as CircuitPB } from './pb/index.js';\nimport { codes } from '../errors.js';\nimport { streamToMaConnection } from '@libp2p/utils/stream-to-ma-conn';\nimport { RELAY_CODEC } from './multicodec.js';\nimport { createListener } from './listener.js';\nimport { handleCanHop, handleHop, hop } from './circuit/hop.js';\nimport { handleStop } from './circuit/stop.js';\nimport { StreamHandler } from './circuit/stream-handler.js';\nimport { symbol } from '@libp2p/interface-transport';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { abortableDuplex } from 'abortable-iterator';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { setMaxListeners } from 'events';\nconst log = logger('libp2p:circuit');\nexport class Circuit {\n  constructor(components, init) {\n    this._init = init;\n    this.components = components;\n    this._started = false;\n  }\n\n  isStarted() {\n    return this._started;\n  }\n\n  async start() {\n    if (this._started) {\n      return;\n    }\n\n    this._started = true;\n    await this.components.registrar.handle(RELAY_CODEC, data => {\n      void this._onProtocol(data).catch(err => {\n        log.error(err);\n      });\n    }, { ...this._init\n    }).catch(err => {\n      log.error(err);\n    });\n  }\n\n  async stop() {\n    await this.components.registrar.unhandle(RELAY_CODEC);\n  }\n\n  hopEnabled() {\n    return true;\n  }\n\n  hopActive() {\n    return true;\n  }\n\n  get [symbol]() {\n    return true;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'libp2p/circuit-relay-v1';\n  }\n\n  async _onProtocol(data) {\n    const {\n      connection,\n      stream\n    } = data;\n    const controller = new TimeoutController(this._init.hop.timeout);\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, controller.signal);\n    } catch {}\n\n    try {\n      const source = abortableDuplex(stream, controller.signal);\n      const streamHandler = new StreamHandler({\n        stream: { ...stream,\n          ...source\n        }\n      });\n      const request = await streamHandler.read();\n\n      if (request == null) {\n        log('request was invalid, could not read from stream');\n        streamHandler.write({\n          type: CircuitPB.Type.STATUS,\n          code: CircuitPB.Status.MALFORMED_MESSAGE\n        });\n        streamHandler.close();\n        return;\n      }\n\n      let virtualConnection;\n\n      switch (request.type) {\n        case CircuitPB.Type.CAN_HOP:\n          {\n            log('received CAN_HOP request from %p', connection.remotePeer);\n            await handleCanHop({\n              circuit: this,\n              connection,\n              streamHandler\n            });\n            break;\n          }\n\n        case CircuitPB.Type.HOP:\n          {\n            log('received HOP request from %p', connection.remotePeer);\n            await handleHop({\n              connection,\n              request,\n              streamHandler,\n              circuit: this,\n              connectionManager: this.components.connectionManager\n            });\n            break;\n          }\n\n        case CircuitPB.Type.STOP:\n          {\n            log('received STOP request from %p', connection.remotePeer);\n            virtualConnection = await handleStop({\n              connection,\n              request,\n              streamHandler\n            });\n            break;\n          }\n\n        default:\n          {\n            log('Request of type %s not supported', request.type);\n            streamHandler.write({\n              type: CircuitPB.Type.STATUS,\n              code: CircuitPB.Status.MALFORMED_MESSAGE\n            });\n            streamHandler.close();\n            return;\n          }\n      }\n\n      if (virtualConnection != null) {\n        const remoteAddr = connection.remoteAddr.encapsulate('/p2p-circuit').encapsulate(multiaddr(request.dstPeer?.addrs[0]));\n        const localAddr = multiaddr(request.srcPeer?.addrs[0]);\n        const maConn = streamToMaConnection({\n          stream: virtualConnection,\n          remoteAddr,\n          localAddr\n        });\n        const type = request.type === CircuitPB.Type.HOP ? 'relay' : 'inbound';\n        log('new %s connection %s', type, maConn.remoteAddr);\n        const conn = await this.components.upgrader.upgradeInbound(maConn);\n        log('%s connection %s upgraded', type, maConn.remoteAddr);\n\n        if (this.handler != null) {\n          this.handler(conn);\n        }\n      }\n    } finally {\n      controller.clear();\n    }\n  }\n  /**\n   * Dial a peer over a relay\n   */\n\n\n  async dial(ma) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Check the multiaddr to see if it contains a relay and a destination peer\n    const addrs = ma.toString().split('/p2p-circuit');\n    const relayAddr = multiaddr(addrs[0]);\n    const destinationAddr = multiaddr(addrs[addrs.length - 1]);\n    const relayId = relayAddr.getPeerId();\n    const destinationId = destinationAddr.getPeerId();\n\n    if (relayId == null || destinationId == null) {\n      const errMsg = 'Circuit relay dial failed as addresses did not have peer id';\n      log.error(errMsg);\n      throw errCode(new Error(errMsg), codes.ERR_RELAYED_DIAL);\n    }\n\n    const relayPeer = peerIdFromString(relayId);\n    const destinationPeer = peerIdFromString(destinationId);\n    let disconnectOnFailure = false;\n    const relayConnections = this.components.connectionManager.getConnections(relayPeer);\n    let relayConnection = relayConnections[0];\n\n    if (relayConnection == null) {\n      await this.components.peerStore.addressBook.add(relayPeer, [relayAddr]);\n      relayConnection = await this.components.connectionManager.openConnection(relayPeer, options);\n      disconnectOnFailure = true;\n    }\n\n    try {\n      const virtualConnection = await hop({ ...options,\n        connection: relayConnection,\n        request: {\n          type: CircuitPB.Type.HOP,\n          srcPeer: {\n            id: this.components.peerId.toBytes(),\n            addrs: this.components.addressManager.getAddresses().map(addr => addr.bytes)\n          },\n          dstPeer: {\n            id: destinationPeer.toBytes(),\n            addrs: [multiaddr(destinationAddr).bytes]\n          }\n        }\n      });\n      const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`);\n      const maConn = streamToMaConnection({\n        stream: virtualConnection,\n        remoteAddr: ma,\n        localAddr\n      });\n      log('new outbound connection %s', maConn.remoteAddr);\n      return await this.components.upgrader.upgradeOutbound(maConn);\n    } catch (err) {\n      log.error('Circuit relay dial failed', err);\n      disconnectOnFailure && (await relayConnection.close());\n      throw err;\n    }\n  }\n  /**\n   * Create a listener\n   */\n\n\n  createListener(options) {\n    // Called on successful HOP and STOP requests\n    this.handler = options.handler;\n    return createListener({\n      connectionManager: this.components.connectionManager,\n      peerStore: this.components.peerStore\n    });\n  }\n  /**\n   * Filter check for all Multiaddrs that this transport can dial on\n   *\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]}\n   */\n\n\n  filter(multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n    return multiaddrs.filter(ma => {\n      return mafmt.Circuit.matches(ma);\n    });\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,QAAuB,gBAAvB;AACA,OAAOC,OAAP,MAAoB,UAApB;AACA,OAAO,KAAKC,KAAZ,MAAuB,qBAAvB;AAEA,SAASC,SAAT,QAA0B,yBAA1B;AACA,SAASC,YAAY,IAAIC,SAAzB,QAA0C,eAA1C;AACA,SAASC,KAAT,QAAsB,cAAtB;AACA,SAASC,oBAAT,QAAqC,iCAArC;AACA,SAASC,WAAT,QAA4B,iBAA5B;AACA,SAASC,cAAT,QAA+B,eAA/B;AACA,SAASC,YAAT,EAAuBC,SAAvB,EAAkCC,GAAlC,QAA6C,kBAA7C;AACA,SAASC,UAAT,QAA2B,mBAA3B;AACA,SAASC,aAAT,QAA8B,6BAA9B;AACA,SAASC,MAAT,QAAiC,6BAAjC;AACA,SAASC,gBAAT,QAAiC,iBAAjC;AAMA,SAASC,eAAT,QAAgC,oBAAhC;AACA,SAASC,iBAAT,QAAkC,0BAAlC;AACA,SAASC,eAAT,QAAgC,QAAhC;AASA,MAAMC,GAAG,GAAGpB,MAAM,CAAC,gBAAD,CAAlB;AAWA,OAAM,MAAOqB,OAAP,CAAc;AAMlBC,cAAaC,UAAb,EAA4CC,IAA5C,EAA6D;AAC3D,SAAKC,KAAL,GAAaD,IAAb;AACA,SAAKD,UAAL,GAAkBA,UAAlB;AACA,SAAKG,QAAL,GAAgB,KAAhB;AACD;;AAEDC,WAAS;AACP,WAAO,KAAKD,QAAZ;AACD;;AAEU,QAALE,KAAK;AACT,QAAI,KAAKF,QAAT,EAAmB;AACjB;AACD;;AAED,SAAKA,QAAL,GAAgB,IAAhB;AAEA,UAAM,KAAKH,UAAL,CAAgBM,SAAhB,CAA0BC,MAA1B,CAAiCtB,WAAjC,EAA+CuB,IAAD,IAAS;AAC3D,WAAK,KAAKC,WAAL,CAAiBD,IAAjB,EAAuBE,KAAvB,CAA6BC,GAAG,IAAG;AACtCd,WAAG,CAACe,KAAJ,CAAUD,GAAV;AACD,OAFI,CAAL;AAGD,KAJK,EAIH,EAAE,GAAG,KAAKT;AAAV,KAJG,EAKHQ,KALG,CAKGC,GAAG,IAAG;AACXd,SAAG,CAACe,KAAJ,CAAUD,GAAV;AACD,KAPG,CAAN;AAQD;;AAES,QAAJE,IAAI;AACR,UAAM,KAAKb,UAAL,CAAgBM,SAAhB,CAA0BQ,QAA1B,CAAmC7B,WAAnC,CAAN;AACD;;AAED8B,YAAU;AACR,WAAO,IAAP;AACD;;AAEDC,WAAS;AACP,WAAO,IAAP;AACD;;AAEU,OAANxB,MAAM,IAAC;AACV,WAAO,IAAP;AACD;;AAEsB,OAAlByB,MAAM,CAACC,WAAW,IAAC;AACtB,WAAO,yBAAP;AACD;;AAEgB,QAAXT,WAAW,CAAED,IAAF,EAA0B;AACzC,UAAM;AAAEW,gBAAF;AAAcC;AAAd,QAAyBZ,IAA/B;AACA,UAAMa,UAAU,GAAG,IAAI1B,iBAAJ,CAAsB,KAAKO,KAAL,CAAWb,GAAX,CAAeiC,OAArC,CAAnB;;AAEA,QAAI;AACF;AACA1B,qBAAe,GAAG2B,QAAH,EAAaF,UAAU,CAACG,MAAxB,CAAf;AACD,KAHD,CAGE,MAAM,CAAE;;AAEV,QAAI;AACF,YAAMC,MAAM,GAAG/B,eAAe,CAAC0B,MAAD,EAASC,UAAU,CAACG,MAApB,CAA9B;AACA,YAAME,aAAa,GAAG,IAAInC,aAAJ,CAAkB;AACtC6B,cAAM,EAAE,EACN,GAAGA,MADG;AAEN,aAAGK;AAFG;AAD8B,OAAlB,CAAtB;AAMA,YAAME,OAAO,GAAG,MAAMD,aAAa,CAACE,IAAd,EAAtB;;AAEA,UAAID,OAAO,IAAI,IAAf,EAAqB;AACnB9B,WAAG,CAAC,iDAAD,CAAH;AACA6B,qBAAa,CAACG,KAAd,CAAoB;AAClBC,cAAI,EAAEhD,SAAS,CAACiD,IAAV,CAAeC,MADH;AAElBC,cAAI,EAAEnD,SAAS,CAACoD,MAAV,CAAiBC;AAFL,SAApB;AAIAT,qBAAa,CAACU,KAAd;AACA;AACD;;AAED,UAAIC,iBAAJ;;AAEA,cAAQV,OAAO,CAACG,IAAhB;AACE,aAAKhD,SAAS,CAACiD,IAAV,CAAeO,OAApB;AAA6B;AAC3BzC,eAAG,CAAC,kCAAD,EAAqCsB,UAAU,CAACoB,UAAhD,CAAH;AACA,kBAAMpD,YAAY,CAAC;AAAEqD,qBAAO,EAAE,IAAX;AAAiBrB,wBAAjB;AAA6BO;AAA7B,aAAD,CAAlB;AACA;AACD;;AACD,aAAK5C,SAAS,CAACiD,IAAV,CAAeU,GAApB;AAAyB;AACvB5C,eAAG,CAAC,8BAAD,EAAiCsB,UAAU,CAACoB,UAA5C,CAAH;AACA,kBAAMnD,SAAS,CAAC;AACd+B,wBADc;AAEdQ,qBAFc;AAGdD,2BAHc;AAIdc,qBAAO,EAAE,IAJK;AAKdE,+BAAiB,EAAE,KAAK1C,UAAL,CAAgB0C;AALrB,aAAD,CAAf;AAOA;AACD;;AACD,aAAK5D,SAAS,CAACiD,IAAV,CAAeY,IAApB;AAA0B;AACxB9C,eAAG,CAAC,+BAAD,EAAkCsB,UAAU,CAACoB,UAA7C,CAAH;AACAF,6BAAiB,GAAG,MAAM/C,UAAU,CAAC;AACnC6B,wBADmC;AAEnCQ,qBAFmC;AAGnCD;AAHmC,aAAD,CAApC;AAKA;AACD;;AACD;AAAS;AACP7B,eAAG,CAAC,kCAAD,EAAqC8B,OAAO,CAACG,IAA7C,CAAH;AACAJ,yBAAa,CAACG,KAAd,CAAoB;AAClBC,kBAAI,EAAEhD,SAAS,CAACiD,IAAV,CAAeC,MADH;AAElBC,kBAAI,EAAEnD,SAAS,CAACoD,MAAV,CAAiBC;AAFL,aAApB;AAIAT,yBAAa,CAACU,KAAd;AACA;AACD;AAlCH;;AAqCA,UAAIC,iBAAiB,IAAI,IAAzB,EAA+B;AAC7B,cAAMO,UAAU,GAAGzB,UAAU,CAACyB,UAAX,CAChBC,WADgB,CACJ,cADI,EAEhBA,WAFgB,CAEJjE,SAAS,CAAC+C,OAAO,CAACmB,OAAR,EAAiBC,KAAjB,CAAuB,CAAvB,CAAD,CAFL,CAAnB;AAGA,cAAMC,SAAS,GAAGpE,SAAS,CAAC+C,OAAO,CAACsB,OAAR,EAAiBF,KAAjB,CAAuB,CAAvB,CAAD,CAA3B;AACA,cAAMG,MAAM,GAAGlE,oBAAoB,CAAC;AAClCoC,gBAAM,EAAEiB,iBAD0B;AAElCO,oBAFkC;AAGlCI;AAHkC,SAAD,CAAnC;AAKA,cAAMlB,IAAI,GAAGH,OAAO,CAACG,IAAR,KAAiBhD,SAAS,CAACiD,IAAV,CAAeU,GAAhC,GAAsC,OAAtC,GAAgD,SAA7D;AACA5C,WAAG,CAAC,sBAAD,EAAyBiC,IAAzB,EAA+BoB,MAAM,CAACN,UAAtC,CAAH;AAEA,cAAMO,IAAI,GAAG,MAAM,KAAKnD,UAAL,CAAgBoD,QAAhB,CAAyBC,cAAzB,CAAwCH,MAAxC,CAAnB;AACArD,WAAG,CAAC,2BAAD,EAA8BiC,IAA9B,EAAoCoB,MAAM,CAACN,UAA3C,CAAH;;AAEA,YAAI,KAAKU,OAAL,IAAgB,IAApB,EAA0B;AACxB,eAAKA,OAAL,CAAaH,IAAb;AACD;AACF;AACF,KA/ED,SA+EU;AACR9B,gBAAU,CAACkC,KAAX;AACD;AACF;AAED;;;;;AAGU,QAAJC,IAAI,CAAEC,EAAF,EAA2C;AAAA,QAA1BC,OAA0B,uEAAF,EAAE;AACnD;AACA,UAAMX,KAAK,GAAGU,EAAE,CAACE,QAAH,GAAcC,KAAd,CAAoB,cAApB,CAAd;AACA,UAAMC,SAAS,GAAGjF,SAAS,CAACmE,KAAK,CAAC,CAAD,CAAN,CAA3B;AACA,UAAMe,eAAe,GAAGlF,SAAS,CAACmE,KAAK,CAACA,KAAK,CAACgB,MAAN,GAAe,CAAhB,CAAN,CAAjC;AACA,UAAMC,OAAO,GAAGH,SAAS,CAACI,SAAV,EAAhB;AACA,UAAMC,aAAa,GAAGJ,eAAe,CAACG,SAAhB,EAAtB;;AAEA,QAAID,OAAO,IAAI,IAAX,IAAmBE,aAAa,IAAI,IAAxC,EAA8C;AAC5C,YAAMC,MAAM,GAAG,6DAAf;AACAtE,SAAG,CAACe,KAAJ,CAAUuD,MAAV;AACA,YAAMzF,OAAO,CAAC,IAAI0F,KAAJ,CAAUD,MAAV,CAAD,EAAoBpF,KAAK,CAACsF,gBAA1B,CAAb;AACD;;AAED,UAAMC,SAAS,GAAG7E,gBAAgB,CAACuE,OAAD,CAAlC;AACA,UAAMO,eAAe,GAAG9E,gBAAgB,CAACyE,aAAD,CAAxC;AAEA,QAAIM,mBAAmB,GAAG,KAA1B;AACA,UAAMC,gBAAgB,GAAG,KAAKzE,UAAL,CAAgB0C,iBAAhB,CAAkCgC,cAAlC,CAAiDJ,SAAjD,CAAzB;AACA,QAAIK,eAAe,GAAGF,gBAAgB,CAAC,CAAD,CAAtC;;AAEA,QAAIE,eAAe,IAAI,IAAvB,EAA6B;AAC3B,YAAM,KAAK3E,UAAL,CAAgB4E,SAAhB,CAA0BC,WAA1B,CAAsCC,GAAtC,CAA0CR,SAA1C,EAAqD,CAACT,SAAD,CAArD,CAAN;AACAc,qBAAe,GAAG,MAAM,KAAK3E,UAAL,CAAgB0C,iBAAhB,CAAkCqC,cAAlC,CAAiDT,SAAjD,EAA4DZ,OAA5D,CAAxB;AACAc,yBAAmB,GAAG,IAAtB;AACD;;AAED,QAAI;AACF,YAAMnC,iBAAiB,GAAG,MAAMhD,GAAG,CAAC,EAClC,GAAGqE,OAD+B;AAElCvC,kBAAU,EAAEwD,eAFsB;AAGlChD,eAAO,EAAE;AACPG,cAAI,EAAEhD,SAAS,CAACiD,IAAV,CAAeU,GADd;AAEPQ,iBAAO,EAAE;AACP+B,cAAE,EAAE,KAAKhF,UAAL,CAAgBiF,MAAhB,CAAuBC,OAAvB,EADG;AAEPnC,iBAAK,EAAE,KAAK/C,UAAL,CAAgBmF,cAAhB,CAA+BC,YAA/B,GAA8CC,GAA9C,CAAkDC,IAAI,IAAIA,IAAI,CAACC,KAA/D;AAFA,WAFF;AAMPzC,iBAAO,EAAE;AACPkC,cAAE,EAAET,eAAe,CAACW,OAAhB,EADG;AAEPnC,iBAAK,EAAE,CAACnE,SAAS,CAACkF,eAAD,CAAT,CAA2ByB,KAA5B;AAFA;AANF;AAHyB,OAAD,CAAnC;AAgBA,YAAMvC,SAAS,GAAGa,SAAS,CAAChB,WAAV,CAAsB,oBAAoB,KAAK7C,UAAL,CAAgBiF,MAAhB,CAAuBtB,QAAvB,EAAiC,EAA3E,CAAlB;AACA,YAAMT,MAAM,GAAGlE,oBAAoB,CAAC;AAClCoC,cAAM,EAAEiB,iBAD0B;AAElCO,kBAAU,EAAEa,EAFsB;AAGlCT;AAHkC,OAAD,CAAnC;AAKAnD,SAAG,CAAC,4BAAD,EAA+BqD,MAAM,CAACN,UAAtC,CAAH;AAEA,aAAO,MAAM,KAAK5C,UAAL,CAAgBoD,QAAhB,CAAyBoC,eAAzB,CAAyCtC,MAAzC,CAAb;AACD,KA1BD,CA0BE,OAAOvC,GAAP,EAAiB;AACjBd,SAAG,CAACe,KAAJ,CAAU,2BAAV,EAAuCD,GAAvC;AACA6D,yBAAmB,KAAI,MAAMG,eAAe,CAACvC,KAAhB,EAAV,CAAnB;AACA,YAAMzB,GAAN;AACD;AACF;AAED;;;;;AAGAzB,gBAAc,CAAEwE,OAAF,EAAgC;AAC5C;AACA,SAAKJ,OAAL,GAAeI,OAAO,CAACJ,OAAvB;AAEA,WAAOpE,cAAc,CAAC;AACpBwD,uBAAiB,EAAE,KAAK1C,UAAL,CAAgB0C,iBADf;AAEpBkC,eAAS,EAAE,KAAK5E,UAAL,CAAgB4E;AAFP,KAAD,CAArB;AAID;AAED;;;;;;;;AAMAa,QAAM,CAAEC,UAAF,EAAyB;AAC7BA,cAAU,GAAGC,KAAK,CAACC,OAAN,CAAcF,UAAd,IAA4BA,UAA5B,GAAyC,CAACA,UAAD,CAAtD;AAEA,WAAOA,UAAU,CAACD,MAAX,CAAmBhC,EAAD,IAAO;AAC9B,aAAO9E,KAAK,CAACmB,OAAN,CAAc+F,OAAd,CAAsBpC,EAAtB,CAAP;AACD,KAFM,CAAP;AAGD;;AA1OiB","names":["logger","errCode","mafmt","multiaddr","CircuitRelay","CircuitPB","codes","streamToMaConnection","RELAY_CODEC","createListener","handleCanHop","handleHop","hop","handleStop","StreamHandler","symbol","peerIdFromString","abortableDuplex","TimeoutController","setMaxListeners","log","Circuit","constructor","components","init","_init","_started","isStarted","start","registrar","handle","data","_onProtocol","catch","err","error","stop","unhandle","hopEnabled","hopActive","Symbol","toStringTag","connection","stream","controller","timeout","Infinity","signal","source","streamHandler","request","read","write","type","Type","STATUS","code","Status","MALFORMED_MESSAGE","close","virtualConnection","CAN_HOP","remotePeer","circuit","HOP","connectionManager","STOP","remoteAddr","encapsulate","dstPeer","addrs","localAddr","srcPeer","maConn","conn","upgrader","upgradeInbound","handler","clear","dial","ma","options","toString","split","relayAddr","destinationAddr","length","relayId","getPeerId","destinationId","errMsg","Error","ERR_RELAYED_DIAL","relayPeer","destinationPeer","disconnectOnFailure","relayConnections","getConnections","relayConnection","peerStore","addressBook","add","openConnection","id","peerId","toBytes","addressManager","getAddresses","map","addr","bytes","upgradeOutbound","filter","multiaddrs","Array","isArray","matches"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\circuit\\transport.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport * as mafmt from '@multiformats/mafmt'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { CircuitRelay as CircuitPB } from './pb/index.js'\nimport { codes } from '../errors.js'\nimport { streamToMaConnection } from '@libp2p/utils/stream-to-ma-conn'\nimport { RELAY_CODEC } from './multicodec.js'\nimport { createListener } from './listener.js'\nimport { handleCanHop, handleHop, hop } from './circuit/hop.js'\nimport { handleStop } from './circuit/stop.js'\nimport { StreamHandler } from './circuit/stream-handler.js'\nimport { symbol, Upgrader } from '@libp2p/interface-transport'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { IncomingStreamData, Registrar } from '@libp2p/interface-registrar'\nimport type { Listener, Transport, CreateListenerOptions, ConnectionHandler } from '@libp2p/interface-transport'\nimport type { Connection } from '@libp2p/interface-connection'\nimport type { RelayConfig } from './index.js'\nimport { abortableDuplex } from 'abortable-iterator'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { setMaxListeners } from 'events'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { Duplex } from 'it-stream-types'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { PeerStore } from '@libp2p/interface-peer-store'\nimport type { AddressManager } from '@libp2p/interface-address-manager'\n\nconst log = logger('libp2p:circuit')\n\nexport interface CircuitComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  registrar: Registrar\n  connectionManager: ConnectionManager\n  upgrader: Upgrader\n  addressManager: AddressManager\n}\n\nexport class Circuit implements Transport, Startable {\n  private handler?: ConnectionHandler\n  private readonly components: CircuitComponents\n  private readonly _init: RelayConfig\n  private _started: boolean\n\n  constructor (components: CircuitComponents, init: RelayConfig) {\n    this._init = init\n    this.components = components\n    this._started = false\n  }\n\n  isStarted () {\n    return this._started\n  }\n\n  async start (): Promise<void> {\n    if (this._started) {\n      return\n    }\n\n    this._started = true\n\n    await this.components.registrar.handle(RELAY_CODEC, (data) => {\n      void this._onProtocol(data).catch(err => {\n        log.error(err)\n      })\n    }, { ...this._init })\n      .catch(err => {\n        log.error(err)\n      })\n  }\n\n  async stop () {\n    await this.components.registrar.unhandle(RELAY_CODEC)\n  }\n\n  hopEnabled () {\n    return true\n  }\n\n  hopActive () {\n    return true\n  }\n\n  get [symbol] (): true {\n    return true\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'libp2p/circuit-relay-v1'\n  }\n\n  async _onProtocol (data: IncomingStreamData) {\n    const { connection, stream } = data\n    const controller = new TimeoutController(this._init.hop.timeout)\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, controller.signal)\n    } catch {}\n\n    try {\n      const source = abortableDuplex(stream, controller.signal)\n      const streamHandler = new StreamHandler({\n        stream: {\n          ...stream,\n          ...source\n        }\n      })\n      const request = await streamHandler.read()\n\n      if (request == null) {\n        log('request was invalid, could not read from stream')\n        streamHandler.write({\n          type: CircuitPB.Type.STATUS,\n          code: CircuitPB.Status.MALFORMED_MESSAGE\n        })\n        streamHandler.close()\n        return\n      }\n\n      let virtualConnection: Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array> | undefined\n\n      switch (request.type) {\n        case CircuitPB.Type.CAN_HOP: {\n          log('received CAN_HOP request from %p', connection.remotePeer)\n          await handleCanHop({ circuit: this, connection, streamHandler })\n          break\n        }\n        case CircuitPB.Type.HOP: {\n          log('received HOP request from %p', connection.remotePeer)\n          await handleHop({\n            connection,\n            request,\n            streamHandler,\n            circuit: this,\n            connectionManager: this.components.connectionManager\n          })\n          break\n        }\n        case CircuitPB.Type.STOP: {\n          log('received STOP request from %p', connection.remotePeer)\n          virtualConnection = await handleStop({\n            connection,\n            request,\n            streamHandler\n          })\n          break\n        }\n        default: {\n          log('Request of type %s not supported', request.type)\n          streamHandler.write({\n            type: CircuitPB.Type.STATUS,\n            code: CircuitPB.Status.MALFORMED_MESSAGE\n          })\n          streamHandler.close()\n          return\n        }\n      }\n\n      if (virtualConnection != null) {\n        const remoteAddr = connection.remoteAddr\n          .encapsulate('/p2p-circuit')\n          .encapsulate(multiaddr(request.dstPeer?.addrs[0]))\n        const localAddr = multiaddr(request.srcPeer?.addrs[0])\n        const maConn = streamToMaConnection({\n          stream: virtualConnection,\n          remoteAddr,\n          localAddr\n        })\n        const type = request.type === CircuitPB.Type.HOP ? 'relay' : 'inbound'\n        log('new %s connection %s', type, maConn.remoteAddr)\n\n        const conn = await this.components.upgrader.upgradeInbound(maConn)\n        log('%s connection %s upgraded', type, maConn.remoteAddr)\n\n        if (this.handler != null) {\n          this.handler(conn)\n        }\n      }\n    } finally {\n      controller.clear()\n    }\n  }\n\n  /**\n   * Dial a peer over a relay\n   */\n  async dial (ma: Multiaddr, options: AbortOptions = {}): Promise<Connection> {\n    // Check the multiaddr to see if it contains a relay and a destination peer\n    const addrs = ma.toString().split('/p2p-circuit')\n    const relayAddr = multiaddr(addrs[0])\n    const destinationAddr = multiaddr(addrs[addrs.length - 1])\n    const relayId = relayAddr.getPeerId()\n    const destinationId = destinationAddr.getPeerId()\n\n    if (relayId == null || destinationId == null) {\n      const errMsg = 'Circuit relay dial failed as addresses did not have peer id'\n      log.error(errMsg)\n      throw errCode(new Error(errMsg), codes.ERR_RELAYED_DIAL)\n    }\n\n    const relayPeer = peerIdFromString(relayId)\n    const destinationPeer = peerIdFromString(destinationId)\n\n    let disconnectOnFailure = false\n    const relayConnections = this.components.connectionManager.getConnections(relayPeer)\n    let relayConnection = relayConnections[0]\n\n    if (relayConnection == null) {\n      await this.components.peerStore.addressBook.add(relayPeer, [relayAddr])\n      relayConnection = await this.components.connectionManager.openConnection(relayPeer, options)\n      disconnectOnFailure = true\n    }\n\n    try {\n      const virtualConnection = await hop({\n        ...options,\n        connection: relayConnection,\n        request: {\n          type: CircuitPB.Type.HOP,\n          srcPeer: {\n            id: this.components.peerId.toBytes(),\n            addrs: this.components.addressManager.getAddresses().map(addr => addr.bytes)\n          },\n          dstPeer: {\n            id: destinationPeer.toBytes(),\n            addrs: [multiaddr(destinationAddr).bytes]\n          }\n        }\n      })\n\n      const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`)\n      const maConn = streamToMaConnection({\n        stream: virtualConnection,\n        remoteAddr: ma,\n        localAddr\n      })\n      log('new outbound connection %s', maConn.remoteAddr)\n\n      return await this.components.upgrader.upgradeOutbound(maConn)\n    } catch (err: any) {\n      log.error('Circuit relay dial failed', err)\n      disconnectOnFailure && await relayConnection.close()\n      throw err\n    }\n  }\n\n  /**\n   * Create a listener\n   */\n  createListener (options: CreateListenerOptions): Listener {\n    // Called on successful HOP and STOP requests\n    this.handler = options.handler\n\n    return createListener({\n      connectionManager: this.components.connectionManager,\n      peerStore: this.components.peerStore\n    })\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can dial on\n   *\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]}\n   */\n  filter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    return multiaddrs.filter((ma) => {\n      return mafmt.Circuit.matches(ma)\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}