{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { codes } from './errors.js';\nimport { Key } from 'interface-datastore/key';\nimport { base32 } from 'multiformats/bases/base32';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { Peer as PeerPB } from './pb/peer.js';\nimport mortice from 'mortice';\nimport { equals as uint8arrayEquals } from 'uint8arrays/equals';\nconst log = logger('libp2p:peer-store:store');\nconst NAMESPACE_COMMON = '/peers/';\nexport class PersistentStore {\n  constructor(components) {\n    this.components = components;\n    this.lock = mortice({\n      name: 'peer-store',\n      singleProcess: true\n    });\n  }\n\n  _peerIdToDatastoreKey(peerId) {\n    if (peerId.type == null) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw new CodeError('peerId must be an instance of peer-id', codes.ERR_INVALID_PARAMETERS);\n    }\n\n    const b32key = peerId.toCID().toString();\n    return new Key(`${NAMESPACE_COMMON}${b32key}`);\n  }\n\n  async has(peerId) {\n    return await this.components.datastore.has(this._peerIdToDatastoreKey(peerId));\n  }\n\n  async delete(peerId) {\n    await this.components.datastore.delete(this._peerIdToDatastoreKey(peerId));\n  }\n\n  async load(peerId) {\n    const buf = await this.components.datastore.get(this._peerIdToDatastoreKey(peerId));\n    const peer = PeerPB.decode(buf);\n    const metadata = new Map();\n\n    for (const meta of peer.metadata) {\n      metadata.set(meta.key, meta.value);\n    }\n\n    return { ...peer,\n      id: peerId,\n      addresses: peer.addresses.map(_ref => {\n        let {\n          multiaddr: ma,\n          isCertified\n        } = _ref;\n        return {\n          multiaddr: multiaddr(ma),\n          isCertified: isCertified ?? false\n        };\n      }),\n      metadata,\n      pubKey: peer.pubKey ?? undefined,\n      peerRecordEnvelope: peer.peerRecordEnvelope ?? undefined\n    };\n  }\n\n  async save(peer) {\n    if (peer.pubKey != null && peer.id.publicKey != null && !uint8arrayEquals(peer.pubKey, peer.id.publicKey)) {\n      log.error('peer publicKey bytes do not match peer id publicKey bytes');\n      throw new CodeError('publicKey bytes do not match peer id publicKey bytes', codes.ERR_INVALID_PARAMETERS);\n    } // dedupe addresses\n\n\n    const addressSet = new Set();\n    const addresses = peer.addresses.filter(address => {\n      if (addressSet.has(address.multiaddr.toString())) {\n        return false;\n      }\n\n      addressSet.add(address.multiaddr.toString());\n      return true;\n    }).sort((a, b) => {\n      return a.multiaddr.toString().localeCompare(b.multiaddr.toString());\n    }).map(_ref2 => {\n      let {\n        multiaddr,\n        isCertified\n      } = _ref2;\n      return {\n        multiaddr: multiaddr.bytes,\n        isCertified\n      };\n    });\n    const metadata = [];\n    [...peer.metadata.keys()].sort().forEach(key => {\n      const value = peer.metadata.get(key);\n\n      if (value != null) {\n        metadata.push({\n          key,\n          value\n        });\n      }\n    });\n    const buf = PeerPB.encode({\n      addresses,\n      protocols: peer.protocols.sort(),\n      pubKey: peer.pubKey,\n      metadata,\n      peerRecordEnvelope: peer.peerRecordEnvelope\n    });\n    await this.components.datastore.put(this._peerIdToDatastoreKey(peer.id), buf.subarray());\n    return await this.load(peer.id);\n  }\n\n  async patch(peerId, data) {\n    const peer = await this.load(peerId);\n    return await this._patch(peerId, data, peer);\n  }\n\n  async patchOrCreate(peerId, data) {\n    let peer;\n\n    try {\n      peer = await this.load(peerId);\n    } catch (err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n\n      peer = {\n        id: peerId,\n        addresses: [],\n        protocols: [],\n        metadata: new Map()\n      };\n    }\n\n    return await this._patch(peerId, data, peer);\n  }\n\n  async _patch(peerId, data, peer) {\n    return await this.save({ ...peer,\n      ...data,\n      id: peerId\n    });\n  }\n\n  async merge(peerId, data) {\n    const peer = await this.load(peerId);\n    return await this._merge(peerId, data, peer);\n  }\n\n  async mergeOrCreate(peerId, data) {\n    /** @type {Peer} */\n    let peer;\n\n    try {\n      peer = await this.load(peerId);\n    } catch (err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n\n      peer = {\n        id: peerId,\n        addresses: [],\n        protocols: [],\n        metadata: new Map()\n      };\n    }\n\n    return await this._merge(peerId, data, peer);\n  }\n\n  async _merge(peerId, data, peer) {\n    // if the peer has certified addresses, use those in\n    // favour of the supplied versions\n    const addresses = new Map();\n    peer.addresses.forEach(addr => {\n      addresses.set(addr.multiaddr.toString(), addr.isCertified);\n    });\n    (data.addresses ?? []).forEach(addr => {\n      const addrString = addr.multiaddr.toString();\n      const isAlreadyCertified = Boolean(addresses.get(addrString));\n      const isCertified = isAlreadyCertified || addr.isCertified;\n      addresses.set(addrString, isCertified);\n    });\n    return await this.save({\n      id: peerId,\n      addresses: Array.from(addresses.entries()).map(_ref3 => {\n        let [addrStr, isCertified] = _ref3;\n        return {\n          multiaddr: multiaddr(addrStr),\n          isCertified\n        };\n      }),\n      protocols: Array.from(new Set([...(peer.protocols ?? []), ...(data.protocols ?? [])])),\n      metadata: new Map([...(peer.metadata?.entries() ?? []), ...(data.metadata?.entries() ?? [])]),\n      pubKey: data.pubKey ?? (peer != null ? peer.pubKey : undefined),\n      peerRecordEnvelope: data.peerRecordEnvelope ?? (peer != null ? peer.peerRecordEnvelope : undefined)\n    });\n  }\n\n  async *all() {\n    for await (const key of this.components.datastore.queryKeys({\n      prefix: NAMESPACE_COMMON\n    })) {\n      // /peers/${peer-id-as-libp2p-key-cid-string-in-base-32}\n      const base32Str = key.toString().split('/')[2];\n      const buf = base32.decode(base32Str);\n      yield this.load(peerIdFromBytes(buf));\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","peerIdFromBytes","CodeError","codes","Key","base32","multiaddr","Peer","PeerPB","mortice","equals","uint8arrayEquals","log","NAMESPACE_COMMON","PersistentStore","constructor","components","lock","name","singleProcess","_peerIdToDatastoreKey","peerId","type","error","ERR_INVALID_PARAMETERS","b32key","toCID","toString","has","datastore","delete","load","buf","get","peer","decode","metadata","Map","meta","set","key","value","id","addresses","map","ma","isCertified","pubKey","undefined","peerRecordEnvelope","save","publicKey","addressSet","Set","filter","address","add","sort","a","b","localeCompare","bytes","keys","forEach","push","encode","protocols","put","subarray","patch","data","_patch","patchOrCreate","err","code","ERR_NOT_FOUND","merge","_merge","mergeOrCreate","addr","addrString","isAlreadyCertified","Boolean","Array","from","entries","addrStr","all","queryKeys","prefix","base32Str","split"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\peer-store\\src\\store.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { codes } from './errors.js'\nimport { Key } from 'interface-datastore/key'\nimport { base32 } from 'multiformats/bases/base32'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { Metadata, Peer as PeerPB } from './pb/peer.js'\nimport mortice from 'mortice'\nimport { equals as uint8arrayEquals } from 'uint8arrays/equals'\nimport type { Peer } from '@libp2p/interface-peer-store'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { PersistentPeerStoreComponents } from './index.js'\n\nconst log = logger('libp2p:peer-store:store')\n\nconst NAMESPACE_COMMON = '/peers/'\n\nexport interface Store {\n  has: (peerId: PeerId) => Promise<boolean>\n  save: (peer: Peer) => Promise<Peer>\n  load: (peerId: PeerId) => Promise<Peer>\n  delete: (peerId: PeerId) => Promise<void>\n  merge: (peerId: PeerId, data: Partial<Peer>) => Promise<Peer>\n  mergeOrCreate: (peerId: PeerId, data: Partial<Peer>) => Promise<Peer>\n  patch: (peerId: PeerId, data: Partial<Peer>) => Promise<Peer>\n  patchOrCreate: (peerId: PeerId, data: Partial<Peer>) => Promise<Peer>\n  all: () => AsyncIterable<Peer>\n\n  lock: {\n    readLock: () => Promise<() => void>\n    writeLock: () => Promise<() => void>\n  }\n}\n\nexport class PersistentStore {\n  private readonly components: PersistentPeerStoreComponents\n  public lock: any\n\n  constructor (components: PersistentPeerStoreComponents) {\n    this.components = components\n    this.lock = mortice({\n      name: 'peer-store',\n      singleProcess: true\n    })\n  }\n\n  _peerIdToDatastoreKey (peerId: PeerId): Key {\n    if (peerId.type == null) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw new CodeError('peerId must be an instance of peer-id', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    const b32key = peerId.toCID().toString()\n    return new Key(`${NAMESPACE_COMMON}${b32key}`)\n  }\n\n  async has (peerId: PeerId): Promise<boolean> {\n    return await this.components.datastore.has(this._peerIdToDatastoreKey(peerId))\n  }\n\n  async delete (peerId: PeerId): Promise<void> {\n    await this.components.datastore.delete(this._peerIdToDatastoreKey(peerId))\n  }\n\n  async load (peerId: PeerId): Promise<Peer> {\n    const buf = await this.components.datastore.get(this._peerIdToDatastoreKey(peerId))\n    const peer = PeerPB.decode(buf)\n    const metadata = new Map()\n\n    for (const meta of peer.metadata) {\n      metadata.set(meta.key, meta.value)\n    }\n\n    return {\n      ...peer,\n      id: peerId,\n      addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {\n        return {\n          multiaddr: multiaddr(ma),\n          isCertified: isCertified ?? false\n        }\n      }),\n      metadata,\n      pubKey: peer.pubKey ?? undefined,\n      peerRecordEnvelope: peer.peerRecordEnvelope ?? undefined\n    }\n  }\n\n  async save (peer: Peer): Promise<Peer> {\n    if (peer.pubKey != null && peer.id.publicKey != null && !uint8arrayEquals(peer.pubKey, peer.id.publicKey)) {\n      log.error('peer publicKey bytes do not match peer id publicKey bytes')\n      throw new CodeError('publicKey bytes do not match peer id publicKey bytes', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    // dedupe addresses\n    const addressSet = new Set()\n    const addresses = peer.addresses\n      .filter(address => {\n        if (addressSet.has(address.multiaddr.toString())) {\n          return false\n        }\n\n        addressSet.add(address.multiaddr.toString())\n        return true\n      })\n      .sort((a, b) => {\n        return a.multiaddr.toString().localeCompare(b.multiaddr.toString())\n      })\n      .map(({ multiaddr, isCertified }) => ({\n        multiaddr: multiaddr.bytes,\n        isCertified\n      }))\n\n    const metadata: Metadata[] = []\n\n    ;[...peer.metadata.keys()].sort().forEach(key => {\n      const value = peer.metadata.get(key)\n\n      if (value != null) {\n        metadata.push({ key, value })\n      }\n    })\n\n    const buf = PeerPB.encode({\n      addresses,\n      protocols: peer.protocols.sort(),\n      pubKey: peer.pubKey,\n      metadata,\n      peerRecordEnvelope: peer.peerRecordEnvelope\n    })\n\n    await this.components.datastore.put(this._peerIdToDatastoreKey(peer.id), buf.subarray())\n\n    return await this.load(peer.id)\n  }\n\n  async patch (peerId: PeerId, data: Partial<Peer>): Promise<Peer> {\n    const peer = await this.load(peerId)\n\n    return await this._patch(peerId, data, peer)\n  }\n\n  async patchOrCreate (peerId: PeerId, data: Partial<Peer>): Promise<Peer> {\n    let peer: Peer\n\n    try {\n      peer = await this.load(peerId)\n    } catch (err: any) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n\n      peer = { id: peerId, addresses: [], protocols: [], metadata: new Map() }\n    }\n\n    return await this._patch(peerId, data, peer)\n  }\n\n  async _patch (peerId: PeerId, data: Partial<Peer>, peer: Peer): Promise<Peer> {\n    return await this.save({\n      ...peer,\n      ...data,\n      id: peerId\n    })\n  }\n\n  async merge (peerId: PeerId, data: Partial<Peer>): Promise<Peer> {\n    const peer = await this.load(peerId)\n\n    return await this._merge(peerId, data, peer)\n  }\n\n  async mergeOrCreate (peerId: PeerId, data: Partial<Peer>): Promise<Peer> {\n    /** @type {Peer} */\n    let peer\n\n    try {\n      peer = await this.load(peerId)\n    } catch (err: any) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n\n      peer = { id: peerId, addresses: [], protocols: [], metadata: new Map() }\n    }\n\n    return await this._merge(peerId, data, peer)\n  }\n\n  async _merge (peerId: PeerId, data: Partial<Peer>, peer: Peer): Promise<Peer> {\n    // if the peer has certified addresses, use those in\n    // favour of the supplied versions\n    const addresses = new Map<string, boolean>()\n\n    peer.addresses.forEach((addr) => {\n      addresses.set(addr.multiaddr.toString(), addr.isCertified)\n    })\n\n    ;(data.addresses ?? []).forEach(addr => {\n      const addrString = addr.multiaddr.toString()\n      const isAlreadyCertified = Boolean(addresses.get(addrString))\n\n      const isCertified = isAlreadyCertified || addr.isCertified\n\n      addresses.set(addrString, isCertified)\n    })\n\n    return await this.save({\n      id: peerId,\n      addresses: Array.from(addresses.entries()).map(([addrStr, isCertified]) => {\n        return {\n          multiaddr: multiaddr(addrStr),\n          isCertified\n        }\n      }),\n      protocols: Array.from(new Set([\n        ...(peer.protocols ?? []),\n        ...(data.protocols ?? [])\n      ])),\n      metadata: new Map([\n        ...(peer.metadata?.entries() ?? []),\n        ...(data.metadata?.entries() ?? [])\n      ]),\n      pubKey: data.pubKey ?? (peer != null ? peer.pubKey : undefined),\n      peerRecordEnvelope: data.peerRecordEnvelope ?? (peer != null ? peer.peerRecordEnvelope : undefined)\n    })\n  }\n\n  async * all (): AsyncGenerator<Peer, void, unknown> {\n    for await (const key of this.components.datastore.queryKeys({\n      prefix: NAMESPACE_COMMON\n    })) {\n      // /peers/${peer-id-as-libp2p-key-cid-string-in-base-32}\n      const base32Str = key.toString().split('/')[2]\n      const buf = base32.decode(base32Str)\n\n      yield this.load(peerIdFromBytes(buf))\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}