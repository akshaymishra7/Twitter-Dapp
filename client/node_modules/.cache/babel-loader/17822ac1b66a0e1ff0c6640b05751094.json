{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { codes, messages } from './errors.js';\nimport { storeAddresses, uniquePeers, requirePeers } from './content-routing/utils.js';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport merge from 'it-merge';\nimport { pipe } from 'it-pipe';\nimport first from 'it-first';\nimport drain from 'it-drain';\nimport filter from 'it-filter';\nimport { setDelayedInterval, clearDelayedInterval // @ts-expect-error module with no types\n} from 'set-delayed-interval';\nimport { setMaxListeners } from 'events';\nconst log = logger('libp2p:peer-routing');\nexport class DefaultPeerRouting {\n  constructor(components, init) {\n    this.components = components;\n    this.routers = init.routers ?? [];\n    this.refreshManagerInit = init.refreshManager ?? {};\n    this.started = false;\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);\n  }\n\n  isStarted() {\n    return this.started;\n  }\n  /**\n   * Start peer routing service.\n   */\n\n\n  async start() {\n    if (this.started || this.routers.length === 0 || this.timeoutId != null || this.refreshManagerInit.enabled === false) {\n      return;\n    }\n\n    this.timeoutId = setDelayedInterval(this._findClosestPeersTask, this.refreshManagerInit.interval, this.refreshManagerInit.bootDelay);\n    this.started = true;\n  }\n  /**\n   * Recurrent task to find closest peers and add their addresses to the Address Book.\n   */\n\n\n  async _findClosestPeersTask() {\n    if (this.abortController != null) {\n      // we are already running the query\n      return;\n    }\n\n    try {\n      this.abortController = new TimeoutController(this.refreshManagerInit.timeout ?? 10e3); // this controller may be used while dialing lots of peers so prevent MaxListenersExceededWarning\n      // appearing in the console\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, this.abortController.signal);\n      } catch {} // nb getClosestPeers adds the addresses to the address book\n\n\n      await drain(this.getClosestPeers(this.components.peerId.toBytes(), {\n        signal: this.abortController.signal\n      }));\n    } catch (err) {\n      log.error(err);\n    } finally {\n      this.abortController?.clear();\n      this.abortController = undefined;\n    }\n  }\n  /**\n   * Stop peer routing service.\n   */\n\n\n  async stop() {\n    clearDelayedInterval(this.timeoutId); // abort query if it is in-flight\n\n    this.abortController?.abort();\n    this.started = false;\n  }\n  /**\n   * Iterates over all peer routers in parallel to find the given peer\n   */\n\n\n  async findPeer(id, options) {\n    if (this.routers.length === 0) {\n      throw errCode(new Error('No peer routers available'), codes.ERR_NO_ROUTERS_AVAILABLE);\n    }\n\n    if (id.toString() === this.components.peerId.toString()) {\n      throw errCode(new Error('Should not try to find self'), codes.ERR_FIND_SELF);\n    }\n\n    const output = await pipe(merge(...this.routers.map(router => async function* () {\n      try {\n        yield await router.findPeer(id, options);\n      } catch (err) {\n        log.error(err);\n      }\n    }())), source => filter(source, Boolean), source => storeAddresses(source, this.components.peerStore), async source => await first(source));\n\n    if (output != null) {\n      return output;\n    }\n\n    throw errCode(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);\n  }\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   */\n\n\n  async *getClosestPeers(key, options) {\n    if (this.routers.length === 0) {\n      throw errCode(new Error('No peer routers available'), codes.ERR_NO_ROUTERS_AVAILABLE);\n    }\n\n    yield* pipe(merge(...this.routers.map(router => router.getClosestPeers(key, options))), source => storeAddresses(source, this.components.peerStore), source => uniquePeers(source), source => requirePeers(source));\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","errCode","codes","messages","storeAddresses","uniquePeers","requirePeers","TimeoutController","merge","pipe","first","drain","filter","setDelayedInterval","clearDelayedInterval","setMaxListeners","log","DefaultPeerRouting","constructor","components","init","routers","refreshManagerInit","refreshManager","started","_findClosestPeersTask","bind","isStarted","start","length","timeoutId","enabled","interval","bootDelay","abortController","timeout","Infinity","signal","getClosestPeers","peerId","toBytes","err","error","clear","undefined","stop","abort","findPeer","id","options","Error","ERR_NO_ROUTERS_AVAILABLE","toString","ERR_FIND_SELF","output","map","router","source","Boolean","peerStore","NOT_FOUND","ERR_NOT_FOUND","key"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\peer-routing.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { codes, messages } from './errors.js'\nimport {\n  storeAddresses,\n  uniquePeers,\n  requirePeers\n} from './content-routing/utils.js'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport merge from 'it-merge'\nimport { pipe } from 'it-pipe'\nimport first from 'it-first'\nimport drain from 'it-drain'\nimport filter from 'it-filter'\nimport {\n  setDelayedInterval,\n  clearDelayedInterval\n// @ts-expect-error module with no types\n} from 'set-delayed-interval'\nimport { setMaxListeners } from 'events'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { PeerRouting } from '@libp2p/interface-peer-routing'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { PeerStore } from '@libp2p/interface-peer-store'\n\nconst log = logger('libp2p:peer-routing')\n\nexport interface RefreshManagerInit {\n  /**\n   * Whether to enable the Refresh manager\n   */\n  enabled?: boolean\n\n  /**\n   * Boot delay to start the Refresh Manager (in ms)\n   */\n  bootDelay?: number\n\n  /**\n   * Interval between each Refresh Manager run (in ms)\n   */\n  interval?: number\n\n  /**\n   * How long to let each refresh run (in ms)\n   */\n  timeout?: number\n}\n\nexport interface PeerRoutingInit {\n  routers?: PeerRouting[]\n  refreshManager?: RefreshManagerInit\n}\n\nexport interface DefaultPeerRoutingComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n}\n\nexport class DefaultPeerRouting implements PeerRouting, Startable {\n  private readonly components: DefaultPeerRoutingComponents\n  private readonly routers: PeerRouting[]\n  private readonly refreshManagerInit: RefreshManagerInit\n  private timeoutId?: ReturnType<typeof setTimeout>\n  private started: boolean\n  private abortController?: TimeoutController\n\n  constructor (components: DefaultPeerRoutingComponents, init: PeerRoutingInit) {\n    this.components = components\n    this.routers = init.routers ?? []\n    this.refreshManagerInit = init.refreshManager ?? {}\n    this.started = false\n\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this)\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * Start peer routing service.\n   */\n  async start () {\n    if (this.started || this.routers.length === 0 || this.timeoutId != null || this.refreshManagerInit.enabled === false) {\n      return\n    }\n\n    this.timeoutId = setDelayedInterval(\n      this._findClosestPeersTask, this.refreshManagerInit.interval, this.refreshManagerInit.bootDelay\n    )\n\n    this.started = true\n  }\n\n  /**\n   * Recurrent task to find closest peers and add their addresses to the Address Book.\n   */\n  async _findClosestPeersTask () {\n    if (this.abortController != null) {\n      // we are already running the query\n      return\n    }\n\n    try {\n      this.abortController = new TimeoutController(this.refreshManagerInit.timeout ?? 10e3)\n\n      // this controller may be used while dialing lots of peers so prevent MaxListenersExceededWarning\n      // appearing in the console\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, this.abortController.signal)\n      } catch {}\n\n      // nb getClosestPeers adds the addresses to the address book\n      await drain(this.getClosestPeers(this.components.peerId.toBytes(), { signal: this.abortController.signal }))\n    } catch (err: any) {\n      log.error(err)\n    } finally {\n      this.abortController?.clear()\n      this.abortController = undefined\n    }\n  }\n\n  /**\n   * Stop peer routing service.\n   */\n  async stop () {\n    clearDelayedInterval(this.timeoutId)\n\n    // abort query if it is in-flight\n    this.abortController?.abort()\n\n    this.started = false\n  }\n\n  /**\n   * Iterates over all peer routers in parallel to find the given peer\n   */\n  async findPeer (id: PeerId, options?: AbortOptions): Promise<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw errCode(new Error('No peer routers available'), codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    if (id.toString() === this.components.peerId.toString()) {\n      throw errCode(new Error('Should not try to find self'), codes.ERR_FIND_SELF)\n    }\n\n    const output = await pipe(\n      merge(\n        ...this.routers.map(router => (async function * () {\n          try {\n            yield await router.findPeer(id, options)\n          } catch (err) {\n            log.error(err)\n          }\n        })())\n      ),\n      (source) => filter(source, Boolean),\n      (source) => storeAddresses(source, this.components.peerStore),\n      async (source) => await first(source)\n    )\n\n    if (output != null) {\n      return output\n    }\n\n    throw errCode(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND)\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   */\n  async * getClosestPeers (key: Uint8Array, options?: AbortOptions): AsyncIterable<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw errCode(new Error('No peer routers available'), codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    yield * pipe(\n      merge(\n        ...this.routers.map(router => router.getClosestPeers(key, options))\n      ),\n      (source) => storeAddresses(source, this.components.peerStore),\n      (source) => uniquePeers(source),\n      (source) => requirePeers(source)\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"module"}