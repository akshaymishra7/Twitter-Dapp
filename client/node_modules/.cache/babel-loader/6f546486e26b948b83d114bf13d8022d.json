{"ast":null,"code":"import { Message, MESSAGE_TYPE } from '../message/index.js';\nimport parallel from 'it-parallel';\nimport map from 'it-map';\nimport { convertBuffer } from '../utils.js';\nimport { ALPHA } from '../constants.js';\nimport { pipe } from 'it-pipe';\nimport { queryErrorEvent, peerResponseEvent, providerEvent } from '../query/events.js';\nimport { logger } from '@libp2p/logger';\nexport class ContentRouting {\n  constructor(components, init) {\n    const {\n      network,\n      peerRouting,\n      queryManager,\n      routingTable,\n      providers,\n      lan\n    } = init;\n    this.components = components;\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:content-routing`);\n    this.network = network;\n    this.peerRouting = peerRouting;\n    this.queryManager = queryManager;\n    this.routingTable = routingTable;\n    this.providers = providers;\n  }\n  /**\n   * Announce to the network that we can provide the value for a given key and\n   * are contactable on the given multiaddrs\n   */\n\n\n  async *provide(key, multiaddrs) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.log('provide %s', key); // Add peer as provider\n\n    await this.providers.addProvider(key, this.components.peerId);\n    const msg = new Message(MESSAGE_TYPE.ADD_PROVIDER, key.multihash.bytes, 0);\n    msg.providerPeers = [{\n      id: this.components.peerId,\n      multiaddrs,\n      protocols: []\n    }];\n    let sent = 0;\n\n    const maybeNotifyPeer = event => {\n      return async () => {\n        if (event.name !== 'FINAL_PEER') {\n          return [event];\n        }\n\n        const events = [];\n        this.log('putProvider %s to %p', key, event.peer.id);\n\n        try {\n          this.log('sending provider record for %s to %p', key, event.peer.id);\n\n          for await (const sendEvent of this.network.sendMessage(event.peer.id, msg, options)) {\n            if (sendEvent.name === 'PEER_RESPONSE') {\n              this.log('sent provider record for %s to %p', key, event.peer.id);\n              sent++;\n            }\n\n            events.push(sendEvent);\n          }\n        } catch (err) {\n          this.log.error('error sending provide record to peer %p', event.peer.id, err);\n          events.push(queryErrorEvent({\n            from: event.peer.id,\n            error: err\n          }));\n        }\n\n        return events;\n      };\n    }; // Notify closest peers\n\n\n    yield* pipe(this.peerRouting.getClosestPeers(key.multihash.bytes, options), source => map(source, event => maybeNotifyPeer(event)), source => parallel(source, {\n      ordered: false,\n      concurrency: ALPHA\n    }), async function* (source) {\n      for await (const events of source) {\n        yield* events;\n      }\n    });\n    this.log('sent provider records to %d peers', sent);\n  }\n  /**\n   * Search the dht for up to `K` providers of the given CID.\n   */\n\n\n  async *findProviders(key, options) {\n    const toFind = this.routingTable.kBucketSize;\n    const target = key.multihash.bytes;\n    const id = await convertBuffer(target);\n    const self = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\n    this.log('findProviders %c', key);\n    const provs = await this.providers.getProviders(key); // yield values if we have some, also slice because maybe we got lucky and already have too many?\n\n    if (provs.length > 0) {\n      const providers = [];\n\n      for (const peerId of provs.slice(0, toFind)) {\n        providers.push({\n          id: peerId,\n          multiaddrs: ((await this.components.peerStore.addressBook.get(peerId)) ?? []).map(address => address.multiaddr),\n          protocols: []\n        });\n      }\n\n      yield peerResponseEvent({\n        from: this.components.peerId,\n        messageType: MESSAGE_TYPE.GET_PROVIDERS,\n        providers\n      });\n      yield providerEvent({\n        from: this.components.peerId,\n        providers\n      });\n    } // All done\n\n\n    if (provs.length >= toFind) {\n      return;\n    }\n    /**\n     * The query function to use on this particular disjoint path\n     */\n\n\n    const findProvidersQuery = async function* (_ref) {\n      let {\n        peer,\n        signal\n      } = _ref;\n      const request = new Message(MESSAGE_TYPE.GET_PROVIDERS, target, 0);\n      yield* self.network.sendRequest(peer, request, {\n        signal\n      });\n    };\n\n    const providers = new Set(provs.map(p => p.toString()));\n\n    for await (const event of this.queryManager.run(target, this.routingTable.closestPeers(id), findProvidersQuery, options)) {\n      yield event;\n\n      if (event.name === 'PEER_RESPONSE') {\n        this.log('Found %d provider entries for %c and %d closer peers', event.providers.length, key, event.closer.length);\n        const newProviders = [];\n\n        for (const peer of event.providers) {\n          if (providers.has(peer.id.toString())) {\n            continue;\n          }\n\n          providers.add(peer.id.toString());\n          newProviders.push(peer);\n        }\n\n        if (newProviders.length > 0) {\n          yield providerEvent({\n            from: event.from,\n            providers: newProviders\n          });\n        }\n\n        if (providers.size === toFind) {\n          return;\n        }\n      }\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Message","MESSAGE_TYPE","parallel","map","convertBuffer","ALPHA","pipe","queryErrorEvent","peerResponseEvent","providerEvent","logger","ContentRouting","constructor","components","init","network","peerRouting","queryManager","routingTable","providers","lan","log","provide","key","multiaddrs","options","addProvider","peerId","msg","ADD_PROVIDER","multihash","bytes","providerPeers","id","protocols","sent","maybeNotifyPeer","event","name","events","peer","sendEvent","sendMessage","push","err","error","from","getClosestPeers","source","ordered","concurrency","findProviders","toFind","kBucketSize","target","self","provs","getProviders","length","slice","peerStore","addressBook","get","address","multiaddr","messageType","GET_PROVIDERS","findProvidersQuery","signal","request","sendRequest","Set","p","toString","run","closestPeers","closer","newProviders","has","add","size"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\content-routing\\index.ts"],"sourcesContent":["import { Message, MESSAGE_TYPE } from '../message/index.js'\nimport parallel from 'it-parallel'\nimport map from 'it-map'\nimport { convertBuffer } from '../utils.js'\nimport { ALPHA } from '../constants.js'\nimport { pipe } from 'it-pipe'\nimport {\n  queryErrorEvent,\n  peerResponseEvent,\n  providerEvent\n} from '../query/events.js'\nimport { logger } from '@libp2p/logger'\nimport type { PeerResponseEvent, ProviderEvent, QueryEvent, QueryOptions } from '@libp2p/interface-dht'\nimport type { PeerRouting } from '../peer-routing/index.js'\nimport type { QueryManager } from '../query/manager.js'\nimport type { RoutingTable } from '../routing-table/index.js'\nimport type { Network } from '../network.js'\nimport type { Logger } from '@libp2p/logger'\nimport type { Providers } from '../providers.js'\nimport type { QueryFunc } from '../query/types.js'\nimport type { CID } from 'multiformats/cid'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { KadDHTComponents } from '../index.js'\n\nexport interface ContentRoutingInit {\n  network: Network\n  peerRouting: PeerRouting\n  queryManager: QueryManager\n  routingTable: RoutingTable\n  providers: Providers\n  lan: boolean\n}\n\nexport class ContentRouting {\n  private readonly log: Logger\n  private readonly components: KadDHTComponents\n  private readonly network: Network\n  private readonly peerRouting: PeerRouting\n  private readonly queryManager: QueryManager\n  private readonly routingTable: RoutingTable\n  private readonly providers: Providers\n\n  constructor (components: KadDHTComponents, init: ContentRoutingInit) {\n    const { network, peerRouting, queryManager, routingTable, providers, lan } = init\n\n    this.components = components\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:content-routing`)\n    this.network = network\n    this.peerRouting = peerRouting\n    this.queryManager = queryManager\n    this.routingTable = routingTable\n    this.providers = providers\n  }\n\n  /**\n   * Announce to the network that we can provide the value for a given key and\n   * are contactable on the given multiaddrs\n   */\n  async * provide (key: CID, multiaddrs: Multiaddr[], options: AbortOptions = {}): AsyncGenerator<QueryEvent, void, undefined> {\n    this.log('provide %s', key)\n\n    // Add peer as provider\n    await this.providers.addProvider(key, this.components.peerId)\n\n    const msg = new Message(MESSAGE_TYPE.ADD_PROVIDER, key.multihash.bytes, 0)\n    msg.providerPeers = [{\n      id: this.components.peerId,\n      multiaddrs,\n      protocols: []\n    }]\n\n    let sent = 0\n\n    const maybeNotifyPeer = (event: QueryEvent) => {\n      return async () => {\n        if (event.name !== 'FINAL_PEER') {\n          return [event]\n        }\n\n        const events = []\n\n        this.log('putProvider %s to %p', key, event.peer.id)\n\n        try {\n          this.log('sending provider record for %s to %p', key, event.peer.id)\n\n          for await (const sendEvent of this.network.sendMessage(event.peer.id, msg, options)) {\n            if (sendEvent.name === 'PEER_RESPONSE') {\n              this.log('sent provider record for %s to %p', key, event.peer.id)\n              sent++\n            }\n\n            events.push(sendEvent)\n          }\n        } catch (err: any) {\n          this.log.error('error sending provide record to peer %p', event.peer.id, err)\n          events.push(queryErrorEvent({ from: event.peer.id, error: err }))\n        }\n\n        return events\n      }\n    }\n\n    // Notify closest peers\n    yield * pipe(\n      this.peerRouting.getClosestPeers(key.multihash.bytes, options),\n      (source) => map(source, (event) => maybeNotifyPeer(event)),\n      (source) => parallel(source, {\n        ordered: false,\n        concurrency: ALPHA\n      }),\n      async function * (source) {\n        for await (const events of source) {\n          yield * events\n        }\n      }\n    )\n\n    this.log('sent provider records to %d peers', sent)\n  }\n\n  /**\n   * Search the dht for up to `K` providers of the given CID.\n   */\n  async * findProviders (key: CID, options: QueryOptions): AsyncGenerator<PeerResponseEvent | ProviderEvent | QueryEvent> {\n    const toFind = this.routingTable.kBucketSize\n    const target = key.multihash.bytes\n    const id = await convertBuffer(target)\n    const self = this // eslint-disable-line @typescript-eslint/no-this-alias\n\n    this.log('findProviders %c', key)\n\n    const provs = await this.providers.getProviders(key)\n\n    // yield values if we have some, also slice because maybe we got lucky and already have too many?\n    if (provs.length > 0) {\n      const providers: PeerInfo[] = []\n\n      for (const peerId of provs.slice(0, toFind)) {\n        providers.push({\n          id: peerId,\n          multiaddrs: ((await this.components.peerStore.addressBook.get(peerId)) ?? []).map(address => address.multiaddr),\n          protocols: []\n        })\n      }\n\n      yield peerResponseEvent({ from: this.components.peerId, messageType: MESSAGE_TYPE.GET_PROVIDERS, providers })\n      yield providerEvent({ from: this.components.peerId, providers })\n    }\n\n    // All done\n    if (provs.length >= toFind) {\n      return\n    }\n\n    /**\n     * The query function to use on this particular disjoint path\n     */\n    const findProvidersQuery: QueryFunc = async function * ({ peer, signal }) {\n      const request = new Message(MESSAGE_TYPE.GET_PROVIDERS, target, 0)\n\n      yield * self.network.sendRequest(peer, request, { signal })\n    }\n\n    const providers = new Set(provs.map(p => p.toString()))\n\n    for await (const event of this.queryManager.run(target, this.routingTable.closestPeers(id), findProvidersQuery, options)) {\n      yield event\n\n      if (event.name === 'PEER_RESPONSE') {\n        this.log('Found %d provider entries for %c and %d closer peers', event.providers.length, key, event.closer.length)\n\n        const newProviders = []\n\n        for (const peer of event.providers) {\n          if (providers.has(peer.id.toString())) {\n            continue\n          }\n\n          providers.add(peer.id.toString())\n          newProviders.push(peer)\n        }\n\n        if (newProviders.length > 0) {\n          yield providerEvent({ from: event.from, providers: newProviders })\n        }\n\n        if (providers.size === toFind) {\n          return\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}