{"ast":null,"code":"import ready from './ready.js';\nexport default ((socket, options) => {\n  options = options ?? {};\n  options.closeOnEnd = options.closeOnEnd !== false;\n\n  const sink = async source => {\n    for await (const data of source) {\n      try {\n        await ready(socket);\n      } catch (err) {\n        if (err.message === 'socket closed') break;\n        throw err;\n      }\n\n      socket.send(data);\n    }\n\n    if (options.closeOnEnd != null && socket.readyState <= 1) {\n      return await new Promise((resolve, reject) => {\n        socket.addEventListener('close', event => {\n          if (event.wasClean || event.code === 1006) {\n            resolve();\n          } else {\n            const err = Object.assign(new Error('ws error'), {\n              event\n            });\n            reject(err);\n          }\n        });\n        setTimeout(() => socket.close());\n      });\n    }\n  };\n\n  return sink;\n});","map":{"version":3,"mappings":"AAAA,OAAOA,KAAP,MAAkB,YAAlB;AAQA,gBAAe,CAACC,MAAD,EAAoBC,OAApB,KAA4C;AACzDA,SAAO,GAAGA,OAAO,IAAI,EAArB;AACAA,SAAO,CAACC,UAAR,GAAqBD,OAAO,CAACC,UAAR,KAAuB,KAA5C;;AAEA,QAAMC,IAAI,GAAoC,MAAMC,MAAN,IAAe;AAC3D,eAAW,MAAMC,IAAjB,IAAyBD,MAAzB,EAAiC;AAC/B,UAAI;AACF,cAAML,KAAK,CAACC,MAAD,CAAX;AACD,OAFD,CAEE,OAAOM,GAAP,EAAiB;AACjB,YAAIA,GAAG,CAACC,OAAJ,KAAgB,eAApB,EAAqC;AACrC,cAAMD,GAAN;AACD;;AAEDN,YAAM,CAACQ,IAAP,CAAYH,IAAZ;AACD;;AAED,QAAIJ,OAAO,CAACC,UAAR,IAAsB,IAAtB,IAA8BF,MAAM,CAACS,UAAP,IAAqB,CAAvD,EAA0D;AACxD,aAAO,MAAM,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;AAC3CZ,cAAM,CAACa,gBAAP,CAAwB,OAAxB,EAAiCC,KAAK,IAAG;AACvC,cAAIA,KAAK,CAACC,QAAN,IAAkBD,KAAK,CAACE,IAAN,KAAe,IAArC,EAA2C;AACzCL,mBAAO;AACR,WAFD,MAEO;AACL,kBAAML,GAAG,GAAGW,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,UAAV,CAAd,EAAqC;AAAEL;AAAF,aAArC,CAAZ;AACAF,kBAAM,CAACN,GAAD,CAAN;AACD;AACF,SAPD;AASAc,kBAAU,CAAC,MAAMpB,MAAM,CAACqB,KAAP,EAAP,CAAV;AACD,OAXY,CAAb;AAYD;AACF,GA1BD;;AA4BA,SAAOlB,IAAP;AACD,CAjCD","names":["ready","socket","options","closeOnEnd","sink","source","data","err","message","send","readyState","Promise","resolve","reject","addEventListener","event","wasClean","code","Object","assign","Error","setTimeout","close"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-ws\\src\\sink.ts"],"sourcesContent":["import ready from './ready.js'\nimport type { WebSocket } from 'ws'\nimport type { Sink } from 'it-stream-types'\n\nexport interface SinkOptions {\n  closeOnEnd?: boolean\n}\n\nexport default (socket: WebSocket, options: SinkOptions) => {\n  options = options ?? {}\n  options.closeOnEnd = options.closeOnEnd !== false\n\n  const sink: Sink<Uint8Array, Promise<void>> = async source => {\n    for await (const data of source) {\n      try {\n        await ready(socket)\n      } catch (err: any) {\n        if (err.message === 'socket closed') break\n        throw err\n      }\n\n      socket.send(data)\n    }\n\n    if (options.closeOnEnd != null && socket.readyState <= 1) {\n      return await new Promise((resolve, reject) => {\n        socket.addEventListener('close', event => {\n          if (event.wasClean || event.code === 1006) {\n            resolve()\n          } else {\n            const err = Object.assign(new Error('ws error'), { event })\n            reject(err)\n          }\n        })\n\n        setTimeout(() => socket.close())\n      })\n    }\n  }\n\n  return sink\n}\n"]},"metadata":{},"sourceType":"module"}