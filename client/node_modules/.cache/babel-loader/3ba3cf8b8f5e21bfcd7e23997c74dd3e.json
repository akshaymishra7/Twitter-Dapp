{"ast":null,"code":"import * as ipns from 'ipns';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport * as Errors from 'datastore-core/errors';\nimport { ipnsValidator } from 'ipns/validator';\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst log = logger('ipfs:ipns:resolver');\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultMaximumRecursiveDepth = 32;\nexport class IpnsResolver {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   */\n  constructor(routing) {\n    this._routing = routing;\n  }\n  /**\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async resolve(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    const recursive = options.recursive && options.recursive.toString() === 'true';\n    const nameSegments = name.split('/');\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    const key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n    let depth = Infinity;\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth;\n    }\n\n    const res = await this.resolver(key, depth, options);\n    log(`${name} was locally resolved correctly`);\n    return res;\n  }\n  /**\n   * Recursive resolver according to the specified depth\n   *\n   * @param {string} name\n   * @param {number} depth\n   * @param {AbortOptions} options\n   * @returns {Promise<string>}\n   */\n\n\n  async resolver(name, depth, options) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n    }\n\n    const res = await this._resolveName(name, options);\n    const nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res;\n    } // continue recursively until depth equals 0\n\n\n    return this.resolver(nameSegments[2], depth - 1, options);\n  }\n  /**\n   * Resolve ipns entries from the provided routing\n   *\n   * @param {string} name\n   * @param {AbortOptions} options\n   */\n\n\n  async _resolveName(name, options) {\n    const peerId = peerIdFromString(name);\n    const routingKey = ipns.peerIdToRoutingKey(peerId);\n    let record;\n\n    try {\n      record = await this._routing.get(routingKey, options);\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error('could not get record from routing', err);\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND');\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n    } // We should have the public key by now (inline, or in the entry)\n\n\n    return this._validateRecord(peerId, record);\n  }\n  /**\n   * Validate a resolved record\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} record\n   */\n\n\n  async _validateRecord(peerId, record) {\n    // IPNS entry validation\n    await ipnsValidator(uint8ArrayConcat([uint8ArrayFromString('/ipns/'), peerId.toBytes()]), record);\n    const ipnsEntry = ipns.unmarshal(record);\n    return uint8ArrayToString(ipnsEntry.value);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/ipns/resolver.js"],"names":["ipns","peerIdFromString","errcode","logger","toString","uint8ArrayToString","fromString","uint8ArrayFromString","concat","uint8ArrayConcat","Errors","ipnsValidator","log","ERR_NOT_FOUND","notFoundError","code","defaultMaximumRecursiveDepth","IpnsResolver","constructor","routing","_routing","resolve","name","options","Error","recursive","nameSegments","split","length","key","depth","Infinity","res","resolver","errMsg","error","_resolveName","peerId","routingKey","peerIdToRoutingKey","record","get","err","_validateRecord","toBytes","ipnsEntry","unmarshal","value"],"mappings":"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","sourcesContent":["import * as ipns from 'ipns'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport * as Errors from 'datastore-core/errors'\nimport { ipnsValidator } from 'ipns/validator'\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst log = logger('ipfs:ipns:resolver')\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code\n\nconst defaultMaximumRecursiveDepth = 32\n\nexport class IpnsResolver {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   */\n  constructor (routing) {\n    this._routing = routing\n  }\n\n  /**\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n  async resolve (name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const recursive = options.recursive && options.recursive.toString() === 'true'\n\n    const nameSegments = name.split('/')\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const key = nameSegments[2]\n\n    // Define a maximum depth if recursive option enabled\n    let depth = Infinity\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth\n    }\n\n    const res = await this.resolver(key, depth, options)\n\n    log(`${name} was locally resolved correctly`)\n    return res\n  }\n\n  /**\n   * Recursive resolver according to the specified depth\n   *\n   * @param {string} name\n   * @param {number} depth\n   * @param {AbortOptions} options\n   * @returns {Promise<string>}\n   */\n  async resolver (name, depth, options) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT')\n    }\n\n    const res = await this._resolveName(name, options)\n    const nameSegments = res.split('/')\n\n    // If obtained a ipfs cid or recursive option is disabled\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res\n    }\n\n    // continue recursively until depth equals 0\n    return this.resolver(nameSegments[2], depth - 1, options)\n  }\n\n  /**\n   * Resolve ipns entries from the provided routing\n   *\n   * @param {string} name\n   * @param {AbortOptions} options\n   */\n  async _resolveName (name, options) {\n    const peerId = peerIdFromString(name)\n    const routingKey = ipns.peerIdToRoutingKey(peerId)\n    let record\n\n    try {\n      record = await this._routing.get(routingKey, options)\n    } catch (/** @type {any} */ err) {\n      log.error('could not get record from routing', err)\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND')\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n    }\n\n    // We should have the public key by now (inline, or in the entry)\n    return this._validateRecord(peerId, record)\n  }\n\n  /**\n   * Validate a resolved record\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} record\n   */\n  async _validateRecord (peerId, record) {\n    // IPNS entry validation\n    await ipnsValidator(uint8ArrayConcat([\n      uint8ArrayFromString('/ipns/'),\n      peerId.toBytes()\n    ]), record)\n\n    const ipnsEntry = ipns.unmarshal(record)\n\n    return uint8ArrayToString(ipnsEntry.value)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}