{"ast":null,"code":"/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive Protobuf encoded messages over\n * streams.\n *\n * @example\n *\n * ```typescript\n * import { pbStream } from 'it-pb-stream'\n * import { MessageType } from './src/my-message-type.js'\n *\n * // RequestType and ResponseType have been generate from `.proto` files and have\n * // `.encode` and `.decode` methods for serialization/deserialization\n *\n * const stream = pbStream(duplex)\n * stream.writePB({\n *   foo: 'bar'\n * }, MessageType)\n * const res = await stream.readPB(MessageType)\n * ```\n */\nimport * as lp from 'it-length-prefixed';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { pushable } from 'it-pushable';\nimport { unsigned } from 'uint8-varint';\nimport errCode from 'err-code';\n\nconst defaultLengthDecoder = buf => {\n  return unsigned.decode(buf);\n};\n\ndefaultLengthDecoder.bytes = 0;\nexport function pbStream(duplex) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const write = pushable();\n  duplex.sink(write).catch(err => {\n    write.end(err);\n  });\n\n  duplex.sink = async source => {\n    for await (const buf of source) {\n      write.push(buf);\n    }\n  };\n\n  let source = duplex.source;\n\n  if (duplex.source[Symbol.iterator] != null) {\n    source = duplex.source[Symbol.iterator]();\n  } else if (duplex.source[Symbol.asyncIterator] != null) {\n    source = duplex.source[Symbol.asyncIterator]();\n  }\n\n  const readBuffer = new Uint8ArrayList();\n  const W = {\n    read: async bytes => {\n      if (bytes == null) {\n        // just read whatever arrives\n        const {\n          done,\n          value\n        } = await source.next();\n\n        if (done === true) {\n          return new Uint8ArrayList();\n        }\n\n        return value;\n      }\n\n      while (readBuffer.byteLength < bytes) {\n        const {\n          value,\n          done\n        } = await source.next();\n\n        if (done === true) {\n          throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n        }\n\n        readBuffer.append(value);\n      }\n\n      const buf = readBuffer.sublist(0, bytes);\n      readBuffer.consume(bytes);\n      return buf;\n    },\n    readLP: async () => {\n      let dataLength = -1;\n      const lengthBuffer = new Uint8ArrayList();\n      const decodeLength = opts?.lengthDecoder ?? defaultLengthDecoder;\n\n      while (true) {\n        // read one byte at a time until we can decode a varint\n        lengthBuffer.append(await W.read(1));\n\n        try {\n          dataLength = decodeLength(lengthBuffer);\n        } catch (err) {\n          if (err instanceof RangeError) {\n            continue;\n          }\n\n          throw err;\n        }\n\n        if (dataLength > -1) {\n          break;\n        }\n\n        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {\n          throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG');\n        }\n      }\n\n      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {\n        throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG');\n      }\n\n      return await W.read(dataLength);\n    },\n    readPB: async proto => {\n      // readLP, decode\n      const value = await W.readLP();\n\n      if (value == null) {\n        throw new Error('Value is null');\n      } // Is this a buffer?\n\n\n      const buf = value instanceof Uint8Array ? value : value.subarray();\n      return proto.decode(buf);\n    },\n    write: data => {\n      // just write\n      if (data instanceof Uint8Array) {\n        write.push(data);\n      } else {\n        write.push(data.subarray());\n      }\n    },\n    writeLP: data => {\n      // encode, write\n      W.write(lp.encode.single(data, opts));\n    },\n    writePB: (data, proto) => {\n      // encode, writeLP\n      W.writeLP(proto.encode(data));\n    },\n    pb: proto => {\n      return {\n        read: async () => await W.readPB(proto),\n        write: d => {\n          W.writePB(d, proto);\n        },\n        unwrap: () => W\n      };\n    },\n    unwrap: () => {\n      const originalStream = duplex.source;\n\n      duplex.source = async function* () {\n        yield* readBuffer;\n        yield* originalStream;\n      }();\n\n      return duplex;\n    }\n  };\n  return W;\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAO,KAAKA,EAAZ,MAAoB,oBAApB;AAEA,SAASC,cAAT,QAA+B,gBAA/B;AACA,SAASC,QAAT,QAAyB,aAAzB;AACA,SAASC,QAAT,QAAyB,cAAzB;AACA,OAAOC,OAAP,MAAoB,UAApB;;AA6FA,MAAMC,oBAAoB,GAA8BC,GAAD,IAAQ;AAC7D,SAAOH,QAAQ,CAACI,MAAT,CAAgBD,GAAhB,CAAP;AACD,CAFD;;AAGAD,oBAAoB,CAACG,KAArB,GAA6B,CAA7B;AAIA,OAAM,SAAUC,QAAV,CAAoBC,MAApB,EAAyD;AAAA,MAAxBC,IAAwB,uEAAF,EAAE;AAC7D,QAAMC,KAAK,GAAGV,QAAQ,EAAtB;AAEAQ,QAAM,CAACG,IAAP,CAAYD,KAAZ,EAAmBE,KAAnB,CAA0BC,GAAD,IAAe;AACtCH,SAAK,CAACI,GAAN,CAAUD,GAAV;AACD,GAFD;;AAIAL,QAAM,CAACG,IAAP,GAAc,MAAOI,MAAP,IAAsB;AAClC,eAAW,MAAMX,GAAjB,IAAwBW,MAAxB,EAAgC;AAC9BL,WAAK,CAACM,IAAN,CAAWZ,GAAX;AACD;AACF,GAJD;;AAMA,MAAIW,MAAM,GAAGP,MAAM,CAACO,MAApB;;AAEA,MAAIP,MAAM,CAACO,MAAP,CAAcE,MAAM,CAACC,QAArB,KAAkC,IAAtC,EAA4C;AAC1CH,UAAM,GAAGP,MAAM,CAACO,MAAP,CAAcE,MAAM,CAACC,QAArB,GAAT;AACD,GAFD,MAEO,IAAIV,MAAM,CAACO,MAAP,CAAcE,MAAM,CAACE,aAArB,KAAuC,IAA3C,EAAiD;AACtDJ,UAAM,GAAGP,MAAM,CAACO,MAAP,CAAcE,MAAM,CAACE,aAArB,GAAT;AACD;;AAED,QAAMC,UAAU,GAAG,IAAIrB,cAAJ,EAAnB;AAEA,QAAMsB,CAAC,GAAwB;AAC7BC,QAAI,EAAE,MAAOhB,KAAP,IAAgB;AACpB,UAAIA,KAAK,IAAI,IAAb,EAAmB;AACjB;AACA,cAAM;AAAEiB,cAAF;AAAQC;AAAR,YAAkB,MAAMT,MAAM,CAACU,IAAP,EAA9B;;AAEA,YAAIF,IAAI,KAAK,IAAb,EAAmB;AACjB,iBAAO,IAAIxB,cAAJ,EAAP;AACD;;AAED,eAAOyB,KAAP;AACD;;AAED,aAAOJ,UAAU,CAACM,UAAX,GAAwBpB,KAA/B,EAAsC;AACpC,cAAM;AAAEkB,eAAF;AAASD;AAAT,YAAkB,MAAMR,MAAM,CAACU,IAAP,EAA9B;;AAEA,YAAIF,IAAI,KAAK,IAAb,EAAmB;AACjB,gBAAMrB,OAAO,CAAC,IAAIyB,KAAJ,CAAU,yBAAV,CAAD,EAAuC,oBAAvC,CAAb;AACD;;AAEDP,kBAAU,CAACQ,MAAX,CAAkBJ,KAAlB;AACD;;AAED,YAAMpB,GAAG,GAAGgB,UAAU,CAACS,OAAX,CAAmB,CAAnB,EAAsBvB,KAAtB,CAAZ;AACAc,gBAAU,CAACU,OAAX,CAAmBxB,KAAnB;AAEA,aAAOF,GAAP;AACD,KA3B4B;AA4B7B2B,UAAM,EAAE,YAAW;AACjB,UAAIC,UAAU,GAAW,CAAC,CAA1B;AACA,YAAMC,YAAY,GAAG,IAAIlC,cAAJ,EAArB;AACA,YAAMmC,YAAY,GAAGzB,IAAI,EAAE0B,aAAN,IAAuBhC,oBAA5C;;AAEA,aAAO,IAAP,EAAa;AACX;AACA8B,oBAAY,CAACL,MAAb,CAAoB,MAAMP,CAAC,CAACC,IAAF,CAAO,CAAP,CAA1B;;AAEA,YAAI;AACFU,oBAAU,GAAGE,YAAY,CAACD,YAAD,CAAzB;AACD,SAFD,CAEE,OAAOpB,GAAP,EAAY;AACZ,cAAIA,GAAG,YAAYuB,UAAnB,EAA+B;AAC7B;AACD;;AAED,gBAAMvB,GAAN;AACD;;AAED,YAAImB,UAAU,GAAG,CAAC,CAAlB,EAAqB;AACnB;AACD;;AAED,YAAIvB,IAAI,EAAE4B,eAAN,IAAyB,IAAzB,IAAiCJ,YAAY,CAACP,UAAb,GAA0BjB,IAAI,CAAC4B,eAApE,EAAqF;AACnF,gBAAMnC,OAAO,CAAC,IAAIyB,KAAJ,CAAU,gCAAV,CAAD,EAA8C,yBAA9C,CAAb;AACD;AACF;;AAED,UAAIlB,IAAI,EAAE6B,aAAN,IAAuB,IAAvB,IAA+BN,UAAU,GAAGvB,IAAI,CAAC6B,aAArD,EAAoE;AAClE,cAAMpC,OAAO,CAAC,IAAIyB,KAAJ,CAAU,yBAAV,CAAD,EAAuC,uBAAvC,CAAb;AACD;;AAED,aAAO,MAAMN,CAAC,CAACC,IAAF,CAAOU,UAAP,CAAb;AACD,KA7D4B;AA8D7BO,UAAM,EAAE,MAAOC,KAAP,IAAgB;AACtB;AACA,YAAMhB,KAAK,GAAG,MAAMH,CAAC,CAACU,MAAF,EAApB;;AAEA,UAAIP,KAAK,IAAI,IAAb,EAAmB;AACjB,cAAM,IAAIG,KAAJ,CAAU,eAAV,CAAN;AACD,OANqB,CAQtB;;;AACA,YAAMvB,GAAG,GAAGoB,KAAK,YAAYiB,UAAjB,GAA8BjB,KAA9B,GAAsCA,KAAK,CAACkB,QAAN,EAAlD;AAEA,aAAOF,KAAK,CAACnC,MAAN,CAAaD,GAAb,CAAP;AACD,KA1E4B;AA2E7BM,SAAK,EAAGiC,IAAD,IAAS;AACd;AACA,UAAIA,IAAI,YAAYF,UAApB,EAAgC;AAC9B/B,aAAK,CAACM,IAAN,CAAW2B,IAAX;AACD,OAFD,MAEO;AACLjC,aAAK,CAACM,IAAN,CAAW2B,IAAI,CAACD,QAAL,EAAX;AACD;AACF,KAlF4B;AAmF7BE,WAAO,EAAGD,IAAD,IAAS;AAChB;AACAtB,OAAC,CAACX,KAAF,CAAQZ,EAAE,CAAC+C,MAAH,CAAUC,MAAV,CAAiBH,IAAjB,EAAuBlC,IAAvB,CAAR;AACD,KAtF4B;AAuF7BsC,WAAO,EAAE,CAACJ,IAAD,EAAOH,KAAP,KAAgB;AACvB;AACAnB,OAAC,CAACuB,OAAF,CAAUJ,KAAK,CAACK,MAAN,CAAaF,IAAb,CAAV;AACD,KA1F4B;AA2F7BK,MAAE,EAAGR,KAAD,IAAU;AACZ,aAAO;AACLlB,YAAI,EAAE,YAAY,MAAMD,CAAC,CAACkB,MAAF,CAASC,KAAT,CADnB;AAEL9B,aAAK,EAAGuC,CAAD,IAAM;AAAG5B,WAAC,CAAC0B,OAAF,CAAUE,CAAV,EAAaT,KAAb;AAAqB,SAFhC;AAGLU,cAAM,EAAE,MAAM7B;AAHT,OAAP;AAKD,KAjG4B;AAkG7B6B,UAAM,EAAE,MAAK;AACX,YAAMC,cAAc,GAAG3C,MAAM,CAACO,MAA9B;;AACAP,YAAM,CAACO,MAAP,GAAiB,mBAAgB;AAC/B,eAAQK,UAAR;AACA,eAAQ+B,cAAR;AACD,OAHgB,EAAjB;;AAKA,aAAO3C,MAAP;AACD;AA1G4B,GAA/B;AA6GA,SAAOa,CAAP;AACD","names":["lp","Uint8ArrayList","pushable","unsigned","errCode","defaultLengthDecoder","buf","decode","bytes","pbStream","duplex","opts","write","sink","catch","err","end","source","push","Symbol","iterator","asyncIterator","readBuffer","W","read","done","value","next","byteLength","Error","append","sublist","consume","readLP","dataLength","lengthBuffer","decodeLength","lengthDecoder","RangeError","maxLengthLength","maxDataLength","readPB","proto","Uint8Array","subarray","data","writeLP","encode","single","writePB","pb","d","unwrap","originalStream"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-pb-stream\\src\\index.ts"],"sourcesContent":["/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive Protobuf encoded messages over\n * streams.\n *\n * @example\n *\n * ```typescript\n * import { pbStream } from 'it-pb-stream'\n * import { MessageType } from './src/my-message-type.js'\n *\n * // RequestType and ResponseType have been generate from `.proto` files and have\n * // `.encode` and `.decode` methods for serialization/deserialization\n *\n * const stream = pbStream(duplex)\n * stream.writePB({\n *   foo: 'bar'\n * }, MessageType)\n * const res = await stream.readPB(MessageType)\n * ```\n */\n\nimport * as lp from 'it-length-prefixed'\nimport type { Duplex } from 'it-stream-types'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { pushable } from 'it-pushable'\nimport { unsigned } from 'uint8-varint'\nimport errCode from 'err-code'\n\n/**\n * A protobuf decoder - takes a byte array and returns an object\n */\nexport interface Decoder<T> {\n  (data: Uint8Array | Uint8ArrayList): T\n}\n\n/**\n * A protobuf encoder - takes an object and returns a byte array\n */\nexport interface Encoder<T> {\n  (data: T): Uint8Array\n}\n\n/**\n * A message reader/writer that only uses one type of message\n */\nexport interface MessageStream <T, S extends Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array> = Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array>> {\n  /**\n   * Read a message from the stream\n   */\n  read: () => Promise<T>\n\n  /**\n   * Write a message to the stream\n   */\n  write: (d: T) => void\n\n  /**\n   * Unwrap the underlying protobuf stream\n   */\n  unwrap: () => ProtobufStream<S>\n}\n\n/**\n * Convenience methods for working with protobuf streams\n */\nexport interface ProtobufStream <Stream extends Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array> = Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array>> {\n  /**\n   * Read a set number of bytes from the stream\n   */\n  read: (bytes?: number) => Promise<Uint8ArrayList>\n\n  /**\n   * Read the next length-prefixed number of bytes from the stream\n   */\n  readLP: () => Promise<Uint8ArrayList>\n\n  /**\n   * Read the next length-prefixed byte array from the stream and decode it as the passed protobuf format\n   */\n  readPB: <T>(proto: { decode: Decoder<T> }) => Promise<T>\n\n  /**\n   * Write the passed bytes to the stream\n   */\n  write: (input: Uint8Array | Uint8ArrayList) => void\n\n  /**\n   * Write the passed bytes to the stream prefixed by their length\n   */\n  writeLP: (input: Uint8Array | Uint8ArrayList) => void\n\n  /**\n   * Encode the passed object as a protobuf message and write it's length-prefixed bytes tot he stream\n   */\n  writePB: <T>(data: T, proto: { encode: Encoder<T> }) => void\n\n  /**\n   * Returns an object with read/write methods for operating on one specific type of protobuf message\n   */\n  pb: <T> (proto: { encode: Encoder<T>, decode: Decoder<T> }) => MessageStream<T, Stream>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap: () => Stream\n}\n\nexport interface Opts {\n  // encoding opts\n  poolSize: number\n  minPoolSize: number\n  lengthEncoder: lp.LengthEncoderFunction\n\n  // decoding opts\n  lengthDecoder: lp.LengthDecoderFunction\n  maxLengthLength: number\n  maxDataLength: number\n}\n\nconst defaultLengthDecoder: lp.LengthDecoderFunction = (buf) => {\n  return unsigned.decode(buf)\n}\ndefaultLengthDecoder.bytes = 0\n\nexport function pbStream <Stream extends Duplex<Uint8ArrayList, Uint8Array | Uint8ArrayList>> (duplex: Stream, opts?: Partial<Opts>): ProtobufStream<Stream>\nexport function pbStream <Stream extends Duplex<Uint8ArrayList, Uint8Array | Uint8ArrayList>> (duplex: Duplex<Uint8Array>, opts?: Partial<Opts>): ProtobufStream<Stream>\nexport function pbStream (duplex: any, opts: Partial<Opts> = {}): ProtobufStream<any> {\n  const write = pushable()\n\n  duplex.sink(write).catch((err: Error) => {\n    write.end(err)\n  })\n\n  duplex.sink = async (source: any) => {\n    for await (const buf of source) {\n      write.push(buf)\n    }\n  }\n\n  let source = duplex.source\n\n  if (duplex.source[Symbol.iterator] != null) {\n    source = duplex.source[Symbol.iterator]()\n  } else if (duplex.source[Symbol.asyncIterator] != null) {\n    source = duplex.source[Symbol.asyncIterator]()\n  }\n\n  const readBuffer = new Uint8ArrayList()\n\n  const W: ProtobufStream<any> = {\n    read: async (bytes) => {\n      if (bytes == null) {\n        // just read whatever arrives\n        const { done, value } = await source.next()\n\n        if (done === true) {\n          return new Uint8ArrayList()\n        }\n\n        return value\n      }\n\n      while (readBuffer.byteLength < bytes) {\n        const { value, done } = await source.next()\n\n        if (done === true) {\n          throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF')\n        }\n\n        readBuffer.append(value)\n      }\n\n      const buf = readBuffer.sublist(0, bytes)\n      readBuffer.consume(bytes)\n\n      return buf\n    },\n    readLP: async () => {\n      let dataLength: number = -1\n      const lengthBuffer = new Uint8ArrayList()\n      const decodeLength = opts?.lengthDecoder ?? defaultLengthDecoder\n\n      while (true) {\n        // read one byte at a time until we can decode a varint\n        lengthBuffer.append(await W.read(1))\n\n        try {\n          dataLength = decodeLength(lengthBuffer)\n        } catch (err) {\n          if (err instanceof RangeError) {\n            continue\n          }\n\n          throw err\n        }\n\n        if (dataLength > -1) {\n          break\n        }\n\n        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {\n          throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG')\n        }\n      }\n\n      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {\n        throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG')\n      }\n\n      return await W.read(dataLength)\n    },\n    readPB: async (proto) => {\n      // readLP, decode\n      const value = await W.readLP()\n\n      if (value == null) {\n        throw new Error('Value is null')\n      }\n\n      // Is this a buffer?\n      const buf = value instanceof Uint8Array ? value : value.subarray()\n\n      return proto.decode(buf)\n    },\n    write: (data) => {\n      // just write\n      if (data instanceof Uint8Array) {\n        write.push(data)\n      } else {\n        write.push(data.subarray())\n      }\n    },\n    writeLP: (data) => {\n      // encode, write\n      W.write(lp.encode.single(data, opts))\n    },\n    writePB: (data, proto) => {\n      // encode, writeLP\n      W.writeLP(proto.encode(data))\n    },\n    pb: (proto) => {\n      return {\n        read: async () => await W.readPB(proto),\n        write: (d) => { W.writePB(d, proto) },\n        unwrap: () => W\n      }\n    },\n    unwrap: () => {\n      const originalStream = duplex.source\n      duplex.source = (async function * () {\n        yield * readBuffer\n        yield * originalStream\n      }())\n\n      return duplex\n    }\n  }\n\n  return W\n}\n"]},"metadata":{},"sourceType":"module"}