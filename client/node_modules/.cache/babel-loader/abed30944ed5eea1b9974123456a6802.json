{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { codes } from './errors.js';\nimport { peerIdFromPeerId } from '@libp2p/peer-id';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { CustomEvent } from '@libp2p/interfaces/events';\nconst log = logger('libp2p:peer-store:metadata-book');\nconst EVENT_NAME = 'change:metadata';\nexport class PeerStoreMetadataBook {\n  /**\n   * The MetadataBook is responsible for keeping metadata\n   * about known peers\n   */\n  constructor(dispatchEvent, store) {\n    this.dispatchEvent = dispatchEvent;\n    this.store = store;\n  }\n  /**\n   * Get the known data of a provided peer\n   */\n\n\n  async get(peerId) {\n    peerId = peerIdFromPeerId(peerId);\n    log.trace('get await read lock');\n    const release = await this.store.lock.readLock();\n    log.trace('get got read lock');\n\n    try {\n      const peer = await this.store.load(peerId);\n      return peer.metadata;\n    } catch (err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log.trace('get release read lock');\n      release();\n    }\n\n    return new Map();\n  }\n  /**\n   * Get specific metadata value, if it exists\n   */\n\n\n  async getValue(peerId, key) {\n    peerId = peerIdFromPeerId(peerId);\n    log.trace('getValue await read lock');\n    const release = await this.store.lock.readLock();\n    log.trace('getValue got read lock');\n\n    try {\n      const peer = await this.store.load(peerId);\n      return peer.metadata.get(key);\n    } catch (err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log.trace('getValue release write lock');\n      release();\n    }\n  }\n\n  async set(peerId, metadata) {\n    peerId = peerIdFromPeerId(peerId);\n\n    if (!(metadata instanceof Map)) {\n      log.error('valid metadata must be provided to store data');\n      throw new CodeError('valid metadata must be provided', codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log.trace('set await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('set got write lock');\n    let peer;\n\n    try {\n      try {\n        peer = await this.store.load(peerId);\n      } catch (err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      await this.store.mergeOrCreate(peerId, {\n        metadata\n      });\n    } finally {\n      log.trace('set release write lock');\n      release();\n    }\n\n    this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n      detail: {\n        peerId,\n        metadata,\n        oldMetadata: peer == null ? new Map() : peer.metadata\n      }\n    }));\n  }\n  /**\n   * Set metadata key and value of a provided peer\n   */\n\n\n  async setValue(peerId, key, value) {\n    peerId = peerIdFromPeerId(peerId);\n\n    if (typeof key !== 'string' || !(value instanceof Uint8Array)) {\n      log.error('valid key and value must be provided to store data');\n      throw new CodeError('valid key and value must be provided', codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log.trace('setValue await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('setValue got write lock');\n    let peer;\n    let updatedPeer;\n\n    try {\n      try {\n        peer = await this.store.load(peerId);\n        const existingValue = peer.metadata.get(key);\n\n        if (existingValue != null && uint8ArrayEquals(value, existingValue)) {\n          return;\n        }\n      } catch (err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this.store.mergeOrCreate(peerId, {\n        metadata: new Map([[key, value]])\n      });\n    } finally {\n      log.trace('setValue release write lock');\n      release();\n    }\n\n    this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n      detail: {\n        peerId,\n        metadata: updatedPeer.metadata,\n        oldMetadata: peer == null ? new Map() : peer.metadata\n      }\n    }));\n  }\n\n  async delete(peerId) {\n    peerId = peerIdFromPeerId(peerId);\n    log.trace('delete await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('delete got write lock');\n    let peer;\n\n    try {\n      try {\n        peer = await this.store.load(peerId);\n      } catch (err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      if (peer != null) {\n        await this.store.patch(peerId, {\n          metadata: new Map()\n        });\n      }\n    } finally {\n      log.trace('delete release write lock');\n      release();\n    }\n\n    if (peer != null) {\n      this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n        detail: {\n          peerId,\n          metadata: new Map(),\n          oldMetadata: peer.metadata\n        }\n      }));\n    }\n  }\n\n  async deleteValue(peerId, key) {\n    peerId = peerIdFromPeerId(peerId);\n    log.trace('deleteValue await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('deleteValue got write lock');\n    let metadata;\n    let peer;\n\n    try {\n      peer = await this.store.load(peerId);\n      metadata = peer.metadata;\n      metadata.delete(key);\n      await this.store.patch(peerId, {\n        metadata\n      });\n    } catch (err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log.trace('deleteValue release write lock');\n      release();\n    }\n\n    if (metadata != null) {\n      this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n        detail: {\n          peerId,\n          metadata,\n          oldMetadata: peer == null ? new Map() : peer.metadata\n        }\n      }));\n    }\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,QAAuB,gBAAvB;AACA,SAASC,SAAT,QAA0B,2BAA1B;AACA,SAASC,KAAT,QAAsB,aAAtB;AACA,SAASC,gBAAT,QAAiC,iBAAjC;AACA,SAASC,MAAM,IAAIC,gBAAnB,QAA2C,oBAA3C;AACA,SAASC,WAAT,QAA4B,2BAA5B;AAKA,MAAMC,GAAG,GAAGP,MAAM,CAAC,iCAAD,CAAlB;AAEA,MAAMQ,UAAU,GAAG,iBAAnB;AAEA,OAAM,MAAOC,qBAAP,CAA4B;AAIhC;;;;AAIAC,cAAaC,aAAb,EAAwDC,KAAxD,EAAoE;AAClE,SAAKD,aAAL,GAAqBA,aAArB;AACA,SAAKC,KAAL,GAAaA,KAAb;AACD;AAED;;;;;AAGS,QAAHC,GAAG,CAAEC,MAAF,EAAgB;AACvBA,UAAM,GAAGX,gBAAgB,CAACW,MAAD,CAAzB;AAEAP,OAAG,CAACQ,KAAJ,CAAU,qBAAV;AACA,UAAMC,OAAO,GAAG,MAAM,KAAKJ,KAAL,CAAWK,IAAX,CAAgBC,QAAhB,EAAtB;AACAX,OAAG,CAACQ,KAAJ,CAAU,mBAAV;;AAEA,QAAI;AACF,YAAMI,IAAI,GAAG,MAAM,KAAKP,KAAL,CAAWQ,IAAX,CAAgBN,MAAhB,CAAnB;AAEA,aAAOK,IAAI,CAACE,QAAZ;AACD,KAJD,CAIE,OAAOC,GAAP,EAAiB;AACjB,UAAIA,GAAG,CAACC,IAAJ,KAAarB,KAAK,CAACsB,aAAvB,EAAsC;AACpC,cAAMF,GAAN;AACD;AACF,KARD,SAQU;AACRf,SAAG,CAACQ,KAAJ,CAAU,uBAAV;AACAC,aAAO;AACR;;AAED,WAAO,IAAIS,GAAJ,EAAP;AACD;AAED;;;;;AAGc,QAARC,QAAQ,CAAEZ,MAAF,EAAkBa,GAAlB,EAA6B;AACzCb,UAAM,GAAGX,gBAAgB,CAACW,MAAD,CAAzB;AAEAP,OAAG,CAACQ,KAAJ,CAAU,0BAAV;AACA,UAAMC,OAAO,GAAG,MAAM,KAAKJ,KAAL,CAAWK,IAAX,CAAgBC,QAAhB,EAAtB;AACAX,OAAG,CAACQ,KAAJ,CAAU,wBAAV;;AAEA,QAAI;AACF,YAAMI,IAAI,GAAG,MAAM,KAAKP,KAAL,CAAWQ,IAAX,CAAgBN,MAAhB,CAAnB;AAEA,aAAOK,IAAI,CAACE,QAAL,CAAcR,GAAd,CAAkBc,GAAlB,CAAP;AACD,KAJD,CAIE,OAAOL,GAAP,EAAiB;AACjB,UAAIA,GAAG,CAACC,IAAJ,KAAarB,KAAK,CAACsB,aAAvB,EAAsC;AACpC,cAAMF,GAAN;AACD;AACF,KARD,SAQU;AACRf,SAAG,CAACQ,KAAJ,CAAU,6BAAV;AACAC,aAAO;AACR;AACF;;AAEQ,QAAHY,GAAG,CAAEd,MAAF,EAAkBO,QAAlB,EAAmD;AAC1DP,UAAM,GAAGX,gBAAgB,CAACW,MAAD,CAAzB;;AAEA,QAAI,EAAEO,QAAQ,YAAYI,GAAtB,CAAJ,EAAgC;AAC9BlB,SAAG,CAACsB,KAAJ,CAAU,+CAAV;AACA,YAAM,IAAI5B,SAAJ,CAAc,iCAAd,EAAiDC,KAAK,CAAC4B,sBAAvD,CAAN;AACD;;AAEDvB,OAAG,CAACQ,KAAJ,CAAU,sBAAV;AACA,UAAMC,OAAO,GAAG,MAAM,KAAKJ,KAAL,CAAWK,IAAX,CAAgBc,SAAhB,EAAtB;AACAxB,OAAG,CAACQ,KAAJ,CAAU,oBAAV;AAEA,QAAII,IAAJ;;AAEA,QAAI;AACF,UAAI;AACFA,YAAI,GAAG,MAAM,KAAKP,KAAL,CAAWQ,IAAX,CAAgBN,MAAhB,CAAb;AACD,OAFD,CAEE,OAAOQ,GAAP,EAAiB;AACjB,YAAIA,GAAG,CAACC,IAAJ,KAAarB,KAAK,CAACsB,aAAvB,EAAsC;AACpC,gBAAMF,GAAN;AACD;AACF;;AAED,YAAM,KAAKV,KAAL,CAAWoB,aAAX,CAAyBlB,MAAzB,EAAiC;AACrCO;AADqC,OAAjC,CAAN;AAGD,KAZD,SAYU;AACRd,SAAG,CAACQ,KAAJ,CAAU,wBAAV;AACAC,aAAO;AACR;;AAED,SAAKL,aAAL,CAAmB,IAAIL,WAAJ,CAAwCE,UAAxC,EAAoD;AACrEyB,YAAM,EAAE;AACNnB,cADM;AAENO,gBAFM;AAGNa,mBAAW,EAAEf,IAAI,IAAI,IAAR,GAAe,IAAIM,GAAJ,EAAf,GAA2BN,IAAI,CAACE;AAHvC;AAD6D,KAApD,CAAnB;AAOD;AAED;;;;;AAGc,QAARc,QAAQ,CAAErB,MAAF,EAAkBa,GAAlB,EAA+BS,KAA/B,EAAgD;AAC5DtB,UAAM,GAAGX,gBAAgB,CAACW,MAAD,CAAzB;;AAEA,QAAI,OAAOa,GAAP,KAAe,QAAf,IAA2B,EAAES,KAAK,YAAYC,UAAnB,CAA/B,EAA+D;AAC7D9B,SAAG,CAACsB,KAAJ,CAAU,oDAAV;AACA,YAAM,IAAI5B,SAAJ,CAAc,sCAAd,EAAsDC,KAAK,CAAC4B,sBAA5D,CAAN;AACD;;AAEDvB,OAAG,CAACQ,KAAJ,CAAU,2BAAV;AACA,UAAMC,OAAO,GAAG,MAAM,KAAKJ,KAAL,CAAWK,IAAX,CAAgBc,SAAhB,EAAtB;AACAxB,OAAG,CAACQ,KAAJ,CAAU,yBAAV;AAEA,QAAII,IAAJ;AACA,QAAImB,WAAJ;;AAEA,QAAI;AACF,UAAI;AACFnB,YAAI,GAAG,MAAM,KAAKP,KAAL,CAAWQ,IAAX,CAAgBN,MAAhB,CAAb;AACA,cAAMyB,aAAa,GAAGpB,IAAI,CAACE,QAAL,CAAcR,GAAd,CAAkBc,GAAlB,CAAtB;;AAEA,YAAIY,aAAa,IAAI,IAAjB,IAAyBlC,gBAAgB,CAAC+B,KAAD,EAAQG,aAAR,CAA7C,EAAqE;AACnE;AACD;AACF,OAPD,CAOE,OAAOjB,GAAP,EAAiB;AACjB,YAAIA,GAAG,CAACC,IAAJ,KAAarB,KAAK,CAACsB,aAAvB,EAAsC;AACpC,gBAAMF,GAAN;AACD;AACF;;AAEDgB,iBAAW,GAAG,MAAM,KAAK1B,KAAL,CAAWoB,aAAX,CAAyBlB,MAAzB,EAAiC;AACnDO,gBAAQ,EAAE,IAAII,GAAJ,CAAQ,CAAC,CAACE,GAAD,EAAMS,KAAN,CAAD,CAAR;AADyC,OAAjC,CAApB;AAGD,KAjBD,SAiBU;AACR7B,SAAG,CAACQ,KAAJ,CAAU,6BAAV;AACAC,aAAO;AACR;;AAED,SAAKL,aAAL,CAAmB,IAAIL,WAAJ,CAAwCE,UAAxC,EAAoD;AACrEyB,YAAM,EAAE;AACNnB,cADM;AAENO,gBAAQ,EAAEiB,WAAW,CAACjB,QAFhB;AAGNa,mBAAW,EAAEf,IAAI,IAAI,IAAR,GAAe,IAAIM,GAAJ,EAAf,GAA2BN,IAAI,CAACE;AAHvC;AAD6D,KAApD,CAAnB;AAOD;;AAEW,QAANmB,MAAM,CAAE1B,MAAF,EAAgB;AAC1BA,UAAM,GAAGX,gBAAgB,CAACW,MAAD,CAAzB;AAEAP,OAAG,CAACQ,KAAJ,CAAU,yBAAV;AACA,UAAMC,OAAO,GAAG,MAAM,KAAKJ,KAAL,CAAWK,IAAX,CAAgBc,SAAhB,EAAtB;AACAxB,OAAG,CAACQ,KAAJ,CAAU,uBAAV;AAEA,QAAII,IAAJ;;AAEA,QAAI;AACF,UAAI;AACFA,YAAI,GAAG,MAAM,KAAKP,KAAL,CAAWQ,IAAX,CAAgBN,MAAhB,CAAb;AACD,OAFD,CAEE,OAAOQ,GAAP,EAAiB;AACjB,YAAIA,GAAG,CAACC,IAAJ,KAAarB,KAAK,CAACsB,aAAvB,EAAsC;AACpC,gBAAMF,GAAN;AACD;AACF;;AAED,UAAIH,IAAI,IAAI,IAAZ,EAAkB;AAChB,cAAM,KAAKP,KAAL,CAAW6B,KAAX,CAAiB3B,MAAjB,EAAyB;AAC7BO,kBAAQ,EAAE,IAAII,GAAJ;AADmB,SAAzB,CAAN;AAGD;AACF,KAdD,SAcU;AACRlB,SAAG,CAACQ,KAAJ,CAAU,2BAAV;AACAC,aAAO;AACR;;AAED,QAAIG,IAAI,IAAI,IAAZ,EAAkB;AAChB,WAAKR,aAAL,CAAmB,IAAIL,WAAJ,CAAwCE,UAAxC,EAAoD;AACrEyB,cAAM,EAAE;AACNnB,gBADM;AAENO,kBAAQ,EAAE,IAAII,GAAJ,EAFJ;AAGNS,qBAAW,EAAEf,IAAI,CAACE;AAHZ;AAD6D,OAApD,CAAnB;AAOD;AACF;;AAEgB,QAAXqB,WAAW,CAAE5B,MAAF,EAAkBa,GAAlB,EAA6B;AAC5Cb,UAAM,GAAGX,gBAAgB,CAACW,MAAD,CAAzB;AAEAP,OAAG,CAACQ,KAAJ,CAAU,8BAAV;AACA,UAAMC,OAAO,GAAG,MAAM,KAAKJ,KAAL,CAAWK,IAAX,CAAgBc,SAAhB,EAAtB;AACAxB,OAAG,CAACQ,KAAJ,CAAU,4BAAV;AAEA,QAAIM,QAAJ;AACA,QAAIF,IAAJ;;AAEA,QAAI;AACFA,UAAI,GAAG,MAAM,KAAKP,KAAL,CAAWQ,IAAX,CAAgBN,MAAhB,CAAb;AACAO,cAAQ,GAAGF,IAAI,CAACE,QAAhB;AAEAA,cAAQ,CAACmB,MAAT,CAAgBb,GAAhB;AAEA,YAAM,KAAKf,KAAL,CAAW6B,KAAX,CAAiB3B,MAAjB,EAAyB;AAC7BO;AAD6B,OAAzB,CAAN;AAGD,KATD,CASE,OAAOC,GAAP,EAAiB;AACjB,UAAIA,GAAG,CAACC,IAAJ,KAAarB,KAAK,CAACsB,aAAvB,EAAsC;AACpC,cAAMF,GAAN;AACD;AACF,KAbD,SAaU;AACRf,SAAG,CAACQ,KAAJ,CAAU,gCAAV;AACAC,aAAO;AACR;;AAED,QAAIK,QAAQ,IAAI,IAAhB,EAAsB;AACpB,WAAKV,aAAL,CAAmB,IAAIL,WAAJ,CAAwCE,UAAxC,EAAoD;AACrEyB,cAAM,EAAE;AACNnB,gBADM;AAENO,kBAFM;AAGNa,qBAAW,EAAEf,IAAI,IAAI,IAAR,GAAe,IAAIM,GAAJ,EAAf,GAA2BN,IAAI,CAACE;AAHvC;AAD6D,OAApD,CAAnB;AAOD;AACF;;AApO+B","names":["logger","CodeError","codes","peerIdFromPeerId","equals","uint8ArrayEquals","CustomEvent","log","EVENT_NAME","PeerStoreMetadataBook","constructor","dispatchEvent","store","get","peerId","trace","release","lock","readLock","peer","load","metadata","err","code","ERR_NOT_FOUND","Map","getValue","key","set","error","ERR_INVALID_PARAMETERS","writeLock","mergeOrCreate","detail","oldMetadata","setValue","value","Uint8Array","updatedPeer","existingValue","delete","patch","deleteValue"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\peer-store\\src\\metadata-book.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { codes } from './errors.js'\nimport { peerIdFromPeerId } from '@libp2p/peer-id'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { CustomEvent } from '@libp2p/interfaces/events'\nimport type { Store } from './store.js'\nimport type { PeerStore, MetadataBook, PeerMetadataChangeData, Peer } from '@libp2p/interface-peer-store'\nimport type { PeerId } from '@libp2p/interface-peer-id'\n\nconst log = logger('libp2p:peer-store:metadata-book')\n\nconst EVENT_NAME = 'change:metadata'\n\nexport class PeerStoreMetadataBook implements MetadataBook {\n  private readonly dispatchEvent: PeerStore['dispatchEvent']\n  private readonly store: Store\n\n  /**\n   * The MetadataBook is responsible for keeping metadata\n   * about known peers\n   */\n  constructor (dispatchEvent: PeerStore['dispatchEvent'], store: Store) {\n    this.dispatchEvent = dispatchEvent\n    this.store = store\n  }\n\n  /**\n   * Get the known data of a provided peer\n   */\n  async get (peerId: PeerId): Promise<Map<string, Uint8Array>> {\n    peerId = peerIdFromPeerId(peerId)\n\n    log.trace('get await read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('get got read lock')\n\n    try {\n      const peer = await this.store.load(peerId)\n\n      return peer.metadata\n    } catch (err: any) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log.trace('get release read lock')\n      release()\n    }\n\n    return new Map()\n  }\n\n  /**\n   * Get specific metadata value, if it exists\n   */\n  async getValue (peerId: PeerId, key: string): Promise<Uint8Array | undefined> {\n    peerId = peerIdFromPeerId(peerId)\n\n    log.trace('getValue await read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('getValue got read lock')\n\n    try {\n      const peer = await this.store.load(peerId)\n\n      return peer.metadata.get(key)\n    } catch (err: any) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log.trace('getValue release write lock')\n      release()\n    }\n  }\n\n  async set (peerId: PeerId, metadata: Map<string, Uint8Array>): Promise<void> {\n    peerId = peerIdFromPeerId(peerId)\n\n    if (!(metadata instanceof Map)) {\n      log.error('valid metadata must be provided to store data')\n      throw new CodeError('valid metadata must be provided', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log.trace('set await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('set got write lock')\n\n    let peer: Peer | undefined\n\n    try {\n      try {\n        peer = await this.store.load(peerId)\n      } catch (err: any) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      await this.store.mergeOrCreate(peerId, {\n        metadata\n      })\n    } finally {\n      log.trace('set release write lock')\n      release()\n    }\n\n    this.dispatchEvent(new CustomEvent<PeerMetadataChangeData>(EVENT_NAME, {\n      detail: {\n        peerId,\n        metadata,\n        oldMetadata: peer == null ? new Map() : peer.metadata\n      }\n    }))\n  }\n\n  /**\n   * Set metadata key and value of a provided peer\n   */\n  async setValue (peerId: PeerId, key: string, value: Uint8Array): Promise<void> {\n    peerId = peerIdFromPeerId(peerId)\n\n    if (typeof key !== 'string' || !(value instanceof Uint8Array)) {\n      log.error('valid key and value must be provided to store data')\n      throw new CodeError('valid key and value must be provided', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log.trace('setValue await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('setValue got write lock')\n\n    let peer: Peer | undefined\n    let updatedPeer\n\n    try {\n      try {\n        peer = await this.store.load(peerId)\n        const existingValue = peer.metadata.get(key)\n\n        if (existingValue != null && uint8ArrayEquals(value, existingValue)) {\n          return\n        }\n      } catch (err: any) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this.store.mergeOrCreate(peerId, {\n        metadata: new Map([[key, value]])\n      })\n    } finally {\n      log.trace('setValue release write lock')\n      release()\n    }\n\n    this.dispatchEvent(new CustomEvent<PeerMetadataChangeData>(EVENT_NAME, {\n      detail: {\n        peerId,\n        metadata: updatedPeer.metadata,\n        oldMetadata: peer == null ? new Map() : peer.metadata\n      }\n    }))\n  }\n\n  async delete (peerId: PeerId): Promise<void> {\n    peerId = peerIdFromPeerId(peerId)\n\n    log.trace('delete await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('delete got write lock')\n\n    let peer: Peer | undefined\n\n    try {\n      try {\n        peer = await this.store.load(peerId)\n      } catch (err: any) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      if (peer != null) {\n        await this.store.patch(peerId, {\n          metadata: new Map()\n        })\n      }\n    } finally {\n      log.trace('delete release write lock')\n      release()\n    }\n\n    if (peer != null) {\n      this.dispatchEvent(new CustomEvent<PeerMetadataChangeData>(EVENT_NAME, {\n        detail: {\n          peerId,\n          metadata: new Map(),\n          oldMetadata: peer.metadata\n        }\n      }))\n    }\n  }\n\n  async deleteValue (peerId: PeerId, key: string): Promise<void> {\n    peerId = peerIdFromPeerId(peerId)\n\n    log.trace('deleteValue await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('deleteValue got write lock')\n\n    let metadata\n    let peer: Peer | undefined\n\n    try {\n      peer = await this.store.load(peerId)\n      metadata = peer.metadata\n\n      metadata.delete(key)\n\n      await this.store.patch(peerId, {\n        metadata\n      })\n    } catch (err: any) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log.trace('deleteValue release write lock')\n      release()\n    }\n\n    if (metadata != null) {\n      this.dispatchEvent(new CustomEvent<PeerMetadataChangeData>(EVENT_NAME, {\n        detail: {\n          peerId,\n          metadata,\n          oldMetadata: peer == null ? new Map() : peer.metadata\n        }\n      }))\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}