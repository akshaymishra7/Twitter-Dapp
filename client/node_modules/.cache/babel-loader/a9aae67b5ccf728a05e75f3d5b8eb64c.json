{"ast":null,"code":"const RateLimiterAbstract = require('./RateLimiterAbstract');\n\nconst MemoryStorage = require('./component/MemoryStorage/MemoryStorage');\n\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterMemory extends RateLimiterAbstract {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(opts);\n    this._memoryStorage = new MemoryStorage();\n  }\n  /**\n   *\n   * @param key\n   * @param pointsToConsume\n   * @param {Object} options\n   * @returns {Promise<RateLimiterRes>}\n   */\n\n\n  consume(key) {\n    let pointsToConsume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new Promise((resolve, reject) => {\n      const rlKey = this.getKey(key);\n\n      const secDuration = this._getKeySecDuration(options);\n\n      let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);\n\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n\n      if (res.consumedPoints > this.points) {\n        // Block only first time when consumed more than points\n        if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {\n          // Block key\n          res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);\n        }\n\n        reject(res);\n      } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n        // Execute evenly\n        let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n\n        if (delay < this.execEvenlyMinDelayMs) {\n          delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n        }\n\n        setTimeout(resolve, delay, res);\n      } else {\n        resolve(res);\n      }\n    });\n  }\n\n  penalty(key) {\n    let points = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const rlKey = this.getKey(key);\n    return new Promise(resolve => {\n      const secDuration = this._getKeySecDuration(options);\n\n      const res = this._memoryStorage.incrby(rlKey, points, secDuration);\n\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      resolve(res);\n    });\n  }\n\n  reward(key) {\n    let points = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const rlKey = this.getKey(key);\n    return new Promise(resolve => {\n      const secDuration = this._getKeySecDuration(options);\n\n      const res = this._memoryStorage.incrby(rlKey, -points, secDuration);\n\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      resolve(res);\n    });\n  }\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   */\n\n\n  block(key, secDuration) {\n    const msDuration = secDuration * 1000;\n    const initPoints = this.points + 1;\n\n    this._memoryStorage.set(this.getKey(key), initPoints, secDuration);\n\n    return Promise.resolve(new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, initPoints));\n  }\n\n  set(key, points, secDuration) {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n\n    this._memoryStorage.set(this.getKey(key), points, secDuration);\n\n    return Promise.resolve(new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, points));\n  }\n\n  get(key) {\n    const res = this._memoryStorage.get(this.getKey(key));\n\n    if (res !== null) {\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    }\n\n    return Promise.resolve(res);\n  }\n\n  delete(key) {\n    return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));\n  }\n\n}\n\nmodule.exports = RateLimiterMemory;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/rate-limiter-flexible/lib/RateLimiterMemory.js"],"names":["RateLimiterAbstract","require","MemoryStorage","RateLimiterRes","RateLimiterMemory","constructor","opts","_memoryStorage","consume","key","pointsToConsume","options","Promise","resolve","reject","rlKey","getKey","secDuration","_getKeySecDuration","res","incrby","remainingPoints","Math","max","points","consumedPoints","blockDuration","set","execEvenly","msBeforeNext","isFirstInDuration","delay","ceil","execEvenlyMinDelayMs","setTimeout","penalty","reward","block","msDuration","initPoints","duration","get","delete","module","exports"],"mappings":"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","sourcesContent":["const RateLimiterAbstract = require('./RateLimiterAbstract');\nconst MemoryStorage = require('./component/MemoryStorage/MemoryStorage');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterMemory extends RateLimiterAbstract {\n  constructor(opts = {}) {\n    super(opts);\n\n    this._memoryStorage = new MemoryStorage();\n  }\n  /**\n   *\n   * @param key\n   * @param pointsToConsume\n   * @param {Object} options\n   * @returns {Promise<RateLimiterRes>}\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const rlKey = this.getKey(key);\n      const secDuration = this._getKeySecDuration(options);\n      let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n\n      if (res.consumedPoints > this.points) {\n        // Block only first time when consumed more than points\n        if (this.blockDuration > 0 && res.consumedPoints <= (this.points + pointsToConsume)) {\n          // Block key\n          res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);\n        }\n        reject(res);\n      } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n        // Execute evenly\n        let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n        if (delay < this.execEvenlyMinDelayMs) {\n          delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n        }\n\n        setTimeout(resolve, delay, res);\n      } else {\n        resolve(res);\n      }\n    });\n  }\n\n  penalty(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve) => {\n      const secDuration = this._getKeySecDuration(options);\n      const res = this._memoryStorage.incrby(rlKey, points, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      resolve(res);\n    });\n  }\n\n  reward(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve) => {\n      const secDuration = this._getKeySecDuration(options);\n      const res = this._memoryStorage.incrby(rlKey, -points, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      resolve(res);\n    });\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   */\n  block(key, secDuration) {\n    const msDuration = secDuration * 1000;\n    const initPoints = this.points + 1;\n\n    this._memoryStorage.set(this.getKey(key), initPoints, secDuration);\n    return Promise.resolve(\n      new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, initPoints)\n    );\n  }\n\n  set(key, points, secDuration) {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n\n    this._memoryStorage.set(this.getKey(key), points, secDuration);\n    return Promise.resolve(\n      new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, points)\n    );\n  }\n\n  get(key) {\n    const res = this._memoryStorage.get(this.getKey(key));\n    if (res !== null) {\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    }\n\n    return Promise.resolve(res);\n  }\n\n  delete(key) {\n    return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));\n  }\n}\n\nmodule.exports = RateLimiterMemory;\n\n"]},"metadata":{},"sourceType":"script"}