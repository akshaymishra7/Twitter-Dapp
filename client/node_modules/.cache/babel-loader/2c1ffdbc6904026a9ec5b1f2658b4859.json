{"ast":null,"code":"const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\n\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterMemcache extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: memcacheClient\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n    this.client = opts.storeClient;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    res.consumedPoints = parseInt(result.consumedPoints);\n    res.isFirstInDuration = result.consumedPoints === changedPoints;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = result.msBeforeNext;\n    return res;\n  }\n\n  _upsert(rlKey, points, msDuration) {\n    let forceExpire = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    return new Promise((resolve, reject) => {\n      const nowMs = Date.now();\n      const secDuration = Math.floor(msDuration / 1000);\n\n      if (forceExpire) {\n        this.client.set(rlKey, points, secDuration, err => {\n          if (!err) {\n            this.client.set(`${rlKey}_expire`, secDuration > 0 ? nowMs + secDuration * 1000 : -1, secDuration, () => {\n              const res = {\n                consumedPoints: points,\n                msBeforeNext: secDuration > 0 ? secDuration * 1000 : -1\n              };\n              resolve(res);\n            });\n          } else {\n            reject(err);\n          }\n        });\n      } else {\n        this.client.incr(rlKey, points, (err, consumedPoints) => {\n          if (err || consumedPoints === false) {\n            this.client.add(rlKey, points, secDuration, (errAddKey, createdNew) => {\n              if (errAddKey || !createdNew) {\n                // Try to upsert again in case of race condition\n                if (typeof options.attemptNumber === 'undefined' || options.attemptNumber < 3) {\n                  const nextOptions = Object.assign({}, options);\n                  nextOptions.attemptNumber = nextOptions.attemptNumber ? nextOptions.attemptNumber + 1 : 1;\n\n                  this._upsert(rlKey, points, msDuration, forceExpire, nextOptions).then(resUpsert => resolve(resUpsert)).catch(errUpsert => reject(errUpsert));\n                } else {\n                  reject(new Error('Can not add key'));\n                }\n              } else {\n                this.client.add(`${rlKey}_expire`, secDuration > 0 ? nowMs + secDuration * 1000 : -1, secDuration, () => {\n                  const res = {\n                    consumedPoints: points,\n                    msBeforeNext: secDuration > 0 ? secDuration * 1000 : -1\n                  };\n                  resolve(res);\n                });\n              }\n            });\n          } else {\n            this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {\n              if (errGetExpire) {\n                reject(errGetExpire);\n              } else {\n                const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;\n                const res = {\n                  consumedPoints,\n                  msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1\n                };\n                resolve(res);\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n\n  _get(rlKey) {\n    return new Promise((resolve, reject) => {\n      const nowMs = Date.now();\n      this.client.get(rlKey, (err, consumedPoints) => {\n        if (!consumedPoints) {\n          resolve(null);\n        } else {\n          this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {\n            if (errGetExpire) {\n              reject(errGetExpire);\n            } else {\n              const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;\n              const res = {\n                consumedPoints,\n                msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1\n              };\n              resolve(res);\n            }\n          });\n        }\n      });\n    });\n  }\n\n  _delete(rlKey) {\n    return new Promise((resolve, reject) => {\n      this.client.del(rlKey, (err, res) => {\n        if (err) {\n          reject(err);\n        } else if (res === false) {\n          resolve(res);\n        } else {\n          this.client.del(`${rlKey}_expire`, errDelExpire => {\n            if (errDelExpire) {\n              reject(errDelExpire);\n            } else {\n              resolve(res);\n            }\n          });\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = RateLimiterMemcache;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/rate-limiter-flexible/lib/RateLimiterMemcache.js"],"names":["RateLimiterStoreAbstract","require","RateLimiterRes","RateLimiterMemcache","constructor","opts","client","storeClient","_getRateLimiterRes","rlKey","changedPoints","result","res","consumedPoints","parseInt","isFirstInDuration","remainingPoints","Math","max","points","msBeforeNext","_upsert","msDuration","forceExpire","options","Promise","resolve","reject","nowMs","Date","now","secDuration","floor","set","err","incr","add","errAddKey","createdNew","attemptNumber","nextOptions","Object","assign","then","resUpsert","catch","errUpsert","Error","get","errGetExpire","resGetExpireMs","expireMs","_get","_delete","del","errDelExpire","module","exports"],"mappings":"AAAA,MAAMA,wBAAwB,GAAGC,OAAO,CAAC,4BAAD,CAAxC;;AACA,MAAMC,cAAc,GAAGD,OAAO,CAAC,kBAAD,CAA9B;;AAEA,MAAME,mBAAN,SAAkCH,wBAAlC,CAA2D;AACzD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEI,EAAAA,WAAW,CAACC,IAAD,EAAO;AAChB,UAAMA,IAAN;AAEA,SAAKC,MAAL,GAAcD,IAAI,CAACE,WAAnB;AACD;;AAEDC,EAAAA,kBAAkB,CAACC,KAAD,EAAQC,aAAR,EAAuBC,MAAvB,EAA+B;AAC/C,UAAMC,GAAG,GAAG,IAAIV,cAAJ,EAAZ;AACAU,IAAAA,GAAG,CAACC,cAAJ,GAAqBC,QAAQ,CAACH,MAAM,CAACE,cAAR,CAA7B;AACAD,IAAAA,GAAG,CAACG,iBAAJ,GAAwBJ,MAAM,CAACE,cAAP,KAA0BH,aAAlD;AACAE,IAAAA,GAAG,CAACI,eAAJ,GAAsBC,IAAI,CAACC,GAAL,CAAS,KAAKC,MAAL,GAAcP,GAAG,CAACC,cAA3B,EAA2C,CAA3C,CAAtB;AACAD,IAAAA,GAAG,CAACQ,YAAJ,GAAmBT,MAAM,CAACS,YAA1B;AAEA,WAAOR,GAAP;AACD;;AAEDS,EAAAA,OAAO,CAACZ,KAAD,EAAQU,MAAR,EAAgBG,UAAhB,EAA+D;AAAA,QAAnCC,WAAmC,uEAArB,KAAqB;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AACpE,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,YAAMC,KAAK,GAAGC,IAAI,CAACC,GAAL,EAAd;AACA,YAAMC,WAAW,GAAGd,IAAI,CAACe,KAAL,CAAWV,UAAU,GAAG,IAAxB,CAApB;;AAEA,UAAIC,WAAJ,EAAiB;AACf,aAAKjB,MAAL,CAAY2B,GAAZ,CAAgBxB,KAAhB,EAAuBU,MAAvB,EAA+BY,WAA/B,EAA6CG,GAAD,IAAS;AACnD,cAAI,CAACA,GAAL,EAAU;AACR,iBAAK5B,MAAL,CAAY2B,GAAZ,CACG,GAAExB,KAAM,SADX,EAEEsB,WAAW,GAAG,CAAd,GAAkBH,KAAK,GAAIG,WAAW,GAAG,IAAzC,GAAiD,CAAC,CAFpD,EAGEA,WAHF,EAIE,MAAM;AACJ,oBAAMnB,GAAG,GAAG;AACVC,gBAAAA,cAAc,EAAEM,MADN;AAEVC,gBAAAA,YAAY,EAAEW,WAAW,GAAG,CAAd,GAAkBA,WAAW,GAAG,IAAhC,GAAuC,CAAC;AAF5C,eAAZ;AAIAL,cAAAA,OAAO,CAACd,GAAD,CAAP;AACD,aAVH;AAYD,WAbD,MAaO;AACLe,YAAAA,MAAM,CAACO,GAAD,CAAN;AACD;AACF,SAjBD;AAkBD,OAnBD,MAmBO;AACL,aAAK5B,MAAL,CAAY6B,IAAZ,CAAiB1B,KAAjB,EAAwBU,MAAxB,EAAgC,CAACe,GAAD,EAAMrB,cAAN,KAAyB;AACvD,cAAIqB,GAAG,IAAIrB,cAAc,KAAK,KAA9B,EAAqC;AACnC,iBAAKP,MAAL,CAAY8B,GAAZ,CAAgB3B,KAAhB,EAAuBU,MAAvB,EAA+BY,WAA/B,EAA4C,CAACM,SAAD,EAAYC,UAAZ,KAA2B;AACrE,kBAAID,SAAS,IAAI,CAACC,UAAlB,EAA8B;AAC5B;AACA,oBAAI,OAAOd,OAAO,CAACe,aAAf,KAAiC,WAAjC,IAAgDf,OAAO,CAACe,aAAR,GAAwB,CAA5E,EAA+E;AAC7E,wBAAMC,WAAW,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBlB,OAAlB,CAApB;AACAgB,kBAAAA,WAAW,CAACD,aAAZ,GAA4BC,WAAW,CAACD,aAAZ,GAA6BC,WAAW,CAACD,aAAZ,GAA4B,CAAzD,GAA8D,CAA1F;;AAEA,uBAAKlB,OAAL,CAAaZ,KAAb,EAAoBU,MAApB,EAA4BG,UAA5B,EAAwCC,WAAxC,EAAqDiB,WAArD,EACGG,IADH,CACQC,SAAS,IAAIlB,OAAO,CAACkB,SAAD,CAD5B,EAEGC,KAFH,CAESC,SAAS,IAAInB,MAAM,CAACmB,SAAD,CAF5B;AAGD,iBAPD,MAOO;AACLnB,kBAAAA,MAAM,CAAC,IAAIoB,KAAJ,CAAU,iBAAV,CAAD,CAAN;AACD;AACF,eAZD,MAYO;AACL,qBAAKzC,MAAL,CAAY8B,GAAZ,CACG,GAAE3B,KAAM,SADX,EAEEsB,WAAW,GAAG,CAAd,GAAkBH,KAAK,GAAIG,WAAW,GAAG,IAAzC,GAAiD,CAAC,CAFpD,EAGEA,WAHF,EAIE,MAAM;AACJ,wBAAMnB,GAAG,GAAG;AACVC,oBAAAA,cAAc,EAAEM,MADN;AAEVC,oBAAAA,YAAY,EAAEW,WAAW,GAAG,CAAd,GAAkBA,WAAW,GAAG,IAAhC,GAAuC,CAAC;AAF5C,mBAAZ;AAIAL,kBAAAA,OAAO,CAACd,GAAD,CAAP;AACD,iBAVH;AAYD;AACF,aA3BD;AA4BD,WA7BD,MA6BO;AACL,iBAAKN,MAAL,CAAY0C,GAAZ,CAAiB,GAAEvC,KAAM,SAAzB,EAAmC,CAACwC,YAAD,EAAeC,cAAf,KAAkC;AACnE,kBAAID,YAAJ,EAAkB;AAChBtB,gBAAAA,MAAM,CAACsB,YAAD,CAAN;AACD,eAFD,MAEO;AACL,sBAAME,QAAQ,GAAGD,cAAc,KAAK,KAAnB,GAA2B,CAA3B,GAA+BA,cAAhD;AACA,sBAAMtC,GAAG,GAAG;AACVC,kBAAAA,cADU;AAEVO,kBAAAA,YAAY,EAAE+B,QAAQ,IAAI,CAAZ,GAAgBlC,IAAI,CAACC,GAAL,CAASiC,QAAQ,GAAGvB,KAApB,EAA2B,CAA3B,CAAhB,GAAgD,CAAC;AAFrD,iBAAZ;AAIAF,gBAAAA,OAAO,CAACd,GAAD,CAAP;AACD;AACF,aAXD;AAYD;AACF,SA5CD;AA6CD;AACF,KAtEM,CAAP;AAuED;;AAEDwC,EAAAA,IAAI,CAAC3C,KAAD,EAAQ;AACV,WAAO,IAAIgB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,YAAMC,KAAK,GAAGC,IAAI,CAACC,GAAL,EAAd;AAEA,WAAKxB,MAAL,CAAY0C,GAAZ,CAAgBvC,KAAhB,EAAuB,CAACyB,GAAD,EAAMrB,cAAN,KAAyB;AAC9C,YAAI,CAACA,cAAL,EAAqB;AACnBa,UAAAA,OAAO,CAAC,IAAD,CAAP;AACD,SAFD,MAEO;AACL,eAAKpB,MAAL,CAAY0C,GAAZ,CAAiB,GAAEvC,KAAM,SAAzB,EAAmC,CAACwC,YAAD,EAAeC,cAAf,KAAkC;AACnE,gBAAID,YAAJ,EAAkB;AAChBtB,cAAAA,MAAM,CAACsB,YAAD,CAAN;AACD,aAFD,MAEO;AACL,oBAAME,QAAQ,GAAGD,cAAc,KAAK,KAAnB,GAA2B,CAA3B,GAA+BA,cAAhD;AACA,oBAAMtC,GAAG,GAAG;AACVC,gBAAAA,cADU;AAEVO,gBAAAA,YAAY,EAAE+B,QAAQ,IAAI,CAAZ,GAAgBlC,IAAI,CAACC,GAAL,CAASiC,QAAQ,GAAGvB,KAApB,EAA2B,CAA3B,CAAhB,GAAgD,CAAC;AAFrD,eAAZ;AAIAF,cAAAA,OAAO,CAACd,GAAD,CAAP;AACD;AACF,WAXD;AAYD;AACF,OAjBD;AAkBD,KArBM,CAAP;AAsBD;;AAEDyC,EAAAA,OAAO,CAAC5C,KAAD,EAAQ;AACb,WAAO,IAAIgB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,WAAKrB,MAAL,CAAYgD,GAAZ,CAAgB7C,KAAhB,EAAuB,CAACyB,GAAD,EAAMtB,GAAN,KAAc;AACnC,YAAIsB,GAAJ,EAAS;AACPP,UAAAA,MAAM,CAACO,GAAD,CAAN;AACD,SAFD,MAEO,IAAItB,GAAG,KAAK,KAAZ,EAAmB;AACxBc,UAAAA,OAAO,CAACd,GAAD,CAAP;AACD,SAFM,MAEA;AACL,eAAKN,MAAL,CAAYgD,GAAZ,CAAiB,GAAE7C,KAAM,SAAzB,EAAoC8C,YAAD,IAAkB;AACnD,gBAAIA,YAAJ,EAAkB;AAChB5B,cAAAA,MAAM,CAAC4B,YAAD,CAAN;AACD,aAFD,MAEO;AACL7B,cAAAA,OAAO,CAACd,GAAD,CAAP;AACD;AACF,WAND;AAOD;AACF,OAdD;AAeD,KAhBM,CAAP;AAiBD;;AA/IwD;;AAkJ3D4C,MAAM,CAACC,OAAP,GAAiBtD,mBAAjB","sourcesContent":["const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterMemcache extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: memcacheClient\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n\n    this.client = opts.storeClient;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    res.consumedPoints = parseInt(result.consumedPoints);\n    res.isFirstInDuration = result.consumedPoints === changedPoints;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = result.msBeforeNext;\n\n    return res;\n  }\n\n  _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {\n    return new Promise((resolve, reject) => {\n      const nowMs = Date.now();\n      const secDuration = Math.floor(msDuration / 1000);\n\n      if (forceExpire) {\n        this.client.set(rlKey, points, secDuration, (err) => {\n          if (!err) {\n            this.client.set(\n              `${rlKey}_expire`,\n              secDuration > 0 ? nowMs + (secDuration * 1000) : -1,\n              secDuration,\n              () => {\n                const res = {\n                  consumedPoints: points,\n                  msBeforeNext: secDuration > 0 ? secDuration * 1000 : -1,\n                };\n                resolve(res);\n              }\n            );\n          } else {\n            reject(err);\n          }\n        });\n      } else {\n        this.client.incr(rlKey, points, (err, consumedPoints) => {\n          if (err || consumedPoints === false) {\n            this.client.add(rlKey, points, secDuration, (errAddKey, createdNew) => {\n              if (errAddKey || !createdNew) {\n                // Try to upsert again in case of race condition\n                if (typeof options.attemptNumber === 'undefined' || options.attemptNumber < 3) {\n                  const nextOptions = Object.assign({}, options);\n                  nextOptions.attemptNumber = nextOptions.attemptNumber ? (nextOptions.attemptNumber + 1) : 1;\n\n                  this._upsert(rlKey, points, msDuration, forceExpire, nextOptions)\n                    .then(resUpsert => resolve(resUpsert))\n                    .catch(errUpsert => reject(errUpsert));\n                } else {\n                  reject(new Error('Can not add key'));\n                }\n              } else {\n                this.client.add(\n                  `${rlKey}_expire`,\n                  secDuration > 0 ? nowMs + (secDuration * 1000) : -1,\n                  secDuration,\n                  () => {\n                    const res = {\n                      consumedPoints: points,\n                      msBeforeNext: secDuration > 0 ? secDuration * 1000 : -1,\n                    };\n                    resolve(res);\n                  }\n                );\n              }\n            });\n          } else {\n            this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {\n              if (errGetExpire) {\n                reject(errGetExpire);\n              } else {\n                const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;\n                const res = {\n                  consumedPoints,\n                  msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1,\n                };\n                resolve(res);\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n\n  _get(rlKey) {\n    return new Promise((resolve, reject) => {\n      const nowMs = Date.now();\n\n      this.client.get(rlKey, (err, consumedPoints) => {\n        if (!consumedPoints) {\n          resolve(null);\n        } else {\n          this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {\n            if (errGetExpire) {\n              reject(errGetExpire);\n            } else {\n              const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;\n              const res = {\n                consumedPoints,\n                msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1,\n              };\n              resolve(res);\n            }\n          });\n        }\n      });\n    });\n  }\n\n  _delete(rlKey) {\n    return new Promise((resolve, reject) => {\n      this.client.del(rlKey, (err, res) => {\n        if (err) {\n          reject(err);\n        } else if (res === false) {\n          resolve(res);\n        } else {\n          this.client.del(`${rlKey}_expire`, (errDelExpire) => {\n            if (errDelExpire) {\n              reject(errDelExpire);\n            } else {\n              resolve(res);\n            }\n          });\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = RateLimiterMemcache;\n"]},"metadata":{},"sourceType":"script"}