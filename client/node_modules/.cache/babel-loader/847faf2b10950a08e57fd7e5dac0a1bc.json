{"ast":null,"code":"import { ipfsCore as pkgversion } from '../version.js';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { NotStartedError } from '../errors.js';\nimport errCode from 'err-code';\nimport { logger } from '@libp2p/logger';\nconst log = logger('ipfs:components:id');\n/**\n * @typedef {import('libp2p').Libp2p} Libp2p\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\n/**\n * @param {object} config\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('../types').NetworkService} config.network\n */\n\nexport function createId(_ref) {\n  let {\n    peerId,\n    network\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"id\"]}\n   */\n  async function id() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // eslint-disable-line require-await\n    const net = network.try();\n\n    if (!net) {\n      if (options.peerId) {\n        throw new NotStartedError();\n      }\n\n      if (peerId.publicKey == null) {\n        throw errCode(new Error('Public key missing'), 'ERR_MISSING_PUBLIC_KEY');\n      }\n\n      return {\n        id: peerId,\n        publicKey: uint8ArrayToString(peerId.publicKey, 'base64pad'),\n        addresses: [],\n        agentVersion: `js-ipfs/${pkgversion}`,\n        protocolVersion: '9000',\n        protocols: []\n      };\n    }\n\n    const {\n      libp2p\n    } = net;\n    const peerIdToId = options.peerId ? options.peerId : peerId;\n    const peer = await findPeer(peerIdToId, libp2p, options);\n    const agentVersion = uint8ArrayToString(peer.metadata.get('AgentVersion') || new Uint8Array());\n    const protocolVersion = uint8ArrayToString(peer.metadata.get('ProtocolVersion') || new Uint8Array());\n    const idStr = peer.id.toString();\n    const publicKeyStr = peer.publicKey ? uint8ArrayToString(peer.publicKey, 'base64pad') : '';\n    return {\n      id: peerIdToId,\n      publicKey: publicKeyStr,\n      addresses: (peer.addresses || []).map(ma => {\n        const str = ma.toString(); // some relay-style transports add our peer id to the ma for us\n        // so don't double-add\n\n        if (str.endsWith(`/p2p/${idStr}`)) {\n          return str;\n        }\n\n        return `${str}/p2p/${idStr}`;\n      }).sort().map(ma => multiaddr(ma)),\n      agentVersion,\n      protocolVersion,\n      protocols: (peer.protocols || []).sort()\n    };\n  }\n\n  return withTimeoutOption(id);\n}\n/**\n * @param {PeerId} peerId\n * @param {Libp2p} libp2p\n * @param {AbortOptions} options\n */\n\nasync function findPeer(peerId, libp2p, options) {\n  let peer = await libp2p.peerStore.get(peerId);\n\n  if (!peer) {\n    peer = await findPeerOnDht(peerId, libp2p, options);\n  }\n\n  let publicKey = peerId.publicKey ? peerId.publicKey : await libp2p.peerStore.keyBook.get(peerId);\n\n  if (publicKey == null) {\n    try {\n      publicKey = await libp2p.getPublicKey(peerId, options);\n    } catch (err) {\n      log.error('Could not load public key for', peerId.toString(), err);\n    }\n  }\n\n  return { ...peer,\n    publicKey,\n    metadata: peer.metadata || new Map(),\n    addresses: peer.addresses.map(addr => addr.multiaddr)\n  };\n}\n/**\n * @param {PeerId} peerId\n * @param {Libp2p} libp2p\n * @param {AbortOptions} options\n */\n\n\nasync function findPeerOnDht(peerId, libp2p, options) {\n  if (libp2p.dht == null) {\n    throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n  }\n\n  for await (const event of libp2p.dht.findPeer(peerId, options)) {\n    if (event.name === 'FINAL_PEER') {\n      break;\n    }\n  }\n\n  const peer = await libp2p.peerStore.get(peerId);\n\n  if (!peer) {\n    throw errCode(new Error('Could not find peer'), 'ERR_NOT_FOUND');\n  }\n\n  return peer;\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/id.js"],"names":["ipfsCore","pkgversion","multiaddr","withTimeoutOption","toString","uint8ArrayToString","NotStartedError","errCode","logger","log","createId","peerId","network","id","options","net","try","publicKey","Error","addresses","agentVersion","protocolVersion","protocols","libp2p","peerIdToId","peer","findPeer","metadata","get","Uint8Array","idStr","publicKeyStr","map","ma","str","endsWith","sort","peerStore","findPeerOnDht","keyBook","getPublicKey","err","error","Map","addr","dht","event","name"],"mappings":"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","sourcesContent":["import { ipfsCore as pkgversion } from '../version.js'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { NotStartedError } from '../errors.js'\nimport errCode from 'err-code'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('ipfs:components:id')\n\n/**\n * @typedef {import('libp2p').Libp2p} Libp2p\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\n/**\n * @param {object} config\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('../types').NetworkService} config.network\n */\nexport function createId ({ peerId, network }) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"id\"]}\n   */\n  async function id (options = {}) { // eslint-disable-line require-await\n    const net = network.try()\n\n    if (!net) {\n      if (options.peerId) {\n        throw new NotStartedError()\n      }\n\n      if (peerId.publicKey == null) {\n        throw errCode(new Error('Public key missing'), 'ERR_MISSING_PUBLIC_KEY')\n      }\n\n      return {\n        id: peerId,\n        publicKey: uint8ArrayToString(peerId.publicKey, 'base64pad'),\n        addresses: [],\n        agentVersion: `js-ipfs/${pkgversion}`,\n        protocolVersion: '9000',\n        protocols: []\n      }\n    }\n\n    const { libp2p } = net\n    const peerIdToId = options.peerId ? options.peerId : peerId\n    const peer = await findPeer(peerIdToId, libp2p, options)\n    const agentVersion = uint8ArrayToString(peer.metadata.get('AgentVersion') || new Uint8Array())\n    const protocolVersion = uint8ArrayToString(peer.metadata.get('ProtocolVersion') || new Uint8Array())\n    const idStr = peer.id.toString()\n    const publicKeyStr = peer.publicKey ? uint8ArrayToString(peer.publicKey, 'base64pad') : ''\n\n    return {\n      id: peerIdToId,\n      publicKey: publicKeyStr,\n      addresses: (peer.addresses || [])\n        .map(ma => {\n          const str = ma.toString()\n\n          // some relay-style transports add our peer id to the ma for us\n          // so don't double-add\n          if (str.endsWith(`/p2p/${idStr}`)) {\n            return str\n          }\n\n          return `${str}/p2p/${idStr}`\n        })\n        .sort()\n        .map(ma => multiaddr(ma)),\n      agentVersion,\n      protocolVersion,\n      protocols: (peer.protocols || []).sort()\n    }\n  }\n\n  return withTimeoutOption(id)\n}\n\n/**\n * @param {PeerId} peerId\n * @param {Libp2p} libp2p\n * @param {AbortOptions} options\n */\nasync function findPeer (peerId, libp2p, options) {\n  let peer = await libp2p.peerStore.get(peerId)\n\n  if (!peer) {\n    peer = await findPeerOnDht(peerId, libp2p, options)\n  }\n\n  let publicKey = peerId.publicKey ? peerId.publicKey : await libp2p.peerStore.keyBook.get(peerId)\n\n  if (publicKey == null) {\n    try {\n      publicKey = await libp2p.getPublicKey(peerId, options)\n    } catch (err) {\n      log.error('Could not load public key for', peerId.toString(), err)\n    }\n  }\n\n  return {\n    ...peer,\n    publicKey,\n    metadata: peer.metadata || new Map(),\n    addresses: peer.addresses.map(addr => addr.multiaddr)\n  }\n}\n\n/**\n * @param {PeerId} peerId\n * @param {Libp2p} libp2p\n * @param {AbortOptions} options\n */\nasync function findPeerOnDht (peerId, libp2p, options) {\n  if (libp2p.dht == null) {\n    throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n  }\n\n  for await (const event of libp2p.dht.findPeer(peerId, options)) {\n    if (event.name === 'FINAL_PEER') {\n      break\n    }\n  }\n\n  const peer = await libp2p.peerStore.get(peerId)\n\n  if (!peer) {\n    throw errCode(new Error('Could not find peer'), 'ERR_NOT_FOUND')\n  }\n\n  return peer\n}\n"]},"metadata":{},"sourceType":"module"}