{"ast":null,"code":"import Queue from 'p-queue';\nimport { xor } from 'uint8arrays/xor';\nimport { toString } from 'uint8arrays/to-string';\nimport defer from 'p-defer';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { convertPeerId, convertBuffer } from '../utils.js';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { anySignal } from 'any-signal';\nimport { queryErrorEvent } from './events.js';\nconst MAX_XOR = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF');\n/**\n * Walks a path through the DHT, calling the passed query function for\n * every peer encountered that we have not seen before\n */\n\nexport async function* queryPath(options) {\n  const {\n    key,\n    startingPeer,\n    ourPeerId,\n    signal,\n    query,\n    alpha,\n    pathIndex,\n    numPaths,\n    cleanUp,\n    queryFuncTimeout,\n    log,\n    peersSeen\n  } = options; // Only ALPHA node/value lookups are allowed at any given time for each process\n  // https://github.com/libp2p/specs/tree/master/kad-dht#alpha-concurrency-parameter-%CE%B1\n\n  const queue = new Queue({\n    concurrency: alpha\n  }); // perform lookups on kadId, not the actual value\n\n  const kadId = await convertBuffer(key);\n  /**\n   * Adds the passed peer to the query queue if it's not us and no\n   * other path has passed through this peer\n   */\n\n  function queryPeer(peer, peerKadId) {\n    if (peer == null) {\n      return;\n    }\n\n    peersSeen.add(peer);\n    const peerXor = BigInt('0x' + toString(xor(peerKadId, kadId), 'base16'));\n    queue.add(async () => {\n      let timeout;\n      const signals = [signal];\n\n      if (queryFuncTimeout != null) {\n        timeout = new TimeoutController(queryFuncTimeout);\n        signals.push(timeout.signal);\n      }\n\n      const compoundSignal = anySignal(signals);\n\n      try {\n        for await (const event of query({\n          key,\n          peer,\n          signal: compoundSignal,\n          pathIndex,\n          numPaths\n        })) {\n          if (compoundSignal.aborted) {\n            return;\n          } // if there are closer peers and the query has not completed, continue the query\n\n\n          if (event.name === 'PEER_RESPONSE') {\n            for (const closerPeer of event.closer) {\n              if (peersSeen.has(closerPeer.id)) {\n                // eslint-disable-line max-depth\n                log('already seen %p in query', closerPeer.id);\n                continue;\n              }\n\n              if (ourPeerId.equals(closerPeer.id)) {\n                // eslint-disable-line max-depth\n                log('not querying ourselves');\n                continue;\n              }\n\n              const closerPeerKadId = await convertPeerId(closerPeer.id);\n              const closerPeerXor = BigInt('0x' + toString(xor(closerPeerKadId, kadId), 'base16')); // only continue query if closer peer is actually closer\n\n              if (closerPeerXor > peerXor) {\n                // eslint-disable-line max-depth\n                log('skipping %p as they are not closer to %b than %p', closerPeer.id, key, peer);\n                continue;\n              }\n\n              log('querying closer peer %p', closerPeer.id);\n              queryPeer(closerPeer.id, closerPeerKadId);\n            }\n          } // TODO: we have upgraded to p-queue@7, this should no longer be necessary\n\n\n          queue.emit('completed', event);\n        }\n\n        timeout?.clear();\n      } catch (err) {\n        if (signal.aborted) {\n          // TODO: we have upgraded to p-queue@7, this should no longer be necessary\n          queue.emit('error', err);\n        } else {\n          // TODO: we have upgraded to p-queue@7, this should no longer be necessary\n          queue.emit('completed', queryErrorEvent({\n            from: peer,\n            error: err\n          }));\n        }\n      } finally {\n        timeout?.clear();\n      }\n    }, {\n      // use xor value as the queue priority - closer peers should execute first\n      // subtract it from MAX_XOR because higher priority values execute sooner\n      // @ts-expect-error this is supposed to be a Number but it's ok to use BigInts\n      // as long as all priorities are BigInts since we won't mix BigInts and Number\n      // values in arithmetic operations\n      priority: MAX_XOR - peerXor\n    }).catch(err => {\n      log.error(err);\n    });\n  } // begin the query with the starting peer\n\n\n  queryPeer(startingPeer, await convertPeerId(startingPeer)); // yield results as they come in\n\n  yield* toGenerator(queue, signal, cleanUp, log);\n}\n\nasync function* toGenerator(queue, signal, cleanUp, log) {\n  let deferred = defer();\n  let running = true;\n  const results = [];\n\n  const cleanup = () => {\n    if (!running) {\n      return;\n    }\n\n    log('clean up queue, results %d, queue size %d, pending tasks %d', results.length, queue.size, queue.pending);\n    running = false;\n    queue.clear();\n    results.splice(0, results.length);\n  };\n\n  queue.on('completed', result => {\n    results.push(result);\n    deferred.resolve();\n  });\n  queue.on('error', err => {\n    log('queue error', err);\n    cleanup();\n    deferred.reject(err);\n  });\n  queue.on('idle', () => {\n    log('queue idle');\n    running = false;\n    deferred.resolve();\n  }); // clear the queue and throw if the query is aborted\n\n  signal.addEventListener('abort', () => {\n    log('abort queue');\n    const wasRunning = running;\n    cleanup();\n\n    if (wasRunning) {\n      deferred.reject(new CodeError('Query aborted', 'ERR_QUERY_ABORTED'));\n    }\n  }); // the user broke out of the loop early, ensure we resolve the deferred result\n  // promise and clear the queue of any remaining jobs\n\n  cleanUp.addEventListener('cleanup', () => {\n    cleanup();\n    deferred.resolve();\n  });\n\n  while (running) {\n    // eslint-disable-line no-unmodified-loop-condition\n    await deferred.promise;\n    deferred = defer(); // yield all available results\n\n    while (results.length > 0) {\n      const result = results.shift();\n\n      if (result != null) {\n        yield result;\n      }\n    }\n  } // yield any remaining results\n\n\n  yield* results;\n}","map":{"version":3,"mappings":"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","names":["Queue","xor","toString","defer","CodeError","convertPeerId","convertBuffer","TimeoutController","anySignal","queryErrorEvent","MAX_XOR","BigInt","queryPath","options","key","startingPeer","ourPeerId","signal","query","alpha","pathIndex","numPaths","cleanUp","queryFuncTimeout","log","peersSeen","queue","concurrency","kadId","queryPeer","peer","peerKadId","add","peerXor","timeout","signals","push","compoundSignal","event","aborted","name","closerPeer","closer","has","id","equals","closerPeerKadId","closerPeerXor","emit","clear","err","from","error","priority","catch","toGenerator","deferred","running","results","cleanup","length","size","pending","splice","on","result","resolve","reject","addEventListener","wasRunning","promise","shift"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\query\\query-path.ts"],"sourcesContent":["import Queue from 'p-queue'\nimport { xor } from 'uint8arrays/xor'\nimport { toString } from 'uint8arrays/to-string'\nimport defer from 'p-defer'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { convertPeerId, convertBuffer } from '../utils.js'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { anySignal } from 'any-signal'\nimport { queryErrorEvent } from './events.js'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { EventEmitter } from '@libp2p/interfaces/events'\nimport type { CleanUpEvents } from './manager.js'\nimport type { Logger } from '@libp2p/logger'\nimport type { QueryFunc } from '../query/types.js'\nimport type { QueryEvent } from '@libp2p/interface-dht'\nimport type { PeerSet } from '@libp2p/peer-collections'\n\nconst MAX_XOR = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF')\n\nexport interface QueryPathOptions {\n  /**\n   * What are we trying to find\n   */\n  key: Uint8Array\n\n  /**\n   * Where we start our query\n   */\n  startingPeer: PeerId\n\n  /**\n   * Who we are\n   */\n  ourPeerId: PeerId\n\n  /**\n   * When to stop querying\n   */\n  signal: AbortSignal\n\n  /**\n   * The query function to run with each peer\n   */\n  query: QueryFunc\n\n  /**\n   * How many concurrent node/value lookups to run\n   */\n  alpha: number\n\n  /**\n   * How many concurrent node/value lookups to run\n   */\n  pathIndex: number\n\n  /**\n   * How many concurrent node/value lookups to run\n   */\n  numPaths: number\n\n  /**\n   * will emit a 'cleanup' event if the caller exits the for..await of early\n   */\n  cleanUp: EventEmitter<CleanUpEvents>\n\n  /**\n   * A timeout for queryFunc in ms\n   */\n  queryFuncTimeout?: number\n\n  /**\n   * Query log\n   */\n  log: Logger\n\n  /**\n   * Set of peers seen by this and other paths\n   */\n  peersSeen: PeerSet\n}\n\n/**\n * Walks a path through the DHT, calling the passed query function for\n * every peer encountered that we have not seen before\n */\nexport async function * queryPath (options: QueryPathOptions): AsyncGenerator<QueryEvent, void, undefined> {\n  const { key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, cleanUp, queryFuncTimeout, log, peersSeen } = options\n  // Only ALPHA node/value lookups are allowed at any given time for each process\n  // https://github.com/libp2p/specs/tree/master/kad-dht#alpha-concurrency-parameter-%CE%B1\n  const queue = new Queue({\n    concurrency: alpha\n  })\n\n  // perform lookups on kadId, not the actual value\n  const kadId = await convertBuffer(key)\n\n  /**\n   * Adds the passed peer to the query queue if it's not us and no\n   * other path has passed through this peer\n   */\n  function queryPeer (peer: PeerId, peerKadId: Uint8Array): void {\n    if (peer == null) {\n      return\n    }\n\n    peersSeen.add(peer)\n\n    const peerXor = BigInt('0x' + toString(xor(peerKadId, kadId), 'base16'))\n\n    queue.add(async () => {\n      let timeout\n      const signals = [signal]\n\n      if (queryFuncTimeout != null) {\n        timeout = new TimeoutController(queryFuncTimeout)\n        signals.push(timeout.signal)\n      }\n\n      const compoundSignal = anySignal(signals)\n\n      try {\n        for await (const event of query({\n          key,\n          peer,\n          signal: compoundSignal,\n          pathIndex,\n          numPaths\n        })) {\n          if (compoundSignal.aborted) {\n            return\n          }\n\n          // if there are closer peers and the query has not completed, continue the query\n          if (event.name === 'PEER_RESPONSE') {\n            for (const closerPeer of event.closer) {\n              if (peersSeen.has(closerPeer.id)) { // eslint-disable-line max-depth\n                log('already seen %p in query', closerPeer.id)\n                continue\n              }\n\n              if (ourPeerId.equals(closerPeer.id)) { // eslint-disable-line max-depth\n                log('not querying ourselves')\n                continue\n              }\n\n              const closerPeerKadId = await convertPeerId(closerPeer.id)\n              const closerPeerXor = BigInt('0x' + toString(xor(closerPeerKadId, kadId), 'base16'))\n\n              // only continue query if closer peer is actually closer\n              if (closerPeerXor > peerXor) { // eslint-disable-line max-depth\n                log('skipping %p as they are not closer to %b than %p', closerPeer.id, key, peer)\n                continue\n              }\n\n              log('querying closer peer %p', closerPeer.id)\n              queryPeer(closerPeer.id, closerPeerKadId)\n            }\n          }\n\n          // TODO: we have upgraded to p-queue@7, this should no longer be necessary\n          queue.emit('completed', event)\n        }\n\n        timeout?.clear()\n      } catch (err: any) {\n        if (signal.aborted) {\n          // TODO: we have upgraded to p-queue@7, this should no longer be necessary\n          queue.emit('error', err)\n        } else {\n          // TODO: we have upgraded to p-queue@7, this should no longer be necessary\n          queue.emit('completed', queryErrorEvent({\n            from: peer,\n            error: err\n          }))\n        }\n      } finally {\n        timeout?.clear()\n      }\n    }, {\n      // use xor value as the queue priority - closer peers should execute first\n      // subtract it from MAX_XOR because higher priority values execute sooner\n\n      // @ts-expect-error this is supposed to be a Number but it's ok to use BigInts\n      // as long as all priorities are BigInts since we won't mix BigInts and Number\n      // values in arithmetic operations\n      priority: MAX_XOR - peerXor\n    }).catch(err => {\n      log.error(err)\n    })\n  }\n\n  // begin the query with the starting peer\n  queryPeer(startingPeer, await convertPeerId(startingPeer))\n\n  // yield results as they come in\n  yield * toGenerator(queue, signal, cleanUp, log)\n}\n\nasync function * toGenerator (queue: Queue, signal: AbortSignal, cleanUp: EventEmitter<CleanUpEvents>, log: Logger): AsyncGenerator<QueryEvent, void, undefined> {\n  let deferred = defer()\n  let running = true\n  const results: QueryEvent[] = []\n\n  const cleanup = (): void => {\n    if (!running) {\n      return\n    }\n\n    log('clean up queue, results %d, queue size %d, pending tasks %d', results.length, queue.size, queue.pending)\n\n    running = false\n    queue.clear()\n    results.splice(0, results.length)\n  }\n\n  queue.on('completed', result => {\n    results.push(result)\n    deferred.resolve()\n  })\n  queue.on('error', err => {\n    log('queue error', err)\n    cleanup()\n    deferred.reject(err)\n  })\n  queue.on('idle', () => {\n    log('queue idle')\n    running = false\n    deferred.resolve()\n  })\n\n  // clear the queue and throw if the query is aborted\n  signal.addEventListener('abort', () => {\n    log('abort queue')\n    const wasRunning = running\n    cleanup()\n\n    if (wasRunning) {\n      deferred.reject(new CodeError('Query aborted', 'ERR_QUERY_ABORTED'))\n    }\n  })\n\n  // the user broke out of the loop early, ensure we resolve the deferred result\n  // promise and clear the queue of any remaining jobs\n  cleanUp.addEventListener('cleanup', () => {\n    cleanup()\n    deferred.resolve()\n  })\n\n  while (running) { // eslint-disable-line no-unmodified-loop-condition\n    await deferred.promise\n    deferred = defer()\n\n    // yield all available results\n    while (results.length > 0) {\n      const result = results.shift()\n\n      if (result != null) {\n        yield result\n      }\n    }\n  }\n\n  // yield any remaining results\n  yield * results\n}\n"]},"metadata":{},"sourceType":"module"}