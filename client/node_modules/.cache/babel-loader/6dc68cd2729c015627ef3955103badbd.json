{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { codes } from './errors.js';\nimport { peerIdFromPeerId } from '@libp2p/peer-id';\nimport { CustomEvent } from '@libp2p/interfaces/events';\nconst log = logger('libp2p:peer-store:proto-book');\nconst EVENT_NAME = 'change:protocols';\nexport class PeerStoreProtoBook {\n  /**\n   * The ProtoBook is responsible for keeping the known supported\n   * protocols of a peer\n   */\n  constructor(dispatchEvent, store) {\n    this.dispatchEvent = dispatchEvent;\n    this.store = store;\n  }\n\n  async get(peerId) {\n    log.trace('get wait for read lock');\n    const release = await this.store.lock.readLock();\n    log.trace('get got read lock');\n\n    try {\n      const peer = await this.store.load(peerId);\n      return peer.protocols;\n    } catch (err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log.trace('get release read lock');\n      release();\n    }\n\n    return [];\n  }\n\n  async set(peerId, protocols) {\n    peerId = peerIdFromPeerId(peerId);\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data');\n      throw new CodeError('protocols must be provided', codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log.trace('set await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('set got write lock');\n    let peer;\n    let updatedPeer;\n\n    try {\n      try {\n        peer = await this.store.load(peerId);\n\n        if (new Set([...protocols]).size === peer.protocols.length) {\n          return;\n        }\n      } catch (err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this.store.patchOrCreate(peerId, {\n        protocols\n      });\n      log('stored provided protocols for %p', peerId);\n    } finally {\n      log.trace('set release write lock');\n      release();\n    }\n\n    this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n      detail: {\n        peerId,\n        protocols: updatedPeer.protocols,\n        oldProtocols: peer == null ? [] : peer.protocols\n      }\n    }));\n  }\n\n  async add(peerId, protocols) {\n    peerId = peerIdFromPeerId(peerId);\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data');\n      throw new CodeError('protocols must be provided', codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log.trace('add await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('add got write lock');\n    let peer;\n    let updatedPeer;\n\n    try {\n      try {\n        peer = await this.store.load(peerId);\n\n        if (new Set([...peer.protocols, ...protocols]).size === peer.protocols.length) {\n          return;\n        }\n      } catch (err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this.store.mergeOrCreate(peerId, {\n        protocols\n      });\n      log('added provided protocols for %p', peerId);\n    } finally {\n      log.trace('add release write lock');\n      release();\n    }\n\n    this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n      detail: {\n        peerId,\n        protocols: updatedPeer.protocols,\n        oldProtocols: peer == null ? [] : peer.protocols\n      }\n    }));\n  }\n\n  async remove(peerId, protocols) {\n    peerId = peerIdFromPeerId(peerId);\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data');\n      throw new CodeError('protocols must be provided', codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log.trace('remove await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('remove got write lock');\n    let peer;\n    let updatedPeer;\n\n    try {\n      try {\n        peer = await this.store.load(peerId);\n        const protocolSet = new Set(peer.protocols);\n\n        for (const protocol of protocols) {\n          protocolSet.delete(protocol);\n        }\n\n        if (peer.protocols.length === protocolSet.size) {\n          return;\n        }\n\n        protocols = Array.from(protocolSet);\n      } catch (err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this.store.patchOrCreate(peerId, {\n        protocols\n      });\n    } finally {\n      log.trace('remove release write lock');\n      release();\n    }\n\n    this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n      detail: {\n        peerId,\n        protocols: updatedPeer.protocols,\n        oldProtocols: peer == null ? [] : peer.protocols\n      }\n    }));\n  }\n\n  async delete(peerId) {\n    peerId = peerIdFromPeerId(peerId);\n    log.trace('delete await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('delete got write lock');\n    let peer;\n\n    try {\n      try {\n        peer = await this.store.load(peerId);\n      } catch (err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      await this.store.patchOrCreate(peerId, {\n        protocols: []\n      });\n    } finally {\n      log.trace('delete release write lock');\n      release();\n    }\n\n    if (peer != null) {\n      this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n        detail: {\n          peerId,\n          protocols: [],\n          oldProtocols: peer.protocols\n        }\n      }));\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","CodeError","codes","peerIdFromPeerId","CustomEvent","log","EVENT_NAME","PeerStoreProtoBook","constructor","dispatchEvent","store","get","peerId","trace","release","lock","readLock","peer","load","protocols","err","code","ERR_NOT_FOUND","set","Array","isArray","error","ERR_INVALID_PARAMETERS","writeLock","updatedPeer","Set","size","length","patchOrCreate","detail","oldProtocols","add","mergeOrCreate","remove","protocolSet","protocol","delete","from"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\peer-store\\src\\proto-book.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { codes } from './errors.js'\nimport { peerIdFromPeerId } from '@libp2p/peer-id'\nimport { CustomEvent } from '@libp2p/interfaces/events'\nimport type { Store } from './store.js'\nimport type { Peer, PeerProtocolsChangeData, PeerStore, ProtoBook } from '@libp2p/interface-peer-store'\nimport type { PeerId } from '@libp2p/interface-peer-id'\n\nconst log = logger('libp2p:peer-store:proto-book')\n\nconst EVENT_NAME = 'change:protocols'\n\nexport class PeerStoreProtoBook implements ProtoBook {\n  private readonly dispatchEvent: PeerStore['dispatchEvent']\n  private readonly store: Store\n\n  /**\n   * The ProtoBook is responsible for keeping the known supported\n   * protocols of a peer\n   */\n  constructor (dispatchEvent: PeerStore['dispatchEvent'], store: Store) {\n    this.dispatchEvent = dispatchEvent\n    this.store = store\n  }\n\n  async get (peerId: PeerId): Promise<string[]> {\n    log.trace('get wait for read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('get got read lock')\n\n    try {\n      const peer = await this.store.load(peerId)\n\n      return peer.protocols\n    } catch (err: any) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log.trace('get release read lock')\n      release()\n    }\n\n    return []\n  }\n\n  async set (peerId: PeerId, protocols: string[]): Promise<void> {\n    peerId = peerIdFromPeerId(peerId)\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data')\n      throw new CodeError('protocols must be provided', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log.trace('set await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('set got write lock')\n\n    let peer\n    let updatedPeer\n\n    try {\n      try {\n        peer = await this.store.load(peerId)\n\n        if (new Set([\n          ...protocols\n        ]).size === peer.protocols.length) {\n          return\n        }\n      } catch (err: any) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this.store.patchOrCreate(peerId, {\n        protocols\n      })\n\n      log('stored provided protocols for %p', peerId)\n    } finally {\n      log.trace('set release write lock')\n      release()\n    }\n\n    this.dispatchEvent(new CustomEvent<PeerProtocolsChangeData>(EVENT_NAME, {\n      detail: {\n        peerId,\n        protocols: updatedPeer.protocols,\n        oldProtocols: peer == null ? [] : peer.protocols\n      }\n    }))\n  }\n\n  async add (peerId: PeerId, protocols: string[]): Promise<void> {\n    peerId = peerIdFromPeerId(peerId)\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data')\n      throw new CodeError('protocols must be provided', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log.trace('add await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('add got write lock')\n\n    let peer: Peer | undefined\n    let updatedPeer\n\n    try {\n      try {\n        peer = await this.store.load(peerId)\n\n        if (new Set([\n          ...peer.protocols,\n          ...protocols\n        ]).size === peer.protocols.length) {\n          return\n        }\n      } catch (err: any) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this.store.mergeOrCreate(peerId, {\n        protocols\n      })\n\n      log('added provided protocols for %p', peerId)\n    } finally {\n      log.trace('add release write lock')\n      release()\n    }\n\n    this.dispatchEvent(new CustomEvent<PeerProtocolsChangeData>(EVENT_NAME, {\n      detail: {\n        peerId,\n        protocols: updatedPeer.protocols,\n        oldProtocols: peer == null ? [] : peer.protocols\n      }\n    }))\n  }\n\n  async remove (peerId: PeerId, protocols: string[]): Promise<void> {\n    peerId = peerIdFromPeerId(peerId)\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data')\n      throw new CodeError('protocols must be provided', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log.trace('remove await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('remove got write lock')\n\n    let peer: Peer | undefined\n    let updatedPeer: Peer\n\n    try {\n      try {\n        peer = await this.store.load(peerId)\n        const protocolSet = new Set(peer.protocols)\n\n        for (const protocol of protocols) {\n          protocolSet.delete(protocol)\n        }\n\n        if (peer.protocols.length === protocolSet.size) {\n          return\n        }\n\n        protocols = Array.from(protocolSet)\n      } catch (err: any) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this.store.patchOrCreate(peerId, {\n        protocols\n      })\n    } finally {\n      log.trace('remove release write lock')\n      release()\n    }\n\n    this.dispatchEvent(new CustomEvent<PeerProtocolsChangeData>(EVENT_NAME, {\n      detail: {\n        peerId,\n        protocols: updatedPeer.protocols,\n        oldProtocols: peer == null ? [] : peer.protocols\n      }\n    }))\n  }\n\n  async delete (peerId: PeerId): Promise<void> {\n    peerId = peerIdFromPeerId(peerId)\n\n    log.trace('delete await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('delete got write lock')\n    let peer: Peer | undefined\n\n    try {\n      try {\n        peer = await this.store.load(peerId)\n      } catch (err: any) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      await this.store.patchOrCreate(peerId, {\n        protocols: []\n      })\n    } finally {\n      log.trace('delete release write lock')\n      release()\n    }\n\n    if (peer != null) {\n      this.dispatchEvent(new CustomEvent<PeerProtocolsChangeData>(EVENT_NAME, {\n        detail: {\n          peerId,\n          protocols: [],\n          oldProtocols: peer.protocols\n        }\n      }))\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}