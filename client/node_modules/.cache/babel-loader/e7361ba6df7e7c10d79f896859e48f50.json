{"ast":null,"code":"import { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nimport { CarHeader as headerValidator } from './header-validator.js';\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js';\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockHeader} BlockHeader\n * @typedef {import('./api').BlockIndex} BlockIndex\n * @typedef {import('./coding').BytesReader} BytesReader\n * @typedef {import('./coding').CarHeader} CarHeader\n * @typedef {import('./coding').CarV2Header} CarV2Header\n * @typedef {import('./coding').CarV2FixedHeader} CarV2FixedHeader\n * @typedef {import('./coding').CarDecoder} CarDecoder\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name async decoder.readHeader(reader)\n * @param {BytesReader} reader\n * @param {number} [strictVersion]\n * @returns {Promise<CarHeader|CarV2Header>}\n */\n\nexport async function readHeader(reader, strictVersion) {\n  const length = decodeVarint(await reader.upTo(8), reader);\n\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n\n  const header = await reader.exactly(length, true);\n  const block = decodeDagCbor(header);\n\n  if (!headerValidator(block)) {\n    throw new Error('Invalid CAR header format');\n  }\n\n  if (block.version !== 1 && block.version !== 2 || strictVersion !== undefined && block.version !== strictVersion) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`);\n  } // we've made 'roots' optional in the schema so we can do the version check\n  // before rejecting the block as invalid if there is no version\n\n\n  const hasRoots = Array.isArray(block.roots);\n\n  if (block.version === 1 && !hasRoots || block.version === 2 && hasRoots) {\n    throw new Error('Invalid CAR header format');\n  }\n\n  if (block.version === 1) {\n    return block;\n  } // version 2\n\n\n  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true));\n  reader.seek(v2Header.dataOffset - reader.pos);\n  const v1Header = await readHeader(reader, 1);\n  return Object.assign(v1Header, v2Header);\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n/**\n * @param {BytesReader} reader\n * @returns {Promise<CID>}\n */\n\nasync function readCid(reader) {\n  const first = await reader.exactly(2, false);\n\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = await reader.exactly(34, true);\n    const multihash = Digest.decode(bytes);\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n\n  const version = decodeVarint(await reader.upTo(8), reader);\n\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`);\n  }\n\n  const codec = decodeVarint(await reader.upTo(8), reader);\n  const bytes = await reader.exactly(getMultihashLength(await reader.upTo(8)), true);\n  const multihash = Digest.decode(bytes);\n  return CID.create(version, codec, multihash);\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesReader} reader\n * @returns {Promise<BlockHeader>}\n */\n\n\nexport async function readBlockHead(reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos;\n  let length = decodeVarint(await reader.upTo(8), reader);\n\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - Number(reader.pos - start); // subtract CID length\n\n  return {\n    cid,\n    length,\n    blockLength\n  };\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n/**\n * @param {BytesReader} reader\n * @returns {Promise<Block>}\n */\n\nasync function readBlock(reader) {\n  const {\n    cid,\n    blockLength\n  } = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength, true);\n  return {\n    bytes,\n    cid\n  };\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n/**\n * @param {BytesReader} reader\n * @returns {Promise<BlockIndex>}\n */\n\n\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {\n    cid,\n    length,\n    blockLength\n  } = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n/**\n * Creates a `CarDecoder` from a `BytesReader`. The `CarDecoder` is as async\n * interface that will consume the bytes from the `BytesReader` to yield a\n * `header()` and either `blocks()` or `blocksIndex()` data.\n *\n * @name decoder.createDecoder(reader)\n * @param {BytesReader} reader\n * @returns {CarDecoder}\n */\n\n\nexport function createDecoder(reader) {\n  const headerPromise = (async () => {\n    const header = await readHeader(reader);\n\n    if (header.version === 2) {\n      const v1length = reader.pos - header.dataOffset;\n      reader = limitReader(reader, header.dataSize - v1length);\n    }\n\n    return header;\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  })();\n\n  return {\n    header: () => headerPromise,\n\n    async *blocks() {\n      await headerPromise;\n\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n\n    async *blocksIndex() {\n      await headerPromise;\n\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n\n  };\n}\n/**\n * Creates a `BytesReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesReader}\n */\n\nexport function bytesReader(bytes) {\n  let pos = 0;\n  /** @type {BytesReader} */\n\n  return {\n    async upTo(length) {\n      const out = bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n      /* c8 ignore next 2 */\n\n      return out; // Node.js 12 c8 bug\n    },\n\n    async exactly(length) {\n      let seek = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n\n      const out = bytes.subarray(pos, pos + length);\n\n      if (seek) {\n        pos += length;\n      }\n\n      return out;\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    seek(length) {\n      pos += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\n/**\n * @ignore\n * reusable reader for streams and files, we just need a way to read an\n * additional chunk (of some undetermined size) and a way to close the\n * reader when finished\n * @param {() => Promise<Uint8Array|null>} readChunk\n * @returns {BytesReader}\n */\n\nexport function chunkReader(readChunk\n/*, closer */\n) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n\n  const read = async (\n  /** @type {number} */\n  length) => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n\n    while (have < length) {\n      const chunk = await readChunk();\n\n      if (chunk == null) {\n        break;\n      }\n      /* c8 ignore next 8 */\n      // undo this ignore ^ when we have a fd implementation that can seek()\n\n\n      if (have < 0) {\n        // because of a seek()\n\n        /* c8 ignore next 4 */\n        // toohard to test the else\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        } // else discard\n\n      } else {\n        bufa.push(chunk);\n      }\n\n      have += chunk.length;\n    }\n\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n\n    offset = 0;\n  };\n  /** @type {BytesReader} */\n\n\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    async exactly(length) {\n      let seek = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n\n      const out = currentChunk.subarray(offset, offset + length);\n\n      if (seek) {\n        pos += length;\n        offset += length;\n      }\n\n      return out;\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\n/**\n * Creates a `BytesReader` from an `AsyncIterable<Uint8Array>`, which allows for\n * consumption of CAR data from a streaming source.\n *\n * @name decoder.asyncIterableReader(asyncIterable)\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {BytesReader}\n */\n\nexport function asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n\n  async function readChunk() {\n    const next = await iterator.next();\n\n    if (next.done) {\n      return null;\n    }\n\n    return next.value;\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  return chunkReader(readChunk);\n}\n/**\n * Wraps a `BytesReader` in a limiting `BytesReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesReader} reader\n * @param {number} byteLimit\n * @returns {BytesReader}\n */\n\nexport function limitReader(reader, byteLimit) {\n  let bytesRead = 0;\n  /** @type {BytesReader} */\n\n  return {\n    async upTo(length) {\n      let bytes = await reader.upTo(length);\n\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead);\n      }\n\n      return bytes;\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    async exactly(length) {\n      let seek = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const bytes = await reader.exactly(length, seek);\n\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data');\n      }\n\n      if (seek) {\n        bytesRead += length;\n      }\n\n      return bytes;\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    seek(length) {\n      bytesRead += length;\n      reader.seek(length);\n    },\n\n    get pos() {\n      return reader.pos;\n    }\n\n  };\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/@ipld/car/src/decoder.js"],"names":["CID","Digest","decode","decodeDagCbor","CarHeader","headerValidator","CIDV0_BYTES","decodeV2Header","decodeVarint","getMultihashLength","V2_HEADER_LENGTH","readHeader","reader","strictVersion","length","upTo","Error","header","exactly","block","version","undefined","hasRoots","Array","isArray","roots","v2Header","seek","dataOffset","pos","v1Header","Object","assign","readCid","first","SHA2_256","LENGTH","bytes","multihash","create","DAG_PB","codec","readBlockHead","start","cid","blockLength","Number","readBlock","readBlockIndex","offset","index","blockOffset","createDecoder","headerPromise","v1length","limitReader","dataSize","blocks","blocksIndex","bytesReader","out","subarray","Math","min","chunkReader","readChunk","have","currentChunk","Uint8Array","read","bufa","chunk","push","reduce","p","c","off","b","set","asyncIterableReader","asyncIterable","iterator","Symbol","asyncIterator","next","done","value","byteLimit","bytesRead"],"mappings":"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","sourcesContent":["import { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor'\nimport { CarHeader as headerValidator } from './header-validator.js'\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js'\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockHeader} BlockHeader\n * @typedef {import('./api').BlockIndex} BlockIndex\n * @typedef {import('./coding').BytesReader} BytesReader\n * @typedef {import('./coding').CarHeader} CarHeader\n * @typedef {import('./coding').CarV2Header} CarV2Header\n * @typedef {import('./coding').CarV2FixedHeader} CarV2FixedHeader\n * @typedef {import('./coding').CarDecoder} CarDecoder\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name async decoder.readHeader(reader)\n * @param {BytesReader} reader\n * @param {number} [strictVersion]\n * @returns {Promise<CarHeader|CarV2Header>}\n */\nexport async function readHeader (reader, strictVersion) {\n  const length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)')\n  }\n  const header = await reader.exactly(length, true)\n  const block = decodeDagCbor(header)\n  if (!headerValidator(block)) {\n    throw new Error('Invalid CAR header format')\n  }\n  if ((block.version !== 1 && block.version !== 2) || (strictVersion !== undefined && block.version !== strictVersion)) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`)\n  }\n  // we've made 'roots' optional in the schema so we can do the version check\n  // before rejecting the block as invalid if there is no version\n  const hasRoots = Array.isArray(block.roots)\n  if ((block.version === 1 && !hasRoots) || (block.version === 2 && hasRoots)) {\n    throw new Error('Invalid CAR header format')\n  }\n  if (block.version === 1) {\n    return block\n  }\n  // version 2\n  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true))\n  reader.seek(v2Header.dataOffset - reader.pos)\n  const v1Header = await readHeader(reader, 1)\n  return Object.assign(v1Header, v2Header)\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<CID>}\n */\nasync function readCid (reader) {\n  const first = await reader.exactly(2, false)\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = await reader.exactly(34, true)\n    const multihash = Digest.decode(bytes)\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash)\n  }\n\n  const version = decodeVarint(await reader.upTo(8), reader)\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`)\n  }\n  const codec = decodeVarint(await reader.upTo(8), reader)\n  const bytes = await reader.exactly(getMultihashLength(await reader.upTo(8)), true)\n  const multihash = Digest.decode(bytes)\n  return CID.create(version, codec, multihash)\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesReader} reader\n * @returns {Promise<BlockHeader>}\n */\nexport async function readBlockHead (reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos\n  let length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)')\n  }\n  length += (reader.pos - start)\n  const cid = await readCid(reader)\n  const blockLength = length - Number(reader.pos - start) // subtract CID length\n\n  return { cid, length, blockLength }\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<Block>}\n */\nasync function readBlock (reader) {\n  const { cid, blockLength } = await readBlockHead(reader)\n  const bytes = await reader.exactly(blockLength, true)\n  return { bytes, cid }\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<BlockIndex>}\n */\nasync function readBlockIndex (reader) {\n  const offset = reader.pos\n  const { cid, length, blockLength } = await readBlockHead(reader)\n  const index = { cid, length, blockLength, offset, blockOffset: reader.pos }\n  reader.seek(index.blockLength)\n  return index\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * Creates a `CarDecoder` from a `BytesReader`. The `CarDecoder` is as async\n * interface that will consume the bytes from the `BytesReader` to yield a\n * `header()` and either `blocks()` or `blocksIndex()` data.\n *\n * @name decoder.createDecoder(reader)\n * @param {BytesReader} reader\n * @returns {CarDecoder}\n */\nexport function createDecoder (reader) {\n  const headerPromise = (async () => {\n    const header = await readHeader(reader)\n    if (header.version === 2) {\n      const v1length = reader.pos - header.dataOffset\n      reader = limitReader(reader, header.dataSize - v1length)\n    }\n    return header\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  })()\n\n  return {\n    header: () => headerPromise,\n\n    async * blocks () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader)\n      }\n    },\n\n    async * blocksIndex () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader)\n      }\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesReader}\n */\nexport function bytesReader (bytes) {\n  let pos = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      const out = bytes.subarray(pos, pos + Math.min(length, bytes.length - pos))\n      /* c8 ignore next 2 */\n      return out\n      // Node.js 12 c8 bug\n    },\n\n    async exactly (length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = bytes.subarray(pos, pos + length)\n      if (seek) {\n        pos += length\n      }\n      return out\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    seek (length) {\n      pos += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * @ignore\n * reusable reader for streams and files, we just need a way to read an\n * additional chunk (of some undetermined size) and a way to close the\n * reader when finished\n * @param {() => Promise<Uint8Array|null>} readChunk\n * @returns {BytesReader}\n */\nexport function chunkReader (readChunk /*, closer */) {\n  let pos = 0\n  let have = 0\n  let offset = 0\n  let currentChunk = new Uint8Array(0)\n\n  const read = async (/** @type {number} */ length) => {\n    have = currentChunk.length - offset\n    const bufa = [currentChunk.subarray(offset)]\n    while (have < length) {\n      const chunk = await readChunk()\n      if (chunk == null) {\n        break\n      }\n      /* c8 ignore next 8 */\n      // undo this ignore ^ when we have a fd implementation that can seek()\n      if (have < 0) { // because of a seek()\n        /* c8 ignore next 4 */\n        // toohard to test the else\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have))\n        } // else discard\n      } else {\n        bufa.push(chunk)\n      }\n      have += chunk.length\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0))\n    let off = 0\n    for (const b of bufa) {\n      currentChunk.set(b, off)\n      off += b.length\n    }\n    offset = 0\n  }\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length))\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    async exactly (length, seek = false) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = currentChunk.subarray(offset, offset + length)\n      if (seek) {\n        pos += length\n        offset += length\n      }\n      return out\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    seek (length) {\n      pos += length\n      offset += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from an `AsyncIterable<Uint8Array>`, which allows for\n * consumption of CAR data from a streaming source.\n *\n * @name decoder.asyncIterableReader(asyncIterable)\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {BytesReader}\n */\nexport function asyncIterableReader (asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]()\n\n  async function readChunk () {\n    const next = await iterator.next()\n    if (next.done) {\n      return null\n    }\n    return next.value\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  return chunkReader(readChunk)\n}\n\n/**\n * Wraps a `BytesReader` in a limiting `BytesReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesReader} reader\n * @param {number} byteLimit\n * @returns {BytesReader}\n */\nexport function limitReader (reader, byteLimit) {\n  let bytesRead = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      let bytes = await reader.upTo(length)\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead)\n      }\n      return bytes\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    async exactly (length, seek = false) {\n      const bytes = await reader.exactly(length, seek)\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data')\n      }\n      if (seek) {\n        bytesRead += length\n      }\n      return bytes\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    seek (length) {\n      bytesRead += length\n      reader.seek(length)\n    },\n\n    get pos () {\n      return reader.pos\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}