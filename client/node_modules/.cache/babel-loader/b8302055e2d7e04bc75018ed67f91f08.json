{"ast":null,"code":"import parseDuration from 'parse-duration';\nimport errCode from 'err-code';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\n/**\n * @typedef {import('ipfs-core-types/src/stats').BWOptions} BWOptions\n * @typedef {import('ipfs-core-types/src/stats').BWResult} BandwidthInfo\n * @typedef {import('libp2p').Libp2p} libp2p\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {libp2p} libp2p\n * @param {BWOptions} opts\n * @returns {BandwidthInfo}\n */\n\nfunction getBandwidthStats(libp2p, opts) {\n  /*\n    let stats\n  \n    if (!libp2p.metrics) {\n      stats = undefined\n    } else if (opts.peer) {\n      stats = libp2p.metrics.forPeer(opts.peer)\n    } else if (opts.proto) {\n      stats = libp2p.metrics.forProtocol(opts.proto)\n    } else {\n      stats = libp2p.metrics.getGlobal()\n    }\n  */\n  //  if (!stats) {\n  return {\n    totalIn: BigInt(0),\n    totalOut: BigInt(0),\n    rateIn: 0.0,\n    rateOut: 0.0\n  }; //  }\n\n  /*\n    const movingAverages = stats.getMovingAverages()\n    const snapshot = stats.getSnapshot()\n  \n    return {\n      totalIn: snapshot.dataReceived,\n      totalOut: snapshot.dataSent,\n      rateIn: movingAverages.dataReceived[60000].movingAverage / 60,\n      rateOut: movingAverages.dataSent[60000].movingAverage / 60\n    }\n  */\n}\n/**\n * @param {object} config\n * @param {import('../../types').NetworkService} config.network\n */\n\n\nexport function createBw(_ref) {\n  let {\n    network\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/stats').API<{}>[\"bw\"]}\n   */\n  const bw = async function* () {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      libp2p\n    } = await network.use(options);\n\n    if (!options.poll) {\n      yield getBandwidthStats(libp2p, options);\n      return;\n    }\n\n    const interval = options.interval || 1000;\n    let ms = -1;\n\n    try {\n      ms = typeof interval === 'string' ? parseDuration(interval) || -1 : interval;\n      if (!ms || ms < 0) throw new Error('invalid duration');\n    } catch (\n    /** @type {any} */\n    err) {\n      throw errCode(err, 'ERR_INVALID_POLL_INTERVAL');\n    }\n\n    let timeoutId;\n\n    try {\n      while (true) {\n        yield getBandwidthStats(libp2p, options); // eslint-disable-next-line no-loop-func\n\n        await new Promise(resolve => {\n          timeoutId = setTimeout(resolve, ms);\n        });\n      }\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  };\n\n  return withTimeoutOption(bw);\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/stats/bw.js"],"names":["parseDuration","errCode","withTimeoutOption","getBandwidthStats","libp2p","opts","totalIn","BigInt","totalOut","rateIn","rateOut","createBw","network","bw","options","use","poll","interval","ms","Error","err","timeoutId","Promise","resolve","setTimeout","clearTimeout"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,gBAA1B;AACA,OAAOC,OAAP,MAAoB,UAApB;AACA,SAASC,iBAAT,QAAkC,qCAAlC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASC,iBAAT,CAA4BC,MAA5B,EAAoCC,IAApC,EAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;AACA,SAAO;AACLC,IAAAA,OAAO,EAAEC,MAAM,CAAC,CAAD,CADV;AAELC,IAAAA,QAAQ,EAAED,MAAM,CAAC,CAAD,CAFX;AAGLE,IAAAA,MAAM,EAAE,GAHH;AAILC,IAAAA,OAAO,EAAE;AAJJ,GAAP,CAfwC,CAqBxC;;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACC;AAED;AACA;AACA;AACA;;;AACA,OAAO,SAASC,QAAT,OAAgC;AAAA,MAAb;AAAEC,IAAAA;AAAF,GAAa;;AACrC;AACF;AACA;AACE,QAAMC,EAAE,GAAG,mBAAgC;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AACzC,UAAM;AAAEV,MAAAA;AAAF,QAAa,MAAMQ,OAAO,CAACG,GAAR,CAAYD,OAAZ,CAAzB;;AAEA,QAAI,CAACA,OAAO,CAACE,IAAb,EAAmB;AACjB,YAAMb,iBAAiB,CAACC,MAAD,EAASU,OAAT,CAAvB;AACA;AACD;;AAED,UAAMG,QAAQ,GAAGH,OAAO,CAACG,QAAR,IAAoB,IAArC;AACA,QAAIC,EAAE,GAAG,CAAC,CAAV;;AACA,QAAI;AACFA,MAAAA,EAAE,GAAG,OAAOD,QAAP,KAAoB,QAApB,GAA+BjB,aAAa,CAACiB,QAAD,CAAb,IAA2B,CAAC,CAA3D,GAA+DA,QAApE;AACA,UAAI,CAACC,EAAD,IAAOA,EAAE,GAAG,CAAhB,EAAmB,MAAM,IAAIC,KAAJ,CAAU,kBAAV,CAAN;AACpB,KAHD,CAGE;AAAO;AAAmBC,IAAAA,GAA1B,EAA+B;AAC/B,YAAMnB,OAAO,CAACmB,GAAD,EAAM,2BAAN,CAAb;AACD;;AAED,QAAIC,SAAJ;;AACA,QAAI;AACF,aAAO,IAAP,EAAa;AACX,cAAMlB,iBAAiB,CAACC,MAAD,EAASU,OAAT,CAAvB,CADW,CAEX;;AACA,cAAM,IAAIQ,OAAJ,CAAYC,OAAO,IAAI;AAAEF,UAAAA,SAAS,GAAGG,UAAU,CAACD,OAAD,EAAUL,EAAV,CAAtB;AAAqC,SAA9D,CAAN;AACD;AACF,KAND,SAMU;AACRO,MAAAA,YAAY,CAACJ,SAAD,CAAZ;AACD;AACF,GA3BD;;AA6BA,SAAOnB,iBAAiB,CAACW,EAAD,CAAxB;AACD","sourcesContent":["import parseDuration from 'parse-duration'\nimport errCode from 'err-code'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\n/**\n * @typedef {import('ipfs-core-types/src/stats').BWOptions} BWOptions\n * @typedef {import('ipfs-core-types/src/stats').BWResult} BandwidthInfo\n * @typedef {import('libp2p').Libp2p} libp2p\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {libp2p} libp2p\n * @param {BWOptions} opts\n * @returns {BandwidthInfo}\n */\nfunction getBandwidthStats (libp2p, opts) {\n/*\n  let stats\n\n  if (!libp2p.metrics) {\n    stats = undefined\n  } else if (opts.peer) {\n    stats = libp2p.metrics.forPeer(opts.peer)\n  } else if (opts.proto) {\n    stats = libp2p.metrics.forProtocol(opts.proto)\n  } else {\n    stats = libp2p.metrics.getGlobal()\n  }\n*/\n  //  if (!stats) {\n  return {\n    totalIn: BigInt(0),\n    totalOut: BigInt(0),\n    rateIn: 0.0,\n    rateOut: 0.0\n  }\n  //  }\n/*\n  const movingAverages = stats.getMovingAverages()\n  const snapshot = stats.getSnapshot()\n\n  return {\n    totalIn: snapshot.dataReceived,\n    totalOut: snapshot.dataSent,\n    rateIn: movingAverages.dataReceived[60000].movingAverage / 60,\n    rateOut: movingAverages.dataSent[60000].movingAverage / 60\n  }\n*/\n}\n\n/**\n * @param {object} config\n * @param {import('../../types').NetworkService} config.network\n */\nexport function createBw ({ network }) {\n  /**\n   * @type {import('ipfs-core-types/src/stats').API<{}>[\"bw\"]}\n   */\n  const bw = async function * (options = {}) {\n    const { libp2p } = await network.use(options)\n\n    if (!options.poll) {\n      yield getBandwidthStats(libp2p, options)\n      return\n    }\n\n    const interval = options.interval || 1000\n    let ms = -1\n    try {\n      ms = typeof interval === 'string' ? parseDuration(interval) || -1 : interval\n      if (!ms || ms < 0) throw new Error('invalid duration')\n    } catch (/** @type {any} */ err) {\n      throw errCode(err, 'ERR_INVALID_POLL_INTERVAL')\n    }\n\n    let timeoutId\n    try {\n      while (true) {\n        yield getBandwidthStats(libp2p, options)\n        // eslint-disable-next-line no-loop-func\n        await new Promise(resolve => { timeoutId = setTimeout(resolve, ms) })\n      }\n    } finally {\n      clearTimeout(timeoutId)\n    }\n  }\n\n  return withTimeoutOption(bw)\n}\n"]},"metadata":{},"sourceType":"module"}