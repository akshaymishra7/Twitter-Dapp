{"ast":null,"code":"import { Key } from 'interface-datastore';\nimport { BaseDatastore, Errors } from 'datastore-core';\nimport filter from 'it-filter';\nimport map from 'it-map';\nimport take from 'it-take';\nimport sort from 'it-sort';\nimport { Level } from 'level';\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Options} QueryOptions\n * @typedef {import('abstract-level').AbstractLevel<any, string, Uint8Array>} LevelDb\n */\n\n/**\n * A datastore backed by leveldb\n */\n\nexport class LevelDatastore extends BaseDatastore {\n  /**\n   * @param {string | LevelDb} path\n   * @param {import('level').DatabaseOptions<string, Uint8Array> & import('level').OpenOptions} [opts]\n   */\n  constructor(path) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    /** @type {LevelDb} */\n\n    this.db = typeof path === 'string' ? new Level(path, { ...opts,\n      keyEncoding: 'utf8',\n      valueEncoding: 'view'\n    }) : path;\n    /** @type {import('level').OpenOptions} */\n\n    this.opts = {\n      createIfMissing: true,\n      compression: false,\n      // same default as go\n      ...opts\n    };\n  }\n\n  async open() {\n    try {\n      await this.db.open(this.opts);\n    } catch (\n    /** @type {any} */\n    err) {\n      throw Errors.dbOpenFailedError(err);\n    }\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   */\n\n\n  async put(key, value) {\n    try {\n      await this.db.put(key.toString(), value);\n    } catch (\n    /** @type {any} */\n    err) {\n      throw Errors.dbWriteFailedError(err);\n    }\n  }\n  /**\n   * @param {Key} key\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  async get(key) {\n    let data;\n\n    try {\n      data = await this.db.get(key.toString());\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.notFound) throw Errors.notFoundError(err);\n      throw Errors.dbWriteFailedError(err);\n    }\n\n    return data;\n  }\n  /**\n   * @param {Key} key\n   * @returns {Promise<boolean>}\n   */\n\n\n  async has(key) {\n    try {\n      await this.db.get(key.toString());\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.notFound) return false;\n      throw err;\n    }\n\n    return true;\n  }\n  /**\n   * @param {Key} key\n   * @returns {Promise<void>}\n   */\n\n\n  async delete(key) {\n    try {\n      await this.db.del(key.toString());\n    } catch (\n    /** @type {any} */\n    err) {\n      throw Errors.dbDeleteFailedError(err);\n    }\n  }\n\n  close() {\n    return this.db && this.db.close();\n  }\n  /**\n   * @returns {Batch}\n   */\n\n\n  batch() {\n    /** @type {Array<{ type: 'put', key: string, value: Uint8Array; } | { type: 'del', key: string }>} */\n    const ops = [];\n    return {\n      put: (key, value) => {\n        ops.push({\n          type: 'put',\n          key: key.toString(),\n          value: value\n        });\n      },\n      delete: key => {\n        ops.push({\n          type: 'del',\n          key: key.toString()\n        });\n      },\n      commit: () => {\n        return this.db.batch(ops);\n      }\n    };\n  }\n  /**\n   * @param {Query} q\n   */\n\n\n  query(q) {\n    let it = this._query({\n      values: true,\n      prefix: q.prefix\n    });\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it);\n    }\n\n    const {\n      offset,\n      limit\n    } = q;\n\n    if (offset) {\n      let i = 0;\n      it = filter(it, () => i++ >= offset);\n    }\n\n    if (limit) {\n      it = take(it, limit);\n    }\n\n    return it;\n  }\n  /**\n   * @param {KeyQuery} q\n   */\n\n\n  queryKeys(q) {\n    let it = map(this._query({\n      values: false,\n      prefix: q.prefix\n    }), _ref => {\n      let {\n        key\n      } = _ref;\n      return key;\n    });\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it);\n    }\n\n    const {\n      offset,\n      limit\n    } = q;\n\n    if (offset) {\n      let i = 0;\n      it = filter(it, () => i++ >= offset);\n    }\n\n    if (limit) {\n      it = take(it, limit);\n    }\n\n    return it;\n  }\n  /**\n   * @param {object} opts\n   * @param {boolean} opts.values\n   * @param {string} [opts.prefix]\n   * @returns {AsyncIterable<Pair>}\n   */\n\n\n  _query(opts) {\n    /** @type {import('level').IteratorOptions<string, Uint8Array>} */\n    const iteratorOpts = {\n      keys: true,\n      keyEncoding: 'buffer',\n      values: opts.values\n    }; // Let the db do the prefix matching\n\n    if (opts.prefix != null) {\n      const prefix = opts.prefix.toString(); // Match keys greater than or equal to `prefix` and\n\n      iteratorOpts.gte = prefix; // less than `prefix` + \\xFF (hex escape sequence)\n\n      iteratorOpts.lt = prefix + '\\xFF';\n    }\n\n    const iterator = this.db.iterator(iteratorOpts);\n\n    if (iterator[Symbol.asyncIterator]) {\n      return levelIteratorToIterator(iterator);\n    } // @ts-expect-error support older level\n\n\n    if (iterator.next != null && iterator.end != null) {\n      // @ts-expect-error support older level\n      return oldLevelIteratorToIterator(iterator);\n    }\n\n    throw new Error('Level returned incompatible iterator');\n  }\n\n}\n/**\n * @param {import('level').Iterator<LevelDb, string, Uint8Array>} li - Level iterator\n * @returns {AsyncIterable<Pair>}\n */\n\nasync function* levelIteratorToIterator(li) {\n  for await (const [key, value] of li) {\n    yield {\n      key: new Key(key, false),\n      value\n    };\n  }\n\n  await li.close();\n}\n/**\n * @typedef {object} LevelIterator\n * @property {(cb: (err: Error, key: string | Uint8Array | null, value: any)=> void)=>void} next\n * @property {(cb: (err: Error) => void) => void } end\n */\n\n/**\n * @param {LevelIterator} li - Level iterator\n * @returns {AsyncIterable<Pair>}\n */\n\n\nfunction oldLevelIteratorToIterator(li) {\n  return {\n    [Symbol.asyncIterator]() {\n      return {\n        next: () => new Promise((resolve, reject) => {\n          li.next((err, key, value) => {\n            if (err) return reject(err);\n\n            if (key == null) {\n              return li.end(err => {\n                if (err) return reject(err);\n                resolve({\n                  done: true,\n                  value: undefined\n                });\n              });\n            }\n\n            resolve({\n              done: false,\n              value: {\n                key: new Key(key, false),\n                value\n              }\n            });\n          });\n        }),\n        return: () => new Promise((resolve, reject) => {\n          li.end(err => {\n            if (err) return reject(err);\n            resolve({\n              done: true,\n              value: undefined\n            });\n          });\n        })\n      };\n    }\n\n  };\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/datastore-level/src/index.js"],"names":["Key","BaseDatastore","Errors","filter","map","take","sort","Level","LevelDatastore","constructor","path","opts","db","keyEncoding","valueEncoding","createIfMissing","compression","open","err","dbOpenFailedError","put","key","value","toString","dbWriteFailedError","get","data","notFound","notFoundError","has","delete","del","dbDeleteFailedError","close","batch","ops","push","type","commit","query","q","it","_query","values","prefix","Array","isArray","filters","reduce","f","orders","offset","limit","i","queryKeys","iteratorOpts","keys","gte","lt","iterator","Symbol","asyncIterator","levelIteratorToIterator","next","end","oldLevelIteratorToIterator","Error","li","Promise","resolve","reject","done","undefined","return"],"mappings":"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","sourcesContent":["import { Key } from 'interface-datastore'\nimport { BaseDatastore, Errors } from 'datastore-core'\nimport filter from 'it-filter'\nimport map from 'it-map'\nimport take from 'it-take'\nimport sort from 'it-sort'\nimport { Level } from 'level'\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Options} QueryOptions\n * @typedef {import('abstract-level').AbstractLevel<any, string, Uint8Array>} LevelDb\n */\n\n/**\n * A datastore backed by leveldb\n */\nexport class LevelDatastore extends BaseDatastore {\n  /**\n   * @param {string | LevelDb} path\n   * @param {import('level').DatabaseOptions<string, Uint8Array> & import('level').OpenOptions} [opts]\n   */\n  constructor (path, opts = {}) {\n    super()\n\n    /** @type {LevelDb} */\n    this.db = typeof path === 'string'\n      ? new Level(path, {\n        ...opts,\n        keyEncoding: 'utf8',\n        valueEncoding: 'view'\n      })\n      : path\n\n    /** @type {import('level').OpenOptions} */\n    this.opts = {\n      createIfMissing: true,\n      compression: false, // same default as go\n      ...opts\n    }\n  }\n\n  async open () {\n    try {\n      await this.db.open(this.opts)\n    } catch (/** @type {any} */ err) {\n      throw Errors.dbOpenFailedError(err)\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   */\n  async put (key, value) {\n    try {\n      await this.db.put(key.toString(), value)\n    } catch (/** @type {any} */ err) {\n      throw Errors.dbWriteFailedError(err)\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {Promise<Uint8Array>}\n   */\n  async get (key) {\n    let data\n    try {\n      data = await this.db.get(key.toString())\n    } catch (/** @type {any} */ err) {\n      if (err.notFound) throw Errors.notFoundError(err)\n      throw Errors.dbWriteFailedError(err)\n    }\n    return data\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {Promise<boolean>}\n   */\n  async has (key) {\n    try {\n      await this.db.get(key.toString())\n    } catch (/** @type {any} */ err) {\n      if (err.notFound) return false\n      throw err\n    }\n    return true\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {Promise<void>}\n   */\n  async delete (key) {\n    try {\n      await this.db.del(key.toString())\n    } catch (/** @type {any} */ err) {\n      throw Errors.dbDeleteFailedError(err)\n    }\n  }\n\n  close () {\n    return this.db && this.db.close()\n  }\n\n  /**\n   * @returns {Batch}\n   */\n  batch () {\n    /** @type {Array<{ type: 'put', key: string, value: Uint8Array; } | { type: 'del', key: string }>} */\n    const ops = []\n    return {\n      put: (key, value) => {\n        ops.push({\n          type: 'put',\n          key: key.toString(),\n          value: value\n        })\n      },\n      delete: (key) => {\n        ops.push({\n          type: 'del',\n          key: key.toString()\n        })\n      },\n      commit: () => {\n        return this.db.batch(ops)\n      }\n    }\n  }\n\n  /**\n   * @param {Query} q\n   */\n  query (q) {\n    let it = this._query({\n      values: true,\n      prefix: q.prefix\n    })\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    const { offset, limit } = q\n    if (offset) {\n      let i = 0\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (limit) {\n      it = take(it, limit)\n    }\n\n    return it\n  }\n\n  /**\n   * @param {KeyQuery} q\n   */\n  queryKeys (q) {\n    let it = map(this._query({\n      values: false,\n      prefix: q.prefix\n    }), ({ key }) => key)\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    const { offset, limit } = q\n    if (offset) {\n      let i = 0\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (limit) {\n      it = take(it, limit)\n    }\n\n    return it\n  }\n\n  /**\n   * @param {object} opts\n   * @param {boolean} opts.values\n   * @param {string} [opts.prefix]\n   * @returns {AsyncIterable<Pair>}\n   */\n  _query (opts) {\n    /** @type {import('level').IteratorOptions<string, Uint8Array>} */\n    const iteratorOpts = {\n      keys: true,\n      keyEncoding: 'buffer',\n      values: opts.values\n    }\n\n    // Let the db do the prefix matching\n    if (opts.prefix != null) {\n      const prefix = opts.prefix.toString()\n      // Match keys greater than or equal to `prefix` and\n      iteratorOpts.gte = prefix\n      // less than `prefix` + \\xFF (hex escape sequence)\n      iteratorOpts.lt = prefix + '\\xFF'\n    }\n\n    const iterator = this.db.iterator(iteratorOpts)\n\n    if (iterator[Symbol.asyncIterator]) {\n      return levelIteratorToIterator(iterator)\n    }\n\n    // @ts-expect-error support older level\n    if (iterator.next != null && iterator.end != null) {\n      // @ts-expect-error support older level\n      return oldLevelIteratorToIterator(iterator)\n    }\n\n    throw new Error('Level returned incompatible iterator')\n  }\n}\n\n/**\n * @param {import('level').Iterator<LevelDb, string, Uint8Array>} li - Level iterator\n * @returns {AsyncIterable<Pair>}\n */\nasync function * levelIteratorToIterator (li) {\n  for await (const [key, value] of li) {\n    yield { key: new Key(key, false), value }\n  }\n\n  await li.close()\n}\n\n/**\n * @typedef {object} LevelIterator\n * @property {(cb: (err: Error, key: string | Uint8Array | null, value: any)=> void)=>void} next\n * @property {(cb: (err: Error) => void) => void } end\n */\n\n/**\n * @param {LevelIterator} li - Level iterator\n * @returns {AsyncIterable<Pair>}\n */\nfunction oldLevelIteratorToIterator (li) {\n  return {\n    [Symbol.asyncIterator] () {\n      return {\n        next: () => new Promise((resolve, reject) => {\n          li.next((err, key, value) => {\n            if (err) return reject(err)\n            if (key == null) {\n              return li.end(err => {\n                if (err) return reject(err)\n                resolve({ done: true, value: undefined })\n              })\n            }\n            resolve({ done: false, value: { key: new Key(key, false), value } })\n          })\n        }),\n        return: () => new Promise((resolve, reject) => {\n          li.end(err => {\n            if (err) return reject(err)\n            resolve({ done: true, value: undefined })\n          })\n        })\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}