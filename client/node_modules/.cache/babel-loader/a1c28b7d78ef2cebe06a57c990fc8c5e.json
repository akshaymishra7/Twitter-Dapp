{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport * as lp from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport first from 'it-first';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { multiaddr, protocols } from '@multiformats/multiaddr';\nimport { Identify } from './pb/message.js';\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record';\nimport { MULTICODEC_IDENTIFY, MULTICODEC_IDENTIFY_PUSH, IDENTIFY_PROTOCOL_VERSION, MULTICODEC_IDENTIFY_PROTOCOL_NAME, MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME, MULTICODEC_IDENTIFY_PROTOCOL_VERSION, MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION } from './consts.js';\nimport { codes } from '../errors.js';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { abortableDuplex } from 'abortable-iterator';\nimport { setMaxListeners } from 'events';\nconst log = logger('libp2p:identify'); // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L52\n\nconst MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;\nexport class IdentifyService {\n  constructor(components, init) {\n    this.components = components;\n    this.started = false;\n    this.init = init;\n    this.identifyProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`;\n    this.identifyPushProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`; // Store self host metadata\n\n    this.host = {\n      protocolVersion: `${init.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n      ...init.host\n    }; // When a new connection happens, trigger identify\n\n    this.components.connectionManager.addEventListener('peer:connect', evt => {\n      const connection = evt.detail;\n      this.identify(connection).catch(log.error);\n    }); // When self multiaddrs change, trigger identify-push\n\n    this.components.peerStore.addEventListener('change:multiaddrs', evt => {\n      const {\n        peerId\n      } = evt.detail;\n\n      if (this.components.peerId.equals(peerId)) {\n        void this.pushToPeerStore().catch(err => log.error(err));\n      }\n    }); // When self protocols change, trigger identify-push\n\n    this.components.peerStore.addEventListener('change:protocols', evt => {\n      const {\n        peerId\n      } = evt.detail;\n\n      if (this.components.peerId.equals(peerId)) {\n        void this.pushToPeerStore().catch(err => log.error(err));\n      }\n    });\n  }\n\n  isStarted() {\n    return this.started;\n  }\n\n  async start() {\n    if (this.started) {\n      return;\n    }\n\n    await this.components.peerStore.metadataBook.setValue(this.components.peerId, 'AgentVersion', uint8ArrayFromString(this.host.agentVersion));\n    await this.components.peerStore.metadataBook.setValue(this.components.peerId, 'ProtocolVersion', uint8ArrayFromString(this.host.protocolVersion));\n    await this.components.registrar.handle(this.identifyProtocolStr, data => {\n      void this._handleIdentify(data).catch(err => {\n        log.error(err);\n      });\n    }, {\n      maxInboundStreams: this.init.maxInboundStreams,\n      maxOutboundStreams: this.init.maxOutboundStreams\n    });\n    await this.components.registrar.handle(this.identifyPushProtocolStr, data => {\n      void this._handlePush(data).catch(err => {\n        log.error(err);\n      });\n    }, {\n      maxInboundStreams: this.init.maxPushIncomingStreams,\n      maxOutboundStreams: this.init.maxPushOutgoingStreams\n    });\n    this.started = true;\n  }\n\n  async stop() {\n    await this.components.registrar.unhandle(this.identifyProtocolStr);\n    await this.components.registrar.unhandle(this.identifyPushProtocolStr);\n    this.started = false;\n  }\n  /**\n   * Send an Identify Push update to the list of connections\n   */\n\n\n  async push(connections) {\n    const signedPeerRecord = await this.components.peerStore.addressBook.getRawEnvelope(this.components.peerId);\n    const listenAddrs = this.components.addressManager.getAddresses().map(ma => ma.bytes);\n    const protocols = await this.components.peerStore.protoBook.get(this.components.peerId);\n    const pushes = connections.map(async connection => {\n      let stream;\n      const timeoutController = new TimeoutController(this.init.timeout);\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal);\n      } catch {}\n\n      try {\n        stream = await connection.newStream([this.identifyPushProtocolStr], {\n          signal: timeoutController.signal\n        }); // make stream abortable\n\n        const source = abortableDuplex(stream, timeoutController.signal);\n        await source.sink(pipe([Identify.encode({\n          listenAddrs,\n          signedPeerRecord,\n          protocols\n        })], lp.encode()));\n      } catch (err) {\n        // Just log errors\n        log.error('could not push identify update to peer', err);\n      } finally {\n        if (stream != null) {\n          stream.close();\n        }\n\n        timeoutController.clear();\n      }\n    });\n    await Promise.all(pushes);\n  }\n  /**\n   * Calls `push` on all peer connections\n   */\n\n\n  async pushToPeerStore() {\n    // Do not try to push if we are not running\n    if (!this.isStarted()) {\n      return;\n    }\n\n    const connections = [];\n\n    for (const conn of this.components.connectionManager.getConnections()) {\n      const peerId = conn.remotePeer;\n      const peer = await this.components.peerStore.get(peerId);\n\n      if (!peer.protocols.includes(this.identifyPushProtocolStr)) {\n        continue;\n      }\n\n      connections.push(conn);\n    }\n\n    await this.push(connections);\n  }\n\n  async _identify(connection) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let timeoutController;\n    let signal = options.signal;\n    let stream; // create a timeout if no abort signal passed\n\n    if (signal == null) {\n      timeoutController = new TimeoutController(this.init.timeout);\n      signal = timeoutController.signal;\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal);\n      } catch {}\n    }\n\n    try {\n      stream = await connection.newStream([this.identifyProtocolStr], {\n        signal\n      }); // make stream abortable\n\n      const source = abortableDuplex(stream, signal);\n      const data = await pipe([], source, lp.decode({\n        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n      }), async source => await first(source));\n\n      if (data == null) {\n        throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED);\n      }\n\n      try {\n        return Identify.decode(data);\n      } catch (err) {\n        throw errCode(err, codes.ERR_INVALID_MESSAGE);\n      }\n    } finally {\n      if (timeoutController != null) {\n        timeoutController.clear();\n      }\n\n      if (stream != null) {\n        stream.close();\n      }\n    }\n  }\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   */\n\n\n  async identify(connection) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const message = await this._identify(connection, options);\n    const {\n      publicKey,\n      listenAddrs,\n      protocols,\n      observedAddr,\n      signedPeerRecord,\n      agentVersion,\n      protocolVersion\n    } = message;\n\n    if (publicKey == null) {\n      throw errCode(new Error('public key was missing from identify message'), codes.ERR_MISSING_PUBLIC_KEY);\n    }\n\n    const id = await peerIdFromKeys(publicKey);\n\n    if (!connection.remotePeer.equals(id)) {\n      throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n    }\n\n    if (this.components.peerId.equals(id)) {\n      throw errCode(new Error('identified peer is our own peer id?'), codes.ERR_INVALID_PEER);\n    } // Get the observedAddr if there is one\n\n\n    const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);\n\n    if (signedPeerRecord != null) {\n      log('received signed peer record from %p', id);\n\n      try {\n        const envelope = await RecordEnvelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN);\n\n        if (!envelope.peerId.equals(id)) {\n          throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n        }\n\n        if (await this.components.peerStore.addressBook.consumePeerRecord(envelope)) {\n          await this.components.peerStore.protoBook.set(id, protocols);\n\n          if (agentVersion != null) {\n            await this.components.peerStore.metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(agentVersion));\n          }\n\n          if (protocolVersion != null) {\n            await this.components.peerStore.metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(protocolVersion));\n          }\n\n          log('identify completed for peer %p and protocols %o', id, protocols);\n          return;\n        }\n      } catch (err) {\n        log('received invalid envelope, discard it and fallback to listenAddrs is available', err);\n      }\n    } else {\n      log('no signed peer record received from %p', id);\n    }\n\n    log('falling back to legacy addresses from %p', id); // LEGACY: Update peers data in PeerStore\n\n    try {\n      await this.components.peerStore.addressBook.set(id, listenAddrs.map(addr => multiaddr(addr)));\n    } catch (err) {\n      log.error('received invalid addrs', err);\n    }\n\n    await this.components.peerStore.protoBook.set(id, protocols);\n\n    if (agentVersion != null) {\n      await this.components.peerStore.metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(agentVersion));\n    }\n\n    if (protocolVersion != null) {\n      await this.components.peerStore.metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(protocolVersion));\n    }\n\n    log('identify completed for peer %p and protocols %o', id, protocols); // TODO: Add and score our observed addr\n\n    log('received observed address of %s', cleanObservedAddr?.toString()); // this.components.addressManager.addObservedAddr(observedAddr)\n  }\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   */\n\n\n  async _handleIdentify(data) {\n    const {\n      connection,\n      stream\n    } = data;\n    const timeoutController = new TimeoutController(this.init.timeout);\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, timeoutController.signal);\n    } catch {}\n\n    try {\n      const publicKey = this.components.peerId.publicKey ?? new Uint8Array(0);\n      const peerData = await this.components.peerStore.get(this.components.peerId);\n      const multiaddrs = this.components.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code));\n      let signedPeerRecord = peerData.peerRecordEnvelope;\n\n      if (multiaddrs.length > 0 && signedPeerRecord == null) {\n        const peerRecord = new PeerRecord({\n          peerId: this.components.peerId,\n          multiaddrs\n        });\n        const envelope = await RecordEnvelope.seal(peerRecord, this.components.peerId);\n        await this.components.peerStore.addressBook.consumePeerRecord(envelope);\n        signedPeerRecord = envelope.marshal().subarray();\n      }\n\n      const message = Identify.encode({\n        protocolVersion: this.host.protocolVersion,\n        agentVersion: this.host.agentVersion,\n        publicKey,\n        listenAddrs: multiaddrs.map(addr => addr.bytes),\n        signedPeerRecord,\n        observedAddr: connection.remoteAddr.bytes,\n        protocols: peerData.protocols\n      }); // make stream abortable\n\n      const source = abortableDuplex(stream, timeoutController.signal);\n      const msgWithLenPrefix = pipe([message], lp.encode());\n      await source.sink(msgWithLenPrefix);\n    } catch (err) {\n      log.error('could not respond to identify request', err);\n    } finally {\n      stream.close();\n      timeoutController.clear();\n    }\n  }\n  /**\n   * Reads the Identify Push message from the given `connection`\n   */\n\n\n  async _handlePush(data) {\n    const {\n      connection,\n      stream\n    } = data;\n    const timeoutController = new TimeoutController(this.init.timeout);\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, timeoutController.signal);\n    } catch {}\n\n    let message;\n\n    try {\n      // make stream abortable\n      const source = abortableDuplex(stream, timeoutController.signal);\n      const data = await pipe([], source, lp.decode({\n        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n      }), async source => await first(source));\n\n      if (data != null) {\n        message = Identify.decode(data);\n      }\n    } catch (err) {\n      return log.error('received invalid message', err);\n    } finally {\n      stream.close();\n      timeoutController.clear();\n    }\n\n    if (message == null) {\n      return log.error('received invalid message');\n    }\n\n    const id = connection.remotePeer;\n\n    if (this.components.peerId.equals(id)) {\n      log('received push from ourselves?');\n      return;\n    }\n\n    log('received push from %p', id);\n\n    if (message.signedPeerRecord != null) {\n      log('received signedPeerRecord in push');\n\n      try {\n        const envelope = await RecordEnvelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN);\n\n        if (await this.components.peerStore.addressBook.consumePeerRecord(envelope)) {\n          log('consumed signedPeerRecord sent in push');\n          await this.components.peerStore.protoBook.set(id, message.protocols);\n          return;\n        } else {\n          log('failed to consume signedPeerRecord sent in push');\n        }\n      } catch (err) {\n        log('received invalid envelope, discard it and fallback to listenAddrs is available', err);\n      }\n    } else {\n      log('did not receive signedPeerRecord in push');\n    } // LEGACY: Update peers data in PeerStore\n\n\n    try {\n      await this.components.peerStore.addressBook.set(id, message.listenAddrs.map(addr => multiaddr(addr)));\n    } catch (err) {\n      log.error('received invalid addrs', err);\n    } // Update the protocols\n\n\n    try {\n      await this.components.peerStore.protoBook.set(id, message.protocols);\n    } catch (err) {\n      log.error('received invalid protocols', err);\n    }\n\n    log('handled push from %p', id);\n  }\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   */\n\n\n  static getCleanMultiaddr(addr) {\n    if (addr != null && addr.length > 0) {\n      try {\n        return multiaddr(addr);\n      } catch {}\n    }\n  }\n\n}\n/**\n * The protocols the IdentifyService supports\n */\n\nexport const multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n};\nexport const Message = {\n  Identify\n};","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,QAAuB,gBAAvB;AACA,OAAOC,OAAP,MAAoB,UAApB;AACA,OAAO,KAAKC,EAAZ,MAAoB,oBAApB;AACA,SAASC,IAAT,QAAqB,SAArB;AACA,OAAOC,KAAP,MAAkB,UAAlB;AACA,SAASC,UAAU,IAAIC,oBAAvB,QAAmD,yBAAnD;AACA,SAASC,SAAT,EAAoBC,SAApB,QAAqC,yBAArC;AACA,SAASC,QAAT,QAAyB,iBAAzB;AACA,SAASC,cAAT,EAAyBC,UAAzB,QAA2C,qBAA3C;AACA,SACEC,mBADF,EAEEC,wBAFF,EAGEC,yBAHF,EAIEC,iCAJF,EAKEC,sCALF,EAMEC,oCANF,EAOEC,yCAPF,QAQO,aARP;AASA,SAASC,KAAT,QAAsB,cAAtB;AAIA,SAASC,cAAT,QAA+B,iBAA/B;AACA,SAASC,iBAAT,QAAkC,0BAAlC;AAEA,SAASC,eAAT,QAAgC,oBAAhC;AACA,SAASC,eAAT,QAAgC,QAAhC;AAMA,MAAMC,GAAG,GAAGxB,MAAM,CAAC,iBAAD,CAAlB,C,CAEA;;AACA,MAAMyB,yBAAyB,GAAG,OAAO,CAAzC;AA0CA,OAAM,MAAOC,eAAP,CAAsB;AAY1BC,cAAaC,UAAb,EAAoDC,IAApD,EAA6E;AAC3E,SAAKD,UAAL,GAAkBA,UAAlB;AACA,SAAKE,OAAL,GAAe,KAAf;AACA,SAAKD,IAAL,GAAYA,IAAZ;AAEA,SAAKE,mBAAL,GAA2B,IAAIF,IAAI,CAACG,cAAc,IAAIjB,iCAAiC,IAAIE,oCAAoC,EAA/H;AACA,SAAKgB,uBAAL,GAA+B,IAAIJ,IAAI,CAACG,cAAc,IAAIhB,sCAAsC,IAAIE,yCAAyC,EAA7I,CAN2E,CAQ3E;;AACA,SAAKgB,IAAL,GAAY;AACVC,qBAAe,EAAE,GAAGN,IAAI,CAACG,cAAc,IAAIlB,yBAAyB,EAD1D;AAEV,SAAGe,IAAI,CAACK;AAFE,KAAZ,CAT2E,CAc3E;;AACA,SAAKN,UAAL,CAAgBQ,iBAAhB,CAAkCC,gBAAlC,CAAmD,cAAnD,EAAoEC,GAAD,IAAQ;AACzE,YAAMC,UAAU,GAAGD,GAAG,CAACE,MAAvB;AACA,WAAKC,QAAL,CAAcF,UAAd,EAA0BG,KAA1B,CAAgClB,GAAG,CAACmB,KAApC;AACD,KAHD,EAf2E,CAoB3E;;AACA,SAAKf,UAAL,CAAgBgB,SAAhB,CAA0BP,gBAA1B,CAA2C,mBAA3C,EAAiEC,GAAD,IAAQ;AACtE,YAAM;AAAEO;AAAF,UAAaP,GAAG,CAACE,MAAvB;;AAEA,UAAI,KAAKZ,UAAL,CAAgBiB,MAAhB,CAAuBC,MAAvB,CAA8BD,MAA9B,CAAJ,EAA2C;AACzC,aAAK,KAAKE,eAAL,GAAuBL,KAAvB,CAA6BM,GAAG,IAAIxB,GAAG,CAACmB,KAAJ,CAAUK,GAAV,CAApC,CAAL;AACD;AACF,KAND,EArB2E,CA6B3E;;AACA,SAAKpB,UAAL,CAAgBgB,SAAhB,CAA0BP,gBAA1B,CAA2C,kBAA3C,EAAgEC,GAAD,IAAQ;AACrE,YAAM;AAAEO;AAAF,UAAaP,GAAG,CAACE,MAAvB;;AAEA,UAAI,KAAKZ,UAAL,CAAgBiB,MAAhB,CAAuBC,MAAvB,CAA8BD,MAA9B,CAAJ,EAA2C;AACzC,aAAK,KAAKE,eAAL,GAAuBL,KAAvB,CAA6BM,GAAG,IAAIxB,GAAG,CAACmB,KAAJ,CAAUK,GAAV,CAApC,CAAL;AACD;AACF,KAND;AAOD;;AAEDC,WAAS;AACP,WAAO,KAAKnB,OAAZ;AACD;;AAEU,QAALoB,KAAK;AACT,QAAI,KAAKpB,OAAT,EAAkB;AAChB;AACD;;AAED,UAAM,KAAKF,UAAL,CAAgBgB,SAAhB,CAA0BO,YAA1B,CAAuCC,QAAvC,CAAgD,KAAKxB,UAAL,CAAgBiB,MAAhE,EAAwE,cAAxE,EAAwFvC,oBAAoB,CAAC,KAAK4B,IAAL,CAAUmB,YAAX,CAA5G,CAAN;AACA,UAAM,KAAKzB,UAAL,CAAgBgB,SAAhB,CAA0BO,YAA1B,CAAuCC,QAAvC,CAAgD,KAAKxB,UAAL,CAAgBiB,MAAhE,EAAwE,iBAAxE,EAA2FvC,oBAAoB,CAAC,KAAK4B,IAAL,CAAUC,eAAX,CAA/G,CAAN;AAEA,UAAM,KAAKP,UAAL,CAAgB0B,SAAhB,CAA0BC,MAA1B,CAAiC,KAAKxB,mBAAtC,EAA4DyB,IAAD,IAAS;AACxE,WAAK,KAAKC,eAAL,CAAqBD,IAArB,EAA2Bd,KAA3B,CAAiCM,GAAG,IAAG;AAC1CxB,WAAG,CAACmB,KAAJ,CAAUK,GAAV;AACD,OAFI,CAAL;AAGD,KAJK,EAIH;AACDU,uBAAiB,EAAE,KAAK7B,IAAL,CAAU6B,iBAD5B;AAEDC,wBAAkB,EAAE,KAAK9B,IAAL,CAAU8B;AAF7B,KAJG,CAAN;AAQA,UAAM,KAAK/B,UAAL,CAAgB0B,SAAhB,CAA0BC,MAA1B,CAAiC,KAAKtB,uBAAtC,EAAgEuB,IAAD,IAAS;AAC5E,WAAK,KAAKI,WAAL,CAAiBJ,IAAjB,EAAuBd,KAAvB,CAA6BM,GAAG,IAAG;AACtCxB,WAAG,CAACmB,KAAJ,CAAUK,GAAV;AACD,OAFI,CAAL;AAGD,KAJK,EAIH;AACDU,uBAAiB,EAAE,KAAK7B,IAAL,CAAUgC,sBAD5B;AAEDF,wBAAkB,EAAE,KAAK9B,IAAL,CAAUiC;AAF7B,KAJG,CAAN;AASA,SAAKhC,OAAL,GAAe,IAAf;AACD;;AAES,QAAJiC,IAAI;AACR,UAAM,KAAKnC,UAAL,CAAgB0B,SAAhB,CAA0BU,QAA1B,CAAmC,KAAKjC,mBAAxC,CAAN;AACA,UAAM,KAAKH,UAAL,CAAgB0B,SAAhB,CAA0BU,QAA1B,CAAmC,KAAK/B,uBAAxC,CAAN;AAEA,SAAKH,OAAL,GAAe,KAAf;AACD;AAED;;;;;AAGU,QAAJmC,IAAI,CAAEC,WAAF,EAA2B;AACnC,UAAMC,gBAAgB,GAAG,MAAM,KAAKvC,UAAL,CAAgBgB,SAAhB,CAA0BwB,WAA1B,CAAsCC,cAAtC,CAAqD,KAAKzC,UAAL,CAAgBiB,MAArE,CAA/B;AACA,UAAMyB,WAAW,GAAG,KAAK1C,UAAL,CAAgB2C,cAAhB,CAA+BC,YAA/B,GAA8CC,GAA9C,CAAmDC,EAAD,IAAQA,EAAE,CAACC,KAA7D,CAApB;AACA,UAAMnE,SAAS,GAAG,MAAM,KAAKoB,UAAL,CAAgBgB,SAAhB,CAA0BgC,SAA1B,CAAoCC,GAApC,CAAwC,KAAKjD,UAAL,CAAgBiB,MAAxD,CAAxB;AAEA,UAAMiC,MAAM,GAAGZ,WAAW,CAACO,GAAZ,CAAgB,MAAMlC,UAAN,IAAmB;AAChD,UAAIwC,MAAJ;AACA,YAAMC,iBAAiB,GAAG,IAAI3D,iBAAJ,CAAsB,KAAKQ,IAAL,CAAUoD,OAAhC,CAA1B;;AAEA,UAAI;AACF;AACA1D,uBAAe,GAAG2D,QAAH,EAAaF,iBAAiB,CAACG,MAA/B,CAAf;AACD,OAHD,CAGE,MAAM,CAAE;;AAEV,UAAI;AACFJ,cAAM,GAAG,MAAMxC,UAAU,CAAC6C,SAAX,CAAqB,CAAC,KAAKnD,uBAAN,CAArB,EAAqD;AAClEkD,gBAAM,EAAEH,iBAAiB,CAACG;AADwC,SAArD,CAAf,CADE,CAKF;;AACA,cAAME,MAAM,GAAG/D,eAAe,CAACyD,MAAD,EAASC,iBAAiB,CAACG,MAA3B,CAA9B;AAEA,cAAME,MAAM,CAACC,IAAP,CAAYnF,IAAI,CACpB,CAACM,QAAQ,CAAC8E,MAAT,CAAgB;AACfjB,qBADe;AAEfH,0BAFe;AAGf3D;AAHe,SAAhB,CAAD,CADoB,EAMpBN,EAAE,CAACqF,MAAH,EANoB,CAAhB,CAAN;AAQD,OAhBD,CAgBE,OAAOvC,GAAP,EAAiB;AACjB;AACAxB,WAAG,CAACmB,KAAJ,CAAU,wCAAV,EAAoDK,GAApD;AACD,OAnBD,SAmBU;AACR,YAAI+B,MAAM,IAAI,IAAd,EAAoB;AAClBA,gBAAM,CAACS,KAAP;AACD;;AAEDR,yBAAiB,CAACS,KAAlB;AACD;AACF,KAnCc,CAAf;AAqCA,UAAMC,OAAO,CAACC,GAAR,CAAYb,MAAZ,CAAN;AACD;AAED;;;;;AAGqB,QAAf/B,eAAe;AACnB;AACA,QAAI,CAAC,KAAKE,SAAL,EAAL,EAAuB;AACrB;AACD;;AAED,UAAMiB,WAAW,GAAiB,EAAlC;;AAEA,SAAK,MAAM0B,IAAX,IAAmB,KAAKhE,UAAL,CAAgBQ,iBAAhB,CAAkCyD,cAAlC,EAAnB,EAAuE;AACrE,YAAMhD,MAAM,GAAG+C,IAAI,CAACE,UAApB;AACA,YAAMC,IAAI,GAAG,MAAM,KAAKnE,UAAL,CAAgBgB,SAAhB,CAA0BiC,GAA1B,CAA8BhC,MAA9B,CAAnB;;AAEA,UAAI,CAACkD,IAAI,CAACvF,SAAL,CAAewF,QAAf,CAAwB,KAAK/D,uBAA7B,CAAL,EAA4D;AAC1D;AACD;;AAEDiC,iBAAW,CAACD,IAAZ,CAAiB2B,IAAjB;AACD;;AAED,UAAM,KAAK3B,IAAL,CAAUC,WAAV,CAAN;AACD;;AAEc,QAAT+B,SAAS,CAAE1D,UAAF,EAAoD;AAAA,QAA1B2D,OAA0B,uEAAF,EAAE;AACjE,QAAIlB,iBAAJ;AACA,QAAIG,MAAM,GAAGe,OAAO,CAACf,MAArB;AACA,QAAIJ,MAAJ,CAHiE,CAKjE;;AACA,QAAII,MAAM,IAAI,IAAd,EAAoB;AAClBH,uBAAiB,GAAG,IAAI3D,iBAAJ,CAAsB,KAAKQ,IAAL,CAAUoD,OAAhC,CAApB;AACAE,YAAM,GAAGH,iBAAiB,CAACG,MAA3B;;AAEA,UAAI;AACF;AACA5D,uBAAe,GAAG2D,QAAH,EAAaF,iBAAiB,CAACG,MAA/B,CAAf;AACD,OAHD,CAGE,MAAM,CAAE;AACX;;AAED,QAAI;AACFJ,YAAM,GAAG,MAAMxC,UAAU,CAAC6C,SAAX,CAAqB,CAAC,KAAKrD,mBAAN,CAArB,EAAiD;AAC9DoD;AAD8D,OAAjD,CAAf,CADE,CAKF;;AACA,YAAME,MAAM,GAAG/D,eAAe,CAACyD,MAAD,EAASI,MAAT,CAA9B;AAEA,YAAM3B,IAAI,GAAG,MAAMrD,IAAI,CACrB,EADqB,EAErBkF,MAFqB,EAGrBnF,EAAE,CAACiG,MAAH,CAAU;AACRC,qBAAa,EAAE,KAAKvE,IAAL,CAAUwE,sBAAV,IAAoC5E;AAD3C,OAAV,CAHqB,EAMrB,MAAO4D,MAAP,IAAkB,MAAMjF,KAAK,CAACiF,MAAD,CANR,CAAvB;;AASA,UAAI7B,IAAI,IAAI,IAAZ,EAAkB;AAChB,cAAMvD,OAAO,CAAC,IAAIqG,KAAJ,CAAU,4BAAV,CAAD,EAA0CnF,KAAK,CAACoF,oBAAhD,CAAb;AACD;;AAED,UAAI;AACF,eAAO9F,QAAQ,CAAC0F,MAAT,CAAgB3C,IAAhB,CAAP;AACD,OAFD,CAEE,OAAOR,GAAP,EAAiB;AACjB,cAAM/C,OAAO,CAAC+C,GAAD,EAAM7B,KAAK,CAACqF,mBAAZ,CAAb;AACD;AACF,KA1BD,SA0BU;AACR,UAAIxB,iBAAiB,IAAI,IAAzB,EAA+B;AAC7BA,yBAAiB,CAACS,KAAlB;AACD;;AAED,UAAIV,MAAM,IAAI,IAAd,EAAoB;AAClBA,cAAM,CAACS,KAAP;AACD;AACF;AACF;AAED;;;;;;;AAKc,QAAR/C,QAAQ,CAAEF,UAAF,EAAoD;AAAA,QAA1B2D,OAA0B,uEAAF,EAAE;AAChE,UAAMO,OAAO,GAAG,MAAM,KAAKR,SAAL,CAAe1D,UAAf,EAA2B2D,OAA3B,CAAtB;AAEA,UAAM;AACJQ,eADI;AAEJpC,iBAFI;AAGJ9D,eAHI;AAIJmG,kBAJI;AAKJxC,sBALI;AAMJd,kBANI;AAOJlB;AAPI,QAQFsE,OARJ;;AAUA,QAAIC,SAAS,IAAI,IAAjB,EAAuB;AACrB,YAAMzG,OAAO,CAAC,IAAIqG,KAAJ,CAAU,8CAAV,CAAD,EAA4DnF,KAAK,CAACyF,sBAAlE,CAAb;AACD;;AAED,UAAMC,EAAE,GAAG,MAAMzF,cAAc,CAACsF,SAAD,CAA/B;;AAEA,QAAI,CAACnE,UAAU,CAACuD,UAAX,CAAsBhD,MAAtB,CAA6B+D,EAA7B,CAAL,EAAuC;AACrC,YAAM5G,OAAO,CAAC,IAAIqG,KAAJ,CAAU,kDAAV,CAAD,EAAgEnF,KAAK,CAAC2F,gBAAtE,CAAb;AACD;;AAED,QAAI,KAAKlF,UAAL,CAAgBiB,MAAhB,CAAuBC,MAAvB,CAA8B+D,EAA9B,CAAJ,EAAuC;AACrC,YAAM5G,OAAO,CAAC,IAAIqG,KAAJ,CAAU,qCAAV,CAAD,EAAmDnF,KAAK,CAAC2F,gBAAzD,CAAb;AACD,KAzB+D,CA2BhE;;;AACA,UAAMC,iBAAiB,GAAGrF,eAAe,CAACsF,iBAAhB,CAAkCL,YAAlC,CAA1B;;AAEA,QAAIxC,gBAAgB,IAAI,IAAxB,EAA8B;AAC5B3C,SAAG,CAAC,qCAAD,EAAwCqF,EAAxC,CAAH;;AAEA,UAAI;AACF,cAAMI,QAAQ,GAAG,MAAMvG,cAAc,CAACwG,cAAf,CAA8B/C,gBAA9B,EAAgDxD,UAAU,CAACwG,MAA3D,CAAvB;;AAEA,YAAI,CAACF,QAAQ,CAACpE,MAAT,CAAgBC,MAAhB,CAAuB+D,EAAvB,CAAL,EAAiC;AAC/B,gBAAM5G,OAAO,CAAC,IAAIqG,KAAJ,CAAU,kDAAV,CAAD,EAAgEnF,KAAK,CAAC2F,gBAAtE,CAAb;AACD;;AAED,YAAI,MAAM,KAAKlF,UAAL,CAAgBgB,SAAhB,CAA0BwB,WAA1B,CAAsCgD,iBAAtC,CAAwDH,QAAxD,CAAV,EAA6E;AAC3E,gBAAM,KAAKrF,UAAL,CAAgBgB,SAAhB,CAA0BgC,SAA1B,CAAoCyC,GAApC,CAAwCR,EAAxC,EAA4CrG,SAA5C,CAAN;;AAEA,cAAI6C,YAAY,IAAI,IAApB,EAA0B;AACxB,kBAAM,KAAKzB,UAAL,CAAgBgB,SAAhB,CAA0BO,YAA1B,CAAuCC,QAAvC,CAAgDyD,EAAhD,EAAoD,cAApD,EAAoEvG,oBAAoB,CAAC+C,YAAD,CAAxF,CAAN;AACD;;AAED,cAAIlB,eAAe,IAAI,IAAvB,EAA6B;AAC3B,kBAAM,KAAKP,UAAL,CAAgBgB,SAAhB,CAA0BO,YAA1B,CAAuCC,QAAvC,CAAgDyD,EAAhD,EAAoD,iBAApD,EAAuEvG,oBAAoB,CAAC6B,eAAD,CAA3F,CAAN;AACD;;AAEDX,aAAG,CAAC,iDAAD,EAAoDqF,EAApD,EAAwDrG,SAAxD,CAAH;AAEA;AACD;AACF,OAtBD,CAsBE,OAAOwC,GAAP,EAAiB;AACjBxB,WAAG,CAAC,gFAAD,EAAmFwB,GAAnF,CAAH;AACD;AACF,KA5BD,MA4BO;AACLxB,SAAG,CAAC,wCAAD,EAA2CqF,EAA3C,CAAH;AACD;;AAEDrF,OAAG,CAAC,0CAAD,EAA6CqF,EAA7C,CAAH,CA9DgE,CAgEhE;;AACA,QAAI;AACF,YAAM,KAAKjF,UAAL,CAAgBgB,SAAhB,CAA0BwB,WAA1B,CAAsCiD,GAAtC,CAA0CR,EAA1C,EAA8CvC,WAAW,CAACG,GAAZ,CAAiB6C,IAAD,IAAU/G,SAAS,CAAC+G,IAAD,CAAnC,CAA9C,CAAN;AACD,KAFD,CAEE,OAAOtE,GAAP,EAAiB;AACjBxB,SAAG,CAACmB,KAAJ,CAAU,wBAAV,EAAoCK,GAApC;AACD;;AAED,UAAM,KAAKpB,UAAL,CAAgBgB,SAAhB,CAA0BgC,SAA1B,CAAoCyC,GAApC,CAAwCR,EAAxC,EAA4CrG,SAA5C,CAAN;;AAEA,QAAI6C,YAAY,IAAI,IAApB,EAA0B;AACxB,YAAM,KAAKzB,UAAL,CAAgBgB,SAAhB,CAA0BO,YAA1B,CAAuCC,QAAvC,CAAgDyD,EAAhD,EAAoD,cAApD,EAAoEvG,oBAAoB,CAAC+C,YAAD,CAAxF,CAAN;AACD;;AAED,QAAIlB,eAAe,IAAI,IAAvB,EAA6B;AAC3B,YAAM,KAAKP,UAAL,CAAgBgB,SAAhB,CAA0BO,YAA1B,CAAuCC,QAAvC,CAAgDyD,EAAhD,EAAoD,iBAApD,EAAuEvG,oBAAoB,CAAC6B,eAAD,CAA3F,CAAN;AACD;;AAEDX,OAAG,CAAC,iDAAD,EAAoDqF,EAApD,EAAwDrG,SAAxD,CAAH,CAjFgE,CAmFhE;;AACAgB,OAAG,CAAC,iCAAD,EAAoCuF,iBAAiB,EAAEQ,QAAnB,EAApC,CAAH,CApFgE,CAqFhE;AACD;AAED;;;;;;AAIqB,QAAf9D,eAAe,CAAED,IAAF,EAA0B;AAC7C,UAAM;AAAEjB,gBAAF;AAAcwC;AAAd,QAAyBvB,IAA/B;AACA,UAAMwB,iBAAiB,GAAG,IAAI3D,iBAAJ,CAAsB,KAAKQ,IAAL,CAAUoD,OAAhC,CAA1B;;AAEA,QAAI;AACF;AACA1D,qBAAe,GAAG2D,QAAH,EAAaF,iBAAiB,CAACG,MAA/B,CAAf;AACD,KAHD,CAGE,MAAM,CAAE;;AAEV,QAAI;AACF,YAAMuB,SAAS,GAAG,KAAK9E,UAAL,CAAgBiB,MAAhB,CAAuB6D,SAAvB,IAAoC,IAAIc,UAAJ,CAAe,CAAf,CAAtD;AACA,YAAMC,QAAQ,GAAG,MAAM,KAAK7F,UAAL,CAAgBgB,SAAhB,CAA0BiC,GAA1B,CAA8B,KAAKjD,UAAL,CAAgBiB,MAA9C,CAAvB;AACA,YAAM6E,UAAU,GAAG,KAAK9F,UAAL,CAAgB2C,cAAhB,CAA+BC,YAA/B,GAA8CC,GAA9C,CAAkDC,EAAE,IAAIA,EAAE,CAACiD,eAAH,CAAmBnH,SAAS,CAAC,KAAD,CAAT,CAAiBoH,IAApC,CAAxD,CAAnB;AACA,UAAIzD,gBAAgB,GAAGsD,QAAQ,CAACI,kBAAhC;;AAEA,UAAIH,UAAU,CAACI,MAAX,GAAoB,CAApB,IAAyB3D,gBAAgB,IAAI,IAAjD,EAAuD;AACrD,cAAM4D,UAAU,GAAG,IAAIpH,UAAJ,CAAe;AAChCkC,gBAAM,EAAE,KAAKjB,UAAL,CAAgBiB,MADQ;AAEhC6E;AAFgC,SAAf,CAAnB;AAKA,cAAMT,QAAQ,GAAG,MAAMvG,cAAc,CAACsH,IAAf,CAAoBD,UAApB,EAAgC,KAAKnG,UAAL,CAAgBiB,MAAhD,CAAvB;AACA,cAAM,KAAKjB,UAAL,CAAgBgB,SAAhB,CAA0BwB,WAA1B,CAAsCgD,iBAAtC,CAAwDH,QAAxD,CAAN;AACA9C,wBAAgB,GAAG8C,QAAQ,CAACgB,OAAT,GAAmBC,QAAnB,EAAnB;AACD;;AAED,YAAMzB,OAAO,GAAGhG,QAAQ,CAAC8E,MAAT,CAAgB;AAC9BpD,uBAAe,EAAE,KAAKD,IAAL,CAAUC,eADG;AAE9BkB,oBAAY,EAAE,KAAKnB,IAAL,CAAUmB,YAFM;AAG9BqD,iBAH8B;AAI9BpC,mBAAW,EAAEoD,UAAU,CAACjD,GAAX,CAAe6C,IAAI,IAAIA,IAAI,CAAC3C,KAA5B,CAJiB;AAK9BR,wBAL8B;AAM9BwC,oBAAY,EAAEpE,UAAU,CAAC4F,UAAX,CAAsBxD,KANN;AAO9BnE,iBAAS,EAAEiH,QAAQ,CAACjH;AAPU,OAAhB,CAAhB,CAjBE,CA2BF;;AACA,YAAM6E,MAAM,GAAG/D,eAAe,CAACyD,MAAD,EAASC,iBAAiB,CAACG,MAA3B,CAA9B;AAEA,YAAMiD,gBAAgB,GAAGjI,IAAI,CAAC,CAACsG,OAAD,CAAD,EAAYvG,EAAE,CAACqF,MAAH,EAAZ,CAA7B;AACA,YAAMF,MAAM,CAACC,IAAP,CAAY8C,gBAAZ,CAAN;AACD,KAhCD,CAgCE,OAAOpF,GAAP,EAAiB;AACjBxB,SAAG,CAACmB,KAAJ,CAAU,uCAAV,EAAmDK,GAAnD;AACD,KAlCD,SAkCU;AACR+B,YAAM,CAACS,KAAP;AACAR,uBAAiB,CAACS,KAAlB;AACD;AACF;AAED;;;;;AAGiB,QAAX7B,WAAW,CAAEJ,IAAF,EAA0B;AACzC,UAAM;AAAEjB,gBAAF;AAAcwC;AAAd,QAAyBvB,IAA/B;AACA,UAAMwB,iBAAiB,GAAG,IAAI3D,iBAAJ,CAAsB,KAAKQ,IAAL,CAAUoD,OAAhC,CAA1B;;AAEA,QAAI;AACF;AACA1D,qBAAe,GAAG2D,QAAH,EAAaF,iBAAiB,CAACG,MAA/B,CAAf;AACD,KAHD,CAGE,MAAM,CAAE;;AAEV,QAAIsB,OAAJ;;AACA,QAAI;AACF;AACA,YAAMpB,MAAM,GAAG/D,eAAe,CAACyD,MAAD,EAASC,iBAAiB,CAACG,MAA3B,CAA9B;AAEA,YAAM3B,IAAI,GAAG,MAAMrD,IAAI,CACrB,EADqB,EAErBkF,MAFqB,EAGrBnF,EAAE,CAACiG,MAAH,CAAU;AACRC,qBAAa,EAAE,KAAKvE,IAAL,CAAUwE,sBAAV,IAAoC5E;AAD3C,OAAV,CAHqB,EAMrB,MAAO4D,MAAP,IAAkB,MAAMjF,KAAK,CAACiF,MAAD,CANR,CAAvB;;AASA,UAAI7B,IAAI,IAAI,IAAZ,EAAkB;AAChBiD,eAAO,GAAGhG,QAAQ,CAAC0F,MAAT,CAAgB3C,IAAhB,CAAV;AACD;AACF,KAhBD,CAgBE,OAAOR,GAAP,EAAiB;AACjB,aAAOxB,GAAG,CAACmB,KAAJ,CAAU,0BAAV,EAAsCK,GAAtC,CAAP;AACD,KAlBD,SAkBU;AACR+B,YAAM,CAACS,KAAP;AACAR,uBAAiB,CAACS,KAAlB;AACD;;AAED,QAAIgB,OAAO,IAAI,IAAf,EAAqB;AACnB,aAAOjF,GAAG,CAACmB,KAAJ,CAAU,0BAAV,CAAP;AACD;;AAED,UAAMkE,EAAE,GAAGtE,UAAU,CAACuD,UAAtB;;AAEA,QAAI,KAAKlE,UAAL,CAAgBiB,MAAhB,CAAuBC,MAAvB,CAA8B+D,EAA9B,CAAJ,EAAuC;AACrCrF,SAAG,CAAC,+BAAD,CAAH;AACA;AACD;;AAEDA,OAAG,CAAC,uBAAD,EAA0BqF,EAA1B,CAAH;;AAEA,QAAIJ,OAAO,CAACtC,gBAAR,IAA4B,IAAhC,EAAsC;AACpC3C,SAAG,CAAC,mCAAD,CAAH;;AAEA,UAAI;AACF,cAAMyF,QAAQ,GAAG,MAAMvG,cAAc,CAACwG,cAAf,CAA8BT,OAAO,CAACtC,gBAAtC,EAAwDxD,UAAU,CAACwG,MAAnE,CAAvB;;AAEA,YAAI,MAAM,KAAKvF,UAAL,CAAgBgB,SAAhB,CAA0BwB,WAA1B,CAAsCgD,iBAAtC,CAAwDH,QAAxD,CAAV,EAA6E;AAC3EzF,aAAG,CAAC,wCAAD,CAAH;AAEA,gBAAM,KAAKI,UAAL,CAAgBgB,SAAhB,CAA0BgC,SAA1B,CAAoCyC,GAApC,CAAwCR,EAAxC,EAA4CJ,OAAO,CAACjG,SAApD,CAAN;AACA;AACD,SALD,MAKO;AACLgB,aAAG,CAAC,iDAAD,CAAH;AACD;AACF,OAXD,CAWE,OAAOwB,GAAP,EAAiB;AACjBxB,WAAG,CAAC,gFAAD,EAAmFwB,GAAnF,CAAH;AACD;AACF,KAjBD,MAiBO;AACLxB,SAAG,CAAC,0CAAD,CAAH;AACD,KAjEwC,CAmEzC;;;AACA,QAAI;AACF,YAAM,KAAKI,UAAL,CAAgBgB,SAAhB,CAA0BwB,WAA1B,CAAsCiD,GAAtC,CAA0CR,EAA1C,EACJJ,OAAO,CAACnC,WAAR,CAAoBG,GAApB,CAAyB6C,IAAD,IAAU/G,SAAS,CAAC+G,IAAD,CAA3C,CADI,CAAN;AAED,KAHD,CAGE,OAAOtE,GAAP,EAAiB;AACjBxB,SAAG,CAACmB,KAAJ,CAAU,wBAAV,EAAoCK,GAApC;AACD,KAzEwC,CA2EzC;;;AACA,QAAI;AACF,YAAM,KAAKpB,UAAL,CAAgBgB,SAAhB,CAA0BgC,SAA1B,CAAoCyC,GAApC,CAAwCR,EAAxC,EAA4CJ,OAAO,CAACjG,SAApD,CAAN;AACD,KAFD,CAEE,OAAOwC,GAAP,EAAiB;AACjBxB,SAAG,CAACmB,KAAJ,CAAU,4BAAV,EAAwCK,GAAxC;AACD;;AAEDxB,OAAG,CAAC,sBAAD,EAAyBqF,EAAzB,CAAH;AACD;AAED;;;;;AAGwB,SAAjBG,iBAAiB,CAAEM,IAAF,EAA8C;AACpE,QAAIA,IAAI,IAAI,IAAR,IAAgBA,IAAI,CAACQ,MAAL,GAAc,CAAlC,EAAqC;AACnC,UAAI;AACF,eAAOvH,SAAS,CAAC+G,IAAD,CAAhB;AACD,OAFD,CAEE,MAAM,CAEP;AACF;AACF;;AA7cyB;AAgd5B;;;;AAGA,OAAO,MAAMe,WAAW,GAAG;AACzBC,UAAQ,EAAE1H,mBADe;AAEzB2H,eAAa,EAAE1H;AAFU,CAApB;AAKP,OAAO,MAAM2H,OAAO,GAAG;AAAE/H;AAAF,CAAhB","names":["logger","errCode","lp","pipe","first","fromString","uint8ArrayFromString","multiaddr","protocols","Identify","RecordEnvelope","PeerRecord","MULTICODEC_IDENTIFY","MULTICODEC_IDENTIFY_PUSH","IDENTIFY_PROTOCOL_VERSION","MULTICODEC_IDENTIFY_PROTOCOL_NAME","MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME","MULTICODEC_IDENTIFY_PROTOCOL_VERSION","MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION","codes","peerIdFromKeys","TimeoutController","abortableDuplex","setMaxListeners","log","MAX_IDENTIFY_MESSAGE_SIZE","IdentifyService","constructor","components","init","started","identifyProtocolStr","protocolPrefix","identifyPushProtocolStr","host","protocolVersion","connectionManager","addEventListener","evt","connection","detail","identify","catch","error","peerStore","peerId","equals","pushToPeerStore","err","isStarted","start","metadataBook","setValue","agentVersion","registrar","handle","data","_handleIdentify","maxInboundStreams","maxOutboundStreams","_handlePush","maxPushIncomingStreams","maxPushOutgoingStreams","stop","unhandle","push","connections","signedPeerRecord","addressBook","getRawEnvelope","listenAddrs","addressManager","getAddresses","map","ma","bytes","protoBook","get","pushes","stream","timeoutController","timeout","Infinity","signal","newStream","source","sink","encode","close","clear","Promise","all","conn","getConnections","remotePeer","peer","includes","_identify","options","decode","maxDataLength","maxIdentifyMessageSize","Error","ERR_CONNECTION_ENDED","ERR_INVALID_MESSAGE","message","publicKey","observedAddr","ERR_MISSING_PUBLIC_KEY","id","ERR_INVALID_PEER","cleanObservedAddr","getCleanMultiaddr","envelope","openAndCertify","DOMAIN","consumePeerRecord","set","addr","toString","Uint8Array","peerData","multiaddrs","decapsulateCode","code","peerRecordEnvelope","length","peerRecord","seal","marshal","subarray","remoteAddr","msgWithLenPrefix","multicodecs","IDENTIFY","IDENTIFY_PUSH","Message"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\identify\\index.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport * as lp from 'it-length-prefixed'\nimport { pipe } from 'it-pipe'\nimport first from 'it-first'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { multiaddr, protocols } from '@multiformats/multiaddr'\nimport { Identify } from './pb/message.js'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH,\n  IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION\n} from './consts.js'\nimport { codes } from '../errors.js'\nimport type { IncomingStreamData, Registrar } from '@libp2p/interface-registrar'\nimport type { Connection, Stream } from '@libp2p/interface-connection'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport { abortableDuplex } from 'abortable-iterator'\nimport { setMaxListeners } from 'events'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { PeerStore } from '@libp2p/interface-peer-store'\nimport type { AddressManager } from '@libp2p/interface-address-manager'\n\nconst log = logger('libp2p:identify')\n\n// https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L52\nconst MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8\n\nexport interface HostProperties {\n  agentVersion: string\n}\n\nexport interface IdentifyServiceInit {\n  /**\n   * The prefix to use for the protocol (default: 'ipfs')\n   */\n  protocolPrefix: string\n\n  /**\n   * What details we should send as part of an identify message\n   */\n  host: HostProperties\n\n  /**\n   * How long we should wait for a remote peer to send their identify response\n   */\n  timeout: number\n\n  /**\n   * Identify responses larger than this in bytes will be rejected (default: 8192)\n   */\n  maxIdentifyMessageSize?: number\n\n  maxInboundStreams: number\n  maxOutboundStreams: number\n\n  maxPushIncomingStreams: number\n  maxPushOutgoingStreams: number\n}\n\nexport interface IdentifyServiceComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  connectionManager: ConnectionManager\n  registrar: Registrar\n  addressManager: AddressManager\n}\n\nexport class IdentifyService implements Startable {\n  private readonly components: IdentifyServiceComponents\n  private readonly identifyProtocolStr: string\n  private readonly identifyPushProtocolStr: string\n  public readonly host: {\n    protocolVersion: string\n    agentVersion: string\n  }\n\n  private readonly init: IdentifyServiceInit\n  private started: boolean\n\n  constructor (components: IdentifyServiceComponents, init: IdentifyServiceInit) {\n    this.components = components\n    this.started = false\n    this.init = init\n\n    this.identifyProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`\n    this.identifyPushProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`\n\n    // Store self host metadata\n    this.host = {\n      protocolVersion: `${init.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n      ...init.host\n    }\n\n    // When a new connection happens, trigger identify\n    this.components.connectionManager.addEventListener('peer:connect', (evt) => {\n      const connection = evt.detail\n      this.identify(connection).catch(log.error)\n    })\n\n    // When self multiaddrs change, trigger identify-push\n    this.components.peerStore.addEventListener('change:multiaddrs', (evt) => {\n      const { peerId } = evt.detail\n\n      if (this.components.peerId.equals(peerId)) {\n        void this.pushToPeerStore().catch(err => log.error(err))\n      }\n    })\n\n    // When self protocols change, trigger identify-push\n    this.components.peerStore.addEventListener('change:protocols', (evt) => {\n      const { peerId } = evt.detail\n\n      if (this.components.peerId.equals(peerId)) {\n        void this.pushToPeerStore().catch(err => log.error(err))\n      }\n    })\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  async start () {\n    if (this.started) {\n      return\n    }\n\n    await this.components.peerStore.metadataBook.setValue(this.components.peerId, 'AgentVersion', uint8ArrayFromString(this.host.agentVersion))\n    await this.components.peerStore.metadataBook.setValue(this.components.peerId, 'ProtocolVersion', uint8ArrayFromString(this.host.protocolVersion))\n\n    await this.components.registrar.handle(this.identifyProtocolStr, (data) => {\n      void this._handleIdentify(data).catch(err => {\n        log.error(err)\n      })\n    }, {\n      maxInboundStreams: this.init.maxInboundStreams,\n      maxOutboundStreams: this.init.maxOutboundStreams\n    })\n    await this.components.registrar.handle(this.identifyPushProtocolStr, (data) => {\n      void this._handlePush(data).catch(err => {\n        log.error(err)\n      })\n    }, {\n      maxInboundStreams: this.init.maxPushIncomingStreams,\n      maxOutboundStreams: this.init.maxPushOutgoingStreams\n    })\n\n    this.started = true\n  }\n\n  async stop () {\n    await this.components.registrar.unhandle(this.identifyProtocolStr)\n    await this.components.registrar.unhandle(this.identifyPushProtocolStr)\n\n    this.started = false\n  }\n\n  /**\n   * Send an Identify Push update to the list of connections\n   */\n  async push (connections: Connection[]): Promise<void> {\n    const signedPeerRecord = await this.components.peerStore.addressBook.getRawEnvelope(this.components.peerId)\n    const listenAddrs = this.components.addressManager.getAddresses().map((ma) => ma.bytes)\n    const protocols = await this.components.peerStore.protoBook.get(this.components.peerId)\n\n    const pushes = connections.map(async connection => {\n      let stream: Stream | undefined\n      const timeoutController = new TimeoutController(this.init.timeout)\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal)\n      } catch {}\n\n      try {\n        stream = await connection.newStream([this.identifyPushProtocolStr], {\n          signal: timeoutController.signal\n        })\n\n        // make stream abortable\n        const source = abortableDuplex(stream, timeoutController.signal)\n\n        await source.sink(pipe(\n          [Identify.encode({\n            listenAddrs,\n            signedPeerRecord,\n            protocols\n          })],\n          lp.encode()\n        ))\n      } catch (err: any) {\n        // Just log errors\n        log.error('could not push identify update to peer', err)\n      } finally {\n        if (stream != null) {\n          stream.close()\n        }\n\n        timeoutController.clear()\n      }\n    })\n\n    await Promise.all(pushes)\n  }\n\n  /**\n   * Calls `push` on all peer connections\n   */\n  async pushToPeerStore () {\n    // Do not try to push if we are not running\n    if (!this.isStarted()) {\n      return\n    }\n\n    const connections: Connection[] = []\n\n    for (const conn of this.components.connectionManager.getConnections()) {\n      const peerId = conn.remotePeer\n      const peer = await this.components.peerStore.get(peerId)\n\n      if (!peer.protocols.includes(this.identifyPushProtocolStr)) {\n        continue\n      }\n\n      connections.push(conn)\n    }\n\n    await this.push(connections)\n  }\n\n  async _identify (connection: Connection, options: AbortOptions = {}): Promise<Identify> {\n    let timeoutController\n    let signal = options.signal\n    let stream: Stream | undefined\n\n    // create a timeout if no abort signal passed\n    if (signal == null) {\n      timeoutController = new TimeoutController(this.init.timeout)\n      signal = timeoutController.signal\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal)\n      } catch {}\n    }\n\n    try {\n      stream = await connection.newStream([this.identifyProtocolStr], {\n        signal\n      })\n\n      // make stream abortable\n      const source = abortableDuplex(stream, signal)\n\n      const data = await pipe(\n        [],\n        source,\n        lp.decode({\n          maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n        }),\n        async (source) => await first(source)\n      )\n\n      if (data == null) {\n        throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED)\n      }\n\n      try {\n        return Identify.decode(data)\n      } catch (err: any) {\n        throw errCode(err, codes.ERR_INVALID_MESSAGE)\n      }\n    } finally {\n      if (timeoutController != null) {\n        timeoutController.clear()\n      }\n\n      if (stream != null) {\n        stream.close()\n      }\n    }\n  }\n\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   */\n  async identify (connection: Connection, options: AbortOptions = {}): Promise<void> {\n    const message = await this._identify(connection, options)\n\n    const {\n      publicKey,\n      listenAddrs,\n      protocols,\n      observedAddr,\n      signedPeerRecord,\n      agentVersion,\n      protocolVersion\n    } = message\n\n    if (publicKey == null) {\n      throw errCode(new Error('public key was missing from identify message'), codes.ERR_MISSING_PUBLIC_KEY)\n    }\n\n    const id = await peerIdFromKeys(publicKey)\n\n    if (!connection.remotePeer.equals(id)) {\n      throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER)\n    }\n\n    if (this.components.peerId.equals(id)) {\n      throw errCode(new Error('identified peer is our own peer id?'), codes.ERR_INVALID_PEER)\n    }\n\n    // Get the observedAddr if there is one\n    const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr)\n\n    if (signedPeerRecord != null) {\n      log('received signed peer record from %p', id)\n\n      try {\n        const envelope = await RecordEnvelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN)\n\n        if (!envelope.peerId.equals(id)) {\n          throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER)\n        }\n\n        if (await this.components.peerStore.addressBook.consumePeerRecord(envelope)) {\n          await this.components.peerStore.protoBook.set(id, protocols)\n\n          if (agentVersion != null) {\n            await this.components.peerStore.metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(agentVersion))\n          }\n\n          if (protocolVersion != null) {\n            await this.components.peerStore.metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(protocolVersion))\n          }\n\n          log('identify completed for peer %p and protocols %o', id, protocols)\n\n          return\n        }\n      } catch (err: any) {\n        log('received invalid envelope, discard it and fallback to listenAddrs is available', err)\n      }\n    } else {\n      log('no signed peer record received from %p', id)\n    }\n\n    log('falling back to legacy addresses from %p', id)\n\n    // LEGACY: Update peers data in PeerStore\n    try {\n      await this.components.peerStore.addressBook.set(id, listenAddrs.map((addr) => multiaddr(addr)))\n    } catch (err: any) {\n      log.error('received invalid addrs', err)\n    }\n\n    await this.components.peerStore.protoBook.set(id, protocols)\n\n    if (agentVersion != null) {\n      await this.components.peerStore.metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(agentVersion))\n    }\n\n    if (protocolVersion != null) {\n      await this.components.peerStore.metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(protocolVersion))\n    }\n\n    log('identify completed for peer %p and protocols %o', id, protocols)\n\n    // TODO: Add and score our observed addr\n    log('received observed address of %s', cleanObservedAddr?.toString())\n    // this.components.addressManager.addObservedAddr(observedAddr)\n  }\n\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   */\n  async _handleIdentify (data: IncomingStreamData) {\n    const { connection, stream } = data\n    const timeoutController = new TimeoutController(this.init.timeout)\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, timeoutController.signal)\n    } catch {}\n\n    try {\n      const publicKey = this.components.peerId.publicKey ?? new Uint8Array(0)\n      const peerData = await this.components.peerStore.get(this.components.peerId)\n      const multiaddrs = this.components.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n      let signedPeerRecord = peerData.peerRecordEnvelope\n\n      if (multiaddrs.length > 0 && signedPeerRecord == null) {\n        const peerRecord = new PeerRecord({\n          peerId: this.components.peerId,\n          multiaddrs\n        })\n\n        const envelope = await RecordEnvelope.seal(peerRecord, this.components.peerId)\n        await this.components.peerStore.addressBook.consumePeerRecord(envelope)\n        signedPeerRecord = envelope.marshal().subarray()\n      }\n\n      const message = Identify.encode({\n        protocolVersion: this.host.protocolVersion,\n        agentVersion: this.host.agentVersion,\n        publicKey,\n        listenAddrs: multiaddrs.map(addr => addr.bytes),\n        signedPeerRecord,\n        observedAddr: connection.remoteAddr.bytes,\n        protocols: peerData.protocols\n      })\n\n      // make stream abortable\n      const source = abortableDuplex(stream, timeoutController.signal)\n\n      const msgWithLenPrefix = pipe([message], lp.encode())\n      await source.sink(msgWithLenPrefix)\n    } catch (err: any) {\n      log.error('could not respond to identify request', err)\n    } finally {\n      stream.close()\n      timeoutController.clear()\n    }\n  }\n\n  /**\n   * Reads the Identify Push message from the given `connection`\n   */\n  async _handlePush (data: IncomingStreamData) {\n    const { connection, stream } = data\n    const timeoutController = new TimeoutController(this.init.timeout)\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, timeoutController.signal)\n    } catch {}\n\n    let message: Identify | undefined\n    try {\n      // make stream abortable\n      const source = abortableDuplex(stream, timeoutController.signal)\n\n      const data = await pipe(\n        [],\n        source,\n        lp.decode({\n          maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n        }),\n        async (source) => await first(source)\n      )\n\n      if (data != null) {\n        message = Identify.decode(data)\n      }\n    } catch (err: any) {\n      return log.error('received invalid message', err)\n    } finally {\n      stream.close()\n      timeoutController.clear()\n    }\n\n    if (message == null) {\n      return log.error('received invalid message')\n    }\n\n    const id = connection.remotePeer\n\n    if (this.components.peerId.equals(id)) {\n      log('received push from ourselves?')\n      return\n    }\n\n    log('received push from %p', id)\n\n    if (message.signedPeerRecord != null) {\n      log('received signedPeerRecord in push')\n\n      try {\n        const envelope = await RecordEnvelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN)\n\n        if (await this.components.peerStore.addressBook.consumePeerRecord(envelope)) {\n          log('consumed signedPeerRecord sent in push')\n\n          await this.components.peerStore.protoBook.set(id, message.protocols)\n          return\n        } else {\n          log('failed to consume signedPeerRecord sent in push')\n        }\n      } catch (err: any) {\n        log('received invalid envelope, discard it and fallback to listenAddrs is available', err)\n      }\n    } else {\n      log('did not receive signedPeerRecord in push')\n    }\n\n    // LEGACY: Update peers data in PeerStore\n    try {\n      await this.components.peerStore.addressBook.set(id,\n        message.listenAddrs.map((addr) => multiaddr(addr)))\n    } catch (err: any) {\n      log.error('received invalid addrs', err)\n    }\n\n    // Update the protocols\n    try {\n      await this.components.peerStore.protoBook.set(id, message.protocols)\n    } catch (err: any) {\n      log.error('received invalid protocols', err)\n    }\n\n    log('handled push from %p', id)\n  }\n\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   */\n  static getCleanMultiaddr (addr: Uint8Array | string | null | undefined) {\n    if (addr != null && addr.length > 0) {\n      try {\n        return multiaddr(addr)\n      } catch {\n\n      }\n    }\n  }\n}\n\n/**\n * The protocols the IdentifyService supports\n */\nexport const multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n}\n\nexport const Message = { Identify }\n"]},"metadata":{},"sourceType":"module"}