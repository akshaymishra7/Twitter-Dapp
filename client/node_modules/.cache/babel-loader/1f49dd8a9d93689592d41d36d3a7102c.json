{"ast":null,"code":"import { CodeError } from '@libp2p/interfaces/errors';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport randomBytes from '../random-bytes.js';\nimport webcrypto from '../webcrypto.js';\nimport { jwk2pub, jwk2priv } from './jwk2pem.js';\nimport * as utils from './rsa-utils.js';\nexport { utils };\nexport async function generateKey(bits) {\n  const pair = await webcrypto.get().subtle.generateKey({\n    name: 'RSASSA-PKCS1-v1_5',\n    modulusLength: bits,\n    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n    hash: {\n      name: 'SHA-256'\n    }\n  }, true, ['sign', 'verify']);\n  const keys = await exportKey(pair);\n  return {\n    privateKey: keys[0],\n    publicKey: keys[1]\n  };\n} // Takes a jwk key\n\nexport async function unmarshalPrivateKey(key) {\n  const privateKey = await webcrypto.get().subtle.importKey('jwk', key, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, true, ['sign']);\n  const pair = [privateKey, await derivePublicFromPrivate(key)];\n  const keys = await exportKey({\n    privateKey: pair[0],\n    publicKey: pair[1]\n  });\n  return {\n    privateKey: keys[0],\n    publicKey: keys[1]\n  };\n}\nexport { randomBytes as getRandomValues };\nexport async function hashAndSign(key, msg) {\n  const privateKey = await webcrypto.get().subtle.importKey('jwk', key, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, false, ['sign']);\n  const sig = await webcrypto.get().subtle.sign({\n    name: 'RSASSA-PKCS1-v1_5'\n  }, privateKey, Uint8Array.from(msg));\n  return new Uint8Array(sig, 0, sig.byteLength);\n}\nexport async function hashAndVerify(key, sig, msg) {\n  const publicKey = await webcrypto.get().subtle.importKey('jwk', key, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, false, ['verify']);\n  return webcrypto.get().subtle.verify({\n    name: 'RSASSA-PKCS1-v1_5'\n  }, publicKey, sig, msg);\n}\n\nasync function exportKey(pair) {\n  if (pair.privateKey == null || pair.publicKey == null) {\n    throw new CodeError('Private and public key are required', 'ERR_INVALID_PARAMETERS');\n  }\n\n  return Promise.all([webcrypto.get().subtle.exportKey('jwk', pair.privateKey), webcrypto.get().subtle.exportKey('jwk', pair.publicKey)]);\n}\n\nasync function derivePublicFromPrivate(jwKey) {\n  return webcrypto.get().subtle.importKey('jwk', {\n    kty: jwKey.kty,\n    n: jwKey.n,\n    e: jwKey.e\n  }, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, true, ['verify']);\n}\n/*\n\nRSA encryption/decryption for the browser with webcrypto workaround\n\"bloody dark magic. webcrypto's why.\"\n\nExplanation:\n  - Convert JWK to nodeForge\n  - Convert msg Uint8Array to nodeForge buffer: ByteBuffer is a \"binary-string backed buffer\", so let's make our Uint8Array a binary string\n  - Convert resulting nodeForge buffer to Uint8Array: it returns a binary string, turn that into a Uint8Array\n\n*/\n\n\nfunction convertKey(key, pub, msg, handle) {\n  const fkey = pub ? jwk2pub(key) : jwk2priv(key);\n  const fmsg = uint8ArrayToString(Uint8Array.from(msg), 'ascii');\n  const fomsg = handle(fmsg, fkey);\n  return uint8ArrayFromString(fomsg, 'ascii');\n}\n\nexport function encrypt(key, msg) {\n  return convertKey(key, true, msg, (msg, key) => key.encrypt(msg));\n}\nexport function decrypt(key, msg) {\n  return convertKey(key, false, msg, (msg, key) => key.decrypt(msg));\n}","map":{"version":3,"mappings":"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","names":["CodeError","fromString","uint8ArrayFromString","toString","uint8ArrayToString","randomBytes","webcrypto","jwk2pub","jwk2priv","utils","generateKey","bits","pair","get","subtle","name","modulusLength","publicExponent","Uint8Array","hash","keys","exportKey","privateKey","publicKey","unmarshalPrivateKey","key","importKey","derivePublicFromPrivate","getRandomValues","hashAndSign","msg","sig","sign","from","byteLength","hashAndVerify","verify","Promise","all","jwKey","kty","n","e","convertKey","pub","handle","fkey","fmsg","fomsg","encrypt","decrypt"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\crypto\\src\\keys\\rsa-browser.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport randomBytes from '../random-bytes.js'\nimport webcrypto from '../webcrypto.js'\nimport { jwk2pub, jwk2priv } from './jwk2pem.js'\nimport * as utils from './rsa-utils.js'\nimport type { JWKKeyPair } from './interface.js'\n\nexport { utils }\n\nexport async function generateKey (bits: number): Promise<JWKKeyPair> {\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      modulusLength: bits,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: { name: 'SHA-256' }\n    },\n    true,\n    ['sign', 'verify']\n  )\n\n  const keys = await exportKey(pair)\n\n  return {\n    privateKey: keys[0],\n    publicKey: keys[1]\n  }\n}\n\n// Takes a jwk key\nexport async function unmarshalPrivateKey (key: JsonWebKey): Promise<JWKKeyPair> {\n  const privateKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    true,\n    ['sign']\n  )\n\n  const pair = [\n    privateKey,\n    await derivePublicFromPrivate(key)\n  ]\n\n  const keys = await exportKey({\n    privateKey: pair[0],\n    publicKey: pair[1]\n  })\n\n  return {\n    privateKey: keys[0],\n    publicKey: keys[1]\n  }\n}\n\nexport { randomBytes as getRandomValues }\n\nexport async function hashAndSign (key: JsonWebKey, msg: Uint8Array): Promise<Uint8Array> {\n  const privateKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    false,\n    ['sign']\n  )\n\n  const sig = await webcrypto.get().subtle.sign(\n    { name: 'RSASSA-PKCS1-v1_5' },\n    privateKey,\n    Uint8Array.from(msg)\n  )\n\n  return new Uint8Array(sig, 0, sig.byteLength)\n}\n\nexport async function hashAndVerify (key: JsonWebKey, sig: Uint8Array, msg: Uint8Array): Promise<boolean> {\n  const publicKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    false,\n    ['verify']\n  )\n\n  return webcrypto.get().subtle.verify(\n    { name: 'RSASSA-PKCS1-v1_5' },\n    publicKey,\n    sig,\n    msg\n  )\n}\n\nasync function exportKey (pair: CryptoKeyPair): Promise<[JsonWebKey, JsonWebKey]> {\n  if (pair.privateKey == null || pair.publicKey == null) {\n    throw new CodeError('Private and public key are required', 'ERR_INVALID_PARAMETERS')\n  }\n\n  return Promise.all([\n    webcrypto.get().subtle.exportKey('jwk', pair.privateKey),\n    webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n  ])\n}\n\nasync function derivePublicFromPrivate (jwKey: JsonWebKey): Promise<CryptoKey> {\n  return webcrypto.get().subtle.importKey(\n    'jwk',\n    {\n      kty: jwKey.kty,\n      n: jwKey.n,\n      e: jwKey.e\n    },\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    true,\n    ['verify']\n  )\n}\n\n/*\n\nRSA encryption/decryption for the browser with webcrypto workaround\n\"bloody dark magic. webcrypto's why.\"\n\nExplanation:\n  - Convert JWK to nodeForge\n  - Convert msg Uint8Array to nodeForge buffer: ByteBuffer is a \"binary-string backed buffer\", so let's make our Uint8Array a binary string\n  - Convert resulting nodeForge buffer to Uint8Array: it returns a binary string, turn that into a Uint8Array\n\n*/\n\nfunction convertKey (key: JsonWebKey, pub: boolean, msg: Uint8Array, handle: (msg: string, key: { encrypt: (msg: string) => string, decrypt: (msg: string) => string }) => string): Uint8Array {\n  const fkey = pub ? jwk2pub(key) : jwk2priv(key)\n  const fmsg = uint8ArrayToString(Uint8Array.from(msg), 'ascii')\n  const fomsg = handle(fmsg, fkey)\n  return uint8ArrayFromString(fomsg, 'ascii')\n}\n\nexport function encrypt (key: JsonWebKey, msg: Uint8Array): Uint8Array {\n  return convertKey(key, true, msg, (msg, key) => key.encrypt(msg))\n}\n\nexport function decrypt (key: JsonWebKey, msg: Uint8Array): Uint8Array {\n  return convertKey(key, false, msg, (msg, key) => key.decrypt(msg))\n}\n"]},"metadata":{},"sourceType":"module"}