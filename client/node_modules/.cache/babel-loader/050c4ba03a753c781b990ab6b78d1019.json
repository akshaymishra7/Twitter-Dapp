{"ast":null,"code":"const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\n\nconst RateLimiterRes = require('./RateLimiterRes');\n/**\n * Get MongoDB driver version as upsert options differ\n * @params {Object} Client instance\n * @returns {Object} Version Object containing major, feature & minor versions.\n */\n\n\nfunction getDriverVersion(client) {\n  try {\n    const _client = client.client ? client.client : client;\n\n    const {\n      version\n    } = _client.topology.s.options.metadata.driver;\n\n    const _v = version.split('.').map(v => parseInt(v));\n\n    return {\n      major: _v[0],\n      feature: _v[1],\n      patch: _v[2]\n    };\n  } catch (err) {\n    return {\n      major: 0,\n      feature: 0,\n      patch: 0\n    };\n  }\n}\n\nclass RateLimiterMongo extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   indexKeyPrefix: {attr1: 1, attr2: 1}\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   mongo: MongoClient\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n    this.dbName = opts.dbName;\n    this.tableName = opts.tableName;\n    this.indexKeyPrefix = opts.indexKeyPrefix;\n\n    if (opts.mongo) {\n      this.client = opts.mongo;\n    } else {\n      this.client = opts.storeClient;\n    }\n\n    if (typeof this.client.then === 'function') {\n      // If Promise\n      this.client.then(conn => {\n        this.client = conn;\n\n        this._initCollection();\n\n        this._driverVersion = getDriverVersion(this.client);\n      });\n    } else {\n      this._initCollection();\n\n      this._driverVersion = getDriverVersion(this.client);\n    }\n  }\n\n  get dbName() {\n    return this._dbName;\n  }\n\n  set dbName(value) {\n    this._dbName = typeof value === 'undefined' ? RateLimiterMongo.getDbName() : value;\n  }\n\n  static getDbName() {\n    return 'node-rate-limiter-flexible';\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get client() {\n    return this._client;\n  }\n\n  set client(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('mongo is not set');\n    }\n\n    this._client = value;\n  }\n\n  get indexKeyPrefix() {\n    return this._indexKeyPrefix;\n  }\n\n  set indexKeyPrefix(obj) {\n    this._indexKeyPrefix = obj || {};\n  }\n\n  _initCollection() {\n    const db = typeof this.client.db === 'function' ? this.client.db(this.dbName) : this.client;\n    const collection = db.collection(this.tableName);\n    collection.createIndex({\n      expire: -1\n    }, {\n      expireAfterSeconds: 0\n    });\n    collection.createIndex(Object.assign({}, this.indexKeyPrefix, {\n      key: 1\n    }), {\n      unique: true\n    });\n    this._collection = collection;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    let doc;\n\n    if (typeof result.value === 'undefined') {\n      doc = result;\n    } else {\n      doc = result.value;\n    }\n\n    res.isFirstInDuration = doc.points === changedPoints;\n    res.consumedPoints = doc.points;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = doc.expire !== null ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0) : -1;\n    return res;\n  }\n\n  _upsert(key, points, msDuration) {\n    let forceExpire = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n    let where;\n    let upsertData;\n\n    if (forceExpire) {\n      where = {\n        key\n      };\n      where = Object.assign(where, docAttrs);\n      upsertData = {\n        $set: {\n          key,\n          points,\n          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null\n        }\n      };\n      upsertData.$set = Object.assign(upsertData.$set, docAttrs);\n    } else {\n      where = {\n        $or: [{\n          expire: {\n            $gt: new Date()\n          }\n        }, {\n          expire: {\n            $eq: null\n          }\n        }],\n        key\n      };\n      where = Object.assign(where, docAttrs);\n      upsertData = {\n        $setOnInsert: {\n          key,\n          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null\n        },\n        $inc: {\n          points\n        }\n      };\n      upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);\n    } // Options for collection updates differ between driver versions\n\n\n    const upsertOptions = {\n      upsert: true\n    };\n\n    if (this._driverVersion.major >= 4 || this._driverVersion.major === 3 && this._driverVersion.feature >= 7 || this._driverVersion.feature >= 6 && this._driverVersion.patch >= 7) {\n      upsertOptions.returnDocument = 'after';\n    } else {\n      upsertOptions.returnOriginal = false;\n    }\n    /*\n     * 1. Find actual limit and increment points\n     * 2. If limit expired, but Mongo doesn't clean doc by TTL yet, try to replace limit doc completely\n     * 3. If 2 or more Mongo threads try to insert the new limit doc, only the first succeed\n     * 4. Try to upsert from step 1. Actual limit is created now, points are incremented without problems\n     */\n\n\n    return new Promise((resolve, reject) => {\n      this._collection.findOneAndUpdate(where, upsertData, upsertOptions).then(res => {\n        resolve(res);\n      }).catch(errUpsert => {\n        if (errUpsert && errUpsert.code === 11000) {\n          // E11000 duplicate key error collection\n          const replaceWhere = Object.assign({\n            // try to replace OLD limit doc\n            $or: [{\n              expire: {\n                $lte: new Date()\n              }\n            }, {\n              expire: {\n                $eq: null\n              }\n            }],\n            key\n          }, docAttrs);\n          const replaceTo = {\n            $set: Object.assign({\n              key,\n              points,\n              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null\n            }, docAttrs)\n          };\n\n          this._collection.findOneAndUpdate(replaceWhere, replaceTo, upsertOptions).then(res => {\n            resolve(res);\n          }).catch(errReplace => {\n            if (errReplace && errReplace.code === 11000) {\n              // E11000 duplicate key error collection\n              this._upsert(key, points, msDuration, forceExpire).then(res => resolve(res)).catch(err => reject(err));\n            } else {\n              reject(errReplace);\n            }\n          });\n        } else {\n          reject(errUpsert);\n        }\n      });\n    });\n  }\n\n  _get(rlKey) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n    const where = Object.assign({\n      key: rlKey,\n      $or: [{\n        expire: {\n          $gt: new Date()\n        }\n      }, {\n        expire: {\n          $eq: null\n        }\n      }]\n    }, docAttrs);\n    return this._collection.findOne(where);\n  }\n\n  _delete(rlKey) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n    const where = Object.assign({\n      key: rlKey\n    }, docAttrs);\n    return this._collection.deleteOne(where).then(res => res.deletedCount > 0);\n  }\n\n}\n\nmodule.exports = RateLimiterMongo;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/rate-limiter-flexible/lib/RateLimiterMongo.js"],"names":["RateLimiterStoreAbstract","require","RateLimiterRes","getDriverVersion","client","_client","version","topology","s","options","metadata","driver","_v","split","map","v","parseInt","major","feature","patch","err","RateLimiterMongo","constructor","opts","dbName","tableName","indexKeyPrefix","mongo","storeClient","then","conn","_initCollection","_driverVersion","_dbName","value","getDbName","_tableName","keyPrefix","Error","_indexKeyPrefix","obj","db","collection","createIndex","expire","expireAfterSeconds","Object","assign","key","unique","_collection","_getRateLimiterRes","rlKey","changedPoints","result","res","doc","isFirstInDuration","points","consumedPoints","remainingPoints","Math","max","msBeforeNext","Date","getTime","now","_upsert","msDuration","forceExpire","Promise","reject","docAttrs","attrs","where","upsertData","$set","$or","$gt","$eq","$setOnInsert","$inc","upsertOptions","upsert","returnDocument","returnOriginal","resolve","findOneAndUpdate","catch","errUpsert","code","replaceWhere","$lte","replaceTo","errReplace","_get","findOne","_delete","deleteOne","deletedCount","module","exports"],"mappings":"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","sourcesContent":["const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\n/**\n * Get MongoDB driver version as upsert options differ\n * @params {Object} Client instance\n * @returns {Object} Version Object containing major, feature & minor versions.\n */\nfunction getDriverVersion(client) {\n  try {\n    const _client = client.client ? client.client : client;\n\n    const { version } = _client.topology.s.options.metadata.driver;\n    const _v = version.split('.').map(v => parseInt(v));\n\n    return {\n      major: _v[0],\n      feature: _v[1],\n      patch: _v[2],\n    };\n  } catch (err) {\n    return { major: 0, feature: 0, patch: 0 };\n  }\n}\n\nclass RateLimiterMongo extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   indexKeyPrefix: {attr1: 1, attr2: 1}\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   mongo: MongoClient\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n\n    this.dbName = opts.dbName;\n    this.tableName = opts.tableName;\n    this.indexKeyPrefix = opts.indexKeyPrefix;\n\n    if (opts.mongo) {\n      this.client = opts.mongo;\n    } else {\n      this.client = opts.storeClient;\n    }\n    if (typeof this.client.then === 'function') {\n      // If Promise\n      this.client\n        .then((conn) => {\n          this.client = conn;\n          this._initCollection();\n          this._driverVersion = getDriverVersion(this.client);\n        });\n    } else {\n      this._initCollection();\n      this._driverVersion = getDriverVersion(this.client);\n    }\n  }\n\n  get dbName() {\n    return this._dbName;\n  }\n\n  set dbName(value) {\n    this._dbName = typeof value === 'undefined' ? RateLimiterMongo.getDbName() : value;\n  }\n\n  static getDbName() {\n    return 'node-rate-limiter-flexible';\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get client() {\n    return this._client;\n  }\n\n  set client(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('mongo is not set');\n    }\n    this._client = value;\n  }\n\n  get indexKeyPrefix() {\n    return this._indexKeyPrefix;\n  }\n\n  set indexKeyPrefix(obj) {\n    this._indexKeyPrefix = obj || {};\n  }\n\n  _initCollection() {\n    const db = typeof this.client.db === 'function'\n      ? this.client.db(this.dbName)\n      : this.client;\n\n    const collection = db.collection(this.tableName);\n    collection.createIndex({ expire: -1 }, { expireAfterSeconds: 0 });\n    collection.createIndex(Object.assign({}, this.indexKeyPrefix, { key: 1 }), { unique: true });\n\n    this._collection = collection;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n\n    let doc;\n    if (typeof result.value === 'undefined') {\n      doc = result;\n    } else {\n      doc = result.value;\n    }\n\n    res.isFirstInDuration = doc.points === changedPoints;\n    res.consumedPoints = doc.points;\n\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = doc.expire !== null\n      ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0)\n      : -1;\n\n    return res;\n  }\n\n  _upsert(key, points, msDuration, forceExpire = false, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n\n    let where;\n    let upsertData;\n    if (forceExpire) {\n      where = { key };\n      where = Object.assign(where, docAttrs);\n      upsertData = {\n        $set: {\n          key,\n          points,\n          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null,\n        },\n      };\n      upsertData.$set = Object.assign(upsertData.$set, docAttrs);\n    } else {\n      where = {\n        $or: [\n          { expire: { $gt: new Date() } },\n          { expire: { $eq: null } },\n        ],\n        key,\n      };\n      where = Object.assign(where, docAttrs);\n      upsertData = {\n        $setOnInsert: {\n          key,\n          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null,\n        },\n        $inc: { points },\n      };\n      upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);\n    }\n\n    // Options for collection updates differ between driver versions\n    const upsertOptions = {\n      upsert: true,\n    };\n    if ((this._driverVersion.major >= 4) ||\n        (this._driverVersion.major === 3 &&\n          (this._driverVersion.feature >=7) || \n          (this._driverVersion.feature >= 6 && \n              this._driverVersion.patch >= 7 ))) \n    {\n      upsertOptions.returnDocument = 'after';\n    } else {\n      upsertOptions.returnOriginal = false;\n    }\n\n    /*\n     * 1. Find actual limit and increment points\n     * 2. If limit expired, but Mongo doesn't clean doc by TTL yet, try to replace limit doc completely\n     * 3. If 2 or more Mongo threads try to insert the new limit doc, only the first succeed\n     * 4. Try to upsert from step 1. Actual limit is created now, points are incremented without problems\n     */\n    return new Promise((resolve, reject) => {\n      this._collection.findOneAndUpdate(\n        where,\n        upsertData,\n        upsertOptions\n      ).then((res) => {\n        resolve(res);\n      }).catch((errUpsert) => {\n        if (errUpsert && errUpsert.code === 11000) { // E11000 duplicate key error collection\n          const replaceWhere = Object.assign({ // try to replace OLD limit doc\n            $or: [\n              { expire: { $lte: new Date() } },\n              { expire: { $eq: null } },\n            ],\n            key,\n          }, docAttrs);\n\n          const replaceTo = {\n            $set: Object.assign({\n              key,\n              points,\n              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null,\n            }, docAttrs)\n          };\n\n          this._collection.findOneAndUpdate(\n            replaceWhere,\n            replaceTo,\n            upsertOptions\n          ).then((res) => {\n            resolve(res);\n          }).catch((errReplace) => {\n            if (errReplace && errReplace.code === 11000) { // E11000 duplicate key error collection\n              this._upsert(key, points, msDuration, forceExpire)\n                .then(res => resolve(res))\n                .catch(err => reject(err));\n            } else {\n              reject(errReplace);\n            }\n          });\n        } else {\n          reject(errUpsert);\n        }\n      });\n    });\n  }\n\n  _get(rlKey, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n\n    const where = Object.assign({\n      key: rlKey,\n      $or: [\n        { expire: { $gt: new Date() } },\n        { expire: { $eq: null } },\n      ],\n    }, docAttrs);\n\n    return this._collection.findOne(where);\n  }\n\n  _delete(rlKey, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n    const where = Object.assign({ key: rlKey }, docAttrs);\n\n    return this._collection.deleteOne(where)\n      .then(res => res.deletedCount > 0);\n  }\n}\n\nmodule.exports = RateLimiterMongo;\n"]},"metadata":{},"sourceType":"script"}