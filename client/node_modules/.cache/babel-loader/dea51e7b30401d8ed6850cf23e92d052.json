{"ast":null,"code":"/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\n\nconst _0n = BigInt(0);\n\nconst _1n = BigInt(1);\n\nconst _2n = BigInt(2);\n\nconst _3n = BigInt(3);\n\nconst _8n = BigInt(8);\n\nconst CURVE = Object.freeze({\n  a: _0n,\n  b: BigInt(7),\n  P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n  h: _1n,\n  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')\n});\n\nconst divNearest = (a, b) => (a + b / _2n) / b;\n\nconst endo = {\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n\n  splitScalar(k) {\n    const {\n      n\n    } = CURVE;\n    const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n    const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n    const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n    const b2 = a1;\n    const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\n    const k1neg = k1 > POW_2_128;\n    const k2neg = k2 > POW_2_128;\n    if (k1neg) k1 = n - k1;\n    if (k2neg) k2 = n - k2;\n\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\n      throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n    }\n\n    return {\n      k1neg,\n      k1,\n      k2neg,\n      k2\n    };\n  }\n\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\nexport { CURVE };\n\nfunction weierstrass(x) {\n  const {\n    a,\n    b\n  } = CURVE;\n  const x2 = mod(x * x);\n  const x3 = mod(x2 * x);\n  return mod(x3 + a * x + b);\n}\n\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\n\nclass ShaError extends Error {\n  constructor(message) {\n    super(message);\n  }\n\n}\n\nfunction assertJacPoint(other) {\n  if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');\n}\n\nclass JacobianPoint {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  static fromAffine(p) {\n    if (!(p instanceof Point)) {\n      throw new TypeError('JacobianPoint#fromAffine: expected Point');\n    }\n\n    if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;\n    return new JacobianPoint(p.x, p.y, _1n);\n  }\n\n  static toAffineBatch(points) {\n    const toInv = invertBatch(points.map(p => p.z));\n    return points.map((p, i) => p.toAffine(toInv[i]));\n  }\n\n  static normalizeZ(points) {\n    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n  }\n\n  equals(other) {\n    assertJacPoint(other);\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2\n    } = other;\n    const Z1Z1 = mod(Z1 * Z1);\n    const Z2Z2 = mod(Z2 * Z2);\n    const U1 = mod(X1 * Z2Z2);\n    const U2 = mod(X2 * Z1Z1);\n    const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n    const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n    return U1 === U2 && S1 === S2;\n  }\n\n  negate() {\n    return new JacobianPoint(this.x, mod(-this.y), this.z);\n  }\n\n  double() {\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const A = mod(X1 * X1);\n    const B = mod(Y1 * Y1);\n    const C = mod(B * B);\n    const x1b = X1 + B;\n    const D = mod(_2n * (mod(x1b * x1b) - A - C));\n    const E = mod(_3n * A);\n    const F = mod(E * E);\n    const X3 = mod(F - _2n * D);\n    const Y3 = mod(E * (D - X3) - _8n * C);\n    const Z3 = mod(_2n * Y1 * Z1);\n    return new JacobianPoint(X3, Y3, Z3);\n  }\n\n  add(other) {\n    assertJacPoint(other);\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2\n    } = other;\n    if (X2 === _0n || Y2 === _0n) return this;\n    if (X1 === _0n || Y1 === _0n) return other;\n    const Z1Z1 = mod(Z1 * Z1);\n    const Z2Z2 = mod(Z2 * Z2);\n    const U1 = mod(X1 * Z2Z2);\n    const U2 = mod(X2 * Z1Z1);\n    const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n    const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n    const H = mod(U2 - U1);\n    const r = mod(S2 - S1);\n\n    if (H === _0n) {\n      if (r === _0n) {\n        return this.double();\n      } else {\n        return JacobianPoint.ZERO;\n      }\n    }\n\n    const HH = mod(H * H);\n    const HHH = mod(H * HH);\n    const V = mod(U1 * HH);\n    const X3 = mod(r * r - HHH - _2n * V);\n    const Y3 = mod(r * (V - X3) - S1 * HHH);\n    const Z3 = mod(Z1 * Z2 * H);\n    return new JacobianPoint(X3, Y3, Z3);\n  }\n\n  subtract(other) {\n    return this.add(other.negate());\n  }\n\n  multiplyUnsafe(scalar) {\n    const P0 = JacobianPoint.ZERO;\n    if (typeof scalar === 'bigint' && scalar === _0n) return P0;\n    let n = normalizeScalar(scalar);\n    if (n === _1n) return this;\n\n    if (!USE_ENDOMORPHISM) {\n      let p = P0;\n      let d = this;\n\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n\n      return p;\n    }\n\n    let {\n      k1neg,\n      k1,\n      k2neg,\n      k2\n    } = endo.splitScalar(n);\n    let k1p = P0;\n    let k2p = P0;\n    let d = this;\n\n    while (k1 > _0n || k2 > _0n) {\n      if (k1 & _1n) k1p = k1p.add(d);\n      if (k2 & _1n) k2p = k2p.add(d);\n      d = d.double();\n      k1 >>= _1n;\n      k2 >>= _1n;\n    }\n\n    if (k1neg) k1p = k1p.negate();\n    if (k2neg) k2p = k2p.negate();\n    k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n    return k1p.add(k2p);\n  }\n\n  precomputeWindow(W) {\n    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n    const points = [];\n    let p = this;\n    let base = p;\n\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n\n      for (let i = 1; i < 2 ** (W - 1); i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n\n      p = base.double();\n    }\n\n    return points;\n  }\n\n  wNAF(n, affinePoint) {\n    if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n\n    if (256 % W) {\n      throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n    }\n\n    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n\n    if (!precomputes) {\n      precomputes = this.precomputeWindow(W);\n\n      if (affinePoint && W !== 1) {\n        precomputes = JacobianPoint.normalizeZ(precomputes);\n        pointPrecomputes.set(affinePoint, precomputes);\n      }\n    }\n\n    let p = JacobianPoint.ZERO;\n    let f = JacobianPoint.BASE;\n    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n    const windowSize = 2 ** (W - 1);\n    const mask = BigInt(2 ** W - 1);\n    const maxNumber = 2 ** W;\n    const shiftBy = BigInt(W);\n\n    for (let window = 0; window < windows; window++) {\n      const offset = window * windowSize;\n      let wbits = Number(n & mask);\n      n >>= shiftBy;\n\n      if (wbits > windowSize) {\n        wbits -= maxNumber;\n        n += _1n;\n      }\n\n      const offset1 = offset;\n      const offset2 = offset + Math.abs(wbits) - 1;\n      const cond1 = window % 2 !== 0;\n      const cond2 = wbits < 0;\n\n      if (wbits === 0) {\n        f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n      } else {\n        p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n      }\n    }\n\n    return {\n      p,\n      f\n    };\n  }\n\n  multiply(scalar, affinePoint) {\n    let n = normalizeScalar(scalar);\n    let point;\n    let fake;\n\n    if (USE_ENDOMORPHISM) {\n      const {\n        k1neg,\n        k1,\n        k2neg,\n        k2\n      } = endo.splitScalar(n);\n      let {\n        p: k1p,\n        f: f1p\n      } = this.wNAF(k1, affinePoint);\n      let {\n        p: k2p,\n        f: f2p\n      } = this.wNAF(k2, affinePoint);\n      k1p = constTimeNegate(k1neg, k1p);\n      k2p = constTimeNegate(k2neg, k2p);\n      k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n      point = k1p.add(k2p);\n      fake = f1p.add(f2p);\n    } else {\n      const {\n        p,\n        f\n      } = this.wNAF(n, affinePoint);\n      point = p;\n      fake = f;\n    }\n\n    return JacobianPoint.normalizeZ([point, fake])[0];\n  }\n\n  toAffine(invZ) {\n    const {\n      x,\n      y,\n      z\n    } = this;\n    const is0 = this.equals(JacobianPoint.ZERO);\n    if (invZ == null) invZ = is0 ? _8n : invert(z);\n    const iz1 = invZ;\n    const iz2 = mod(iz1 * iz1);\n    const iz3 = mod(iz2 * iz1);\n    const ax = mod(x * iz2);\n    const ay = mod(y * iz3);\n    const zz = mod(z * iz1);\n    if (is0) return Point.ZERO;\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return new Point(ax, ay);\n  }\n\n}\n\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\n\nfunction constTimeNegate(condition, item) {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  _setWindowSize(windowSize) {\n    this._WINDOW_SIZE = windowSize;\n    pointPrecomputes.delete(this);\n  }\n\n  hasEvenY() {\n    return this.y % _2n === _0n;\n  }\n\n  static fromCompressedHex(bytes) {\n    const isShort = bytes.length === 32;\n    const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n    if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n    const y2 = weierstrass(x);\n    let y = sqrtMod(y2);\n    const isYOdd = (y & _1n) === _1n;\n\n    if (isShort) {\n      if (isYOdd) y = mod(-y);\n    } else {\n      const isFirstByteOdd = (bytes[0] & 1) === 1;\n      if (isFirstByteOdd !== isYOdd) y = mod(-y);\n    }\n\n    const point = new Point(x, y);\n    point.assertValidity();\n    return point;\n  }\n\n  static fromUncompressedHex(bytes) {\n    const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n    const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n    const point = new Point(x, y);\n    point.assertValidity();\n    return point;\n  }\n\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex);\n    const len = bytes.length;\n    const header = bytes[0];\n    if (len === fieldLen) return this.fromCompressedHex(bytes);\n\n    if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n      return this.fromCompressedHex(bytes);\n    }\n\n    if (len === uncompressedLen && header === 0x04) return this.fromUncompressedHex(bytes);\n    throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n  }\n\n  static fromPrivateKey(privateKey) {\n    return Point.BASE.multiply(normalizePrivateKey(privateKey));\n  }\n\n  static fromSignature(msgHash, signature, recovery) {\n    const {\n      r,\n      s\n    } = normalizeSignature(signature);\n    if (![0, 1, 2, 3].includes(recovery)) throw new Error('Cannot recover: invalid recovery bit');\n    const h = truncateHash(ensureBytes(msgHash));\n    const {\n      n\n    } = CURVE;\n    const radj = recovery === 2 || recovery === 3 ? r + n : r;\n    const rinv = invert(radj, n);\n    const u1 = mod(-h * rinv, n);\n    const u2 = mod(s * rinv, n);\n    const prefix = recovery & 1 ? '03' : '02';\n    const R = Point.fromHex(prefix + numTo32bStr(radj));\n    const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n    if (!Q) throw new Error('Cannot recover signature: point at infinify');\n    Q.assertValidity();\n    return Q;\n  }\n\n  toRawBytes() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return hexToBytes(this.toHex(isCompressed));\n  }\n\n  toHex() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const x = numTo32bStr(this.x);\n\n    if (isCompressed) {\n      const prefix = this.hasEvenY() ? '02' : '03';\n      return `${prefix}${x}`;\n    } else {\n      return `04${x}${numTo32bStr(this.y)}`;\n    }\n  }\n\n  toHexX() {\n    return this.toHex(true).slice(2);\n  }\n\n  toRawX() {\n    return this.toRawBytes(true).slice(1);\n  }\n\n  assertValidity() {\n    const msg = 'Point is not on elliptic curve';\n    const {\n      x,\n      y\n    } = this;\n    if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);\n    const left = mod(y * y);\n    const right = weierstrass(x);\n    if (mod(left - right) !== _0n) throw new Error(msg);\n  }\n\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n\n  negate() {\n    return new Point(this.x, mod(-this.y));\n  }\n\n  double() {\n    return JacobianPoint.fromAffine(this).double().toAffine();\n  }\n\n  add(other) {\n    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n  }\n\n  subtract(other) {\n    return this.add(other.negate());\n  }\n\n  multiply(scalar) {\n    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n  }\n\n  multiplyAndAddUnsafe(Q, a, b) {\n    const P = JacobianPoint.fromAffine(this);\n    const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n    const sum = aP.add(bQ);\n    return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n  }\n\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\n\nfunction sliceDER(s) {\n  return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\n\nfunction parseDERInt(data) {\n  if (data.length < 2 || data[0] !== 0x02) {\n    throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n  }\n\n  const len = data[1];\n  const res = data.subarray(2, len + 2);\n\n  if (!len || res.length !== len) {\n    throw new Error(`Invalid signature integer: wrong length`);\n  }\n\n  if (res[0] === 0x00 && res[1] <= 0x7f) {\n    throw new Error('Invalid signature integer: trailing length');\n  }\n\n  return {\n    data: bytesToNumber(res),\n    left: data.subarray(len + 2)\n  };\n}\n\nfunction parseDERSignature(data) {\n  if (data.length < 2 || data[0] != 0x30) {\n    throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n  }\n\n  if (data[1] !== data.length - 2) {\n    throw new Error('Invalid signature: incorrect length');\n  }\n\n  const {\n    data: r,\n    left: sBytes\n  } = parseDERInt(data.subarray(2));\n  const {\n    data: s,\n    left: rBytesLeft\n  } = parseDERInt(sBytes);\n\n  if (rBytesLeft.length) {\n    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n  }\n\n  return {\n    r,\n    s\n  };\n}\n\nexport class Signature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n\n  static fromCompact(hex) {\n    const arr = hex instanceof Uint8Array;\n    const name = 'Signature.fromCompact';\n    if (typeof hex !== 'string' && !arr) throw new TypeError(`${name}: Expected string or Uint8Array`);\n    const str = arr ? bytesToHex(hex) : hex;\n    if (str.length !== 128) throw new Error(`${name}: Expected 64-byte hex`);\n    return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n  }\n\n  static fromDER(hex) {\n    const arr = hex instanceof Uint8Array;\n    if (typeof hex !== 'string' && !arr) throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n    const {\n      r,\n      s\n    } = parseDERSignature(arr ? hex : hexToBytes(hex));\n    return new Signature(r, s);\n  }\n\n  static fromHex(hex) {\n    return this.fromDER(hex);\n  }\n\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');\n    if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');\n  }\n\n  hasHighS() {\n    const HALF = CURVE.n >> _1n;\n    return this.s > HALF;\n  }\n\n  normalizeS() {\n    return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n  }\n\n  toDERRawBytes() {\n    return hexToBytes(this.toDERHex());\n  }\n\n  toDERHex() {\n    const sHex = sliceDER(numberToHexUnpadded(this.s));\n    const rHex = sliceDER(numberToHexUnpadded(this.r));\n    const sHexL = sHex.length / 2;\n    const rHexL = rHex.length / 2;\n    const sLen = numberToHexUnpadded(sHexL);\n    const rLen = numberToHexUnpadded(rHexL);\n    const length = numberToHexUnpadded(rHexL + sHexL + 4);\n    return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n  }\n\n  toRawBytes() {\n    return this.toDERRawBytes();\n  }\n\n  toHex() {\n    return this.toDERHex();\n  }\n\n  toCompactRawBytes() {\n    return hexToBytes(this.toCompactHex());\n  }\n\n  toCompactHex() {\n    return numTo32bStr(this.r) + numTo32bStr(this.s);\n  }\n\n}\n\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  if (!arrays.every(b => b instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n\n  return result;\n}\n\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  let hex = '';\n\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n\n  return hex;\n}\n\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\n\nfunction numTo32bStr(num) {\n  if (typeof num !== 'bigint') throw new Error('Expected bigint');\n  if (!(_0n <= num && num < POW_2_256)) throw new Error('Expected number 0 <= n < 2^256');\n  return num.toString(16).padStart(64, '0');\n}\n\nfunction numTo32b(num) {\n  const b = hexToBytes(numTo32bStr(num));\n  if (b.length !== 32) throw new Error('Error: expected 32 bytes');\n  return b;\n}\n\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n  }\n\n  return BigInt(`0x${hex}`);\n}\n\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n  const array = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n\n  return array;\n}\n\nfunction bytesToNumber(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\n\nfunction ensureBytes(hex) {\n  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\n\nfunction normalizeScalar(num) {\n  if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0) return BigInt(num);\n  if (typeof num === 'bigint' && isWithinCurveOrder(num)) return num;\n  throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\n\nfunction mod(a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n\nfunction pow2(x, power) {\n  const {\n    P\n  } = CURVE;\n  let res = x;\n\n  while (power-- > _0n) {\n    res *= res;\n    res %= P;\n  }\n\n  return res;\n}\n\nfunction sqrtMod(x) {\n  const {\n    P\n  } = CURVE;\n\n  const _6n = BigInt(6);\n\n  const _11n = BigInt(11);\n\n  const _22n = BigInt(22);\n\n  const _23n = BigInt(23);\n\n  const _44n = BigInt(44);\n\n  const _88n = BigInt(88);\n\n  const b2 = x * x * x % P;\n  const b3 = b2 * b2 * x % P;\n  const b6 = pow2(b3, _3n) * b3 % P;\n  const b9 = pow2(b6, _3n) * b3 % P;\n  const b11 = pow2(b9, _2n) * b2 % P;\n  const b22 = pow2(b11, _11n) * b11 % P;\n  const b44 = pow2(b22, _22n) * b22 % P;\n  const b88 = pow2(b44, _44n) * b44 % P;\n  const b176 = pow2(b88, _88n) * b88 % P;\n  const b220 = pow2(b176, _44n) * b44 % P;\n  const b223 = pow2(b220, _3n) * b3 % P;\n  const t1 = pow2(b223, _23n) * b22 % P;\n  const t2 = pow2(t1, _6n) * b2 % P;\n  const rt = pow2(t2, _2n);\n  const xc = rt * rt % P;\n  if (xc !== x) throw new Error('Cannot find square root');\n  return rt;\n}\n\nfunction invert(number) {\n  let modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n\n  let a = mod(number, modulo);\n  let b = modulo;\n  let x = _0n,\n      y = _1n,\n      u = _1n,\n      v = _0n;\n\n  while (a !== _0n) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction invertBatch(nums) {\n  let p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const scratch = new Array(nums.length);\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (num === _0n) return acc;\n    scratch[i] = acc;\n    return mod(acc * num, p);\n  }, _1n);\n  const inverted = invert(lastMultiplied, p);\n  nums.reduceRight((acc, num, i) => {\n    if (num === _0n) return acc;\n    scratch[i] = mod(acc * scratch[i], p);\n    return mod(acc * num, p);\n  }, inverted);\n  return scratch;\n}\n\nfunction bits2int_2(bytes) {\n  const delta = bytes.length * 8 - groupLen * 8;\n  const num = bytesToNumber(bytes);\n  return delta > 0 ? num >> BigInt(delta) : num;\n}\n\nfunction truncateHash(hash) {\n  let truncateOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const h = bits2int_2(hash);\n  if (truncateOnly) return h;\n  const {\n    n\n  } = CURVE;\n  return h >= n ? h - n : h;\n}\n\nlet _sha256Sync;\n\nlet _hmacSha256Sync;\n\nclass HmacDrbg {\n  constructor(hashLen, qByteLen) {\n    this.hashLen = hashLen;\n    this.qByteLen = qByteLen;\n    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n    this.v = new Uint8Array(hashLen).fill(1);\n    this.k = new Uint8Array(hashLen).fill(0);\n    this.counter = 0;\n  }\n\n  hmac() {\n    for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      values[_key2] = arguments[_key2];\n    }\n\n    return utils.hmacSha256(this.k, ...values);\n  }\n\n  hmacSync() {\n    for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      values[_key3] = arguments[_key3];\n    }\n\n    return _hmacSha256Sync(this.k, ...values);\n  }\n\n  checkSync() {\n    if (typeof _hmacSha256Sync !== 'function') throw new ShaError('hmacSha256Sync needs to be set');\n  }\n\n  incr() {\n    if (this.counter >= 1000) throw new Error('Tried 1,000 k values for sign(), all were invalid');\n    this.counter += 1;\n  }\n\n  async reseed() {\n    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n    this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n    this.v = await this.hmac(this.v);\n    if (seed.length === 0) return;\n    this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n    this.v = await this.hmac(this.v);\n  }\n\n  reseedSync() {\n    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n    this.checkSync();\n    this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n    this.v = this.hmacSync(this.v);\n    if (seed.length === 0) return;\n    this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n    this.v = this.hmacSync(this.v);\n  }\n\n  async generate() {\n    this.incr();\n    let len = 0;\n    const out = [];\n\n    while (len < this.qByteLen) {\n      this.v = await this.hmac(this.v);\n      const sl = this.v.slice();\n      out.push(sl);\n      len += this.v.length;\n    }\n\n    return concatBytes(...out);\n  }\n\n  generateSync() {\n    this.checkSync();\n    this.incr();\n    let len = 0;\n    const out = [];\n\n    while (len < this.qByteLen) {\n      this.v = this.hmacSync(this.v);\n      const sl = this.v.slice();\n      out.push(sl);\n      len += this.v.length;\n    }\n\n    return concatBytes(...out);\n  }\n\n}\n\nfunction isWithinCurveOrder(num) {\n  return _0n < num && num < CURVE.n;\n}\n\nfunction isValidFieldElement(num) {\n  return _0n < num && num < CURVE.P;\n}\n\nfunction kmdToSig(kBytes, m, d) {\n  let lowS = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  const {\n    n\n  } = CURVE;\n  const k = truncateHash(kBytes, true);\n  if (!isWithinCurveOrder(k)) return;\n  const kinv = invert(k, n);\n  const q = Point.BASE.multiply(k);\n  const r = mod(q.x, n);\n  if (r === _0n) return;\n  const s = mod(kinv * mod(m + d * r, n), n);\n  if (s === _0n) return;\n  let sig = new Signature(r, s);\n  let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n\n  if (lowS && sig.hasHighS()) {\n    sig = sig.normalizeS();\n    recovery ^= 1;\n  }\n\n  return {\n    sig,\n    recovery\n  };\n}\n\nfunction normalizePrivateKey(key) {\n  let num;\n\n  if (typeof key === 'bigint') {\n    num = key;\n  } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n    num = BigInt(key);\n  } else if (typeof key === 'string') {\n    if (key.length !== 2 * groupLen) throw new Error('Expected 32 bytes of private key');\n    num = hexToNumber(key);\n  } else if (key instanceof Uint8Array) {\n    if (key.length !== groupLen) throw new Error('Expected 32 bytes of private key');\n    num = bytesToNumber(key);\n  } else {\n    throw new TypeError('Expected valid private key');\n  }\n\n  if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');\n  return num;\n}\n\nfunction normalizePublicKey(publicKey) {\n  if (publicKey instanceof Point) {\n    publicKey.assertValidity();\n    return publicKey;\n  } else {\n    return Point.fromHex(publicKey);\n  }\n}\n\nfunction normalizeSignature(signature) {\n  if (signature instanceof Signature) {\n    signature.assertValidity();\n    return signature;\n  }\n\n  try {\n    return Signature.fromDER(signature);\n  } catch (error) {\n    return Signature.fromCompact(signature);\n  }\n}\n\nexport function getPublicKey(privateKey) {\n  let isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery) {\n  let isCompressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\n\nfunction isProbPub(item) {\n  const arr = item instanceof Uint8Array;\n  const str = typeof item === 'string';\n  const len = (arr || str) && item.length;\n  if (arr) return len === compressedLen || len === uncompressedLen;\n  if (str) return len === compressedLen * 2 || len === uncompressedLen * 2;\n  if (item instanceof Point) return true;\n  return false;\n}\n\nexport function getSharedSecret(privateA, publicB) {\n  let isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (isProbPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');\n  if (!isProbPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');\n  const b = normalizePublicKey(publicB);\n  b.assertValidity();\n  return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\n\nfunction bits2int(bytes) {\n  const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n  return bytesToNumber(slice);\n}\n\nfunction bits2octets(bytes) {\n  const z1 = bits2int(bytes);\n  const z2 = mod(z1, CURVE.n);\n  return int2octets(z2 < _0n ? z1 : z2);\n}\n\nfunction int2octets(num) {\n  return numTo32b(num);\n}\n\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n  if (msgHash == null) throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n  const h1 = ensureBytes(msgHash);\n  const d = normalizePrivateKey(privateKey);\n  const seedArgs = [int2octets(d), bits2octets(h1)];\n\n  if (extraEntropy != null) {\n    if (extraEntropy === true) extraEntropy = utils.randomBytes(fieldLen);\n    const e = ensureBytes(extraEntropy);\n    if (e.length !== fieldLen) throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n    seedArgs.push(e);\n  }\n\n  const seed = concatBytes(...seedArgs);\n  const m = bits2int(h1);\n  return {\n    seed,\n    m,\n    d\n  };\n}\n\nfunction finalizeSig(recSig, opts) {\n  const {\n    sig,\n    recovery\n  } = recSig;\n  const {\n    der,\n    recovered\n  } = Object.assign({\n    canonical: true,\n    der: true\n  }, opts);\n  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n  return recovered ? [hashed, recovery] : hashed;\n}\n\nasync function sign(msgHash, privKey) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    seed,\n    m,\n    d\n  } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n  const drbg = new HmacDrbg(hashLen, groupLen);\n  await drbg.reseed(seed);\n  let sig;\n\n  while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical))) await drbg.reseed();\n\n  return finalizeSig(sig, opts);\n}\n\nfunction signSync(msgHash, privKey) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    seed,\n    m,\n    d\n  } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n  const drbg = new HmacDrbg(hashLen, groupLen);\n  drbg.reseedSync(seed);\n  let sig;\n\n  while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical))) drbg.reseedSync();\n\n  return finalizeSig(sig, opts);\n}\n\nexport { sign, signSync };\nconst vopts = {\n  strict: true\n};\nexport function verify(signature, msgHash, publicKey) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : vopts;\n  let sig;\n\n  try {\n    sig = normalizeSignature(signature);\n    msgHash = ensureBytes(msgHash);\n  } catch (error) {\n    return false;\n  }\n\n  const {\n    r,\n    s\n  } = sig;\n  if (opts.strict && sig.hasHighS()) return false;\n  const h = truncateHash(msgHash);\n  let P;\n\n  try {\n    P = normalizePublicKey(publicKey);\n  } catch (error) {\n    return false;\n  }\n\n  const {\n    n\n  } = CURVE;\n  const sinv = invert(s, n);\n  const u1 = mod(h * sinv, n);\n  const u2 = mod(r * sinv, n);\n  const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n  if (!R) return false;\n  const v = mod(R.x, n);\n  return v === r;\n}\n\nfunction schnorrChallengeFinalize(ch) {\n  return mod(bytesToNumber(ch), CURVE.n);\n}\n\nclass SchnorrSignature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex);\n    if (bytes.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n    const r = bytesToNumber(bytes.subarray(0, 32));\n    const s = bytesToNumber(bytes.subarray(32, 64));\n    return new SchnorrSignature(r, s);\n  }\n\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error('Invalid signature');\n  }\n\n  toHex() {\n    return numTo32bStr(this.r) + numTo32bStr(this.s);\n  }\n\n  toRawBytes() {\n    return hexToBytes(this.toHex());\n  }\n\n}\n\nfunction schnorrGetPublicKey(privateKey) {\n  return Point.fromPrivateKey(privateKey).toRawX();\n}\n\nclass InternalSchnorrSignature {\n  constructor(message, privateKey) {\n    let auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : utils.randomBytes();\n    if (message == null) throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n    this.m = ensureBytes(message);\n    const {\n      x,\n      scalar\n    } = this.getScalar(normalizePrivateKey(privateKey));\n    this.px = x;\n    this.d = scalar;\n    this.rand = ensureBytes(auxRand);\n    if (this.rand.length !== 32) throw new TypeError('sign: Expected 32 bytes of aux randomness');\n  }\n\n  getScalar(priv) {\n    const point = Point.fromPrivateKey(priv);\n    const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n    return {\n      point,\n      scalar,\n      x: point.toRawX()\n    };\n  }\n\n  initNonce(d, t0h) {\n    return numTo32b(d ^ bytesToNumber(t0h));\n  }\n\n  finalizeNonce(k0h) {\n    const k0 = mod(bytesToNumber(k0h), CURVE.n);\n    if (k0 === _0n) throw new Error('sign: Creation of signature failed. k is zero');\n    const {\n      point: R,\n      x: rx,\n      scalar: k\n    } = this.getScalar(k0);\n    return {\n      R,\n      rx,\n      k\n    };\n  }\n\n  finalizeSig(R, k, e, d) {\n    return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n  }\n\n  error() {\n    throw new Error('sign: Invalid signature produced');\n  }\n\n  async calc() {\n    const {\n      m,\n      d,\n      px,\n      rand\n    } = this;\n    const tag = utils.taggedHash;\n    const t = this.initNonce(d, await tag(TAGS.aux, rand));\n    const {\n      R,\n      rx,\n      k\n    } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n    const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n    const sig = this.finalizeSig(R, k, e, d);\n    if (!(await schnorrVerify(sig, m, px))) this.error();\n    return sig;\n  }\n\n  calcSync() {\n    const {\n      m,\n      d,\n      px,\n      rand\n    } = this;\n    const tag = utils.taggedHashSync;\n    const t = this.initNonce(d, tag(TAGS.aux, rand));\n    const {\n      R,\n      rx,\n      k\n    } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n    const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n    const sig = this.finalizeSig(R, k, e, d);\n    if (!schnorrVerifySync(sig, m, px)) this.error();\n    return sig;\n  }\n\n}\n\nasync function schnorrSign(msg, privKey, auxRand) {\n  return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\n\nfunction schnorrSignSync(msg, privKey, auxRand) {\n  return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\n\nfunction initSchnorrVerify(signature, message, publicKey) {\n  const raw = signature instanceof SchnorrSignature;\n  const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n  if (raw) sig.assertValidity();\n  return { ...sig,\n    m: ensureBytes(message),\n    P: normalizePublicKey(publicKey)\n  };\n}\n\nfunction finalizeSchnorrVerify(r, P, s, e) {\n  const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n  if (!R || !R.hasEvenY() || R.x !== r) return false;\n  return true;\n}\n\nasync function schnorrVerify(signature, message, publicKey) {\n  try {\n    const {\n      r,\n      s,\n      m,\n      P\n    } = initSchnorrVerify(signature, message, publicKey);\n    const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n    return finalizeSchnorrVerify(r, P, s, e);\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction schnorrVerifySync(signature, message, publicKey) {\n  try {\n    const {\n      r,\n      s,\n      m,\n      P\n    } = initSchnorrVerify(signature, message, publicKey);\n    const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n    return finalizeSchnorrVerify(r, P, s, e);\n  } catch (error) {\n    if (error instanceof ShaError) throw error;\n    return false;\n  }\n}\n\nexport const schnorr = {\n  Signature: SchnorrSignature,\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  signSync: schnorrSignSync,\n  verifySync: schnorrVerifySync\n};\n\nPoint.BASE._setWindowSize(8);\n\nconst crypto = {\n  node: nodeCrypto,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\nconst TAGS = {\n  challenge: 'BIP0340/challenge',\n  aux: 'BIP0340/aux',\n  nonce: 'BIP0340/nonce'\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n  bytesToHex,\n  hexToBytes,\n  concatBytes,\n  mod,\n  invert,\n\n  isValidPrivateKey(privateKey) {\n    try {\n      normalizePrivateKey(privateKey);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  },\n\n  _bigintTo32Bytes: numTo32b,\n  _normalizePrivateKey: normalizePrivateKey,\n  hashToPrivateKey: hash => {\n    hash = ensureBytes(hash);\n    const minLen = groupLen + 8;\n\n    if (hash.length < minLen || hash.length > 1024) {\n      throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n    }\n\n    const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n\n    return numTo32b(num);\n  },\n  randomBytes: function () {\n    let bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      const {\n        randomBytes\n      } = crypto.node;\n      return Uint8Array.from(randomBytes(bytesLength));\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),\n\n  precompute() {\n    let windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n    const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n\n    cached._setWindowSize(windowSize);\n\n    cached.multiply(_3n);\n    return cached;\n  },\n\n  sha256: async function () {\n    for (var _len4 = arguments.length, messages = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      messages[_key4] = arguments[_key4];\n    }\n\n    if (crypto.web) {\n      const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n      return new Uint8Array(buffer);\n    } else if (crypto.node) {\n      const {\n        createHash\n      } = crypto.node;\n      const hash = createHash('sha256');\n      messages.forEach(m => hash.update(m));\n      return Uint8Array.from(hash.digest());\n    } else {\n      throw new Error(\"The environment doesn't have sha256 function\");\n    }\n  },\n  hmacSha256: async function (key) {\n    for (var _len5 = arguments.length, messages = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      messages[_key5 - 1] = arguments[_key5];\n    }\n\n    if (crypto.web) {\n      const ckey = await crypto.web.subtle.importKey('raw', key, {\n        name: 'HMAC',\n        hash: {\n          name: 'SHA-256'\n        }\n      }, false, ['sign']);\n      const message = concatBytes(...messages);\n      const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n      return new Uint8Array(buffer);\n    } else if (crypto.node) {\n      const {\n        createHmac\n      } = crypto.node;\n      const hash = createHmac('sha256', key);\n      messages.forEach(m => hash.update(m));\n      return Uint8Array.from(hash.digest());\n    } else {\n      throw new Error(\"The environment doesn't have hmac-sha256 function\");\n    }\n  },\n  sha256Sync: undefined,\n  hmacSha256Sync: undefined,\n  taggedHash: async function (tag) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n\n    if (tagP === undefined) {\n      const tagH = await utils.sha256(Uint8Array.from(tag, c => c.charCodeAt(0)));\n      tagP = concatBytes(tagH, tagH);\n      TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n\n    for (var _len6 = arguments.length, messages = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      messages[_key6 - 1] = arguments[_key6];\n    }\n\n    return utils.sha256(tagP, ...messages);\n  },\n  taggedHashSync: function (tag) {\n    if (typeof _sha256Sync !== 'function') throw new ShaError('sha256Sync is undefined, you need to set it');\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n\n    if (tagP === undefined) {\n      const tagH = _sha256Sync(Uint8Array.from(tag, c => c.charCodeAt(0)));\n\n      tagP = concatBytes(tagH, tagH);\n      TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n\n    for (var _len7 = arguments.length, messages = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      messages[_key7 - 1] = arguments[_key7];\n    }\n\n    return _sha256Sync(tagP, ...messages);\n  },\n  _JacobianPoint: JacobianPoint\n};\nObject.defineProperties(utils, {\n  sha256Sync: {\n    configurable: false,\n\n    get() {\n      return _sha256Sync;\n    },\n\n    set(val) {\n      if (!_sha256Sync) _sha256Sync = val;\n    }\n\n  },\n  hmacSha256Sync: {\n    configurable: false,\n\n    get() {\n      return _hmacSha256Sync;\n    },\n\n    set(val) {\n      if (!_hmacSha256Sync) _hmacSha256Sync = val;\n    }\n\n  }\n});","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/@noble/secp256k1/lib/esm/index.js"],"names":["nodeCrypto","_0n","BigInt","_1n","_2n","_3n","_8n","CURVE","Object","freeze","a","b","P","n","h","Gx","Gy","beta","divNearest","endo","splitScalar","k","a1","b1","a2","b2","POW_2_128","c1","c2","k1","mod","k2","k1neg","k2neg","Error","fieldLen","groupLen","hashLen","compressedLen","uncompressedLen","weierstrass","x","x2","x3","USE_ENDOMORPHISM","ShaError","constructor","message","assertJacPoint","other","JacobianPoint","TypeError","y","z","fromAffine","p","Point","equals","ZERO","toAffineBatch","points","toInv","invertBatch","map","i","toAffine","normalizeZ","X1","Y1","Z1","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","negate","double","A","B","C","x1b","D","E","F","X3","Y3","Z3","add","H","r","HH","HHH","V","subtract","multiplyUnsafe","scalar","P0","normalizeScalar","d","k1p","k2p","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","BASE","_WINDOW_SIZE","precomputes","pointPrecomputes","get","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","offset1","offset2","Math","abs","cond1","cond2","constTimeNegate","multiply","point","fake","f1p","f2p","invZ","is0","invert","iz1","iz2","iz3","ax","ay","zz","condition","item","neg","WeakMap","_setWindowSize","delete","hasEvenY","fromCompressedHex","bytes","isShort","length","bytesToNumber","subarray","isValidFieldElement","y2","sqrtMod","isYOdd","isFirstByteOdd","assertValidity","fromUncompressedHex","fromHex","hex","ensureBytes","len","header","fromPrivateKey","privateKey","normalizePrivateKey","fromSignature","msgHash","signature","recovery","s","normalizeSignature","includes","truncateHash","radj","rinv","u1","u2","prefix","R","numTo32bStr","Q","multiplyAndAddUnsafe","toRawBytes","isCompressed","hexToBytes","toHex","toHexX","slice","toRawX","msg","left","right","aP","bQ","sum","undefined","sliceDER","parseInt","parseDERInt","data","bytesToHex","res","parseDERSignature","sBytes","rBytesLeft","Signature","fromCompact","arr","Uint8Array","name","str","hexToNumber","fromDER","isWithinCurveOrder","hasHighS","HALF","normalizeS","toDERRawBytes","toDERHex","sHex","numberToHexUnpadded","rHex","sHexL","rHexL","sLen","rLen","toCompactRawBytes","toCompactHex","concatBytes","arrays","every","reduce","result","pad","hexes","Array","from","v","toString","padStart","uint8a","POW_2_256","num","numTo32b","array","j","hexByte","byte","isNaN","isSafeInteger","pow2","power","_6n","_11n","_22n","_23n","_44n","_88n","b3","b6","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","rt","xc","number","modulo","u","q","m","gcd","nums","scratch","lastMultiplied","acc","inverted","reduceRight","bits2int_2","delta","hash","truncateOnly","_sha256Sync","_hmacSha256Sync","HmacDrbg","qByteLen","fill","counter","hmac","values","utils","hmacSha256","hmacSync","checkSync","incr","reseed","seed","reseedSync","generate","out","sl","generateSync","kmdToSig","kBytes","lowS","kinv","sig","key","normalizePublicKey","publicKey","error","getPublicKey","recoverPublicKey","isProbPub","getSharedSecret","privateA","publicB","bits2int","bits2octets","z1","z2","int2octets","initSigArgs","extraEntropy","h1","seedArgs","randomBytes","e","finalizeSig","recSig","opts","der","recovered","assign","canonical","hashed","sign","privKey","drbg","signSync","vopts","strict","verify","sinv","schnorrChallengeFinalize","ch","SchnorrSignature","schnorrGetPublicKey","InternalSchnorrSignature","auxRand","getScalar","px","rand","priv","initNonce","t0h","finalizeNonce","k0h","k0","rx","calc","tag","taggedHash","t","TAGS","aux","nonce","challenge","schnorrVerify","calcSync","taggedHashSync","schnorrVerifySync","schnorrSign","schnorrSignSync","initSchnorrVerify","raw","finalizeSchnorrVerify","schnorr","verifySync","crypto","node","web","self","TAGGED_HASH_PREFIXES","isValidPrivateKey","_bigintTo32Bytes","_normalizePrivateKey","hashToPrivateKey","minLen","bytesLength","getRandomValues","randomPrivateKey","precompute","cached","sha256","messages","buffer","subtle","digest","createHash","forEach","update","ckey","importKey","createHmac","sha256Sync","hmacSha256Sync","tagP","tagH","c","charCodeAt","_JacobianPoint","defineProperties","configurable","val"],"mappings":"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","sourcesContent":["/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n});\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst endo = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    splitScalar(k) {\n        const { n } = CURVE;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg)\n            k1 = n - k1;\n        if (k2neg)\n            k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n    },\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\nexport { CURVE };\nfunction weierstrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nfunction assertJacPoint(other) {\n    if (!(other instanceof JacobianPoint))\n        throw new TypeError('JacobianPoint expected');\n}\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return JacobianPoint.ZERO;\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.BASE;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            k1p = constTimeNegate(k1neg, k1p);\n            k2p = constTimeNegate(k2neg, k2p);\n            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(JacobianPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weierstrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === fieldLen)\n            return this.fromCompressedHex(bytes);\n        if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === uncompressedLen && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const { r, s } = normalizeSignature(signature);\n        if (![0, 1, 2, 3].includes(recovery))\n            throw new Error('Cannot recover: invalid recovery bit');\n        const h = truncateHash(ensureBytes(msgHash));\n        const { n } = CURVE;\n        const radj = recovery === 2 || recovery === 3 ? r + n : r;\n        const rinv = invert(radj, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(radj));\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? '02' : '03';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weierstrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nexport class Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n    toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const sHexL = sHex.length / 2;\n        const rHexL = rHex.length / 2;\n        const sLen = numberToHexUnpadded(sHexL);\n        const rLen = numberToHexUnpadded(rHexL);\n        const length = numberToHexUnpadded(rHexL + sHexL + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b) => b instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    if (!(_0n <= num && num < POW_2_256))\n        throw new Error('Expected number 0 <= n < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32)\n        throw new Error('Error: expected 32 bytes');\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    const rt = pow2(t2, _2n);\n    const xc = (rt * rt) % P;\n    if (xc !== x)\n        throw new Error('Cannot find square root');\n    return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nfunction bits2int_2(bytes) {\n    const delta = bytes.length * 8 - groupLen * 8;\n    const num = bytesToNumber(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n    const h = bits2int_2(hash);\n    if (truncateOnly)\n        return h;\n    const { n } = CURVE;\n    return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor(hashLen, qByteLen) {\n        this.hashLen = hashLen;\n        this.qByteLen = qByteLen;\n        if (typeof hashLen !== 'number' || hashLen < 2)\n            throw new Error('hashLen must be a number');\n        if (typeof qByteLen !== 'number' || qByteLen < 2)\n            throw new Error('qByteLen must be a number');\n        this.v = new Uint8Array(hashLen).fill(1);\n        this.k = new Uint8Array(hashLen).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== 'function')\n            throw new ShaError('hmacSha256Sync needs to be set');\n    }\n    incr() {\n        if (this.counter >= 1000)\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = await this.hmac(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = this.hmacSync(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n    const { n } = CURVE;\n    const k = truncateHash(kBytes, true);\n    if (!isWithinCurveOrder(k))\n        return;\n    const kinv = invert(k, n);\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(kinv * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    let sig = new Signature(r, s);\n    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    if (lowS && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 2 * groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nexport function getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === compressedLen || len === uncompressedLen;\n    if (str)\n        return len === compressedLen * 2 || len === uncompressedLen * 2;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isProbPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(fieldLen);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== fieldLen)\n            throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    const { sig, recovery } = recSig;\n    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    await drbg.reseed(seed);\n    let sig;\n    while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    drbg.reseedSync(seed);\n    let sig;\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = { strict: true };\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = utils.randomBytes()) {\n        if (message == null)\n            throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32)\n            throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return { point, scalar, x: point.toRawX() };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n)\n            throw new Error('sign: Creation of signature failed. k is zero');\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return { R, rx, k };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error('sign: Invalid signature produced');\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!(await schnorrVerify(sig, m, px)))\n            this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px))\n            this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        if (error instanceof ShaError)\n            throw error;\n        return false;\n    }\n}\nexport const schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        const minLen = groupLen + 8;\n        if (hash.length < minLen || hash.length > 1024) {\n            throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n        }\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof _sha256Sync !== 'function')\n            throw new ShaError('sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    _JacobianPoint: JacobianPoint,\n};\nObject.defineProperties(utils, {\n    sha256Sync: {\n        configurable: false,\n        get() {\n            return _sha256Sync;\n        },\n        set(val) {\n            if (!_sha256Sync)\n                _sha256Sync = val;\n        },\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get() {\n            return _hmacSha256Sync;\n        },\n        set(val) {\n            if (!_hmacSha256Sync)\n                _hmacSha256Sync = val;\n        },\n    },\n});\n"]},"metadata":{},"sourceType":"module"}