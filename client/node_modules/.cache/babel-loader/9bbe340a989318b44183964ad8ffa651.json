{"ast":null,"code":"import { CID } from 'multiformats/cid';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { base58btc } from 'multiformats/bases/base58'; // @ts-ignore\n\nimport vd from 'varint-decoder';\nimport ve from '../utils/varint-encoder.js';\nimport { isMapEqual } from '../utils/index.js';\nimport { Message } from './message.js';\nimport { BitswapMessageEntry as Entry } from './entry.js';\nimport { CodeError } from '@libp2p/interfaces/errors';\n/**\n * @typedef {import('../types').MultihashHasherLoader} MultihashHasherLoader\n */\n\nexport class BitswapMessage {\n  /**\n   * @param {boolean} full\n   */\n  constructor(full) {\n    this.full = full;\n    /** @type {Map<string, Entry>} */\n\n    this.wantlist = new Map();\n    /** @type {Map<string, Uint8Array>} */\n\n    this.blocks = new Map();\n    /** @type {Map<string, import('./message').Message.BlockPresenceType>} */\n\n    this.blockPresences = new Map();\n    this.pendingBytes = 0;\n  }\n\n  get empty() {\n    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;\n  }\n  /**\n   *\n   * @param {CID} cid\n   * @param {number} priority\n   * @param {import('./message').Message.Wantlist.WantType | null} [wantType]\n   * @param {boolean} [cancel]\n   * @param {boolean} [sendDontHave]\n   * @returns {void}\n   */\n\n\n  addEntry(cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block;\n    }\n\n    const cidStr = cid.toString(base58btc);\n    const entry = this.wantlist.get(cidStr);\n\n    if (entry) {\n      // Only change priority if want is of the same type\n      if (entry.wantType === wantType) {\n        entry.priority = priority;\n      } // Only change from \"dont cancel\" to \"do cancel\"\n\n\n      if (cancel) {\n        entry.cancel = Boolean(cancel);\n      } // Only change from \"dont send\" to \"do send\" DONT_HAVE\n\n\n      if (sendDontHave) {\n        entry.sendDontHave = Boolean(sendDontHave);\n      } // want-block overrides existing want-have\n\n\n      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n        entry.wantType = wantType;\n      }\n    } else {\n      this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave));\n    }\n  }\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @returns {void}\n   */\n\n\n  addBlock(cid, block) {\n    const cidStr = cid.toString(base58btc);\n    this.blocks.set(cidStr, block);\n  }\n  /**\n   * @param {CID} cid\n   */\n\n\n  addHave(cid) {\n    const cidStr = cid.toString(base58btc);\n\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n    }\n  }\n  /**\n   * @param {CID} cid\n   */\n\n\n  addDontHave(cid) {\n    const cidStr = cid.toString(base58btc);\n\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n    }\n  }\n  /**\n   * @param {CID} cid\n   */\n\n\n  cancel(cid) {\n    const cidStr = cid.toString(base58btc);\n    this.wantlist.delete(cidStr);\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n  }\n  /**\n   * @param {number} size\n   */\n\n\n  setPendingBytes(size) {\n    this.pendingBytes = size;\n  }\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.0.0\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  serializeToBitswap100() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.bytes,\n            // cid\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          };\n        }),\n        full: this.full ? true : undefined\n      },\n      blocks: Array.from(this.blocks.values())\n    };\n    return Message.encode(msg).finish();\n  }\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.1.0\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  serializeToBitswap110() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.bytes,\n            // cid\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          };\n        }),\n        full: this.full ? true : undefined\n      },\n\n      /** @type {import('./message').Message.BlockPresence[]} */\n      blockPresences: [],\n\n      /** @type {{ prefix: Uint8Array, data: Uint8Array }[]} */\n      payload: [],\n      pendingBytes: this.pendingBytes\n    };\n\n    for (const [cidStr, data] of this.blocks.entries()) {\n      const cid = CID.parse(cidStr);\n      const version = cid.version;\n      const codec = cid.code;\n      const multihash = cid.multihash.code;\n      const digestLength = cid.multihash.digest.length;\n      const prefix = ve([version, codec, multihash, digestLength]);\n      msg.payload.push(new Message.Block({\n        prefix,\n        data\n      }));\n    }\n\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push(new Message.BlockPresence({\n        cid: CID.parse(cidStr).bytes,\n        type: bpType\n      }));\n    }\n\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes;\n    }\n\n    return Message.encode(msg).finish();\n  }\n  /**\n   * @param {BitswapMessage} other\n   * @returns {boolean}\n   */\n\n\n  equals(other) {\n    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || // @TODO - Is this a bug ?\n    // @ts-expect-error - isMap equals map values to be objects not numbers\n    !isMapEqual(this.blockPresences, other.blockPresences)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get [Symbol.toStringTag]() {\n    const list = Array.from(this.wantlist.keys());\n    const blocks = Array.from(this.blocks.keys());\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;\n  }\n\n}\n/**\n * @param {Uint8Array} raw\n * @param {MultihashHasherLoader} [hashLoader]\n */\n\nBitswapMessage.deserialize = async (raw, hashLoader) => {\n  const decoded = Message.decode(raw);\n  const isFull = decoded.wantlist && decoded.wantlist.full || false;\n  const msg = new BitswapMessage(isFull);\n\n  if (decoded.wantlist && decoded.wantlist.entries) {\n    decoded.wantlist.entries.forEach(entry => {\n      if (!entry.block) {\n        return;\n      } // note: entry.block is the CID here\n\n\n      const cid = CID.decode(entry.block);\n      msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));\n    });\n  }\n\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach(blockPresence => {\n      if (!blockPresence.cid) {\n        return;\n      }\n\n      const cid = CID.decode(blockPresence.cid);\n\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid);\n      } else {\n        msg.addDontHave(cid);\n      }\n    });\n  } // Bitswap 1.0.0\n  // decoded.blocks are just the byte arrays\n\n\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async b => {\n      const hash = await sha256.digest(b);\n      const cid = CID.createV0(hash);\n      msg.addBlock(cid, b);\n    }));\n    return msg;\n  } // Bitswap 1.1.0\n\n\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async p => {\n      if (!p.prefix || !p.data) {\n        return;\n      }\n\n      const values = vd(p.prefix);\n      const cidVersion = values[0];\n      const multicodec = values[1];\n      const hashAlg = values[2];\n      const hasher = hashAlg === sha256.code ? sha256 : hashLoader && (await hashLoader.getHasher(hashAlg));\n\n      if (!hasher) {\n        throw new CodeError('Unknown hash algorithm', 'ERR_UNKNOWN_HASH_ALG');\n      } // const hashLen = values[3] // We haven't need to use this so far\n\n\n      const hash = await hasher.digest(p.data);\n      const cid = CID.create(cidVersion, multicodec, hash);\n      msg.addBlock(cid, p.data);\n    }));\n    msg.setPendingBytes(decoded.pendingBytes);\n    return msg;\n  }\n\n  return msg;\n};\n/**\n * @param {CID} cid\n */\n\n\nBitswapMessage.blockPresenceSize = cid => {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.bytes.length + 1;\n};\n\nBitswapMessage.Entry = Entry;\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n};\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-bitswap/src/message/index.js"],"names":["CID","sha256","base58btc","vd","ve","isMapEqual","Message","BitswapMessageEntry","Entry","CodeError","BitswapMessage","constructor","full","wantlist","Map","blocks","blockPresences","pendingBytes","empty","size","addEntry","cid","priority","wantType","cancel","sendDontHave","WantType","Block","cidStr","toString","entry","get","Boolean","Have","set","addBlock","block","addHave","has","BlockPresenceType","addDontHave","DontHave","delete","setPendingBytes","serializeToBitswap100","msg","entries","Array","from","values","map","bytes","Number","undefined","encode","finish","serializeToBitswap110","payload","data","parse","version","codec","code","multihash","digestLength","digest","length","prefix","push","bpType","BlockPresence","type","equals","other","Symbol","toStringTag","list","keys","deserialize","raw","hashLoader","decoded","decode","isFull","forEach","blockPresence","Promise","all","b","hash","createV0","p","cidVersion","multicodec","hashAlg","hasher","getHasher","create","blockPresenceSize","Wantlist"],"mappings":"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","sourcesContent":["import { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { base58btc } from 'multiformats/bases/base58'\n// @ts-ignore\nimport vd from 'varint-decoder'\nimport ve from '../utils/varint-encoder.js'\nimport { isMapEqual } from '../utils/index.js'\nimport { Message } from './message.js'\nimport { BitswapMessageEntry as Entry } from './entry.js'\nimport { CodeError } from '@libp2p/interfaces/errors'\n\n/**\n * @typedef {import('../types').MultihashHasherLoader} MultihashHasherLoader\n */\n\nexport class BitswapMessage {\n  /**\n   * @param {boolean} full\n   */\n  constructor (full) {\n    this.full = full\n    /** @type {Map<string, Entry>} */\n    this.wantlist = new Map()\n\n    /** @type {Map<string, Uint8Array>} */\n    this.blocks = new Map()\n\n    /** @type {Map<string, import('./message').Message.BlockPresenceType>} */\n    this.blockPresences = new Map()\n    this.pendingBytes = 0\n  }\n\n  get empty () {\n    return this.blocks.size === 0 &&\n           this.wantlist.size === 0 &&\n           this.blockPresences.size === 0\n  }\n\n  /**\n   *\n   * @param {CID} cid\n   * @param {number} priority\n   * @param {import('./message').Message.Wantlist.WantType | null} [wantType]\n   * @param {boolean} [cancel]\n   * @param {boolean} [sendDontHave]\n   * @returns {void}\n   */\n  addEntry (cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block\n    }\n\n    const cidStr = cid.toString(base58btc)\n    const entry = this.wantlist.get(cidStr)\n    if (entry) {\n      // Only change priority if want is of the same type\n      if (entry.wantType === wantType) {\n        entry.priority = priority\n      }\n      // Only change from \"dont cancel\" to \"do cancel\"\n      if (cancel) {\n        entry.cancel = Boolean(cancel)\n      }\n      // Only change from \"dont send\" to \"do send\" DONT_HAVE\n      if (sendDontHave) {\n        entry.sendDontHave = Boolean(sendDontHave)\n      }\n      // want-block overrides existing want-have\n      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n        entry.wantType = wantType\n      }\n    } else {\n      this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave))\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @returns {void}\n   */\n  addBlock (cid, block) {\n    const cidStr = cid.toString(base58btc)\n    this.blocks.set(cidStr, block)\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  addHave (cid) {\n    const cidStr = cid.toString(base58btc)\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  addDontHave (cid) {\n    const cidStr = cid.toString(base58btc)\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  cancel (cid) {\n    const cidStr = cid.toString(base58btc)\n    this.wantlist.delete(cidStr)\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false)\n  }\n\n  /**\n   * @param {number} size\n   */\n  setPendingBytes (size) {\n    this.pendingBytes = size\n  }\n\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.0.0\n   *\n   * @returns {Uint8Array}\n   */\n  serializeToBitswap100 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.bytes, // cid\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          }\n        }),\n        full: this.full ? true : undefined\n      },\n      blocks: Array.from(this.blocks.values())\n    }\n\n    return Message.encode(msg).finish()\n  }\n\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.1.0\n   *\n   * @returns {Uint8Array}\n   */\n  serializeToBitswap110 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.bytes, // cid\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          }\n        }),\n        full: this.full ? true : undefined\n      },\n      /** @type {import('./message').Message.BlockPresence[]} */\n      blockPresences: [],\n\n      /** @type {{ prefix: Uint8Array, data: Uint8Array }[]} */\n      payload: [],\n      pendingBytes: this.pendingBytes\n    }\n\n    for (const [cidStr, data] of this.blocks.entries()) {\n      const cid = CID.parse(cidStr)\n      const version = cid.version\n      const codec = cid.code\n      const multihash = cid.multihash.code\n      const digestLength = cid.multihash.digest.length\n      const prefix = ve([\n        version, codec, multihash, digestLength\n      ])\n\n      msg.payload.push(\n        new Message.Block({\n          prefix,\n          data\n        })\n      )\n    }\n\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push(new Message.BlockPresence({\n        cid: CID.parse(cidStr).bytes,\n        type: bpType\n      }))\n    }\n\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes\n    }\n\n    return Message.encode(msg).finish()\n  }\n\n  /**\n   * @param {BitswapMessage} other\n   * @returns {boolean}\n   */\n  equals (other) {\n    if (this.full !== other.full ||\n        this.pendingBytes !== other.pendingBytes ||\n        !isMapEqual(this.wantlist, other.wantlist) ||\n        !isMapEqual(this.blocks, other.blocks) ||\n        // @TODO - Is this a bug ?\n        // @ts-expect-error - isMap equals map values to be objects not numbers\n        !isMapEqual(this.blockPresences, other.blockPresences)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  get [Symbol.toStringTag] () {\n    const list = Array.from(this.wantlist.keys())\n    const blocks = Array.from(this.blocks.keys())\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`\n  }\n}\n\n/**\n * @param {Uint8Array} raw\n * @param {MultihashHasherLoader} [hashLoader]\n */\nBitswapMessage.deserialize = async (raw, hashLoader) => {\n  const decoded = Message.decode(raw)\n\n  const isFull = (decoded.wantlist && decoded.wantlist.full) || false\n  const msg = new BitswapMessage(isFull)\n\n  if (decoded.wantlist && decoded.wantlist.entries) {\n    decoded.wantlist.entries.forEach((entry) => {\n      if (!entry.block) {\n        return\n      }\n      // note: entry.block is the CID here\n      const cid = CID.decode(entry.block)\n      msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave))\n    })\n  }\n\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach((blockPresence) => {\n      if (!blockPresence.cid) {\n        return\n      }\n\n      const cid = CID.decode(blockPresence.cid)\n\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid)\n      } else {\n        msg.addDontHave(cid)\n      }\n    })\n  }\n\n  // Bitswap 1.0.0\n  // decoded.blocks are just the byte arrays\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async (b) => {\n      const hash = await sha256.digest(b)\n      const cid = CID.createV0(hash)\n      msg.addBlock(cid, b)\n    }))\n    return msg\n  }\n\n  // Bitswap 1.1.0\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async (p) => {\n      if (!p.prefix || !p.data) {\n        return\n      }\n      const values = vd(p.prefix)\n      const cidVersion = values[0]\n      const multicodec = values[1]\n      const hashAlg = values[2]\n      const hasher = hashAlg === sha256.code ? sha256 : hashLoader && await hashLoader.getHasher(hashAlg)\n\n      if (!hasher) {\n        throw new CodeError('Unknown hash algorithm', 'ERR_UNKNOWN_HASH_ALG')\n      }\n\n      // const hashLen = values[3] // We haven't need to use this so far\n      const hash = await hasher.digest(p.data)\n      const cid = CID.create(cidVersion, multicodec, hash)\n      msg.addBlock(cid, p.data)\n    }))\n    msg.setPendingBytes(decoded.pendingBytes)\n    return msg\n  }\n\n  return msg\n}\n\n/**\n * @param {CID} cid\n */\nBitswapMessage.blockPresenceSize = (cid) => {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.bytes.length + 1\n}\n\nBitswapMessage.Entry = Entry\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n}\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n}\n"]},"metadata":{},"sourceType":"module"}