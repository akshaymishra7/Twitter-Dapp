{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { codes } from '../errors.js';\nimport { randomBytes } from '@libp2p/crypto';\nimport { pipe } from 'it-pipe';\nimport first from 'it-first';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { PROTOCOL_NAME, PING_LENGTH, PROTOCOL_VERSION } from './constants.js';\nimport { abortableDuplex } from 'abortable-iterator';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { setMaxListeners } from 'events';\nconst log = logger('libp2p:ping');\nexport class PingService {\n  constructor(components, init) {\n    this.components = components;\n    this.started = false;\n    this.protocol = `/${init.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;\n    this.init = init;\n  }\n\n  async start() {\n    await this.components.registrar.handle(this.protocol, this.handleMessage, {\n      maxInboundStreams: this.init.maxInboundStreams,\n      maxOutboundStreams: this.init.maxOutboundStreams\n    });\n    this.started = true;\n  }\n\n  async stop() {\n    await this.components.registrar.unhandle(this.protocol);\n    this.started = false;\n  }\n\n  isStarted() {\n    return this.started;\n  }\n  /**\n   * A handler to register with Libp2p to process ping messages\n   */\n\n\n  handleMessage(data) {\n    const {\n      stream\n    } = data;\n    void pipe(stream, stream).catch(err => {\n      log.error(err);\n    });\n  }\n  /**\n   * Ping a given peer and wait for its response, getting the operation latency.\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @returns {Promise<number>}\n   */\n\n\n  async ping(peer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    log('dialing %s to %p', this.protocol, peer);\n    const start = Date.now();\n    const data = randomBytes(PING_LENGTH);\n    const connection = await this.components.connectionManager.openConnection(peer, options);\n    let timeoutController;\n    let signal = options.signal;\n    let stream; // create a timeout if no abort signal passed\n\n    if (signal == null) {\n      timeoutController = new TimeoutController(this.init.timeout);\n      signal = timeoutController.signal;\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal);\n      } catch {}\n    }\n\n    try {\n      stream = await connection.newStream([this.protocol], {\n        signal\n      }); // make stream abortable\n\n      const source = abortableDuplex(stream, signal);\n      const result = await pipe([data], source, async source => await first(source));\n      const end = Date.now();\n\n      if (result == null || !uint8ArrayEquals(data, result.subarray())) {\n        throw errCode(new Error('Received wrong ping ack'), codes.ERR_WRONG_PING_ACK);\n      }\n\n      return end - start;\n    } finally {\n      if (timeoutController != null) {\n        timeoutController.clear();\n      }\n\n      if (stream != null) {\n        stream.close();\n      }\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","errCode","codes","randomBytes","pipe","first","equals","uint8ArrayEquals","PROTOCOL_NAME","PING_LENGTH","PROTOCOL_VERSION","abortableDuplex","TimeoutController","setMaxListeners","log","PingService","constructor","components","init","started","protocol","protocolPrefix","start","registrar","handle","handleMessage","maxInboundStreams","maxOutboundStreams","stop","unhandle","isStarted","data","stream","catch","err","error","ping","peer","options","Date","now","connection","connectionManager","openConnection","timeoutController","signal","timeout","Infinity","newStream","source","result","end","subarray","Error","ERR_WRONG_PING_ACK","clear","close"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\ping\\index.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { codes } from '../errors.js'\nimport { randomBytes } from '@libp2p/crypto'\nimport { pipe } from 'it-pipe'\nimport first from 'it-first'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { PROTOCOL_NAME, PING_LENGTH, PROTOCOL_VERSION } from './constants.js'\nimport type { IncomingStreamData, Registrar } from '@libp2p/interface-registrar'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport { abortableDuplex } from 'abortable-iterator'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport type { Stream } from '@libp2p/interface-connection'\nimport { setMaxListeners } from 'events'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\n\nconst log = logger('libp2p:ping')\n\nexport interface PingServiceInit {\n  protocolPrefix: string\n  maxInboundStreams: number\n  maxOutboundStreams: number\n\n  /**\n   * How long we should wait for a ping response\n   */\n  timeout: number\n}\n\nexport interface PingServiceComponents {\n  registrar: Registrar\n  connectionManager: ConnectionManager\n}\n\nexport class PingService implements Startable {\n  public readonly protocol: string\n  private readonly components: PingServiceComponents\n  private started: boolean\n  private readonly init: PingServiceInit\n\n  constructor (components: PingServiceComponents, init: PingServiceInit) {\n    this.components = components\n    this.started = false\n    this.protocol = `/${init.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`\n    this.init = init\n  }\n\n  async start () {\n    await this.components.registrar.handle(this.protocol, this.handleMessage, {\n      maxInboundStreams: this.init.maxInboundStreams,\n      maxOutboundStreams: this.init.maxOutboundStreams\n    })\n    this.started = true\n  }\n\n  async stop () {\n    await this.components.registrar.unhandle(this.protocol)\n    this.started = false\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * A handler to register with Libp2p to process ping messages\n   */\n  handleMessage (data: IncomingStreamData) {\n    const { stream } = data\n\n    void pipe(stream, stream)\n      .catch(err => {\n        log.error(err)\n      })\n  }\n\n  /**\n   * Ping a given peer and wait for its response, getting the operation latency.\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @returns {Promise<number>}\n   */\n  async ping (peer: PeerId, options: AbortOptions = {}): Promise<number> {\n    log('dialing %s to %p', this.protocol, peer)\n\n    const start = Date.now()\n    const data = randomBytes(PING_LENGTH)\n    const connection = await this.components.connectionManager.openConnection(peer, options)\n    let timeoutController\n    let signal = options.signal\n    let stream: Stream | undefined\n\n    // create a timeout if no abort signal passed\n    if (signal == null) {\n      timeoutController = new TimeoutController(this.init.timeout)\n      signal = timeoutController.signal\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal)\n      } catch {}\n    }\n\n    try {\n      stream = await connection.newStream([this.protocol], {\n        signal\n      })\n\n      // make stream abortable\n      const source = abortableDuplex(stream, signal)\n\n      const result = await pipe(\n        [data],\n        source,\n        async (source) => await first(source)\n      )\n      const end = Date.now()\n\n      if (result == null || !uint8ArrayEquals(data, result.subarray())) {\n        throw errCode(new Error('Received wrong ping ack'), codes.ERR_WRONG_PING_ACK)\n      }\n\n      return end - start\n    } finally {\n      if (timeoutController != null) {\n        timeoutController.clear()\n      }\n\n      if (stream != null) {\n        stream.close()\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}