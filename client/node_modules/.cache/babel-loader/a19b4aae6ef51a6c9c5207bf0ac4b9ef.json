{"ast":null,"code":"import { IPNS } from '../ipns/index.js';\nimport { createRouting } from '../ipns/routing/config.js';\nimport { OfflineDatastore } from '../ipns/routing/offline-datastore.js';\nimport { NotInitializedError, AlreadyInitializedError } from '../errors.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('ipfs:components:ipns');\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n *\n * @typedef {object} ExperimentalOptions\n * @property {boolean} [ipnsPubsub]\n *\n * @typedef {object} LibP2POptions\n * @property {DHTConfig} [config]\n *\n * @typedef {object} DHTConfig\n * @property {boolean} [enabled]\n */\n\nexport class IPNSAPI {\n  /**\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {boolean} [options.offline]\n   * @param {LibP2POptions} [options.libp2p]\n   * @param {ExperimentalOptions} [options.EXPERIMENTAL]\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      pass: ''\n    };\n    this.options = options;\n    /** @type {IPNS | null} */\n\n    this.offline = null;\n    /** @type {IPNS | null} */\n\n    this.online = null;\n  }\n\n  getIPNS() {\n    const ipns = this.online || this.offline;\n\n    if (ipns) {\n      return ipns;\n    } else {\n      throw new NotInitializedError();\n    }\n  }\n\n  get routing() {\n    return this.getIPNS().routing;\n  }\n  /**\n   * Activates IPNS subsystem in an ofline mode. If it was started once already\n   * it will throw an exception.\n   *\n   * This is primarily used for offline ipns modifications, such as the\n   * initializeKeyspace feature.\n   *\n   * @param {object} config\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n   */\n\n\n  startOffline(_ref) {\n    let {\n      repo,\n      peerId,\n      keychain\n    } = _ref;\n\n    if (this.offline != null) {\n      throw new AlreadyInitializedError();\n    }\n\n    log('initializing IPNS keyspace (offline)');\n    const routing = new OfflineDatastore(repo.datastore);\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);\n    this.offline = ipns;\n  }\n  /**\n   * @param {object} config\n   * @param {import('libp2p').Libp2p} config.libp2p\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n   */\n\n\n  async startOnline(_ref2) {\n    let {\n      libp2p,\n      repo,\n      peerId,\n      keychain\n    } = _ref2;\n\n    if (this.online != null) {\n      throw new AlreadyInitializedError();\n    }\n\n    const routing = createRouting({\n      libp2p,\n      repo,\n      peerId,\n      options: this.options\n    }); // @ts-expect-error routing is a TieredDatastore which wants keys to be Keys, IPNS needs keys to be Uint8Arrays\n\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);\n    await ipns.republisher.start();\n    this.online = ipns;\n  }\n\n  async stop() {\n    const ipns = this.online;\n\n    if (ipns) {\n      await ipns.republisher.stop();\n      this.online = null;\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n\n\n  publish(peerId, value, lifetime, options) {\n    return this.getIPNS().publish(peerId, value, lifetime, options);\n  }\n  /**\n   *\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  resolve(name, options) {\n    return this.getIPNS().resolve(name, options);\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} [options]\n   */\n\n\n  initializeKeyspace(peerId, value, options) {\n    return this.getIPNS().initializeKeyspace(peerId, value, options);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/ipns.js"],"names":["IPNS","createRouting","OfflineDatastore","NotInitializedError","AlreadyInitializedError","logger","log","IPNSAPI","constructor","options","pass","offline","online","getIPNS","ipns","routing","startOffline","repo","peerId","keychain","datastore","startOnline","libp2p","republisher","start","stop","publish","value","lifetime","resolve","name","initializeKeyspace"],"mappings":"AAAA,SAASA,IAAT,QAAqB,kBAArB;AACA,SAASC,aAAT,QAA8B,2BAA9B;AACA,SAASC,gBAAT,QAAiC,sCAAjC;AACA,SAASC,mBAAT,EAA8BC,uBAA9B,QAA6D,cAA7D;AACA,SAASC,MAAT,QAAuB,gBAAvB;AAEA,MAAMC,GAAG,GAAGD,MAAM,CAAC,sBAAD,CAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAME,OAAN,CAAc;AACnB;AACF;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,GAA0B;AAAA,QAAxBC,OAAwB,uEAAd;AAAEC,MAAAA,IAAI,EAAE;AAAR,KAAc;AACnC,SAAKD,OAAL,GAAeA,OAAf;AAEA;;AACA,SAAKE,OAAL,GAAe,IAAf;AAEA;;AACA,SAAKC,MAAL,GAAc,IAAd;AACD;;AAEDC,EAAAA,OAAO,GAAI;AACT,UAAMC,IAAI,GAAG,KAAKF,MAAL,IAAe,KAAKD,OAAjC;;AACA,QAAIG,IAAJ,EAAU;AACR,aAAOA,IAAP;AACD,KAFD,MAEO;AACL,YAAM,IAAIX,mBAAJ,EAAN;AACD;AACF;;AAEU,MAAPY,OAAO,GAAI;AACb,WAAO,KAAKF,OAAL,GAAeE,OAAtB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,YAAY,OAA8B;AAAA,QAA5B;AAAEC,MAAAA,IAAF;AAAQC,MAAAA,MAAR;AAAgBC,MAAAA;AAAhB,KAA4B;;AACxC,QAAI,KAAKR,OAAL,IAAgB,IAApB,EAA0B;AACxB,YAAM,IAAIP,uBAAJ,EAAN;AACD;;AAEDE,IAAAA,GAAG,CAAC,sCAAD,CAAH;AAEA,UAAMS,OAAO,GAAG,IAAIb,gBAAJ,CAAqBe,IAAI,CAACG,SAA1B,CAAhB;AACA,UAAMN,IAAI,GAAG,IAAId,IAAJ,CAASe,OAAT,EAAkBE,IAAI,CAACG,SAAvB,EAAkCF,MAAlC,EAA0CC,QAA1C,EAAoD,KAAKV,OAAzD,CAAb;AAEA,SAAKE,OAAL,GAAeG,IAAf;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACmB,QAAXO,WAAW,QAAsC;AAAA,QAApC;AAAEC,MAAAA,MAAF;AAAUL,MAAAA,IAAV;AAAgBC,MAAAA,MAAhB;AAAwBC,MAAAA;AAAxB,KAAoC;;AACrD,QAAI,KAAKP,MAAL,IAAe,IAAnB,EAAyB;AACvB,YAAM,IAAIR,uBAAJ,EAAN;AACD;;AACD,UAAMW,OAAO,GAAGd,aAAa,CAAC;AAAEqB,MAAAA,MAAF;AAAUL,MAAAA,IAAV;AAAgBC,MAAAA,MAAhB;AAAwBT,MAAAA,OAAO,EAAE,KAAKA;AAAtC,KAAD,CAA7B,CAJqD,CAMrD;;AACA,UAAMK,IAAI,GAAG,IAAId,IAAJ,CAASe,OAAT,EAAkBE,IAAI,CAACG,SAAvB,EAAkCF,MAAlC,EAA0CC,QAA1C,EAAoD,KAAKV,OAAzD,CAAb;AACA,UAAMK,IAAI,CAACS,WAAL,CAAiBC,KAAjB,EAAN;AACA,SAAKZ,MAAL,GAAcE,IAAd;AACD;;AAES,QAAJW,IAAI,GAAI;AACZ,UAAMX,IAAI,GAAG,KAAKF,MAAlB;;AACA,QAAIE,IAAJ,EAAU;AACR,YAAMA,IAAI,CAACS,WAAL,CAAiBE,IAAjB,EAAN;AACA,WAAKb,MAAL,GAAc,IAAd;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEc,EAAAA,OAAO,CAAER,MAAF,EAAUS,KAAV,EAAiBC,QAAjB,EAA2BnB,OAA3B,EAAoC;AACzC,WAAO,KAAKI,OAAL,GAAea,OAAf,CAAuBR,MAAvB,EAA+BS,KAA/B,EAAsCC,QAAtC,EAAgDnB,OAAhD,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEoB,EAAAA,OAAO,CAAEC,IAAF,EAAQrB,OAAR,EAAiB;AACtB,WAAO,KAAKI,OAAL,GAAegB,OAAf,CAAuBC,IAAvB,EAA6BrB,OAA7B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEsB,EAAAA,kBAAkB,CAAEb,MAAF,EAAUS,KAAV,EAAiBlB,OAAjB,EAA0B;AAC1C,WAAO,KAAKI,OAAL,GAAekB,kBAAf,CAAkCb,MAAlC,EAA0CS,KAA1C,EAAiDlB,OAAjD,CAAP;AACD;;AAhHkB","sourcesContent":["import { IPNS } from '../ipns/index.js'\nimport { createRouting } from '../ipns/routing/config.js'\nimport { OfflineDatastore } from '../ipns/routing/offline-datastore.js'\nimport { NotInitializedError, AlreadyInitializedError } from '../errors.js'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('ipfs:components:ipns')\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n *\n * @typedef {object} ExperimentalOptions\n * @property {boolean} [ipnsPubsub]\n *\n * @typedef {object} LibP2POptions\n * @property {DHTConfig} [config]\n *\n * @typedef {object} DHTConfig\n * @property {boolean} [enabled]\n */\n\nexport class IPNSAPI {\n  /**\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {boolean} [options.offline]\n   * @param {LibP2POptions} [options.libp2p]\n   * @param {ExperimentalOptions} [options.EXPERIMENTAL]\n   */\n  constructor (options = { pass: '' }) {\n    this.options = options\n\n    /** @type {IPNS | null} */\n    this.offline = null\n\n    /** @type {IPNS | null} */\n    this.online = null\n  }\n\n  getIPNS () {\n    const ipns = this.online || this.offline\n    if (ipns) {\n      return ipns\n    } else {\n      throw new NotInitializedError()\n    }\n  }\n\n  get routing () {\n    return this.getIPNS().routing\n  }\n\n  /**\n   * Activates IPNS subsystem in an ofline mode. If it was started once already\n   * it will throw an exception.\n   *\n   * This is primarily used for offline ipns modifications, such as the\n   * initializeKeyspace feature.\n   *\n   * @param {object} config\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n   */\n  startOffline ({ repo, peerId, keychain }) {\n    if (this.offline != null) {\n      throw new AlreadyInitializedError()\n    }\n\n    log('initializing IPNS keyspace (offline)')\n\n    const routing = new OfflineDatastore(repo.datastore)\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options)\n\n    this.offline = ipns\n  }\n\n  /**\n   * @param {object} config\n   * @param {import('libp2p').Libp2p} config.libp2p\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n   */\n  async startOnline ({ libp2p, repo, peerId, keychain }) {\n    if (this.online != null) {\n      throw new AlreadyInitializedError()\n    }\n    const routing = createRouting({ libp2p, repo, peerId, options: this.options })\n\n    // @ts-expect-error routing is a TieredDatastore which wants keys to be Keys, IPNS needs keys to be Uint8Arrays\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options)\n    await ipns.republisher.start()\n    this.online = ipns\n  }\n\n  async stop () {\n    const ipns = this.online\n    if (ipns) {\n      await ipns.republisher.stop()\n      this.online = null\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  publish (peerId, value, lifetime, options) {\n    return this.getIPNS().publish(peerId, value, lifetime, options)\n  }\n\n  /**\n   *\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n  resolve (name, options) {\n    return this.getIPNS().resolve(name, options)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} [options]\n   */\n  initializeKeyspace (peerId, value, options) {\n    return this.getIPNS().initializeKeyspace(peerId, value, options)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}