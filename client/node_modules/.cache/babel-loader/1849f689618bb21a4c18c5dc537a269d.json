{"ast":null,"code":"import errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { IpnsPublisher } from './publisher.js';\nimport { IpnsRepublisher } from './republisher.js';\nimport { IpnsResolver } from './resolver.js';\nimport { TLRU } from '../utils/tlru.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nconst log = logger('ipfs:ipns');\nconst defaultRecordTtl = 60 * 1000;\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nexport class IPNS {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor(routing, datastore, peerId, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore);\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);\n    this.resolver = new IpnsResolver(routing);\n    this.cache = new TLRU(1000);\n    this.routing = routing;\n  }\n  /**\n   * Publish\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n\n\n  async publish(peerId, value) {\n    let lifetime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : IpnsPublisher.defaultRecordLifetime;\n    let options = arguments.length > 3 ? arguments[3] : undefined;\n\n    try {\n      await this.publisher.publishWithEOL(peerId, value, lifetime, options);\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was published correctly`); // // Add to cache\n\n      const id = peerId.toString(); // @ts-expect-error - parseFloat expects string\n\n      const ttEol = parseFloat(lifetime);\n      const ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n      this.cache.set(id, value, ttl);\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was cached correctly`);\n      return {\n        name: id,\n        value: value\n      };\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n      throw err;\n    }\n  }\n  /**\n   * Resolve\n   *\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async resolve(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof name !== 'string') {\n      throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME');\n    } // If recursive, we should not try to get the cached value\n\n\n    if (!options.nocache && !options.recursive) {\n      // Try to get the record from cache\n      const id = name.split('/')[2];\n      const result = this.cache.get(id);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    try {\n      const result = await this.resolver.resolve(name, options);\n      log(`IPNS record from ${name} was resolved correctly`);\n      return result;\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n      throw err;\n    }\n  }\n  /**\n   * Initialize keyspace\n   *\n   * Sets the ipns record for the given key to point to an empty directory\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} [options]\n   */\n\n\n  async initializeKeyspace(peerId, value, options) {\n    // eslint-disable-line require-await\n    return this.publish(peerId, value, IpnsPublisher.defaultRecordLifetime, options);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/ipns/index.js"],"names":["errcode","logger","IpnsPublisher","IpnsRepublisher","IpnsResolver","TLRU","toString","uint8ArrayToString","log","defaultRecordTtl","IPNS","constructor","routing","datastore","peerId","keychain","options","publisher","republisher","resolver","cache","publish","value","lifetime","defaultRecordLifetime","publishWithEOL","id","ttEol","parseFloat","ttl","set","name","err","error","resolve","Error","nocache","recursive","split","result","get","initializeKeyspace"],"mappings":"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","sourcesContent":["import errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { IpnsPublisher } from './publisher.js'\nimport { IpnsRepublisher } from './republisher.js'\nimport { IpnsResolver } from './resolver.js'\nimport { TLRU } from '../utils/tlru.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nconst log = logger('ipfs:ipns')\nconst defaultRecordTtl = 60 * 1000\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nexport class IPNS {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor (routing, datastore, peerId, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore)\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options)\n    this.resolver = new IpnsResolver(routing)\n    this.cache = new TLRU(1000)\n    this.routing = routing\n  }\n\n  /**\n   * Publish\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  async publish (peerId, value, lifetime = IpnsPublisher.defaultRecordLifetime, options) {\n    try {\n      await this.publisher.publishWithEOL(peerId, value, lifetime, options)\n\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was published correctly`)\n\n      // // Add to cache\n      const id = peerId.toString()\n      // @ts-expect-error - parseFloat expects string\n      const ttEol = parseFloat(lifetime)\n      const ttl = (ttEol < defaultRecordTtl) ? ttEol : defaultRecordTtl\n\n      this.cache.set(id, value, ttl)\n\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was cached correctly`)\n\n      return {\n        name: id,\n        value: value\n      }\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  /**\n   * Resolve\n   *\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n  async resolve (name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME')\n    }\n\n    // If recursive, we should not try to get the cached value\n    if (!options.nocache && !options.recursive) {\n      // Try to get the record from cache\n      const id = name.split('/')[2]\n      const result = this.cache.get(id)\n\n      if (result) {\n        return result\n      }\n    }\n\n    try {\n      const result = await this.resolver.resolve(name, options)\n\n      log(`IPNS record from ${name} was resolved correctly`)\n\n      return result\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  /**\n   * Initialize keyspace\n   *\n   * Sets the ipns record for the given key to point to an empty directory\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} [options]\n   */\n  async initializeKeyspace (peerId, value, options) { // eslint-disable-line require-await\n    return this.publish(peerId, value, IpnsPublisher.defaultRecordLifetime, options)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}