{"ast":null,"code":"import { Key } from 'interface-datastore/key';\nimport PQueue from 'p-queue';\nimport _get from 'just-safe-get';\nimport _set from 'just-safe-set';\nimport errCode from 'err-code';\nimport { NotFoundError } from './errors.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { getWithFallback, hasWithFallback } from './utils/level.js'; // @ts-ignore types are broken in p-queue@6.x.x - also, if we imported via esm\n// we can use the default, if via cjs we need to get the default via prop access\n\nconst Queue = PQueue.default ? PQueue.default : PQueue;\nconst configKey = new Key('config');\n/**\n * @typedef {import('./types').Config} Config\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {Datastore} store\n */\n\nexport function config(store) {\n  const setQueue = new Queue({\n    concurrency: 1\n  });\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     * @returns {Promise<Config>}\n     */\n    async getAll() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      const encodedValue = await getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store);\n      return JSON.parse(uint8ArrayToString(encodedValue));\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {string} key - the config key to get\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     */\n    async get(key) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (key == null) {\n        throw new NotFoundError(`Key ${key} does not exist in config`);\n      }\n\n      const config = await this.getAll(options);\n\n      const value = _get(config, key);\n\n      if (value === undefined) {\n        throw new NotFoundError(`Key ${key} does not exist in config`);\n      }\n\n      return value;\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {string} key - the config key to be written\n     * @param {any} [value] - the config value to be written\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    set(key, value) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      // @ts-ignore ts thinks key will only be a string, but it may not be\n      if (typeof key !== 'string' && !(key instanceof String)) {\n        throw errCode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY');\n      }\n\n      if (value === undefined || value instanceof Uint8Array) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal));\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Config} [value] - the config value to be written\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    replace(value) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!value || value instanceof Uint8Array) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal));\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     */\n    async exists() {\n      // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migration to v10 or above\n      return hasWithFallback(configKey, store.has.bind(store), store);\n    }\n\n  };\n  return configStore;\n  /**\n   * @param {{ key: any; value: any; }} m\n   * @param {AbortSignal | undefined} signal\n   */\n\n  async function _maybeDoSet(m, signal) {\n    if (signal && signal.aborted) {\n      return;\n    }\n\n    const key = m.key;\n    const value = m.value;\n\n    if (key) {\n      const config = await configStore.getAll();\n\n      if (typeof config === 'object' && config !== null) {\n        _set(config, key, value);\n      }\n\n      return _saveAll(config);\n    }\n\n    return _saveAll(value);\n  }\n  /**\n   * @param {unknown} config\n   */\n\n\n  function _saveAll(config) {\n    const buf = uint8ArrayFromString(JSON.stringify(config, null, 2));\n    return store.put(configKey, buf);\n  }\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-repo/src/config.js"],"names":["Key","PQueue","_get","_set","errCode","NotFoundError","toString","uint8ArrayToString","fromString","uint8ArrayFromString","getWithFallback","hasWithFallback","Queue","default","configKey","config","store","setQueue","concurrency","configStore","getAll","options","encodedValue","get","bind","has","JSON","parse","key","value","undefined","set","String","Error","Uint8Array","add","_maybeDoSet","signal","replace","exists","m","aborted","_saveAll","buf","stringify","put"],"mappings":"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","sourcesContent":["\nimport { Key } from 'interface-datastore/key'\nimport PQueue from 'p-queue'\nimport _get from 'just-safe-get'\nimport _set from 'just-safe-set'\nimport errCode from 'err-code'\nimport { NotFoundError } from './errors.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { getWithFallback, hasWithFallback } from './utils/level.js'\n\n// @ts-ignore types are broken in p-queue@6.x.x - also, if we imported via esm\n// we can use the default, if via cjs we need to get the default via prop access\nconst Queue = PQueue.default ? PQueue.default : PQueue\n\nconst configKey = new Key('config')\n\n/**\n * @typedef {import('./types').Config} Config\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {Datastore} store\n */\nexport function config (store) {\n  const setQueue = new Queue({ concurrency: 1 })\n\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     * @returns {Promise<Config>}\n     */\n    async getAll (options = {}) { // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      const encodedValue = await getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store)\n\n      return JSON.parse(uint8ArrayToString(encodedValue))\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {string} key - the config key to get\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     */\n    async get (key, options = {}) {\n      if (key == null) {\n        throw new NotFoundError(`Key ${key} does not exist in config`)\n      }\n\n      const config = await this.getAll(options)\n      const value = _get(config, key)\n\n      if (value === undefined) {\n        throw new NotFoundError(`Key ${key} does not exist in config`)\n      }\n\n      return value\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {string} key - the config key to be written\n     * @param {any} [value] - the config value to be written\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    set (key, value, options = {}) {\n      // @ts-ignore ts thinks key will only be a string, but it may not be\n      if (typeof key !== 'string' && !(key instanceof String)) {\n        throw errCode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY')\n      }\n\n      if (value === undefined || (value instanceof Uint8Array)) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Config} [value] - the config value to be written\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    replace (value, options = {}) {\n      if (!value || (value instanceof Uint8Array)) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     */\n    async exists () { // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migration to v10 or above\n      return hasWithFallback(configKey, store.has.bind(store), store)\n    }\n  }\n\n  return configStore\n\n  /**\n   * @param {{ key: any; value: any; }} m\n   * @param {AbortSignal | undefined} signal\n   */\n  async function _maybeDoSet (m, signal) {\n    if (signal && signal.aborted) {\n      return\n    }\n\n    const key = m.key\n    const value = m.value\n    if (key) {\n      const config = await configStore.getAll()\n      if (typeof config === 'object' && config !== null) {\n        _set(config, key, value)\n      }\n      return _saveAll(config)\n    }\n    return _saveAll(value)\n  }\n\n  /**\n   * @param {unknown} config\n   */\n  function _saveAll (config) {\n    const buf = uint8ArrayFromString(JSON.stringify(config, null, 2))\n    return store.put(configKey, buf)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}