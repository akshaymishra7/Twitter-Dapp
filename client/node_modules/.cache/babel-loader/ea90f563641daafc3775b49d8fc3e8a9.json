{"ast":null,"code":"import 'node-forge/lib/x509.js'; // @ts-expect-error types are missing\n\nimport forge from 'node-forge/lib/forge.js';\nconst pki = forge.pki;\n/**\n * Gets a self-signed X.509 certificate for the key.\n *\n * The output Uint8Array contains the PKCS #7 message in DER.\n *\n * TODO: move to libp2p-crypto package\n */\n\nexport const certificateForKey = (key, privateKey) => {\n  const publicKey = pki.rsa.setPublicKey(privateKey.n, privateKey.e);\n  const cert = pki.createCertificate();\n  cert.publicKey = publicKey;\n  cert.serialNumber = '01';\n  cert.validity.notBefore = new Date();\n  cert.validity.notAfter = new Date();\n  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10); // eslint-disable-line @typescript-eslint/restrict-plus-operands\n\n  const attrs = [{\n    name: 'organizationName',\n    value: 'ipfs'\n  }, {\n    shortName: 'OU',\n    value: 'keystore'\n  }, {\n    name: 'commonName',\n    value: key.id\n  }];\n  cert.setSubject(attrs);\n  cert.setIssuer(attrs);\n  cert.setExtensions([{\n    name: 'basicConstraints',\n    cA: true\n  }, {\n    name: 'keyUsage',\n    keyCertSign: true,\n    digitalSignature: true,\n    nonRepudiation: true,\n    keyEncipherment: true,\n    dataEncipherment: true\n  }, {\n    name: 'extKeyUsage',\n    serverAuth: true,\n    clientAuth: true,\n    codeSigning: true,\n    emailProtection: true,\n    timeStamping: true\n  }, {\n    name: 'nsCertType',\n    client: true,\n    server: true,\n    email: true,\n    objsign: true,\n    sslCA: true,\n    emailCA: true,\n    objCA: true\n  }]); // self-sign certificate\n\n  cert.sign(privateKey);\n  return cert;\n};\n/**\n * Finds the first item in a collection that is matched in the\n * `asyncCompare` function.\n *\n * `asyncCompare` is an async function that must\n * resolve to either `true` or `false`.\n *\n * @param {Array} array\n * @param {function(*)} asyncCompare - An async function that returns a boolean\n */\n\nexport async function findAsync(array, asyncCompare) {\n  const promises = array.map(asyncCompare);\n  const results = await Promise.all(promises);\n  const index = results.findIndex(result => result);\n  return array[index];\n}","map":{"version":3,"mappings":"AAAA,OAAO,wBAAP,C,CACA;;AACA,OAAOA,KAAP,MAAkB,yBAAlB;AAEA,MAAMC,GAAG,GAAGD,KAAK,CAACC,GAAlB;AAEA;;;;;;;;AAOA,OAAO,MAAMC,iBAAiB,GAAG,CAACC,GAAD,EAAWC,UAAX,KAAmD;AAClF,QAAMC,SAAS,GAAGJ,GAAG,CAACK,GAAJ,CAAQC,YAAR,CAAqBH,UAAU,CAACI,CAAhC,EAAmCJ,UAAU,CAACK,CAA9C,CAAlB;AACA,QAAMC,IAAI,GAAGT,GAAG,CAACU,iBAAJ,EAAb;AACAD,MAAI,CAACL,SAAL,GAAiBA,SAAjB;AACAK,MAAI,CAACE,YAAL,GAAoB,IAApB;AACAF,MAAI,CAACG,QAAL,CAAcC,SAAd,GAA0B,IAAIC,IAAJ,EAA1B;AACAL,MAAI,CAACG,QAAL,CAAcG,QAAd,GAAyB,IAAID,IAAJ,EAAzB;AACAL,MAAI,CAACG,QAAL,CAAcG,QAAd,CAAuBC,WAAvB,CAAmCP,IAAI,CAACG,QAAL,CAAcC,SAAd,CAAwBI,WAAxB,KAAwC,EAA3E,EAPkF,CAOH;;AAC/E,QAAMC,KAAK,GAAG,CAAC;AACbC,QAAI,EAAE,kBADO;AAEbC,SAAK,EAAE;AAFM,GAAD,EAGX;AACDC,aAAS,EAAE,IADV;AAEDD,SAAK,EAAE;AAFN,GAHW,EAMX;AACDD,QAAI,EAAE,YADL;AAEDC,SAAK,EAAElB,GAAG,CAACoB;AAFV,GANW,CAAd;AAUAb,MAAI,CAACc,UAAL,CAAgBL,KAAhB;AACAT,MAAI,CAACe,SAAL,CAAeN,KAAf;AACAT,MAAI,CAACgB,aAAL,CAAmB,CAAC;AAClBN,QAAI,EAAE,kBADY;AAElBO,MAAE,EAAE;AAFc,GAAD,EAGhB;AACDP,QAAI,EAAE,UADL;AAEDQ,eAAW,EAAE,IAFZ;AAGDC,oBAAgB,EAAE,IAHjB;AAIDC,kBAAc,EAAE,IAJf;AAKDC,mBAAe,EAAE,IALhB;AAMDC,oBAAgB,EAAE;AANjB,GAHgB,EAUhB;AACDZ,QAAI,EAAE,aADL;AAEDa,cAAU,EAAE,IAFX;AAGDC,cAAU,EAAE,IAHX;AAIDC,eAAW,EAAE,IAJZ;AAKDC,mBAAe,EAAE,IALhB;AAMDC,gBAAY,EAAE;AANb,GAVgB,EAiBhB;AACDjB,QAAI,EAAE,YADL;AAEDkB,UAAM,EAAE,IAFP;AAGDC,UAAM,EAAE,IAHP;AAIDC,SAAK,EAAE,IAJN;AAKDC,WAAO,EAAE,IALR;AAMDC,SAAK,EAAE,IANN;AAODC,WAAO,EAAE,IAPR;AAQDC,SAAK,EAAE;AARN,GAjBgB,CAAnB,EApBkF,CA+ClF;;AACAlC,MAAI,CAACmC,IAAL,CAAUzC,UAAV;AAEA,SAAOM,IAAP;AACD,CAnDM;AAqDP;;;;;;;;;;;AAUA,OAAO,eAAeoC,SAAf,CAA8BC,KAA9B,EAA0CC,YAA1C,EAAgF;AACrF,QAAMC,QAAQ,GAAGF,KAAK,CAACG,GAAN,CAAUF,YAAV,CAAjB;AACA,QAAMG,OAAO,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAYJ,QAAZ,CAAtB;AACA,QAAMK,KAAK,GAAGH,OAAO,CAACI,SAAR,CAAkBC,MAAM,IAAIA,MAA5B,CAAd;AACA,SAAOT,KAAK,CAACO,KAAD,CAAZ;AACD","names":["forge","pki","certificateForKey","key","privateKey","publicKey","rsa","setPublicKey","n","e","cert","createCertificate","serialNumber","validity","notBefore","Date","notAfter","setFullYear","getFullYear","attrs","name","value","shortName","id","setSubject","setIssuer","setExtensions","cA","keyCertSign","digitalSignature","nonRepudiation","keyEncipherment","dataEncipherment","serverAuth","clientAuth","codeSigning","emailProtection","timeStamping","client","server","email","objsign","sslCA","emailCA","objCA","sign","findAsync","array","asyncCompare","promises","map","results","Promise","all","index","findIndex","result"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\keychain\\util.ts"],"sourcesContent":["import 'node-forge/lib/x509.js'\n// @ts-expect-error types are missing\nimport forge from 'node-forge/lib/forge.js'\n\nconst pki = forge.pki\n\n/**\n * Gets a self-signed X.509 certificate for the key.\n *\n * The output Uint8Array contains the PKCS #7 message in DER.\n *\n * TODO: move to libp2p-crypto package\n */\nexport const certificateForKey = (key: any, privateKey: forge.pki.rsa.PrivateKey) => {\n  const publicKey = pki.rsa.setPublicKey(privateKey.n, privateKey.e)\n  const cert = pki.createCertificate()\n  cert.publicKey = publicKey\n  cert.serialNumber = '01'\n  cert.validity.notBefore = new Date()\n  cert.validity.notAfter = new Date()\n  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10) // eslint-disable-line @typescript-eslint/restrict-plus-operands\n  const attrs = [{\n    name: 'organizationName',\n    value: 'ipfs'\n  }, {\n    shortName: 'OU',\n    value: 'keystore'\n  }, {\n    name: 'commonName',\n    value: key.id\n  }]\n  cert.setSubject(attrs)\n  cert.setIssuer(attrs)\n  cert.setExtensions([{\n    name: 'basicConstraints',\n    cA: true\n  }, {\n    name: 'keyUsage',\n    keyCertSign: true,\n    digitalSignature: true,\n    nonRepudiation: true,\n    keyEncipherment: true,\n    dataEncipherment: true\n  }, {\n    name: 'extKeyUsage',\n    serverAuth: true,\n    clientAuth: true,\n    codeSigning: true,\n    emailProtection: true,\n    timeStamping: true\n  }, {\n    name: 'nsCertType',\n    client: true,\n    server: true,\n    email: true,\n    objsign: true,\n    sslCA: true,\n    emailCA: true,\n    objCA: true\n  }])\n  // self-sign certificate\n  cert.sign(privateKey)\n\n  return cert\n}\n\n/**\n * Finds the first item in a collection that is matched in the\n * `asyncCompare` function.\n *\n * `asyncCompare` is an async function that must\n * resolve to either `true` or `false`.\n *\n * @param {Array} array\n * @param {function(*)} asyncCompare - An async function that returns a boolean\n */\nexport async function findAsync <T> (array: T[], asyncCompare: (val: T) => Promise<any>) {\n  const promises = array.map(asyncCompare)\n  const results = await Promise.all(promises)\n  const index = results.findIndex(result => result)\n  return array[index]\n}\n"]},"metadata":{},"sourceType":"module"}