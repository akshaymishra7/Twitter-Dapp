{"ast":null,"code":"// @ts-expect-error no types\nimport isoConstants from 'iso-constants';\nimport toBuffer from 'it-to-buffer';\nimport { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist';\nimport * as Headers from './pack-headers.js';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nconst {\n  S_IFMT,\n  S_IFBLK,\n  S_IFCHR,\n  S_IFDIR,\n  S_IFIFO,\n  S_IFLNK\n} = isoConstants;\nconst DMODE = parseInt('755', 8);\nconst FMODE = parseInt('644', 8);\nconst END_OF_TAR = new Uint8Array(1024);\n\nfunction modeToType() {\n  let mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n  switch (mode & S_IFMT) {\n    case S_IFBLK:\n      return 'block-device';\n\n    case S_IFCHR:\n      return 'character-device';\n\n    case S_IFDIR:\n      return 'directory';\n\n    case S_IFIFO:\n      return 'fifo';\n\n    case S_IFLNK:\n      return 'symlink';\n\n    default:\n      return 'file';\n  }\n}\n\nfunction getPadding(size) {\n  size &= 511;\n\n  if (size !== 0) {\n    return END_OF_TAR.subarray(0, 512 - size);\n  }\n\n  return new Uint8Array(0);\n}\n\nfunction encode(header) {\n  if (header.pax == null) {\n    const encoded = Headers.encode(header);\n\n    if (encoded != null) {\n      return encoded;\n    }\n  }\n\n  return encodePax(header);\n}\n\nfunction encodePax(header) {\n  const paxHeader = Headers.encodePax(header);\n  const newHeader = {\n    name: 'PaxHeader',\n    mode: header.mode,\n    uid: header.uid,\n    gid: header.gid,\n    size: paxHeader.length,\n    mtime: header.mtime,\n    type: 'pax-header',\n    linkname: header.linkname,\n    uname: header.uname,\n    gname: header.gname,\n    devmajor: header.devmajor,\n    devminor: header.devminor\n  };\n  return new Uint8ArrayList(Headers.encode(newHeader) ?? new Uint8Array(0), paxHeader, getPadding(paxHeader.length), Headers.encode({ ...newHeader,\n    size: header.size,\n    type: header.type\n  }) ?? new Uint8Array(0)).subarray();\n}\n\nexport function pack() {\n  return async function* (source) {\n    for await (let {\n      header: partialHeader,\n      body\n    } of source) {\n      const header = { ...partialHeader,\n        size: partialHeader.type === 'symlink' ? 0 : partialHeader.size ?? 0,\n        type: partialHeader.type ?? modeToType(partialHeader.mode),\n        mode: partialHeader.mode ?? (partialHeader.type === 'directory' ? DMODE : FMODE),\n        uid: partialHeader.uid ?? 0,\n        gid: partialHeader.gid ?? 0,\n        mtime: partialHeader.mtime ?? new Date()\n      };\n\n      if (typeof body === 'string') {\n        body = uint8ArrayFromString(body);\n      }\n\n      if (body instanceof Uint8Array || isUint8ArrayList(body)) {\n        header.size = body.length;\n        yield encode(header);\n        yield isUint8ArrayList(body) ? body.subarray() : body;\n        yield getPadding(header.size);\n        continue;\n      }\n\n      if (header.type === 'symlink' && header.linkname == null) {\n        if (body == null) {\n          throw new Error('type was symlink but no linkname or body specified');\n        }\n\n        header.linkname = uint8ArrayToString(await toBuffer(body));\n        yield encode(header);\n        continue;\n      }\n\n      yield encode(header);\n\n      if (header.type !== 'file' && header.type !== 'contiguous-file') {\n        continue;\n      }\n\n      let written = 0;\n\n      for await (const chunk of body ?? []) {\n        written += chunk.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands\n\n        yield isUint8ArrayList(chunk) ? chunk.subarray() : chunk;\n      }\n\n      if (written !== header.size) {\n        // corrupting tar\n        throw new Error(`size mismatch, wrote ${written} of ${header.size} bytes`);\n      }\n\n      yield getPadding(header.size);\n    }\n\n    yield END_OF_TAR;\n  };\n}","map":{"version":3,"mappings":"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","names":["isoConstants","toBuffer","isUint8ArrayList","Uint8ArrayList","Headers","fromString","uint8ArrayFromString","toString","uint8ArrayToString","S_IFMT","S_IFBLK","S_IFCHR","S_IFDIR","S_IFIFO","S_IFLNK","DMODE","parseInt","FMODE","END_OF_TAR","Uint8Array","modeToType","mode","getPadding","size","subarray","encode","header","pax","encoded","encodePax","paxHeader","newHeader","name","uid","gid","length","mtime","type","linkname","uname","gname","devmajor","devminor","pack","source","partialHeader","body","Date","Error","written","chunk"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-tar\\src\\pack.ts"],"sourcesContent":["// @ts-expect-error no types\nimport isoConstants from 'iso-constants'\nimport toBuffer from 'it-to-buffer'\nimport { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\nimport type { TarEntryHeader, TarImportCandidate } from './index.js'\nimport * as Headers from './pack-headers.js'\nimport type { Source, Transform } from 'it-stream-types'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nconst { S_IFMT, S_IFBLK, S_IFCHR, S_IFDIR, S_IFIFO, S_IFLNK } = isoConstants\nconst DMODE = parseInt('755', 8)\nconst FMODE = parseInt('644', 8)\nconst END_OF_TAR = new Uint8Array(1024)\n\nfunction modeToType (mode: number = 0) {\n  switch (mode & S_IFMT) {\n    case S_IFBLK: return 'block-device'\n    case S_IFCHR: return 'character-device'\n    case S_IFDIR: return 'directory'\n    case S_IFIFO: return 'fifo'\n    case S_IFLNK: return 'symlink'\n    default: return 'file'\n  }\n}\n\nfunction getPadding (size: number) {\n  size &= 511\n\n  if (size !== 0) {\n    return END_OF_TAR.subarray(0, 512 - size)\n  }\n\n  return new Uint8Array(0)\n}\n\nfunction encode (header: TarEntryHeader) {\n  if (header.pax == null) {\n    const encoded = Headers.encode(header)\n\n    if (encoded != null) {\n      return encoded\n    }\n  }\n  return encodePax(header)\n}\n\nfunction encodePax (header: TarEntryHeader) {\n  const paxHeader = Headers.encodePax(header)\n\n  const newHeader: TarEntryHeader = {\n    name: 'PaxHeader',\n    mode: header.mode,\n    uid: header.uid,\n    gid: header.gid,\n    size: paxHeader.length,\n    mtime: header.mtime,\n    type: 'pax-header',\n    linkname: header.linkname,\n    uname: header.uname,\n    gname: header.gname,\n    devmajor: header.devmajor,\n    devminor: header.devminor\n  }\n\n  return new Uint8ArrayList(\n    Headers.encode(newHeader) ?? new Uint8Array(0),\n    paxHeader,\n    getPadding(paxHeader.length),\n    Headers.encode({ ...newHeader, size: header.size, type: header.type }) ?? new Uint8Array(0)\n  ).subarray()\n}\n\nexport function pack (): Transform<TarImportCandidate, Uint8Array> {\n  return async function * (source: Source<TarImportCandidate>) { // eslint-disable-line complexity\n    for await (let { header: partialHeader, body } of source) {\n      const header: TarEntryHeader = {\n        ...partialHeader,\n        size: partialHeader.type === 'symlink' ? 0 : partialHeader.size ?? 0,\n        type: partialHeader.type ?? modeToType(partialHeader.mode),\n        mode: partialHeader.mode ?? (partialHeader.type === 'directory' ? DMODE : FMODE),\n        uid: partialHeader.uid ?? 0,\n        gid: partialHeader.gid ?? 0,\n        mtime: partialHeader.mtime ?? new Date()\n      }\n\n      if (typeof body === 'string') {\n        body = uint8ArrayFromString(body)\n      }\n\n      if (body instanceof Uint8Array || isUint8ArrayList(body)) {\n        header.size = body.length\n\n        yield encode(header)\n        yield isUint8ArrayList(body) ? body.subarray() : body\n        yield getPadding(header.size)\n\n        continue\n      }\n\n      if (header.type === 'symlink' && header.linkname == null) {\n        if (body == null) {\n          throw new Error('type was symlink but no linkname or body specified')\n        }\n\n        header.linkname = uint8ArrayToString(await toBuffer(body))\n        yield encode(header)\n        continue\n      }\n\n      yield encode(header)\n\n      if (header.type !== 'file' && header.type !== 'contiguous-file') {\n        continue\n      }\n\n      let written = 0\n      for await (const chunk of (body ?? [])) {\n        written += chunk.length // eslint-disable-line @typescript-eslint/restrict-plus-operands\n        yield isUint8ArrayList(chunk) ? chunk.subarray() : chunk\n      }\n\n      if (written !== header.size) { // corrupting tar\n        throw new Error(`size mismatch, wrote ${written} of ${header.size} bytes`)\n      }\n\n      yield getPadding(header.size)\n    }\n\n    yield END_OF_TAR\n  }\n}\n"]},"metadata":{},"sourceType":"module"}