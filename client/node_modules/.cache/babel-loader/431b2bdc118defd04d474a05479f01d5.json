{"ast":null,"code":"import { CodeError } from '@libp2p/interfaces/errors';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { exporter } from './exporter.js';\nimport * as keysProtobuf from './keys.js';\nimport * as crypto from './secp256k1.js';\nexport class Secp256k1PublicKey {\n  _key;\n\n  constructor(key) {\n    crypto.validatePublicKey(key);\n    this._key = key;\n  }\n\n  async verify(data, sig) {\n    return crypto.hashAndVerify(this._key, sig, data);\n  }\n\n  marshal() {\n    return crypto.compressPublicKey(this._key);\n  }\n\n  get bytes() {\n    return keysProtobuf.PublicKey.encode({\n      Type: keysProtobuf.KeyType.Secp256k1,\n      Data: this.marshal()\n    }).subarray();\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    const {\n      bytes\n    } = await sha256.digest(this.bytes);\n    return bytes;\n  }\n\n}\nexport class Secp256k1PrivateKey {\n  _key;\n  _publicKey;\n\n  constructor(key, publicKey) {\n    this._key = key;\n    this._publicKey = publicKey ?? crypto.computePublicKey(key);\n    crypto.validatePrivateKey(this._key);\n    crypto.validatePublicKey(this._publicKey);\n  }\n\n  async sign(message) {\n    return crypto.hashAndSign(this._key, message);\n  }\n\n  get public() {\n    return new Secp256k1PublicKey(this._publicKey);\n  }\n\n  marshal() {\n    return this._key;\n  }\n\n  get bytes() {\n    return keysProtobuf.PrivateKey.encode({\n      Type: keysProtobuf.KeyType.Secp256k1,\n      Data: this.marshal()\n    }).subarray();\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    const {\n      bytes\n    } = await sha256.digest(this.bytes);\n    return bytes;\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   */\n\n\n  async id() {\n    const hash = await this.public.hash();\n    return uint8ArrayToString(hash, 'base58btc');\n  }\n  /**\n   * Exports the key into a password protected `format`\n   */\n\n\n  async export(password) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'libp2p-key';\n\n    if (format === 'libp2p-key') {\n      return exporter(this.bytes, password);\n    } else {\n      throw new CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT');\n    }\n  }\n\n}\nexport function unmarshalSecp256k1PrivateKey(bytes) {\n  return new Secp256k1PrivateKey(bytes);\n}\nexport function unmarshalSecp256k1PublicKey(bytes) {\n  return new Secp256k1PublicKey(bytes);\n}\nexport async function generateKeyPair() {\n  const privateKeyBytes = crypto.generateKey();\n  return new Secp256k1PrivateKey(privateKeyBytes);\n}","map":{"version":3,"mappings":"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","names":["CodeError","sha256","equals","uint8ArrayEquals","toString","uint8ArrayToString","exporter","keysProtobuf","crypto","Secp256k1PublicKey","_key","constructor","key","validatePublicKey","verify","data","sig","hashAndVerify","marshal","compressPublicKey","bytes","PublicKey","encode","Type","KeyType","Secp256k1","Data","subarray","hash","digest","Secp256k1PrivateKey","_publicKey","publicKey","computePublicKey","validatePrivateKey","sign","message","hashAndSign","public","PrivateKey","id","export","password","format","unmarshalSecp256k1PrivateKey","unmarshalSecp256k1PublicKey","generateKeyPair","privateKeyBytes","generateKey"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\crypto\\src\\keys\\secp256k1-class.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { exporter } from './exporter.js'\nimport * as keysProtobuf from './keys.js'\nimport * as crypto from './secp256k1.js'\nimport type { Multibase } from 'multiformats'\n\nexport class Secp256k1PublicKey {\n  private readonly _key: Uint8Array\n\n  constructor (key: Uint8Array) {\n    crypto.validatePublicKey(key)\n    this._key = key\n  }\n\n  async verify (data: Uint8Array, sig: Uint8Array): Promise<boolean> {\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal (): Uint8Array {\n    return crypto.compressPublicKey(this._key)\n  }\n\n  get bytes (): Uint8Array {\n    return keysProtobuf.PublicKey.encode({\n      Type: keysProtobuf.KeyType.Secp256k1,\n      Data: this.marshal()\n    }).subarray()\n  }\n\n  equals (key: any): boolean {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash (): Promise<Uint8Array> {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n}\n\nexport class Secp256k1PrivateKey {\n  private readonly _key: Uint8Array\n  private readonly _publicKey: Uint8Array\n\n  constructor (key: Uint8Array, publicKey?: Uint8Array) {\n    this._key = key\n    this._publicKey = publicKey ?? crypto.computePublicKey(key)\n    crypto.validatePrivateKey(this._key)\n    crypto.validatePublicKey(this._publicKey)\n  }\n\n  async sign (message: Uint8Array): Promise<Uint8Array> {\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public (): Secp256k1PublicKey {\n    return new Secp256k1PublicKey(this._publicKey)\n  }\n\n  marshal (): Uint8Array {\n    return this._key\n  }\n\n  get bytes (): Uint8Array {\n    return keysProtobuf.PrivateKey.encode({\n      Type: keysProtobuf.KeyType.Secp256k1,\n      Data: this.marshal()\n    }).subarray()\n  }\n\n  equals (key: any): boolean {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash (): Promise<Uint8Array> {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   */\n  async id (): Promise<string> {\n    const hash = await this.public.hash()\n    return uint8ArrayToString(hash, 'base58btc')\n  }\n\n  /**\n   * Exports the key into a password protected `format`\n   */\n  async export (password: string, format = 'libp2p-key'): Promise<Multibase<'m'>> {\n    if (format === 'libp2p-key') {\n      return exporter(this.bytes, password)\n    } else {\n      throw new CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nexport function unmarshalSecp256k1PrivateKey (bytes: Uint8Array): Secp256k1PrivateKey {\n  return new Secp256k1PrivateKey(bytes)\n}\n\nexport function unmarshalSecp256k1PublicKey (bytes: Uint8Array): Secp256k1PublicKey {\n  return new Secp256k1PublicKey(bytes)\n}\n\nexport async function generateKeyPair (): Promise<Secp256k1PrivateKey> {\n  const privateKeyBytes = crypto.generateKey()\n  return new Secp256k1PrivateKey(privateKeyBytes)\n}\n"]},"metadata":{},"sourceType":"module"}