{"ast":null,"code":"import { peerIdFromString } from '@libp2p/peer-id';\nimport { mapIterable } from './util.js';\n/**\n * We can't use PeerIds as set entries because set entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```JavaScript\n * import { peerSet } from '@libp2p/peer-collections'\n *\n * const set = peerSet()\n * set.add(peerId)\n * ```\n */\n\nexport class PeerSet {\n  constructor(set) {\n    this.set = new Set();\n\n    if (set != null) {\n      for (const key of set) {\n        this.set.add(key.toString());\n      }\n    }\n  }\n\n  get size() {\n    return this.set.size;\n  }\n\n  [Symbol.iterator]() {\n    return this.values();\n  }\n\n  add(peer) {\n    this.set.add(peer.toString());\n  }\n\n  clear() {\n    this.set.clear();\n  }\n\n  delete(peer) {\n    this.set.delete(peer.toString());\n  }\n\n  entries() {\n    return mapIterable(this.set.entries(), val => {\n      const peerId = peerIdFromString(val[0]);\n      return [peerId, peerId];\n    });\n  }\n\n  forEach(predicate) {\n    this.set.forEach(str => {\n      const id = peerIdFromString(str);\n      predicate(id, id, this);\n    });\n  }\n\n  has(peer) {\n    return this.set.has(peer.toString());\n  }\n\n  values() {\n    return mapIterable(this.set.values(), val => {\n      return peerIdFromString(val);\n    });\n  }\n\n  intersection(other) {\n    const output = new PeerSet();\n\n    for (const peerId of other) {\n      if (this.has(peerId)) {\n        output.add(peerId);\n      }\n    }\n\n    return output;\n  }\n\n  difference(other) {\n    const output = new PeerSet();\n\n    for (const peerId of this) {\n      if (!other.has(peerId)) {\n        output.add(peerId);\n      }\n    }\n\n    return output;\n  }\n\n  union(other) {\n    const output = new PeerSet();\n\n    for (const peerId of other) {\n      output.add(peerId);\n    }\n\n    for (const peerId of this) {\n      output.add(peerId);\n    }\n\n    return output;\n  }\n\n}","map":{"version":3,"mappings":"AACA,SAASA,gBAAT,QAAiC,iBAAjC;AACA,SAASC,WAAT,QAA4B,WAA5B;AAEA;;;;;;;;;;;;;;;;;;AAiBA,OAAM,MAAOC,OAAP,CAAc;AAGlBC,cAAaC,GAAb,EAA6C;AAC3C,SAAKA,GAAL,GAAW,IAAIC,GAAJ,EAAX;;AAEA,QAAID,GAAG,IAAI,IAAX,EAAiB;AACf,WAAK,MAAME,GAAX,IAAkBF,GAAlB,EAAuB;AACrB,aAAKA,GAAL,CAASG,GAAT,CAAaD,GAAG,CAACE,QAAJ,EAAb;AACD;AACF;AACF;;AAEO,MAAJC,IAAI;AACN,WAAO,KAAKL,GAAL,CAASK,IAAhB;AACD;;AAEe,GAAfC,MAAM,CAACC,QAAQ,IAAC;AACf,WAAO,KAAKC,MAAL,EAAP;AACD;;AAEDL,KAAG,CAAEM,IAAF,EAAc;AACf,SAAKT,GAAL,CAASG,GAAT,CAAaM,IAAI,CAACL,QAAL,EAAb;AACD;;AAEDM,OAAK;AACH,SAAKV,GAAL,CAASU,KAAT;AACD;;AAEDC,QAAM,CAAEF,IAAF,EAAc;AAClB,SAAKT,GAAL,CAASW,MAAT,CAAgBF,IAAI,CAACL,QAAL,EAAhB;AACD;;AAEDQ,SAAO;AACL,WAAOf,WAAW,CAChB,KAAKG,GAAL,CAASY,OAAT,EADgB,EAEfC,GAAD,IAAQ;AACN,YAAMC,MAAM,GAAGlB,gBAAgB,CAACiB,GAAG,CAAC,CAAD,CAAJ,CAA/B;AAEA,aAAO,CAACC,MAAD,EAASA,MAAT,CAAP;AACD,KANe,CAAlB;AAQD;;AAEDC,SAAO,CAAEC,SAAF,EAAkE;AACvE,SAAKhB,GAAL,CAASe,OAAT,CAAkBE,GAAD,IAAQ;AACvB,YAAMC,EAAE,GAAGtB,gBAAgB,CAACqB,GAAD,CAA3B;AAEAD,eAAS,CAACE,EAAD,EAAKA,EAAL,EAAS,IAAT,CAAT;AACD,KAJD;AAKD;;AAEDC,KAAG,CAAEV,IAAF,EAAc;AACf,WAAO,KAAKT,GAAL,CAASmB,GAAT,CAAaV,IAAI,CAACL,QAAL,EAAb,CAAP;AACD;;AAEDI,QAAM;AACJ,WAAOX,WAAW,CAChB,KAAKG,GAAL,CAASQ,MAAT,EADgB,EAEfK,GAAD,IAAQ;AACN,aAAOjB,gBAAgB,CAACiB,GAAD,CAAvB;AACD,KAJe,CAAlB;AAMD;;AAEDO,cAAY,CAAEC,KAAF,EAAgB;AAC1B,UAAMC,MAAM,GAAG,IAAIxB,OAAJ,EAAf;;AAEA,SAAK,MAAMgB,MAAX,IAAqBO,KAArB,EAA4B;AAC1B,UAAI,KAAKF,GAAL,CAASL,MAAT,CAAJ,EAAsB;AACpBQ,cAAM,CAACnB,GAAP,CAAWW,MAAX;AACD;AACF;;AAED,WAAOQ,MAAP;AACD;;AAEDC,YAAU,CAAEF,KAAF,EAAgB;AACxB,UAAMC,MAAM,GAAG,IAAIxB,OAAJ,EAAf;;AAEA,SAAK,MAAMgB,MAAX,IAAqB,IAArB,EAA2B;AACzB,UAAI,CAACO,KAAK,CAACF,GAAN,CAAUL,MAAV,CAAL,EAAwB;AACtBQ,cAAM,CAACnB,GAAP,CAAWW,MAAX;AACD;AACF;;AAED,WAAOQ,MAAP;AACD;;AAEDE,OAAK,CAAEH,KAAF,EAAgB;AACnB,UAAMC,MAAM,GAAG,IAAIxB,OAAJ,EAAf;;AAEA,SAAK,MAAMgB,MAAX,IAAqBO,KAArB,EAA4B;AAC1BC,YAAM,CAACnB,GAAP,CAAWW,MAAX;AACD;;AAED,SAAK,MAAMA,MAAX,IAAqB,IAArB,EAA2B;AACzBQ,YAAM,CAACnB,GAAP,CAAWW,MAAX;AACD;;AAED,WAAOQ,MAAP;AACD;;AArGiB","names":["peerIdFromString","mapIterable","PeerSet","constructor","set","Set","key","add","toString","size","Symbol","iterator","values","peer","clear","delete","entries","val","peerId","forEach","predicate","str","id","has","intersection","other","output","difference","union"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\peer-collections\\src\\set.ts"],"sourcesContent":["import type { PeerId } from '@libp2p/interface-peer-id'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { mapIterable } from './util.js'\n\n/**\n * We can't use PeerIds as set entries because set entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```JavaScript\n * import { peerSet } from '@libp2p/peer-collections'\n *\n * const set = peerSet()\n * set.add(peerId)\n * ```\n */\nexport class PeerSet {\n  private readonly set: Set<string>\n\n  constructor (set?: PeerSet | Iterable<PeerId>) {\n    this.set = new Set()\n\n    if (set != null) {\n      for (const key of set) {\n        this.set.add(key.toString())\n      }\n    }\n  }\n\n  get size (): number {\n    return this.set.size\n  }\n\n  [Symbol.iterator] (): IterableIterator<PeerId> {\n    return this.values()\n  }\n\n  add (peer: PeerId): void {\n    this.set.add(peer.toString())\n  }\n\n  clear (): void {\n    this.set.clear()\n  }\n\n  delete (peer: PeerId): void {\n    this.set.delete(peer.toString())\n  }\n\n  entries (): IterableIterator<[PeerId, PeerId]> {\n    return mapIterable<[string, string], [PeerId, PeerId]>(\n      this.set.entries(),\n      (val) => {\n        const peerId = peerIdFromString(val[0])\n\n        return [peerId, peerId]\n      }\n    )\n  }\n\n  forEach (predicate: (peerId: PeerId, index: PeerId, set: PeerSet) => void): void {\n    this.set.forEach((str) => {\n      const id = peerIdFromString(str)\n\n      predicate(id, id, this)\n    })\n  }\n\n  has (peer: PeerId): boolean {\n    return this.set.has(peer.toString())\n  }\n\n  values (): IterableIterator<PeerId> {\n    return mapIterable<string, PeerId>(\n      this.set.values(),\n      (val) => {\n        return peerIdFromString(val)\n      }\n    )\n  }\n\n  intersection (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of other) {\n      if (this.has(peerId)) {\n        output.add(peerId)\n      }\n    }\n\n    return output\n  }\n\n  difference (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of this) {\n      if (!other.has(peerId)) {\n        output.add(peerId)\n      }\n    }\n\n    return output\n  }\n\n  union (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of other) {\n      output.add(peerId)\n    }\n\n    for (const peerId of this) {\n      output.add(peerId)\n    }\n\n    return output\n  }\n}\n"]},"metadata":{},"sourceType":"module"}