{"ast":null,"code":"import { base58btc } from 'multiformats/bases/base58';\nimport { base32 } from 'multiformats/bases/base32';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport * as mafmt from '@multiformats/mafmt';\nimport { CID } from 'multiformats/cid';\nimport { URL } from 'iso-url';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nexport const pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/;\nexport const pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/;\nconst defaultProtocolMatch = 1;\nconst defaultHashMath = 2; // CID, libp2p-key or DNSLink\n\nexport const subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/;\nconst subdomainIdMatch = 1;\nconst subdomainProtocolMatch = 2; // Fully qualified domain name (FQDN) that has an explicit .tld suffix\n\nconst fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;\n\nfunction isMultihash(hash) {\n  const formatted = convertToString(hash);\n\n  if (formatted === false) {\n    return false;\n  }\n\n  try {\n    Digest.decode(base58btc.decode('z' + formatted));\n  } catch {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isMultiaddr(input) {\n  try {\n    return Boolean(multiaddr(input));\n  } catch {\n    return false;\n  }\n}\n\nfunction isBase32EncodedMultibase(hash) {\n  try {\n    let cid;\n\n    if (isString(hash)) {\n      cid = CID.parse(hash);\n    } else {\n      cid = CID.asCID(hash);\n    }\n\n    if (cid == null) {\n      return false;\n    }\n\n    base32.decode(cid.toString());\n  } catch {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isCID(hash) {\n  try {\n    if (isString(hash)) {\n      return Boolean(CID.parse(hash));\n    }\n\n    if (hash instanceof Uint8Array) {\n      return Boolean(CID.decode(hash));\n    }\n\n    return Boolean(CID.asCID(hash)); // eslint-disable-line no-new\n  } catch {\n    return false;\n  }\n}\n/**\n * @param {string | Uint8Array | Multiaddr} input\n */\n\n\nfunction isPeerMultiaddr(input) {\n  return isMultiaddr(input) && mafmt.P2P.matches(input);\n}\n/**\n * @param {string | Uint8Array} input\n * @param {RegExp | string} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=2]\n */\n\n\nfunction isIpfs(input, pattern) {\n  let protocolMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultProtocolMatch;\n  let hashMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultHashMath;\n  const formatted = convertToString(input);\n\n  if (formatted === false) {\n    return false;\n  }\n\n  const match = formatted.match(pattern);\n\n  if (match == null) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false;\n  }\n\n  let hash = match[hashMatch];\n\n  if (hash != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority component anyway)\n    hash = hash.toLowerCase();\n  }\n\n  return isCID(hash);\n}\n/**\n *\n * @param {string | Uint8Array} input\n * @param {string | RegExp} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=1]\n */\n\n\nfunction isIpns(input, pattern) {\n  let protocolMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultProtocolMatch;\n  let hashMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultHashMath;\n  const formatted = convertToString(input);\n\n  if (formatted === false) {\n    return false;\n  }\n\n  const match = formatted.match(pattern);\n\n  if (match == null) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false;\n  }\n\n  let ipnsId = match[hashMatch];\n\n  if (ipnsId != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase(); // Check if it is cidv1\n\n    if (isCID(ipnsId)) return true; // Check if it looks like FQDN\n\n    try {\n      if (!ipnsId.includes('.') && ipnsId.includes('-')) {\n        // name without tld, assuming its inlined into a single DNS label\n        // (https://github.com/ipfs/in-web-browsers/issues/169)\n        // en-wikipedia--on--ipfs-org â†’ en.wikipedia-on-ipfs.org\n        ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-');\n      } // URL implementation in web browsers forces lowercase of the hostname\n\n\n      const {\n        hostname\n      } = new URL(`http://${ipnsId}`); // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n\n      return fqdnWithTld.test(hostname);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @param {any} input\n */\n\n\nfunction isString(input) {\n  return typeof input === 'string';\n}\n/**\n * @param {Uint8Array | string} input\n */\n\n\nfunction convertToString(input) {\n  if (input instanceof Uint8Array) {\n    return uint8ArrayToString(input, 'base58btc');\n  }\n\n  if (isString(input)) {\n    return input;\n  }\n\n  return false;\n}\n\nexport const ipfsSubdomain = url => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\nexport const ipnsSubdomain = url => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\nexport const subdomain = url => ipfsSubdomain(url) || ipnsSubdomain(url);\nexport const ipfsUrl = url => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url);\nexport const ipnsUrl = url => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url);\nexport const url = url => ipfsUrl(url) || ipnsUrl(url) || subdomain(url);\nexport const path = path => isIpfs(path, pathPattern) || isIpns(path, pathPattern);\nexport { isMultihash as multihash };\nexport { isMultiaddr as multiaddr };\nexport { isPeerMultiaddr as peerMultiaddr };\nexport { isCID as cid };\nexport const base32cid = cid => isCID(cid) && isBase32EncodedMultibase(cid);\nexport const ipfsPath = path => isIpfs(path, pathPattern);\nexport const ipnsPath = path => isIpns(path, pathPattern);\nexport const urlOrPath = x => url(x) || path(x);\nexport const cidPath = path => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern);","map":{"version":3,"mappings":"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","names":["base58btc","base32","Digest","multiaddr","mafmt","CID","URL","toString","uint8ArrayToString","pathGatewayPattern","pathPattern","defaultProtocolMatch","defaultHashMath","subdomainGatewayPattern","subdomainIdMatch","subdomainProtocolMatch","fqdnWithTld","isMultihash","hash","formatted","convertToString","decode","isMultiaddr","input","Boolean","isBase32EncodedMultibase","cid","isString","parse","asCID","isCID","Uint8Array","isPeerMultiaddr","P2P","matches","isIpfs","pattern","protocolMatch","hashMatch","match","toLowerCase","isIpns","ipnsId","includes","replace","hostname","test","e","ipfsSubdomain","url","ipnsSubdomain","subdomain","ipfsUrl","ipnsUrl","path","multihash","peerMultiaddr","base32cid","ipfsPath","ipnsPath","urlOrPath","x","cidPath"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\is-ipfs\\src\\index.ts"],"sourcesContent":["import { base58btc } from 'multiformats/bases/base58'\nimport { base32 } from 'multiformats/bases/base32'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport * as mafmt from '@multiformats/mafmt'\nimport { CID } from 'multiformats/cid'\nimport { URL } from 'iso-url'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nexport const pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/\nexport const pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/\nconst defaultProtocolMatch = 1\nconst defaultHashMath = 2\n\n// CID, libp2p-key or DNSLink\nexport const subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/\nconst subdomainIdMatch = 1\nconst subdomainProtocolMatch = 2\n\n// Fully qualified domain name (FQDN) that has an explicit .tld suffix\nconst fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/\n\nfunction isMultihash (hash: Uint8Array | string): boolean {\n  const formatted = convertToString(hash)\n\n  if (formatted === false) {\n    return false\n  }\n\n  try {\n    Digest.decode(base58btc.decode('z' + formatted))\n  } catch {\n    return false\n  }\n\n  return true\n}\n\nfunction isMultiaddr (input: string | Uint8Array | Multiaddr): input is Multiaddr {\n  try {\n    return Boolean(multiaddr(input))\n  } catch {\n    return false\n  }\n}\n\nfunction isBase32EncodedMultibase (hash: CID | string | Uint8Array): boolean {\n  try {\n    let cid: CID | null\n\n    if (isString(hash)) {\n      cid = CID.parse(hash)\n    } else {\n      cid = CID.asCID(hash)\n    }\n\n    if (cid == null) {\n      return false\n    }\n\n    base32.decode(cid.toString())\n  } catch {\n    return false\n  }\n\n  return true\n}\n\nfunction isCID (hash: CID | Uint8Array | string): hash is CID {\n  try {\n    if (isString(hash)) {\n      return Boolean(CID.parse(hash))\n    }\n\n    if (hash instanceof Uint8Array) {\n      return Boolean(CID.decode(hash))\n    }\n\n    return Boolean(CID.asCID(hash)) // eslint-disable-line no-new\n  } catch {\n    return false\n  }\n}\n\n/**\n * @param {string | Uint8Array | Multiaddr} input\n */\nfunction isPeerMultiaddr (input: string | Uint8Array | Multiaddr): boolean {\n  return isMultiaddr(input) && mafmt.P2P.matches(input)\n}\n\n/**\n * @param {string | Uint8Array} input\n * @param {RegExp | string} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=2]\n */\nfunction isIpfs (input: string | Uint8Array, pattern: RegExp | string, protocolMatch: number = defaultProtocolMatch, hashMatch: number = defaultHashMath) {\n  const formatted = convertToString(input)\n  if (formatted === false) {\n    return false\n  }\n\n  const match = formatted.match(pattern)\n  if (match == null) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false\n  }\n\n  let hash = match[hashMatch]\n\n  if (hash != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority component anyway)\n    hash = hash.toLowerCase()\n  }\n\n  return isCID(hash)\n}\n\n/**\n *\n * @param {string | Uint8Array} input\n * @param {string | RegExp} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=1]\n */\nfunction isIpns (input: string | Uint8Array, pattern: RegExp | string, protocolMatch: number = defaultProtocolMatch, hashMatch: number = defaultHashMath) {\n  const formatted = convertToString(input)\n  if (formatted === false) {\n    return false\n  }\n  const match = formatted.match(pattern)\n  if (match == null) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false\n  }\n\n  let ipnsId = match[hashMatch]\n\n  if (ipnsId != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase()\n    // Check if it is cidv1\n    if (isCID(ipnsId)) return true\n    // Check if it looks like FQDN\n    try {\n      if (!ipnsId.includes('.') && ipnsId.includes('-')) {\n        // name without tld, assuming its inlined into a single DNS label\n        // (https://github.com/ipfs/in-web-browsers/issues/169)\n        // en-wikipedia--on--ipfs-org â†’ en.wikipedia-on-ipfs.org\n        ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-')\n      }\n      // URL implementation in web browsers forces lowercase of the hostname\n      const { hostname } = new URL(`http://${ipnsId}`) // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n      return fqdnWithTld.test(hostname)\n    } catch (e) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {any} input\n */\nfunction isString (input: any): input is string {\n  return typeof input === 'string'\n}\n\n/**\n * @param {Uint8Array | string} input\n */\nfunction convertToString (input: Uint8Array | string) {\n  if (input instanceof Uint8Array) {\n    return uint8ArrayToString(input, 'base58btc')\n  }\n\n  if (isString(input)) {\n    return input\n  }\n\n  return false\n}\n\nexport const ipfsSubdomain = (url: string | Uint8Array) => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\nexport const ipnsSubdomain = (url: string | Uint8Array) => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\nexport const subdomain = (url: string | Uint8Array) => ipfsSubdomain(url) || ipnsSubdomain(url)\nexport const ipfsUrl = (url: string | Uint8Array) => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url)\nexport const ipnsUrl = (url: string | Uint8Array) => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url)\nexport const url = (url: string | Uint8Array) => ipfsUrl(url) || ipnsUrl(url) || subdomain(url)\nexport const path = (path: string | Uint8Array) => isIpfs(path, pathPattern) || isIpns(path, pathPattern)\n\nexport { isMultihash as multihash }\nexport { isMultiaddr as multiaddr }\nexport { isPeerMultiaddr as peerMultiaddr }\nexport { isCID as cid }\n\nexport const base32cid = (cid: CID | string | Uint8Array) => (isCID(cid) && isBase32EncodedMultibase(cid))\nexport const ipfsPath = (path: string | Uint8Array) => isIpfs(path, pathPattern)\nexport const ipnsPath = (path: string | Uint8Array) => isIpns(path, pathPattern)\nexport const urlOrPath = (x: string | Uint8Array) => url(x) || path(x)\nexport const cidPath = (path: string | Uint8Array | CID) => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\n"]},"metadata":{},"sourceType":"module"}