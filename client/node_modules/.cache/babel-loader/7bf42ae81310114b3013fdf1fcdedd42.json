{"ast":null,"code":"import { validatePeerScoreParams } from './peer-score-params.js';\nimport { computeScore } from './compute-score.js';\nimport { MessageDeliveries, DeliveryRecordStatus } from './message-deliveries.js';\nimport { logger } from '@libp2p/logger';\nimport { RejectReason } from '../types.js';\nimport { MapDef } from '../utils/set.js';\nconst log = logger('libp2p:gossipsub:score');\nexport class PeerScore {\n  constructor(params, metrics, opts) {\n    this.params = params;\n    this.metrics = metrics;\n    /**\n     * Per-peer stats for score calculation\n     */\n\n    this.peerStats = new Map();\n    /**\n     * IP colocation tracking; maps IP => set of peers.\n     */\n\n    this.peerIPs = new MapDef(() => new Set());\n    /**\n     * Cache score up to decayInterval if topic stats are unchanged.\n     */\n\n    this.scoreCache = new Map();\n    /**\n     * Recent message delivery timing/participants\n     */\n\n    this.deliveryRecords = new MessageDeliveries();\n    validatePeerScoreParams(params);\n    this.scoreCacheValidityMs = opts.scoreCacheValidityMs;\n    this.computeScore = opts.computeScore ?? computeScore;\n  }\n\n  get size() {\n    return this.peerStats.size;\n  }\n  /**\n   * Start PeerScore instance\n   */\n\n\n  start() {\n    if (this._backgroundInterval) {\n      log('Peer score already running');\n      return;\n    }\n\n    this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);\n    log('started');\n  }\n  /**\n   * Stop PeerScore instance\n   */\n\n\n  stop() {\n    if (!this._backgroundInterval) {\n      log('Peer score already stopped');\n      return;\n    }\n\n    clearInterval(this._backgroundInterval);\n    delete this._backgroundInterval;\n    this.peerIPs.clear();\n    this.peerStats.clear();\n    this.deliveryRecords.clear();\n    log('stopped');\n  }\n  /**\n   * Periodic maintenance\n   */\n\n\n  background() {\n    this.refreshScores();\n    this.deliveryRecords.gc();\n  }\n\n  dumpPeerScoreStats() {\n    return Object.fromEntries(Array.from(this.peerStats.entries()).map(_ref => {\n      let [peer, stats] = _ref;\n      return [peer, stats];\n    }));\n  }\n  /**\n   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n   */\n\n\n  refreshScores() {\n    const now = Date.now();\n    const decayToZero = this.params.decayToZero;\n    this.peerStats.forEach((pstats, id) => {\n      if (!pstats.connected) {\n        // has the retention period expired?\n        if (now > pstats.expire) {\n          // yes, throw it away (but clean up the IP tracking first)\n          this.removeIPsForPeer(id, pstats.knownIPs);\n          this.peerStats.delete(id);\n          this.scoreCache.delete(id);\n        } // we don't decay retained scores, as the peer is not active.\n        // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n        // unless the retention period has elapsed.\n        // similarly, a well behaved peer does not lose its score by getting disconnected.\n\n\n        return;\n      }\n\n      Object.entries(pstats.topics).forEach(_ref2 => {\n        let [topic, tstats] = _ref2;\n        const tparams = this.params.topics[topic];\n\n        if (tparams === undefined) {\n          // we are not scoring this topic\n          // should be unreachable, we only add scored topics to pstats\n          return;\n        } // decay counters\n\n\n        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;\n\n        if (tstats.firstMessageDeliveries < decayToZero) {\n          tstats.firstMessageDeliveries = 0;\n        }\n\n        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;\n\n        if (tstats.meshMessageDeliveries < decayToZero) {\n          tstats.meshMessageDeliveries = 0;\n        }\n\n        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;\n\n        if (tstats.meshFailurePenalty < decayToZero) {\n          tstats.meshFailurePenalty = 0;\n        }\n\n        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;\n\n        if (tstats.invalidMessageDeliveries < decayToZero) {\n          tstats.invalidMessageDeliveries = 0;\n        } // update mesh time and activate mesh message delivery parameter if need be\n\n\n        if (tstats.inMesh) {\n          tstats.meshTime = now - tstats.graftTime;\n\n          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n            tstats.meshMessageDeliveriesActive = true;\n          }\n        }\n      }); // decay P7 counter\n\n      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;\n\n      if (pstats.behaviourPenalty < decayToZero) {\n        pstats.behaviourPenalty = 0;\n      }\n    });\n  }\n  /**\n   * Return the score for a peer\n   */\n\n\n  score(id) {\n    this.metrics?.scoreFnCalls.inc();\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return 0;\n    }\n\n    const now = Date.now();\n    const cacheEntry = this.scoreCache.get(id); // Found cached score within validity period\n\n    if (cacheEntry && cacheEntry.cacheUntil > now) {\n      return cacheEntry.score;\n    }\n\n    this.metrics?.scoreFnRuns.inc();\n    const score = this.computeScore(id, pstats, this.params, this.peerIPs);\n    const cacheUntil = now + this.scoreCacheValidityMs;\n\n    if (cacheEntry) {\n      this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score));\n      cacheEntry.score = score;\n      cacheEntry.cacheUntil = cacheUntil;\n    } else {\n      this.scoreCache.set(id, {\n        score,\n        cacheUntil\n      });\n    }\n\n    return score;\n  }\n  /**\n   * Apply a behavioural penalty to a peer\n   */\n\n\n  addPenalty(id, penalty, penaltyLabel) {\n    const pstats = this.peerStats.get(id);\n\n    if (pstats) {\n      pstats.behaviourPenalty += penalty;\n      this.metrics?.onScorePenalty(penaltyLabel);\n    }\n  }\n\n  addPeer(id) {\n    // create peer stats (not including topic stats for each topic to be scored)\n    // topic stats will be added as needed\n    const pstats = {\n      connected: true,\n      expire: 0,\n      topics: {},\n      knownIPs: new Set(),\n      behaviourPenalty: 0\n    };\n    this.peerStats.set(id, pstats);\n  }\n  /** Adds a new IP to a peer, if the peer is not known the update is ignored */\n\n\n  addIP(id, ip) {\n    const pstats = this.peerStats.get(id);\n\n    if (pstats) {\n      pstats.knownIPs.add(ip);\n    }\n\n    this.peerIPs.getOrDefault(ip).add(id);\n  }\n  /** Remove peer association with IP */\n\n\n  removeIP(id, ip) {\n    const pstats = this.peerStats.get(id);\n\n    if (pstats) {\n      pstats.knownIPs.delete(ip);\n    }\n\n    const peersWithIP = this.peerIPs.get(ip);\n\n    if (peersWithIP) {\n      peersWithIP.delete(id);\n\n      if (peersWithIP.size === 0) {\n        this.peerIPs.delete(ip);\n      }\n    }\n  }\n\n  removePeer(id) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    } // decide whether to retain the score; this currently only retains non-positive scores\n    // to dissuade attacks on the score function.\n\n\n    if (this.score(id) > 0) {\n      this.removeIPsForPeer(id, pstats.knownIPs);\n      this.peerStats.delete(id);\n      return;\n    } // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n    // reset to 0 and mesh delivery penalties applied.\n\n\n    Object.entries(pstats.topics).forEach(_ref3 => {\n      let [topic, tstats] = _ref3;\n      tstats.firstMessageDeliveries = 0;\n      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n\n      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n        const deficit = threshold - tstats.meshMessageDeliveries;\n        tstats.meshFailurePenalty += deficit * deficit;\n      }\n\n      tstats.inMesh = false;\n      tstats.meshMessageDeliveriesActive = false;\n    });\n    pstats.connected = false;\n    pstats.expire = Date.now() + this.params.retainScore;\n  }\n  /** Handles scoring functionality as a peer GRAFTs to a topic. */\n\n\n  graft(id, topic) {\n    const pstats = this.peerStats.get(id);\n\n    if (pstats) {\n      const tstats = this.getPtopicStats(pstats, topic);\n\n      if (tstats) {\n        // if we are scoring the topic, update the mesh status.\n        tstats.inMesh = true;\n        tstats.graftTime = Date.now();\n        tstats.meshTime = 0;\n        tstats.meshMessageDeliveriesActive = false;\n      }\n    }\n  }\n  /** Handles scoring functionality as a peer PRUNEs from a topic. */\n\n\n  prune(id, topic) {\n    const pstats = this.peerStats.get(id);\n\n    if (pstats) {\n      const tstats = this.getPtopicStats(pstats, topic);\n\n      if (tstats) {\n        // sticky mesh delivery rate failure penalty\n        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n\n        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n          const deficit = threshold - tstats.meshMessageDeliveries;\n          tstats.meshFailurePenalty += deficit * deficit;\n        }\n\n        tstats.meshMessageDeliveriesActive = false;\n        tstats.inMesh = false; // TODO: Consider clearing score cache on important penalties\n        // this.scoreCache.delete(id)\n      }\n    }\n  }\n\n  validateMessage(msgIdStr) {\n    this.deliveryRecords.ensureRecord(msgIdStr);\n  }\n\n  deliverMessage(from, msgIdStr, topic) {\n    this.markFirstMessageDelivery(from, topic);\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr);\n    const now = Date.now(); // defensive check that this is the first delivery trace -- delivery status should be unknown\n\n    if (drec.status !== DeliveryRecordStatus.unknown) {\n      log('unexpected delivery: message from %s was first seen %s ago and has delivery status %s', from, now - drec.firstSeen, DeliveryRecordStatus[drec.status]);\n      return;\n    } // mark the message as valid and reward mesh peers that have already forwarded it to us\n\n\n    drec.status = DeliveryRecordStatus.valid;\n    drec.validated = now;\n    drec.peers.forEach(p => {\n      // this check is to make sure a peer can't send us a message twice and get a double count\n      // if it is a first delivery.\n      if (p !== from.toString()) {\n        this.markDuplicateMessageDelivery(p, topic);\n      }\n    });\n  }\n  /**\n   * Similar to `rejectMessage` except does not require the message id or reason for an invalid message.\n   */\n\n\n  rejectInvalidMessage(from, topic) {\n    this.markInvalidMessageDelivery(from, topic);\n  }\n\n  rejectMessage(from, msgIdStr, topic, reason) {\n    switch (reason) {\n      // these messages are not tracked, but the peer is penalized as they are invalid\n      case RejectReason.Error:\n        this.markInvalidMessageDelivery(from, topic);\n        return;\n      // we ignore those messages, so do nothing.\n\n      case RejectReason.Blacklisted:\n        return;\n      // the rest are handled after record creation\n    }\n\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr); // defensive check that this is the first rejection -- delivery status should be unknown\n\n    if (drec.status !== DeliveryRecordStatus.unknown) {\n      log('unexpected rejection: message from %s was first seen %s ago and has delivery status %d', from, Date.now() - drec.firstSeen, DeliveryRecordStatus[drec.status]);\n      return;\n    }\n\n    if (reason === RejectReason.Ignore) {\n      // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n      drec.status = DeliveryRecordStatus.ignored;\n      drec.peers.clear();\n      return;\n    } // mark the message as invalid and penalize peers that have already forwarded it.\n\n\n    drec.status = DeliveryRecordStatus.invalid;\n    this.markInvalidMessageDelivery(from, topic);\n    drec.peers.forEach(p => {\n      this.markInvalidMessageDelivery(p, topic);\n    }); // release the delivery time tracking map to free some memory early\n\n    drec.peers.clear();\n  }\n\n  duplicateMessage(from, msgIdStr, topic) {\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr);\n\n    if (drec.peers.has(from)) {\n      // we have already seen this duplicate\n      return;\n    }\n\n    switch (drec.status) {\n      case DeliveryRecordStatus.unknown:\n        // the message is being validated; track the peer delivery and wait for\n        // the Deliver/Reject/Ignore notification.\n        drec.peers.add(from);\n        break;\n\n      case DeliveryRecordStatus.valid:\n        // mark the peer delivery time to only count a duplicate delivery once.\n        drec.peers.add(from);\n        this.markDuplicateMessageDelivery(from, topic, drec.validated);\n        break;\n\n      case DeliveryRecordStatus.invalid:\n        // we no longer track delivery time\n        this.markInvalidMessageDelivery(from, topic);\n        break;\n\n      case DeliveryRecordStatus.ignored:\n        // the message was ignored; do nothing (we don't know if it was valid)\n        break;\n    }\n  }\n  /**\n   * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n   */\n\n\n  markInvalidMessageDelivery(from, topic) {\n    const pstats = this.peerStats.get(from);\n\n    if (pstats) {\n      const tstats = this.getPtopicStats(pstats, topic);\n\n      if (tstats) {\n        tstats.invalidMessageDeliveries += 1;\n      }\n    }\n  }\n  /**\n   * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n   * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n   * Messages already known (with the seenCache) are counted with markDuplicateMessageDelivery()\n   */\n\n\n  markFirstMessageDelivery(from, topic) {\n    const pstats = this.peerStats.get(from);\n\n    if (pstats) {\n      const tstats = this.getPtopicStats(pstats, topic);\n\n      if (tstats) {\n        let cap = this.params.topics[topic].firstMessageDeliveriesCap;\n        tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1);\n\n        if (tstats.inMesh) {\n          cap = this.params.topics[topic].meshMessageDeliveriesCap;\n          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);\n        }\n      }\n    }\n  }\n  /**\n   * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n   * as long the message was received within the P3 window.\n   */\n\n\n  markDuplicateMessageDelivery(from, topic, validatedTime) {\n    const pstats = this.peerStats.get(from);\n\n    if (pstats) {\n      const now = validatedTime !== undefined ? Date.now() : 0;\n      const tstats = this.getPtopicStats(pstats, topic);\n\n      if (tstats && tstats.inMesh) {\n        const tparams = this.params.topics[topic]; // check against the mesh delivery window -- if the validated time is passed as 0, then\n        // the message was received before we finished validation and thus falls within the mesh\n        // delivery window.\n\n        if (validatedTime !== undefined) {\n          const deliveryDelayMs = now - validatedTime;\n          const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow;\n          this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery);\n\n          if (isLateDelivery) {\n            return;\n          }\n        }\n\n        const cap = tparams.meshMessageDeliveriesCap;\n        tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);\n      }\n    }\n  }\n  /**\n   * Removes an IP list from the tracking list for a peer.\n   */\n\n\n  removeIPsForPeer(id, ipsToRemove) {\n    for (const ipToRemove of ipsToRemove) {\n      const peerSet = this.peerIPs.get(ipToRemove);\n\n      if (peerSet) {\n        peerSet.delete(id);\n\n        if (peerSet.size === 0) {\n          this.peerIPs.delete(ipToRemove);\n        }\n      }\n    }\n  }\n  /**\n   * Returns topic stats if they exist, otherwise if the supplied parameters score the\n   * topic, inserts the default stats and returns a reference to those. If neither apply, returns None.\n   */\n\n\n  getPtopicStats(pstats, topic) {\n    let topicStats = pstats.topics[topic];\n\n    if (topicStats !== undefined) {\n      return topicStats;\n    }\n\n    if (this.params.topics[topic] !== undefined) {\n      topicStats = {\n        inMesh: false,\n        graftTime: 0,\n        meshTime: 0,\n        firstMessageDeliveries: 0,\n        meshMessageDeliveries: 0,\n        meshMessageDeliveriesActive: false,\n        meshFailurePenalty: 0,\n        invalidMessageDeliveries: 0\n      };\n      pstats.topics[topic] = topicStats;\n      return topicStats;\n    }\n\n    return null;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["validatePeerScoreParams","computeScore","MessageDeliveries","DeliveryRecordStatus","logger","RejectReason","MapDef","log","PeerScore","constructor","params","metrics","opts","Map","Set","scoreCacheValidityMs","size","peerStats","start","_backgroundInterval","setInterval","background","decayInterval","stop","clearInterval","peerIPs","clear","deliveryRecords","refreshScores","gc","dumpPeerScoreStats","Object","fromEntries","Array","from","entries","map","peer","stats","now","Date","decayToZero","forEach","pstats","id","connected","expire","removeIPsForPeer","knownIPs","delete","scoreCache","topics","topic","tstats","tparams","undefined","firstMessageDeliveries","firstMessageDeliveriesDecay","meshMessageDeliveries","meshMessageDeliveriesDecay","meshFailurePenalty","meshFailurePenaltyDecay","invalidMessageDeliveries","invalidMessageDeliveriesDecay","inMesh","meshTime","graftTime","meshMessageDeliveriesActivation","meshMessageDeliveriesActive","behaviourPenalty","behaviourPenaltyDecay","score","scoreFnCalls","inc","get","cacheEntry","cacheUntil","scoreFnRuns","scoreCachedDelta","observe","Math","abs","set","addPenalty","penalty","penaltyLabel","onScorePenalty","addPeer","addIP","ip","add","getOrDefault","removeIP","peersWithIP","removePeer","threshold","meshMessageDeliveriesThreshold","deficit","retainScore","graft","getPtopicStats","prune","validateMessage","msgIdStr","ensureRecord","deliverMessage","markFirstMessageDelivery","drec","status","unknown","firstSeen","valid","validated","peers","p","toString","markDuplicateMessageDelivery","rejectInvalidMessage","markInvalidMessageDelivery","rejectMessage","reason","Error","Blacklisted","Ignore","ignored","invalid","duplicateMessage","has","cap","firstMessageDeliveriesCap","min","meshMessageDeliveriesCap","validatedTime","deliveryDelayMs","isLateDelivery","meshMessageDeliveriesWindow","onDuplicateMsgDelivery","ipsToRemove","ipToRemove","peerSet","topicStats"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\score\\peer-score.ts"],"sourcesContent":["import { PeerScoreParams, validatePeerScoreParams } from './peer-score-params.js'\nimport type { PeerStats, TopicStats } from './peer-stats.js'\nimport { computeScore } from './compute-score.js'\nimport { MessageDeliveries, DeliveryRecordStatus } from './message-deliveries.js'\nimport { logger } from '@libp2p/logger'\nimport { MsgIdStr, PeerIdStr, RejectReason, TopicStr, IPStr } from '../types.js'\nimport type { Metrics, ScorePenalty } from '../metrics.js'\nimport { MapDef } from '../utils/set.js'\n\nconst log = logger('libp2p:gossipsub:score')\n\ninterface PeerScoreOpts {\n  /**\n   * Miliseconds to cache computed score per peer\n   */\n  scoreCacheValidityMs: number\n\n  computeScore?: typeof computeScore\n}\n\ninterface ScoreCacheEntry {\n  /** The cached score */\n  score: number\n  /** Unix timestamp in miliseconds, the time after which the cached score for a peer is no longer valid */\n  cacheUntil: number\n}\n\nexport type PeerScoreStatsDump = Record<PeerIdStr, PeerStats>\n\nexport class PeerScore {\n  /**\n   * Per-peer stats for score calculation\n   */\n  readonly peerStats = new Map<PeerIdStr, PeerStats>()\n  /**\n   * IP colocation tracking; maps IP => set of peers.\n   */\n  readonly peerIPs = new MapDef<PeerIdStr, Set<IPStr>>(() => new Set())\n  /**\n   * Cache score up to decayInterval if topic stats are unchanged.\n   */\n  readonly scoreCache = new Map<PeerIdStr, ScoreCacheEntry>()\n  /**\n   * Recent message delivery timing/participants\n   */\n  readonly deliveryRecords = new MessageDeliveries()\n\n  _backgroundInterval?: ReturnType<typeof setInterval>\n\n  private readonly scoreCacheValidityMs: number\n  private readonly computeScore: typeof computeScore\n\n  constructor(readonly params: PeerScoreParams, private readonly metrics: Metrics | null, opts: PeerScoreOpts) {\n    validatePeerScoreParams(params)\n    this.scoreCacheValidityMs = opts.scoreCacheValidityMs\n    this.computeScore = opts.computeScore ?? computeScore\n  }\n\n  get size(): number {\n    return this.peerStats.size\n  }\n\n  /**\n   * Start PeerScore instance\n   */\n  start(): void {\n    if (this._backgroundInterval) {\n      log('Peer score already running')\n      return\n    }\n    this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval)\n    log('started')\n  }\n\n  /**\n   * Stop PeerScore instance\n   */\n  stop(): void {\n    if (!this._backgroundInterval) {\n      log('Peer score already stopped')\n      return\n    }\n    clearInterval(this._backgroundInterval)\n    delete this._backgroundInterval\n    this.peerIPs.clear()\n    this.peerStats.clear()\n    this.deliveryRecords.clear()\n    log('stopped')\n  }\n\n  /**\n   * Periodic maintenance\n   */\n  background(): void {\n    this.refreshScores()\n    this.deliveryRecords.gc()\n  }\n\n  dumpPeerScoreStats(): PeerScoreStatsDump {\n    return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]))\n  }\n\n  /**\n   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n   */\n  public refreshScores(): void {\n    const now = Date.now()\n    const decayToZero = this.params.decayToZero\n\n    this.peerStats.forEach((pstats, id) => {\n      if (!pstats.connected) {\n        // has the retention period expired?\n        if (now > pstats.expire) {\n          // yes, throw it away (but clean up the IP tracking first)\n          this.removeIPsForPeer(id, pstats.knownIPs)\n          this.peerStats.delete(id)\n          this.scoreCache.delete(id)\n        }\n\n        // we don't decay retained scores, as the peer is not active.\n        // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n        // unless the retention period has elapsed.\n        // similarly, a well behaved peer does not lose its score by getting disconnected.\n        return\n      }\n\n      Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n        const tparams = this.params.topics[topic]\n        if (tparams === undefined) {\n          // we are not scoring this topic\n          // should be unreachable, we only add scored topics to pstats\n          return\n        }\n\n        // decay counters\n        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay\n        if (tstats.firstMessageDeliveries < decayToZero) {\n          tstats.firstMessageDeliveries = 0\n        }\n\n        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay\n        if (tstats.meshMessageDeliveries < decayToZero) {\n          tstats.meshMessageDeliveries = 0\n        }\n\n        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay\n        if (tstats.meshFailurePenalty < decayToZero) {\n          tstats.meshFailurePenalty = 0\n        }\n\n        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay\n        if (tstats.invalidMessageDeliveries < decayToZero) {\n          tstats.invalidMessageDeliveries = 0\n        }\n\n        // update mesh time and activate mesh message delivery parameter if need be\n        if (tstats.inMesh) {\n          tstats.meshTime = now - tstats.graftTime\n          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n            tstats.meshMessageDeliveriesActive = true\n          }\n        }\n      })\n\n      // decay P7 counter\n      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay\n      if (pstats.behaviourPenalty < decayToZero) {\n        pstats.behaviourPenalty = 0\n      }\n    })\n  }\n\n  /**\n   * Return the score for a peer\n   */\n  score(id: PeerIdStr): number {\n    this.metrics?.scoreFnCalls.inc()\n\n    const pstats = this.peerStats.get(id)\n    if (!pstats) {\n      return 0\n    }\n\n    const now = Date.now()\n    const cacheEntry = this.scoreCache.get(id)\n\n    // Found cached score within validity period\n    if (cacheEntry && cacheEntry.cacheUntil > now) {\n      return cacheEntry.score\n    }\n\n    this.metrics?.scoreFnRuns.inc()\n\n    const score = this.computeScore(id, pstats, this.params, this.peerIPs)\n    const cacheUntil = now + this.scoreCacheValidityMs\n\n    if (cacheEntry) {\n      this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score))\n      cacheEntry.score = score\n      cacheEntry.cacheUntil = cacheUntil\n    } else {\n      this.scoreCache.set(id, { score, cacheUntil })\n    }\n\n    return score\n  }\n\n  /**\n   * Apply a behavioural penalty to a peer\n   */\n  addPenalty(id: PeerIdStr, penalty: number, penaltyLabel: ScorePenalty): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats) {\n      pstats.behaviourPenalty += penalty\n      this.metrics?.onScorePenalty(penaltyLabel)\n    }\n  }\n\n  addPeer(id: PeerIdStr): void {\n    // create peer stats (not including topic stats for each topic to be scored)\n    // topic stats will be added as needed\n    const pstats: PeerStats = {\n      connected: true,\n      expire: 0,\n      topics: {},\n      knownIPs: new Set(),\n      behaviourPenalty: 0\n    }\n    this.peerStats.set(id, pstats)\n  }\n\n  /** Adds a new IP to a peer, if the peer is not known the update is ignored */\n  addIP(id: PeerIdStr, ip: string): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats) {\n      pstats.knownIPs.add(ip)\n    }\n\n    this.peerIPs.getOrDefault(ip).add(id)\n  }\n\n  /** Remove peer association with IP */\n  removeIP(id: PeerIdStr, ip: string): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats) {\n      pstats.knownIPs.delete(ip)\n    }\n\n    const peersWithIP = this.peerIPs.get(ip)\n    if (peersWithIP) {\n      peersWithIP.delete(id)\n      if (peersWithIP.size === 0) {\n        this.peerIPs.delete(ip)\n      }\n    }\n  }\n\n  removePeer(id: PeerIdStr): void {\n    const pstats = this.peerStats.get(id)\n    if (!pstats) {\n      return\n    }\n\n    // decide whether to retain the score; this currently only retains non-positive scores\n    // to dissuade attacks on the score function.\n    if (this.score(id) > 0) {\n      this.removeIPsForPeer(id, pstats.knownIPs)\n      this.peerStats.delete(id)\n      return\n    }\n\n    // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n    // reset to 0 and mesh delivery penalties applied.\n    Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n      tstats.firstMessageDeliveries = 0\n\n      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold\n      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n        const deficit = threshold - tstats.meshMessageDeliveries\n        tstats.meshFailurePenalty += deficit * deficit\n      }\n\n      tstats.inMesh = false\n      tstats.meshMessageDeliveriesActive = false\n    })\n\n    pstats.connected = false\n    pstats.expire = Date.now() + this.params.retainScore\n  }\n\n  /** Handles scoring functionality as a peer GRAFTs to a topic. */\n  graft(id: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats) {\n        // if we are scoring the topic, update the mesh status.\n        tstats.inMesh = true\n        tstats.graftTime = Date.now()\n        tstats.meshTime = 0\n        tstats.meshMessageDeliveriesActive = false\n      }\n    }\n  }\n\n  /** Handles scoring functionality as a peer PRUNEs from a topic. */\n  prune(id: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats) {\n        // sticky mesh delivery rate failure penalty\n        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold\n        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n          const deficit = threshold - tstats.meshMessageDeliveries\n          tstats.meshFailurePenalty += deficit * deficit\n        }\n        tstats.meshMessageDeliveriesActive = false\n        tstats.inMesh = false\n\n        // TODO: Consider clearing score cache on important penalties\n        // this.scoreCache.delete(id)\n      }\n    }\n  }\n\n  validateMessage(msgIdStr: MsgIdStr): void {\n    this.deliveryRecords.ensureRecord(msgIdStr)\n  }\n\n  deliverMessage(from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr): void {\n    this.markFirstMessageDelivery(from, topic)\n\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n    const now = Date.now()\n\n    // defensive check that this is the first delivery trace -- delivery status should be unknown\n    if (drec.status !== DeliveryRecordStatus.unknown) {\n      log(\n        'unexpected delivery: message from %s was first seen %s ago and has delivery status %s',\n        from,\n        now - drec.firstSeen,\n        DeliveryRecordStatus[drec.status]\n      )\n      return\n    }\n\n    // mark the message as valid and reward mesh peers that have already forwarded it to us\n    drec.status = DeliveryRecordStatus.valid\n    drec.validated = now\n    drec.peers.forEach((p) => {\n      // this check is to make sure a peer can't send us a message twice and get a double count\n      // if it is a first delivery.\n      if (p !== from.toString()) {\n        this.markDuplicateMessageDelivery(p, topic)\n      }\n    })\n  }\n\n  /**\n   * Similar to `rejectMessage` except does not require the message id or reason for an invalid message.\n   */\n  rejectInvalidMessage(from: PeerIdStr, topic: TopicStr): void {\n    this.markInvalidMessageDelivery(from, topic)\n  }\n\n  rejectMessage(from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr, reason: RejectReason): void {\n    switch (reason) {\n      // these messages are not tracked, but the peer is penalized as they are invalid\n      case RejectReason.Error:\n        this.markInvalidMessageDelivery(from, topic)\n        return\n\n      // we ignore those messages, so do nothing.\n      case RejectReason.Blacklisted:\n        return\n\n      // the rest are handled after record creation\n    }\n\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n\n    // defensive check that this is the first rejection -- delivery status should be unknown\n    if (drec.status !== DeliveryRecordStatus.unknown) {\n      log(\n        'unexpected rejection: message from %s was first seen %s ago and has delivery status %d',\n        from,\n        Date.now() - drec.firstSeen,\n        DeliveryRecordStatus[drec.status]\n      )\n      return\n    }\n\n    if (reason === RejectReason.Ignore) {\n      // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n      drec.status = DeliveryRecordStatus.ignored\n      drec.peers.clear()\n      return\n    }\n\n    // mark the message as invalid and penalize peers that have already forwarded it.\n    drec.status = DeliveryRecordStatus.invalid\n\n    this.markInvalidMessageDelivery(from, topic)\n    drec.peers.forEach((p) => {\n      this.markInvalidMessageDelivery(p, topic)\n    })\n\n    // release the delivery time tracking map to free some memory early\n    drec.peers.clear()\n  }\n\n  duplicateMessage(from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr): void {\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n\n    if (drec.peers.has(from)) {\n      // we have already seen this duplicate\n      return\n    }\n\n    switch (drec.status) {\n      case DeliveryRecordStatus.unknown:\n        // the message is being validated; track the peer delivery and wait for\n        // the Deliver/Reject/Ignore notification.\n        drec.peers.add(from)\n        break\n\n      case DeliveryRecordStatus.valid:\n        // mark the peer delivery time to only count a duplicate delivery once.\n        drec.peers.add(from)\n        this.markDuplicateMessageDelivery(from, topic, drec.validated)\n        break\n\n      case DeliveryRecordStatus.invalid:\n        // we no longer track delivery time\n        this.markInvalidMessageDelivery(from, topic)\n        break\n\n      case DeliveryRecordStatus.ignored:\n        // the message was ignored; do nothing (we don't know if it was valid)\n        break\n    }\n  }\n\n  /**\n   * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n   */\n  public markInvalidMessageDelivery(from: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats) {\n        tstats.invalidMessageDeliveries += 1\n      }\n    }\n  }\n\n  /**\n   * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n   * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n   * Messages already known (with the seenCache) are counted with markDuplicateMessageDelivery()\n   */\n  public markFirstMessageDelivery(from: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats) {\n        let cap = this.params.topics[topic].firstMessageDeliveriesCap\n        tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1)\n\n        if (tstats.inMesh) {\n          cap = this.params.topics[topic].meshMessageDeliveriesCap\n          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1)\n        }\n      }\n    }\n  }\n\n  /**\n   * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n   * as long the message was received within the P3 window.\n   */\n  public markDuplicateMessageDelivery(from: PeerIdStr, topic: TopicStr, validatedTime?: number): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats) {\n      const now = validatedTime !== undefined ? Date.now() : 0\n\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats && tstats.inMesh) {\n        const tparams = this.params.topics[topic]\n\n        // check against the mesh delivery window -- if the validated time is passed as 0, then\n        // the message was received before we finished validation and thus falls within the mesh\n        // delivery window.\n        if (validatedTime !== undefined) {\n          const deliveryDelayMs = now - validatedTime\n          const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow\n          this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery)\n\n          if (isLateDelivery) {\n            return\n          }\n        }\n\n        const cap = tparams.meshMessageDeliveriesCap\n        tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1)\n      }\n    }\n  }\n\n  /**\n   * Removes an IP list from the tracking list for a peer.\n   */\n  private removeIPsForPeer(id: PeerIdStr, ipsToRemove: Set<IPStr>): void {\n    for (const ipToRemove of ipsToRemove) {\n      const peerSet = this.peerIPs.get(ipToRemove)\n      if (peerSet) {\n        peerSet.delete(id)\n        if (peerSet.size === 0) {\n          this.peerIPs.delete(ipToRemove)\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns topic stats if they exist, otherwise if the supplied parameters score the\n   * topic, inserts the default stats and returns a reference to those. If neither apply, returns None.\n   */\n  private getPtopicStats(pstats: PeerStats, topic: TopicStr): TopicStats | null {\n    let topicStats: TopicStats | undefined = pstats.topics[topic]\n\n    if (topicStats !== undefined) {\n      return topicStats\n    }\n\n    if (this.params.topics[topic] !== undefined) {\n      topicStats = {\n        inMesh: false,\n        graftTime: 0,\n        meshTime: 0,\n        firstMessageDeliveries: 0,\n        meshMessageDeliveries: 0,\n        meshMessageDeliveriesActive: false,\n        meshFailurePenalty: 0,\n        invalidMessageDeliveries: 0\n      }\n      pstats.topics[topic] = topicStats\n\n      return topicStats\n    }\n\n    return null\n  }\n}\n"]},"metadata":{},"sourceType":"module"}