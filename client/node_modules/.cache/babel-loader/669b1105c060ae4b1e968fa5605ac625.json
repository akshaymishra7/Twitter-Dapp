{"ast":null,"code":"(function (root) {\n  'use strict'; // A list of regular expressions that match arbitrary IPv4 addresses,\n  // for which a number of weird notations exist.\n  // Note that an address like 0010.0xa5.1.1 is considered legal.\n\n  const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n  const ipv4Regexes = {\n    fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n    threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n    twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n    longValue: new RegExp(`^${ipv4Part}$`, 'i')\n  }; // Regular Expression for checking Octal numbers\n\n  const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n  const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n  const zoneIndex = '%[0-9a-z]{1,}'; // IPv6-matching regular expressions.\n  // For IPv6, the task is simpler: it is enough to match the colon-delimited\n  // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n  // the end.\n\n  const ipv6Part = '(?:[0-9a-f]+::?)+';\n  const ipv6Regexes = {\n    zoneIndex: new RegExp(zoneIndex, 'i'),\n    'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n    deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n    transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n  }; // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n\n  function expandIPv6(string, parts) {\n    // More than one '::' means invalid adddress\n    if (string.indexOf('::') !== string.lastIndexOf('::')) {\n      return null;\n    }\n\n    let colonCount = 0;\n    let lastColon = -1;\n    let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n    let replacement, replacementCount; // Remove zone index and save it for later\n\n    if (zoneId) {\n      zoneId = zoneId.substring(1);\n      string = string.replace(/%.+$/, '');\n    } // How many parts do we already have?\n\n\n    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n      colonCount++;\n    } // 0::0 is two parts more than ::\n\n\n    if (string.substr(0, 2) === '::') {\n      colonCount--;\n    }\n\n    if (string.substr(-2, 2) === '::') {\n      colonCount--;\n    } // The following loop would hang if colonCount > parts\n\n\n    if (colonCount > parts) {\n      return null;\n    } // replacement = ':' + '0:' * (parts - colonCount)\n\n\n    replacementCount = parts - colonCount;\n    replacement = ':';\n\n    while (replacementCount--) {\n      replacement += '0:';\n    } // Insert the missing zeroes\n\n\n    string = string.replace('::', replacement); // Trim any garbage which may be hanging around if :: was at the edge in\n    // the source strin\n\n    if (string[0] === ':') {\n      string = string.slice(1);\n    }\n\n    if (string[string.length - 1] === ':') {\n      string = string.slice(0, -1);\n    }\n\n    parts = function () {\n      const ref = string.split(':');\n      const results = [];\n\n      for (let i = 0; i < ref.length; i++) {\n        results.push(parseInt(ref[i], 16));\n      }\n\n      return results;\n    }();\n\n    return {\n      parts: parts,\n      zoneId: zoneId\n    };\n  } // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n\n\n  function matchCIDR(first, second, partSize, cidrBits) {\n    if (first.length !== second.length) {\n      throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n    }\n\n    let part = 0;\n    let shift;\n\n    while (cidrBits > 0) {\n      shift = partSize - cidrBits;\n\n      if (shift < 0) {\n        shift = 0;\n      }\n\n      if (first[part] >> shift !== second[part] >> shift) {\n        return false;\n      }\n\n      cidrBits -= partSize;\n      part += 1;\n    }\n\n    return true;\n  }\n\n  function parseIntAuto(string) {\n    // Hexadedimal base 16 (0x#)\n    if (hexRegex.test(string)) {\n      return parseInt(string, 16);\n    } // While octal representation is discouraged by ECMAScript 3\n    // and forbidden by ECMAScript 5, we silently allow it to\n    // work only if the rest of the string has numbers less than 8.\n\n\n    if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n      if (octalRegex.test(string)) {\n        return parseInt(string, 8);\n      }\n\n      throw new Error(`ipaddr: cannot parse ${string} as octal`);\n    } // Always include the base 10 radix!\n\n\n    return parseInt(string, 10);\n  }\n\n  function padPart(part, length) {\n    while (part.length < length) {\n      part = `0${part}`;\n    }\n\n    return part;\n  }\n\n  const ipaddr = {}; // An IPv4 address (RFC791).\n\n  ipaddr.IPv4 = function () {\n    // Constructs a new IPv4 address from an array of four octets\n    // in network order (MSB first)\n    // Verifies the input.\n    function IPv4(octets) {\n      if (octets.length !== 4) {\n        throw new Error('ipaddr: ipv4 octet count should be 4');\n      }\n\n      let i, octet;\n\n      for (i = 0; i < octets.length; i++) {\n        octet = octets[i];\n\n        if (!(0 <= octet && octet <= 255)) {\n          throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n        }\n      }\n\n      this.octets = octets;\n    } // Special IPv4 address ranges.\n    // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n\n\n    IPv4.prototype.SpecialRanges = {\n      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n      // RFC3171\n      multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n      // RFC3927\n      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n      // RFC5735\n      loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n      // RFC6598\n      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n      // RFC1918\n      'private': [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],\n      // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]\n    }; // The 'kind' method exists on both IPv4 and IPv6 classes.\n\n    IPv4.prototype.kind = function () {\n      return 'ipv4';\n    }; // Checks if this address matches other one within given CIDR range.\n\n\n    IPv4.prototype.match = function (other, cidrRange) {\n      let ref;\n\n      if (cidrRange === undefined) {\n        ref = other;\n        other = ref[0];\n        cidrRange = ref[1];\n      }\n\n      if (other.kind() !== 'ipv4') {\n        throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n      }\n\n      return matchCIDR(this.octets, other.octets, 8, cidrRange);\n    }; // returns a number of leading ones in IPv4 address, making sure that\n    // the rest is a solid sequence of 0's (valid netmask)\n    // returns either the CIDR length or null if mask is not valid\n\n\n    IPv4.prototype.prefixLengthFromSubnetMask = function () {\n      let cidr = 0; // non-zero encountered stop scanning for zeroes\n\n      let stop = false; // number of zeroes in octet\n\n      const zerotable = {\n        0: 8,\n        128: 7,\n        192: 6,\n        224: 5,\n        240: 4,\n        248: 3,\n        252: 2,\n        254: 1,\n        255: 0\n      };\n      let i, octet, zeros;\n\n      for (i = 3; i >= 0; i -= 1) {\n        octet = this.octets[i];\n\n        if (octet in zerotable) {\n          zeros = zerotable[octet];\n\n          if (stop && zeros !== 0) {\n            return null;\n          }\n\n          if (zeros !== 8) {\n            stop = true;\n          }\n\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n\n      return 32 - cidr;\n    }; // Checks if the address corresponds to one of the special ranges.\n\n\n    IPv4.prototype.range = function () {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    }; // Returns an array of byte-sized values in network order (MSB first)\n\n\n    IPv4.prototype.toByteArray = function () {\n      return this.octets.slice(0);\n    }; // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n\n\n    IPv4.prototype.toIPv4MappedAddress = function () {\n      return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n    }; // Symmetrical method strictly for aligning with the IPv6 methods.\n\n\n    IPv4.prototype.toNormalizedString = function () {\n      return this.toString();\n    }; // Returns the address in convenient, decimal-dotted format.\n\n\n    IPv4.prototype.toString = function () {\n      return this.octets.join('.');\n    };\n\n    return IPv4;\n  }(); // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n\n\n  ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n    try {\n      const cidr = this.parseCIDR(string);\n      const ipInterfaceOctets = cidr[0].toByteArray();\n      const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      const octets = [];\n      let i = 0;\n\n      while (i < 4) {\n        // Broadcast address is bitwise OR between ip interface and inverted mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n        i++;\n      }\n\n      return new this(octets);\n    } catch (e) {\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  }; // Checks if a given string is formatted like IPv4 address.\n\n\n  ipaddr.IPv4.isIPv4 = function (string) {\n    return this.parser(string) !== null;\n  }; // Checks if a given string is a valid IPv4 address.\n\n\n  ipaddr.IPv4.isValid = function (string) {\n    try {\n      new this(this.parser(string));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }; // Checks if a given string is a full four-part IPv4 Address.\n\n\n  ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n    if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n      return true;\n    } else {\n      return false;\n    }\n  }; // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n\n\n  ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n    let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n\n      while (i < 4) {\n        // Network address is bitwise AND between ip interface and mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n        i++;\n      }\n\n      return new this(octets);\n    } catch (e) {\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  }; // Tries to parse and validate a string with IPv4 address.\n  // Throws an error if it fails.\n\n\n  ipaddr.IPv4.parse = function (string) {\n    const parts = this.parser(string);\n\n    if (parts === null) {\n      throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n    }\n\n    return new this(parts);\n  }; // Parses the string as an IPv4 Address with CIDR Notation.\n\n\n  ipaddr.IPv4.parseCIDR = function (string) {\n    let match;\n\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      const maskLength = parseInt(match[2]);\n\n      if (maskLength >= 0 && maskLength <= 32) {\n        const parsed = [this.parse(match[1]), maskLength];\n        Object.defineProperty(parsed, 'toString', {\n          value: function () {\n            return this.join('/');\n          }\n        });\n        return parsed;\n      }\n    }\n\n    throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n  }; // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n  // value representing last three octets; this corresponds to a class C\n  // address) are omitted due to classless nature of modern Internet.\n\n\n  ipaddr.IPv4.parser = function (string) {\n    let match, part, value; // parseInt recognizes all that octal & hexadecimal weirdness for us\n\n    if (match = string.match(ipv4Regexes.fourOctet)) {\n      return function () {\n        const ref = match.slice(1, 6);\n        const results = [];\n\n        for (let i = 0; i < ref.length; i++) {\n          part = ref[i];\n          results.push(parseIntAuto(part));\n        }\n\n        return results;\n      }();\n    } else if (match = string.match(ipv4Regexes.longValue)) {\n      value = parseIntAuto(match[1]);\n\n      if (value > 0xffffffff || value < 0) {\n        throw new Error('ipaddr: address outside defined range');\n      }\n\n      return function () {\n        const results = [];\n        let shift;\n\n        for (shift = 0; shift <= 24; shift += 8) {\n          results.push(value >> shift & 0xff);\n        }\n\n        return results;\n      }().reverse();\n    } else if (match = string.match(ipv4Regexes.twoOctet)) {\n      return function () {\n        const ref = match.slice(1, 4);\n        const results = [];\n        value = parseIntAuto(ref[1]);\n\n        if (value > 0xffffff || value < 0) {\n          throw new Error('ipaddr: address outside defined range');\n        }\n\n        results.push(parseIntAuto(ref[0]));\n        results.push(value >> 16 & 0xff);\n        results.push(value >> 8 & 0xff);\n        results.push(value & 0xff);\n        return results;\n      }();\n    } else if (match = string.match(ipv4Regexes.threeOctet)) {\n      return function () {\n        const ref = match.slice(1, 5);\n        const results = [];\n        value = parseIntAuto(ref[2]);\n\n        if (value > 0xffff || value < 0) {\n          throw new Error('ipaddr: address outside defined range');\n        }\n\n        results.push(parseIntAuto(ref[0]));\n        results.push(parseIntAuto(ref[1]));\n        results.push(value >> 8 & 0xff);\n        results.push(value & 0xff);\n        return results;\n      }();\n    } else {\n      return null;\n    }\n  }; // A utility function to return subnet mask in IPv4 format given the prefix length\n\n\n  ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n    prefix = parseInt(prefix);\n\n    if (prefix < 0 || prefix > 32) {\n      throw new Error('ipaddr: invalid IPv4 prefix length');\n    }\n\n    const octets = [0, 0, 0, 0];\n    let j = 0;\n    const filledOctetCount = Math.floor(prefix / 8);\n\n    while (j < filledOctetCount) {\n      octets[j] = 255;\n      j++;\n    }\n\n    if (filledOctetCount < 4) {\n      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;\n    }\n\n    return new this(octets);\n  }; // An IPv6 address (RFC2460)\n\n\n  ipaddr.IPv6 = function () {\n    // Constructs an IPv6 address from an array of eight 16 - bit parts\n    // or sixteen 8 - bit parts in network order(MSB first).\n    // Throws an error if the input is invalid.\n    function IPv6(parts, zoneId) {\n      let i, part;\n\n      if (parts.length === 16) {\n        this.parts = [];\n\n        for (i = 0; i <= 14; i += 2) {\n          this.parts.push(parts[i] << 8 | parts[i + 1]);\n        }\n      } else if (parts.length === 8) {\n        this.parts = parts;\n      } else {\n        throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n      }\n\n      for (i = 0; i < this.parts.length; i++) {\n        part = this.parts[i];\n\n        if (!(0 <= part && part <= 0xffff)) {\n          throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n        }\n      }\n\n      if (zoneId) {\n        this.zoneId = zoneId;\n      }\n    } // Special IPv6 ranges\n\n\n    IPv6.prototype.SpecialRanges = {\n      // RFC4291, here and after\n      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n      // RFC6145\n      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n      // RFC6052\n      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n      // RFC3056\n      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n      // RFC6052, RFC6146\n      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n      // RFC4291\n      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]\n    }; // Checks if this address is an IPv4-mapped IPv6 address.\n\n    IPv6.prototype.isIPv4MappedAddress = function () {\n      return this.range() === 'ipv4Mapped';\n    }; // The 'kind' method exists on both IPv4 and IPv6 classes.\n\n\n    IPv6.prototype.kind = function () {\n      return 'ipv6';\n    }; // Checks if this address matches other one within given CIDR range.\n\n\n    IPv6.prototype.match = function (other, cidrRange) {\n      let ref;\n\n      if (cidrRange === undefined) {\n        ref = other;\n        other = ref[0];\n        cidrRange = ref[1];\n      }\n\n      if (other.kind() !== 'ipv6') {\n        throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n      }\n\n      return matchCIDR(this.parts, other.parts, 16, cidrRange);\n    }; // returns a number of leading ones in IPv6 address, making sure that\n    // the rest is a solid sequence of 0's (valid netmask)\n    // returns either the CIDR length or null if mask is not valid\n\n\n    IPv6.prototype.prefixLengthFromSubnetMask = function () {\n      let cidr = 0; // non-zero encountered stop scanning for zeroes\n\n      let stop = false; // number of zeroes in octet\n\n      const zerotable = {\n        0: 16,\n        32768: 15,\n        49152: 14,\n        57344: 13,\n        61440: 12,\n        63488: 11,\n        64512: 10,\n        65024: 9,\n        65280: 8,\n        65408: 7,\n        65472: 6,\n        65504: 5,\n        65520: 4,\n        65528: 3,\n        65532: 2,\n        65534: 1,\n        65535: 0\n      };\n      let part, zeros;\n\n      for (let i = 7; i >= 0; i -= 1) {\n        part = this.parts[i];\n\n        if (part in zerotable) {\n          zeros = zerotable[part];\n\n          if (stop && zeros !== 0) {\n            return null;\n          }\n\n          if (zeros !== 16) {\n            stop = true;\n          }\n\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n\n      return 128 - cidr;\n    }; // Checks if the address corresponds to one of the special ranges.\n\n\n    IPv6.prototype.range = function () {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    }; // Returns an array of byte-sized values in network order (MSB first)\n\n\n    IPv6.prototype.toByteArray = function () {\n      let part;\n      const bytes = [];\n      const ref = this.parts;\n\n      for (let i = 0; i < ref.length; i++) {\n        part = ref[i];\n        bytes.push(part >> 8);\n        bytes.push(part & 0xff);\n      }\n\n      return bytes;\n    }; // Returns the address in expanded format with all zeroes included, like\n    // 2001:0db8:0008:0066:0000:0000:0000:0001\n\n\n    IPv6.prototype.toFixedLengthString = function () {\n      const addr = function () {\n        const results = [];\n\n        for (let i = 0; i < this.parts.length; i++) {\n          results.push(padPart(this.parts[i].toString(16), 4));\n        }\n\n        return results;\n      }.call(this).join(':');\n\n      let suffix = '';\n\n      if (this.zoneId) {\n        suffix = `%${this.zoneId}`;\n      }\n\n      return addr + suffix;\n    }; // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n    // Throws an error otherwise.\n\n\n    IPv6.prototype.toIPv4Address = function () {\n      if (!this.isIPv4MappedAddress()) {\n        throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n      }\n\n      const ref = this.parts.slice(-2);\n      const high = ref[0];\n      const low = ref[1];\n      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n    }; // Returns the address in expanded format with all zeroes included, like\n    // 2001:db8:8:66:0:0:0:1\n    //\n    // Deprecated: use toFixedLengthString() instead.\n\n\n    IPv6.prototype.toNormalizedString = function () {\n      const addr = function () {\n        const results = [];\n\n        for (let i = 0; i < this.parts.length; i++) {\n          results.push(this.parts[i].toString(16));\n        }\n\n        return results;\n      }.call(this).join(':');\n\n      let suffix = '';\n\n      if (this.zoneId) {\n        suffix = `%${this.zoneId}`;\n      }\n\n      return addr + suffix;\n    }; // Returns the address in compact, human-readable format like\n    // 2001:db8:8:66::1\n    // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n\n\n    IPv6.prototype.toRFC5952String = function () {\n      const regex = /((^|:)(0(:|$)){2,})/g;\n      const string = this.toNormalizedString();\n      let bestMatchIndex = 0;\n      let bestMatchLength = -1;\n      let match;\n\n      while (match = regex.exec(string)) {\n        if (match[0].length > bestMatchLength) {\n          bestMatchIndex = match.index;\n          bestMatchLength = match[0].length;\n        }\n      }\n\n      if (bestMatchLength < 0) {\n        return string;\n      }\n\n      return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n    }; // Returns the address in compact, human-readable format like\n    // 2001:db8:8:66::1\n    //\n    // Deprecated: use toRFC5952String() instead.\n\n\n    IPv6.prototype.toString = function () {\n      // Replace the first sequence of 1 or more '0' parts with '::'\n      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');\n    };\n\n    return IPv6;\n  }(); // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n\n\n  ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n    try {\n      const cidr = this.parseCIDR(string);\n      const ipInterfaceOctets = cidr[0].toByteArray();\n      const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      const octets = [];\n      let i = 0;\n\n      while (i < 16) {\n        // Broadcast address is bitwise OR between ip interface and inverted mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n        i++;\n      }\n\n      return new this(octets);\n    } catch (e) {\n      throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n    }\n  }; // Checks if a given string is formatted like IPv6 address.\n\n\n  ipaddr.IPv6.isIPv6 = function (string) {\n    return this.parser(string) !== null;\n  }; // Checks to see if string is a valid IPv6 Address\n\n\n  ipaddr.IPv6.isValid = function (string) {\n    // Since IPv6.isValid is always called first, this shortcut\n    // provides a substantial performance gain.\n    if (typeof string === 'string' && string.indexOf(':') === -1) {\n      return false;\n    }\n\n    try {\n      const addr = this.parser(string);\n      new this(addr.parts, addr.zoneId);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }; // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n\n\n  ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n    let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n\n      while (i < 16) {\n        // Network address is bitwise AND between ip interface and mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n        i++;\n      }\n\n      return new this(octets);\n    } catch (e) {\n      throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n    }\n  }; // Tries to parse and validate a string with IPv6 address.\n  // Throws an error if it fails.\n\n\n  ipaddr.IPv6.parse = function (string) {\n    const addr = this.parser(string);\n\n    if (addr.parts === null) {\n      throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n    }\n\n    return new this(addr.parts, addr.zoneId);\n  };\n\n  ipaddr.IPv6.parseCIDR = function (string) {\n    let maskLength, match, parsed;\n\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      maskLength = parseInt(match[2]);\n\n      if (maskLength >= 0 && maskLength <= 128) {\n        parsed = [this.parse(match[1]), maskLength];\n        Object.defineProperty(parsed, 'toString', {\n          value: function () {\n            return this.join('/');\n          }\n        });\n        return parsed;\n      }\n    }\n\n    throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n  }; // Parse an IPv6 address.\n\n\n  ipaddr.IPv6.parser = function (string) {\n    let addr, i, match, octet, octets, zoneId;\n\n    if (match = string.match(ipv6Regexes.deprecatedTransitional)) {\n      return this.parser(`::ffff:${match[1]}`);\n    }\n\n    if (ipv6Regexes.native.test(string)) {\n      return expandIPv6(string, 8);\n    }\n\n    if (match = string.match(ipv6Regexes.transitional)) {\n      zoneId = match[6] || '';\n      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);\n\n      if (addr.parts) {\n        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];\n\n        for (i = 0; i < octets.length; i++) {\n          octet = octets[i];\n\n          if (!(0 <= octet && octet <= 255)) {\n            return null;\n          }\n        }\n\n        addr.parts.push(octets[0] << 8 | octets[1]);\n        addr.parts.push(octets[2] << 8 | octets[3]);\n        return {\n          parts: addr.parts,\n          zoneId: addr.zoneId\n        };\n      }\n    }\n\n    return null;\n  }; // A utility function to return subnet mask in IPv6 format given the prefix length\n\n\n  ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n    prefix = parseInt(prefix);\n\n    if (prefix < 0 || prefix > 128) {\n      throw new Error('ipaddr: invalid IPv6 prefix length');\n    }\n\n    const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    let j = 0;\n    const filledOctetCount = Math.floor(prefix / 8);\n\n    while (j < filledOctetCount) {\n      octets[j] = 255;\n      j++;\n    }\n\n    if (filledOctetCount < 16) {\n      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;\n    }\n\n    return new this(octets);\n  }; // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n\n\n  ipaddr.fromByteArray = function (bytes) {\n    const length = bytes.length;\n\n    if (length === 4) {\n      return new ipaddr.IPv4(bytes);\n    } else if (length === 16) {\n      return new ipaddr.IPv6(bytes);\n    } else {\n      throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n    }\n  }; // Checks if the address is valid IP address\n\n\n  ipaddr.isValid = function (string) {\n    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n  }; // Attempts to parse an IP Address, first through IPv6 then IPv4.\n  // Throws an error if it could not be parsed.\n\n\n  ipaddr.parse = function (string) {\n    if (ipaddr.IPv6.isValid(string)) {\n      return ipaddr.IPv6.parse(string);\n    } else if (ipaddr.IPv4.isValid(string)) {\n      return ipaddr.IPv4.parse(string);\n    } else {\n      throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n    }\n  }; // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n  // Throws an error if it could not be parsed.\n\n\n  ipaddr.parseCIDR = function (string) {\n    try {\n      return ipaddr.IPv6.parseCIDR(string);\n    } catch (e) {\n      try {\n        return ipaddr.IPv4.parseCIDR(string);\n      } catch (e2) {\n        throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n      }\n    }\n  }; // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n\n\n  ipaddr.process = function (string) {\n    const addr = this.parse(string);\n\n    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n      return addr.toIPv4Address();\n    } else {\n      return addr;\n    }\n  }; // An utility function to ease named range matching. See examples below.\n  // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n  // on matching IPv4 addresses to IPv6 ranges or vice versa.\n\n\n  ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n    let i, rangeName, rangeSubnets, subnet;\n\n    if (defaultName === undefined || defaultName === null) {\n      defaultName = 'unicast';\n    }\n\n    for (rangeName in rangeList) {\n      if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n        rangeSubnets = rangeList[rangeName]; // ECMA5 Array.isArray isn't available everywhere\n\n        if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n          rangeSubnets = [rangeSubnets];\n        }\n\n        for (i = 0; i < rangeSubnets.length; i++) {\n          subnet = rangeSubnets[i];\n\n          if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n            return rangeName;\n          }\n        }\n      }\n    }\n\n    return defaultName;\n  }; // Export for both the CommonJS and browser-like environment\n\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = ipaddr;\n  } else {\n    root.ipaddr = ipaddr;\n  }\n})(this);","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipaddr.js/lib/ipaddr.js"],"names":["root","ipv4Part","ipv4Regexes","fourOctet","RegExp","threeOctet","twoOctet","longValue","octalRegex","hexRegex","zoneIndex","ipv6Part","ipv6Regexes","deprecatedTransitional","transitional","expandIPv6","string","parts","indexOf","lastIndexOf","colonCount","lastColon","zoneId","match","replacement","replacementCount","substring","replace","substr","slice","length","ref","split","results","i","push","parseInt","matchCIDR","first","second","partSize","cidrBits","Error","part","shift","parseIntAuto","test","isNaN","padPart","ipaddr","IPv4","octets","octet","prototype","SpecialRanges","unspecified","broadcast","multicast","linkLocal","loopback","carrierGradeNat","reserved","kind","other","cidrRange","undefined","prefixLengthFromSubnetMask","cidr","stop","zerotable","zeros","range","subnetMatch","toByteArray","toIPv4MappedAddress","IPv6","parse","toString","toNormalizedString","join","broadcastAddressFromCIDR","parseCIDR","ipInterfaceOctets","subnetMaskOctets","subnetMaskFromPrefixLength","e","isIPv4","parser","isValid","isValidFourPartDecimal","networkAddressFromCIDR","maskLength","parsed","Object","defineProperty","value","reverse","prefix","j","filledOctetCount","Math","floor","pow","uniqueLocal","ipv4Mapped","rfc6145","rfc6052","teredo","isIPv4MappedAddress","bytes","toFixedLengthString","addr","call","suffix","toIPv4Address","high","low","toRFC5952String","regex","bestMatchIndex","bestMatchLength","exec","index","isIPv6","native","fromByteArray","e2","process","address","rangeList","defaultName","rangeName","rangeSubnets","subnet","hasOwnProperty","Array","apply","module","exports"],"mappings":"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","sourcesContent":["(function (root) {\n    'use strict';\n    // A list of regular expressions that match arbitrary IPv4 addresses,\n    // for which a number of weird notations exist.\n    // Note that an address like 0010.0xa5.1.1 is considered legal.\n    const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n    const ipv4Regexes = {\n        fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        longValue: new RegExp(`^${ipv4Part}$`, 'i')\n    };\n\n    // Regular Expression for checking Octal numbers\n    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n\n    const zoneIndex = '%[0-9a-z]{1,}';\n\n    // IPv6-matching regular expressions.\n    // For IPv6, the task is simpler: it is enough to match the colon-delimited\n    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n    // the end.\n    const ipv6Part = '(?:[0-9a-f]+::?)+';\n    const ipv6Regexes = {\n        zoneIndex: new RegExp(zoneIndex, 'i'),\n        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n    };\n\n    // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n    function expandIPv6 (string, parts) {\n        // More than one '::' means invalid adddress\n        if (string.indexOf('::') !== string.lastIndexOf('::')) {\n            return null;\n        }\n\n        let colonCount = 0;\n        let lastColon = -1;\n        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n        let replacement, replacementCount;\n\n        // Remove zone index and save it for later\n        if (zoneId) {\n            zoneId = zoneId.substring(1);\n            string = string.replace(/%.+$/, '');\n        }\n\n        // How many parts do we already have?\n        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n            colonCount++;\n        }\n\n        // 0::0 is two parts more than ::\n        if (string.substr(0, 2) === '::') {\n            colonCount--;\n        }\n\n        if (string.substr(-2, 2) === '::') {\n            colonCount--;\n        }\n\n        // The following loop would hang if colonCount > parts\n        if (colonCount > parts) {\n            return null;\n        }\n\n        // replacement = ':' + '0:' * (parts - colonCount)\n        replacementCount = parts - colonCount;\n        replacement = ':';\n        while (replacementCount--) {\n            replacement += '0:';\n        }\n\n        // Insert the missing zeroes\n        string = string.replace('::', replacement);\n\n        // Trim any garbage which may be hanging around if :: was at the edge in\n        // the source strin\n        if (string[0] === ':') {\n            string = string.slice(1);\n        }\n\n        if (string[string.length - 1] === ':') {\n            string = string.slice(0, -1);\n        }\n\n        parts = (function () {\n            const ref = string.split(':');\n            const results = [];\n\n            for (let i = 0; i < ref.length; i++) {\n                results.push(parseInt(ref[i], 16));\n            }\n\n            return results;\n        })();\n\n        return {\n            parts: parts,\n            zoneId: zoneId\n        };\n    }\n\n    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n    function matchCIDR (first, second, partSize, cidrBits) {\n        if (first.length !== second.length) {\n            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n        }\n\n        let part = 0;\n        let shift;\n\n        while (cidrBits > 0) {\n            shift = partSize - cidrBits;\n            if (shift < 0) {\n                shift = 0;\n            }\n\n            if (first[part] >> shift !== second[part] >> shift) {\n                return false;\n            }\n\n            cidrBits -= partSize;\n            part += 1;\n        }\n\n        return true;\n    }\n\n    function parseIntAuto (string) {\n        // Hexadedimal base 16 (0x#)\n        if (hexRegex.test(string)) {\n            return parseInt(string, 16);\n        }\n        // While octal representation is discouraged by ECMAScript 3\n        // and forbidden by ECMAScript 5, we silently allow it to\n        // work only if the rest of the string has numbers less than 8.\n        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n        if (octalRegex.test(string)) {\n            return parseInt(string, 8);\n        }\n            throw new Error(`ipaddr: cannot parse ${string} as octal`);\n        }\n        // Always include the base 10 radix!\n        return parseInt(string, 10);\n    }\n\n    function padPart (part, length) {\n        while (part.length < length) {\n            part = `0${part}`;\n        }\n\n        return part;\n    }\n\n    const ipaddr = {};\n\n    // An IPv4 address (RFC791).\n    ipaddr.IPv4 = (function () {\n        // Constructs a new IPv4 address from an array of four octets\n        // in network order (MSB first)\n        // Verifies the input.\n        function IPv4 (octets) {\n            if (octets.length !== 4) {\n                throw new Error('ipaddr: ipv4 octet count should be 4');\n            }\n\n            let i, octet;\n\n            for (i = 0; i < octets.length; i++) {\n                octet = octets[i];\n                if (!((0 <= octet && octet <= 255))) {\n                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n                }\n            }\n\n            this.octets = octets;\n        }\n\n        // Special IPv4 address ranges.\n        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n        IPv4.prototype.SpecialRanges = {\n            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n            // RFC3171\n            multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n            // RFC3927\n            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n            // RFC5735\n            loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n            // RFC6598\n            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n            // RFC1918\n            'private': [\n                [new IPv4([10, 0, 0, 0]), 8],\n                [new IPv4([172, 16, 0, 0]), 12],\n                [new IPv4([192, 168, 0, 0]), 16]\n            ],\n            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n            reserved: [\n                [new IPv4([192, 0, 0, 0]), 24],\n                [new IPv4([192, 0, 2, 0]), 24],\n                [new IPv4([192, 88, 99, 0]), 24],\n                [new IPv4([198, 51, 100, 0]), 24],\n                [new IPv4([203, 0, 113, 0]), 24],\n                [new IPv4([240, 0, 0, 0]), 4]\n            ]\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv4.prototype.kind = function () {\n            return 'ipv4';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv4.prototype.match = function (other, cidrRange) {\n            let ref;\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv4') {\n                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n            }\n\n            return matchCIDR(this.octets, other.octets, 8, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv4 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv4.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 8,\n                128: 7,\n                192: 6,\n                224: 5,\n                240: 4,\n                248: 3,\n                252: 2,\n                254: 1,\n                255: 0\n            };\n            let i, octet, zeros;\n\n            for (i = 3; i >= 0; i -= 1) {\n                octet = this.octets[i];\n                if (octet in zerotable) {\n                    zeros = zerotable[octet];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 8) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 32 - cidr;\n        };\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv4.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv4.prototype.toByteArray = function () {\n            return this.octets.slice(0);\n        };\n\n        // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n        IPv4.prototype.toIPv4MappedAddress = function () {\n            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n        };\n\n        // Symmetrical method strictly for aligning with the IPv6 methods.\n        IPv4.prototype.toNormalizedString = function () {\n            return this.toString();\n        };\n\n        // Returns the address in convenient, decimal-dotted format.\n        IPv4.prototype.toString = function () {\n            return this.octets.join('.');\n        };\n\n        return IPv4;\n    })();\n\n    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 4) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Checks if a given string is formatted like IPv4 address.\n    ipaddr.IPv4.isIPv4 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks if a given string is a valid IPv4 address.\n    ipaddr.IPv4.isValid = function (string) {\n        try {\n            new this(this.parser(string));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address.\n    ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 4) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Tries to parse and validate a string with IPv4 address.\n    // Throws an error if it fails.\n    ipaddr.IPv4.parse = function (string) {\n        const parts = this.parser(string);\n\n        if (parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n        }\n\n        return new this(parts);\n    };\n\n    // Parses the string as an IPv4 Address with CIDR Notation.\n    ipaddr.IPv4.parseCIDR = function (string) {\n        let match;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            const maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 32) {\n                const parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n    };\n\n    // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n    // value representing last three octets; this corresponds to a class C\n    // address) are omitted due to classless nature of modern Internet.\n    ipaddr.IPv4.parser = function (string) {\n        let match, part, value;\n\n        // parseInt recognizes all that octal & hexadecimal weirdness for us\n        if ((match = string.match(ipv4Regexes.fourOctet))) {\n            return (function () {\n                const ref = match.slice(1, 6);\n                const results = [];\n\n                for (let i = 0; i < ref.length; i++) {\n                    part = ref[i];\n                    results.push(parseIntAuto(part));\n                }\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.longValue))) {\n            value = parseIntAuto(match[1]);\n            if (value > 0xffffffff || value < 0) {\n                throw new Error('ipaddr: address outside defined range');\n            }\n\n            return ((function () {\n                const results = [];\n                let shift;\n\n                for (shift = 0; shift <= 24; shift += 8) {\n                    results.push((value >> shift) & 0xff);\n                }\n\n                return results;\n            })()).reverse();\n        } else if ((match = string.match(ipv4Regexes.twoOctet))) {\n            return (function () {\n                const ref = match.slice(1, 4);\n                const results = [];\n\n                value = parseIntAuto(ref[1]);\n                if (value > 0xffffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push((value >> 16) & 0xff);\n                results.push((value >>  8) & 0xff);\n                results.push( value        & 0xff);\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.threeOctet))) {\n            return (function () {\n                const ref = match.slice(1, 5);\n                const results = [];\n\n                value = parseIntAuto(ref[2]);\n                if (value > 0xffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push(parseIntAuto(ref[1]));\n                results.push((value >> 8) & 0xff);\n                results.push( value       & 0xff);\n\n                return results;\n            })();\n        } else {\n            return null;\n        }\n    };\n\n    // A utility function to return subnet mask in IPv4 format given the prefix length\n    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 32) {\n            throw new Error('ipaddr: invalid IPv4 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 4) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // An IPv6 address (RFC2460)\n    ipaddr.IPv6 = (function () {\n        // Constructs an IPv6 address from an array of eight 16 - bit parts\n        // or sixteen 8 - bit parts in network order(MSB first).\n        // Throws an error if the input is invalid.\n        function IPv6 (parts, zoneId) {\n            let i, part;\n\n            if (parts.length === 16) {\n                this.parts = [];\n                for (i = 0; i <= 14; i += 2) {\n                    this.parts.push((parts[i] << 8) | parts[i + 1]);\n                }\n            } else if (parts.length === 8) {\n                this.parts = parts;\n            } else {\n                throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n            }\n\n            for (i = 0; i < this.parts.length; i++) {\n                part = this.parts[i];\n                if (!((0 <= part && part <= 0xffff))) {\n                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n                }\n            }\n\n            if (zoneId) {\n                this.zoneId = zoneId;\n            }\n        }\n\n        // Special IPv6 ranges\n        IPv6.prototype.SpecialRanges = {\n            // RFC4291, here and after\n            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n            // RFC6145\n            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n            // RFC6052\n            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n            // RFC3056\n            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n            // RFC6052, RFC6146\n            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n            // RFC4291\n            reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]\n        };\n\n        // Checks if this address is an IPv4-mapped IPv6 address.\n        IPv6.prototype.isIPv4MappedAddress = function () {\n            return this.range() === 'ipv4Mapped';\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv6.prototype.kind = function () {\n            return 'ipv6';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv6.prototype.match = function (other, cidrRange) {\n            let ref;\n\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv6') {\n                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n            }\n\n            return matchCIDR(this.parts, other.parts, 16, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv6 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv6.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 16,\n                32768: 15,\n                49152: 14,\n                57344: 13,\n                61440: 12,\n                63488: 11,\n                64512: 10,\n                65024: 9,\n                65280: 8,\n                65408: 7,\n                65472: 6,\n                65504: 5,\n                65520: 4,\n                65528: 3,\n                65532: 2,\n                65534: 1,\n                65535: 0\n            };\n            let part, zeros;\n\n            for (let i = 7; i >= 0; i -= 1) {\n                part = this.parts[i];\n                if (part in zerotable) {\n                    zeros = zerotable[part];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 16) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 128 - cidr;\n        };\n\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv6.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv6.prototype.toByteArray = function () {\n            let part;\n            const bytes = [];\n            const ref = this.parts;\n            for (let i = 0; i < ref.length; i++) {\n                part = ref[i];\n                bytes.push(part >> 8);\n                bytes.push(part & 0xff);\n            }\n\n            return bytes;\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:0db8:0008:0066:0000:0000:0000:0001\n        IPv6.prototype.toFixedLengthString = function () {\n            const addr = ((function () {\n                const results = [];\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(padPart(this.parts[i].toString(16), 4));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n        // Throws an error otherwise.\n        IPv6.prototype.toIPv4Address = function () {\n            if (!this.isIPv4MappedAddress()) {\n                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n            }\n\n            const ref = this.parts.slice(-2);\n            const high = ref[0];\n            const low = ref[1];\n\n            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:db8:8:66:0:0:0:1\n        //\n        // Deprecated: use toFixedLengthString() instead.\n        IPv6.prototype.toNormalizedString = function () {\n            const addr = ((function () {\n                const results = [];\n\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(this.parts[i].toString(16));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n        IPv6.prototype.toRFC5952String = function () {\n            const regex = /((^|:)(0(:|$)){2,})/g;\n            const string = this.toNormalizedString();\n            let bestMatchIndex = 0;\n            let bestMatchLength = -1;\n            let match;\n\n            while ((match = regex.exec(string))) {\n                if (match[0].length > bestMatchLength) {\n                    bestMatchIndex = match.index;\n                    bestMatchLength = match[0].length;\n                }\n            }\n\n            if (bestMatchLength < 0) {\n                return string;\n            }\n\n            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        //\n        // Deprecated: use toRFC5952String() instead.\n        IPv6.prototype.toString = function () {\n            // Replace the first sequence of 1 or more '0' parts with '::'\n            return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');\n        };\n\n        return IPv6;\n\n    })();\n\n    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 16) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Checks if a given string is formatted like IPv6 address.\n    ipaddr.IPv6.isIPv6 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks to see if string is a valid IPv6 Address\n    ipaddr.IPv6.isValid = function (string) {\n\n        // Since IPv6.isValid is always called first, this shortcut\n        // provides a substantial performance gain.\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            const addr = this.parser(string);\n            new this(addr.parts, addr.zoneId);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 16) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Tries to parse and validate a string with IPv6 address.\n    // Throws an error if it fails.\n    ipaddr.IPv6.parse = function (string) {\n        const addr = this.parser(string);\n\n        if (addr.parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n        }\n\n        return new this(addr.parts, addr.zoneId);\n    };\n\n    ipaddr.IPv6.parseCIDR = function (string) {\n        let maskLength, match, parsed;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 128) {\n                parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n    };\n\n    // Parse an IPv6 address.\n    ipaddr.IPv6.parser = function (string) {\n        let addr, i, match, octet, octets, zoneId;\n\n        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {\n            return this.parser(`::ffff:${match[1]}`);\n        }\n        if (ipv6Regexes.native.test(string)) {\n            return expandIPv6(string, 8);\n        }\n        if ((match = string.match(ipv6Regexes.transitional))) {\n            zoneId = match[6] || '';\n            addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);\n            if (addr.parts) {\n                octets = [\n                    parseInt(match[2]),\n                    parseInt(match[3]),\n                    parseInt(match[4]),\n                    parseInt(match[5])\n                ];\n                for (i = 0; i < octets.length; i++) {\n                    octet = octets[i];\n                    if (!((0 <= octet && octet <= 255))) {\n                        return null;\n                    }\n                }\n\n                addr.parts.push(octets[0] << 8 | octets[1]);\n                addr.parts.push(octets[2] << 8 | octets[3]);\n                return {\n                    parts: addr.parts,\n                    zoneId: addr.zoneId\n                };\n            }\n        }\n\n        return null;\n    };\n\n    // A utility function to return subnet mask in IPv6 format given the prefix length\n    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 128) {\n            throw new Error('ipaddr: invalid IPv6 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 16) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n    ipaddr.fromByteArray = function (bytes) {\n        const length = bytes.length;\n\n        if (length === 4) {\n            return new ipaddr.IPv4(bytes);\n        } else if (length === 16) {\n            return new ipaddr.IPv6(bytes);\n        } else {\n            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n        }\n    };\n\n    // Checks if the address is valid IP address\n    ipaddr.isValid = function (string) {\n        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n    };\n\n\n    // Attempts to parse an IP Address, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parse = function (string) {\n        if (ipaddr.IPv6.isValid(string)) {\n            return ipaddr.IPv6.parse(string);\n        } else if (ipaddr.IPv4.isValid(string)) {\n            return ipaddr.IPv4.parse(string);\n        } else {\n            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n        }\n    };\n\n    // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parseCIDR = function (string) {\n        try {\n            return ipaddr.IPv6.parseCIDR(string);\n        } catch (e) {\n            try {\n                return ipaddr.IPv4.parseCIDR(string);\n            } catch (e2) {\n                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n            }\n        }\n    };\n\n    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n    ipaddr.process = function (string) {\n        const addr = this.parse(string);\n\n        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n            return addr.toIPv4Address();\n        } else {\n            return addr;\n        }\n    };\n\n    // An utility function to ease named range matching. See examples below.\n    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n    // on matching IPv4 addresses to IPv6 ranges or vice versa.\n    ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n        let i, rangeName, rangeSubnets, subnet;\n\n        if (defaultName === undefined || defaultName === null) {\n            defaultName = 'unicast';\n        }\n\n        for (rangeName in rangeList) {\n            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n                rangeSubnets = rangeList[rangeName];\n                // ECMA5 Array.isArray isn't available everywhere\n                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n                    rangeSubnets = [rangeSubnets];\n                }\n\n                for (i = 0; i < rangeSubnets.length; i++) {\n                    subnet = rangeSubnets[i];\n                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n                        return rangeName;\n                    }\n                }\n            }\n        }\n\n        return defaultName;\n    };\n\n    // Export for both the CommonJS and browser-like environment\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = ipaddr;\n\n    } else {\n        root.ipaddr = ipaddr;\n    }\n\n}(this));\n"]},"metadata":{},"sourceType":"script"}