{"ast":null,"code":"/* eslint-disable import/export */\n\n/* eslint-disable complexity */\n\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Peer;\n\n(function (Peer) {\n  let _codec;\n\n  Peer.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(10);\n            Address.codec().encode(value, w);\n          }\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(18);\n            w.string(value);\n          }\n        }\n\n        if (obj.metadata != null) {\n          for (const value of obj.metadata) {\n            w.uint32(26);\n            Metadata.codec().encode(value, w);\n          }\n        }\n\n        if (obj.pubKey != null) {\n          w.uint32(34);\n          w.bytes(obj.pubKey);\n        }\n\n        if (obj.peerRecordEnvelope != null) {\n          w.uint32(42);\n          w.bytes(obj.peerRecordEnvelope);\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {\n          addresses: [],\n          protocols: [],\n          metadata: []\n        };\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.addresses.push(Address.codec().decode(reader, reader.uint32()));\n              break;\n\n            case 2:\n              obj.protocols.push(reader.string());\n              break;\n\n            case 3:\n              obj.metadata.push(Metadata.codec().decode(reader, reader.uint32()));\n              break;\n\n            case 4:\n              obj.pubKey = reader.bytes();\n              break;\n\n            case 5:\n              obj.peerRecordEnvelope = reader.bytes();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  Peer.encode = obj => {\n    return encodeMessage(obj, Peer.codec());\n  };\n\n  Peer.decode = buf => {\n    return decodeMessage(buf, Peer.codec());\n  };\n})(Peer || (Peer = {}));\n\nexport var Address;\n\n(function (Address) {\n  let _codec;\n\n  Address.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {\n          w.uint32(10);\n          w.bytes(obj.multiaddr);\n        }\n\n        if (obj.isCertified != null) {\n          w.uint32(16);\n          w.bool(obj.isCertified);\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {\n          multiaddr: new Uint8Array(0)\n        };\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.multiaddr = reader.bytes();\n              break;\n\n            case 2:\n              obj.isCertified = reader.bool();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  Address.encode = obj => {\n    return encodeMessage(obj, Address.codec());\n  };\n\n  Address.decode = buf => {\n    return decodeMessage(buf, Address.codec());\n  };\n})(Address || (Address = {}));\n\nexport var Metadata;\n\n(function (Metadata) {\n  let _codec;\n\n  Metadata.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.key != null && obj.key !== '') {\n          w.uint32(10);\n          w.string(obj.key);\n        }\n\n        if (obj.value != null && obj.value.byteLength > 0) {\n          w.uint32(18);\n          w.bytes(obj.value);\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {\n          key: '',\n          value: new Uint8Array(0)\n        };\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.key = reader.string();\n              break;\n\n            case 2:\n              obj.value = reader.bytes();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  Metadata.encode = obj => {\n    return encodeMessage(obj, Metadata.codec());\n  };\n\n  Metadata.decode = buf => {\n    return decodeMessage(buf, Metadata.codec());\n  };\n})(Metadata || (Metadata = {}));","map":{"version":3,"mappings":"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","names":["encodeMessage","decodeMessage","message","Peer","_codec","obj","w","opts","lengthDelimited","fork","addresses","value","uint32","Address","codec","encode","protocols","string","metadata","Metadata","pubKey","bytes","peerRecordEnvelope","ldelim","reader","length","end","len","pos","tag","push","decode","skipType","buf","multiaddr","byteLength","isCertified","bool","Uint8Array","key"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\peer-store\\src\\pb\\peer.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Peer {\n  addresses: Address[]\n  protocols: string[]\n  metadata: Metadata[]\n  pubKey?: Uint8Array\n  peerRecordEnvelope?: Uint8Array\n}\n\nexport namespace Peer {\n  let _codec: Codec<Peer>\n\n  export const codec = (): Codec<Peer> => {\n    if (_codec == null) {\n      _codec = message<Peer>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(10)\n            Address.codec().encode(value, w)\n          }\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(18)\n            w.string(value)\n          }\n        }\n\n        if (obj.metadata != null) {\n          for (const value of obj.metadata) {\n            w.uint32(26)\n            Metadata.codec().encode(value, w)\n          }\n        }\n\n        if (obj.pubKey != null) {\n          w.uint32(34)\n          w.bytes(obj.pubKey)\n        }\n\n        if (obj.peerRecordEnvelope != null) {\n          w.uint32(42)\n          w.bytes(obj.peerRecordEnvelope)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          addresses: [],\n          protocols: [],\n          metadata: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.addresses.push(Address.codec().decode(reader, reader.uint32()))\n              break\n            case 2:\n              obj.protocols.push(reader.string())\n              break\n            case 3:\n              obj.metadata.push(Metadata.codec().decode(reader, reader.uint32()))\n              break\n            case 4:\n              obj.pubKey = reader.bytes()\n              break\n            case 5:\n              obj.peerRecordEnvelope = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Peer>): Uint8Array => {\n    return encodeMessage(obj, Peer.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Peer => {\n    return decodeMessage(buf, Peer.codec())\n  }\n}\n\nexport interface Address {\n  multiaddr: Uint8Array\n  isCertified?: boolean\n}\n\nexport namespace Address {\n  let _codec: Codec<Address>\n\n  export const codec = (): Codec<Address> => {\n    if (_codec == null) {\n      _codec = message<Address>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.multiaddr)\n        }\n\n        if (obj.isCertified != null) {\n          w.uint32(16)\n          w.bool(obj.isCertified)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          multiaddr: new Uint8Array(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.multiaddr = reader.bytes()\n              break\n            case 2:\n              obj.isCertified = reader.bool()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Address>): Uint8Array => {\n    return encodeMessage(obj, Address.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Address => {\n    return decodeMessage(buf, Address.codec())\n  }\n}\n\nexport interface Metadata {\n  key: string\n  value: Uint8Array\n}\n\nexport namespace Metadata {\n  let _codec: Codec<Metadata>\n\n  export const codec = (): Codec<Metadata> => {\n    if (_codec == null) {\n      _codec = message<Metadata>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.key != null && obj.key !== '')) {\n          w.uint32(10)\n          w.string(obj.key)\n        }\n\n        if ((obj.value != null && obj.value.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.value)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          key: '',\n          value: new Uint8Array(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.key = reader.string()\n              break\n            case 2:\n              obj.value = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Metadata>): Uint8Array => {\n    return encodeMessage(obj, Metadata.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Metadata => {\n    return decodeMessage(buf, Metadata.codec())\n  }\n}\n"]},"metadata":{},"sourceType":"module"}