{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { codes } from '../errors.js';\nimport * as lp from 'it-length-prefixed';\nimport { FetchRequest, FetchResponse } from './pb/proto.js';\nimport { PROTOCOL_NAME, PROTOCOL_VERSION } from './constants.js';\nimport { abortableDuplex } from 'abortable-iterator';\nimport { pipe } from 'it-pipe';\nimport first from 'it-first';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { setMaxListeners } from 'events';\nimport { fromString as uint8arrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8arrayToString } from 'uint8arrays/to-string';\nconst log = logger('libp2p:fetch');\n/**\n * A simple libp2p protocol for requesting a value corresponding to a key from a peer.\n * Developers can register one or more lookup function for retrieving the value corresponding to\n * a given key.  Each lookup function must act on a distinct part of the overall key space, defined\n * by a fixed prefix that all keys that should be routed to that lookup function will start with.\n */\n\nexport class FetchService {\n  constructor(components, init) {\n    this.started = false;\n    this.components = components;\n    this.protocol = `/${init.protocolPrefix ?? 'libp2p'}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;\n    this.lookupFunctions = new Map(); // Maps key prefix to value lookup function\n\n    this.handleMessage = this.handleMessage.bind(this);\n    this.init = init;\n  }\n\n  async start() {\n    await this.components.registrar.handle(this.protocol, data => {\n      void this.handleMessage(data).catch(err => {\n        log.error(err);\n      }).finally(() => {\n        data.stream.close();\n      });\n    }, {\n      maxInboundStreams: this.init.maxInboundStreams,\n      maxOutboundStreams: this.init.maxOutboundStreams\n    });\n    this.started = true;\n  }\n\n  async stop() {\n    await this.components.registrar.unhandle(this.protocol);\n    this.started = false;\n  }\n\n  isStarted() {\n    return this.started;\n  }\n  /**\n   * Sends a request to fetch the value associated with the given key from the given peer\n   */\n\n\n  async fetch(peer, key) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    log('dialing %s to %p', this.protocol, peer);\n    const connection = await this.components.connectionManager.openConnection(peer, options);\n    let timeoutController;\n    let signal = options.signal;\n    let stream; // create a timeout if no abort signal passed\n\n    if (signal == null) {\n      log('using default timeout of %d ms', this.init.timeout);\n      timeoutController = new TimeoutController(this.init.timeout);\n      signal = timeoutController.signal;\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal);\n      } catch {}\n    }\n\n    try {\n      stream = await connection.newStream(this.protocol, {\n        signal\n      }); // make stream abortable\n\n      const source = abortableDuplex(stream, signal);\n      log('fetch %s', key);\n      const result = await pipe([FetchRequest.encode({\n        identifier: key\n      })], lp.encode(), source, lp.decode(), async function (source) {\n        const buf = await first(source);\n\n        if (buf == null) {\n          throw errCode(new Error('No data received'), codes.ERR_INVALID_MESSAGE);\n        }\n\n        const response = FetchResponse.decode(buf);\n\n        switch (response.status) {\n          case FetchResponse.StatusCode.OK:\n            {\n              log('received status for %s ok', key);\n              return response.data;\n            }\n\n          case FetchResponse.StatusCode.NOT_FOUND:\n            {\n              log('received status for %s not found', key);\n              return null;\n            }\n\n          case FetchResponse.StatusCode.ERROR:\n            {\n              log('received status for %s error', key);\n              const errmsg = uint8arrayToString(response.data);\n              throw errCode(new Error('Error in fetch protocol response: ' + errmsg), codes.ERR_INVALID_PARAMETERS);\n            }\n\n          default:\n            {\n              log('received status for %s unknown', key);\n              throw errCode(new Error('Unknown response status'), codes.ERR_INVALID_MESSAGE);\n            }\n        }\n      });\n      return result ?? null;\n    } finally {\n      if (timeoutController != null) {\n        timeoutController.clear();\n      }\n\n      if (stream != null) {\n        stream.close();\n      }\n    }\n  }\n  /**\n   * Invoked when a fetch request is received.  Reads the request message off the given stream and\n   * responds based on looking up the key in the request via the lookup callback that corresponds\n   * to the key's prefix.\n   */\n\n\n  async handleMessage(data) {\n    const {\n      stream\n    } = data;\n    const self = this;\n    await pipe(stream, lp.decode(), async function* (source) {\n      const buf = await first(source);\n\n      if (buf == null) {\n        throw errCode(new Error('No data received'), codes.ERR_INVALID_MESSAGE);\n      } // for await (const buf of source) {\n\n\n      const request = FetchRequest.decode(buf);\n      let response;\n\n      const lookup = self._getLookupFunction(request.identifier);\n\n      if (lookup != null) {\n        log('look up data with identifier %s', request.identifier);\n        const data = await lookup(request.identifier);\n\n        if (data != null) {\n          log('sending status for %s ok', request.identifier);\n          response = {\n            status: FetchResponse.StatusCode.OK,\n            data\n          };\n        } else {\n          log('sending status for %s not found', request.identifier);\n          response = {\n            status: FetchResponse.StatusCode.NOT_FOUND,\n            data: new Uint8Array(0)\n          };\n        }\n      } else {\n        log('sending status for %s error', request.identifier);\n        const errmsg = uint8arrayFromString(`No lookup function registered for key: ${request.identifier}`);\n        response = {\n          status: FetchResponse.StatusCode.ERROR,\n          data: errmsg\n        };\n      }\n\n      yield FetchResponse.encode(response);\n    }, lp.encode(), stream);\n  }\n  /**\n   * Given a key, finds the appropriate function for looking up its corresponding value, based on\n   * the key's prefix.\n   */\n\n\n  _getLookupFunction(key) {\n    for (const prefix of this.lookupFunctions.keys()) {\n      if (key.startsWith(prefix)) {\n        return this.lookupFunctions.get(prefix);\n      }\n    }\n  }\n  /**\n   * Registers a new lookup callback that can map keys to values, for a given set of keys that\n   * share the same prefix\n   *\n   * @example\n   *\n   * ```js\n   * // ...\n   * libp2p.fetchService.registerLookupFunction('/prefix', (key) => { ... })\n   * ```\n   */\n\n\n  registerLookupFunction(prefix, lookup) {\n    if (this.lookupFunctions.has(prefix)) {\n      throw errCode(new Error(\"Fetch protocol handler for key prefix '\" + prefix + \"' already registered\"), codes.ERR_KEY_ALREADY_EXISTS);\n    }\n\n    this.lookupFunctions.set(prefix, lookup);\n  }\n  /**\n   * Registers a new lookup callback that can map keys to values, for a given set of keys that\n   * share the same prefix.\n   *\n   * @example\n   *\n   * ```js\n   * // ...\n   * libp2p.fetchService.unregisterLookupFunction('/prefix')\n   * ```\n   */\n\n\n  unregisterLookupFunction(prefix, lookup) {\n    if (lookup != null) {\n      const existingLookup = this.lookupFunctions.get(prefix);\n\n      if (existingLookup !== lookup) {\n        return;\n      }\n    }\n\n    this.lookupFunctions.delete(prefix);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","errCode","codes","lp","FetchRequest","FetchResponse","PROTOCOL_NAME","PROTOCOL_VERSION","abortableDuplex","pipe","first","TimeoutController","setMaxListeners","fromString","uint8arrayFromString","toString","uint8arrayToString","log","FetchService","constructor","components","init","started","protocol","protocolPrefix","lookupFunctions","Map","handleMessage","bind","start","registrar","handle","data","catch","err","error","finally","stream","close","maxInboundStreams","maxOutboundStreams","stop","unhandle","isStarted","fetch","peer","key","options","connection","connectionManager","openConnection","timeoutController","signal","timeout","Infinity","newStream","source","result","encode","identifier","decode","buf","Error","ERR_INVALID_MESSAGE","response","status","StatusCode","OK","NOT_FOUND","ERROR","errmsg","ERR_INVALID_PARAMETERS","clear","self","request","lookup","_getLookupFunction","Uint8Array","prefix","keys","startsWith","get","registerLookupFunction","has","ERR_KEY_ALREADY_EXISTS","set","unregisterLookupFunction","existingLookup","delete"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\fetch\\index.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { codes } from '../errors.js'\nimport * as lp from 'it-length-prefixed'\nimport { FetchRequest, FetchResponse } from './pb/proto.js'\nimport { PROTOCOL_NAME, PROTOCOL_VERSION } from './constants.js'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { Stream } from '@libp2p/interface-connection'\nimport type { IncomingStreamData, Registrar } from '@libp2p/interface-registrar'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport { abortableDuplex } from 'abortable-iterator'\nimport { pipe } from 'it-pipe'\nimport first from 'it-first'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { setMaxListeners } from 'events'\nimport { fromString as uint8arrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8arrayToString } from 'uint8arrays/to-string'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\n\nconst log = logger('libp2p:fetch')\n\nexport interface FetchServiceInit {\n  protocolPrefix: string\n  maxInboundStreams: number\n  maxOutboundStreams: number\n\n  /**\n   * How long we should wait for a remote peer to send any data\n   */\n  timeout: number\n}\n\nexport interface HandleMessageOptions {\n  stream: Stream\n  protocol: string\n}\n\nexport interface LookupFunction {\n  (key: string): Promise<Uint8Array | null>\n}\n\nexport interface FetchServiceComponents {\n  registrar: Registrar\n  connectionManager: ConnectionManager\n}\n\n/**\n * A simple libp2p protocol for requesting a value corresponding to a key from a peer.\n * Developers can register one or more lookup function for retrieving the value corresponding to\n * a given key.  Each lookup function must act on a distinct part of the overall key space, defined\n * by a fixed prefix that all keys that should be routed to that lookup function will start with.\n */\nexport class FetchService implements Startable {\n  public readonly protocol: string\n  private readonly components: FetchServiceComponents\n  private readonly lookupFunctions: Map<string, LookupFunction>\n  private started: boolean\n  private readonly init: FetchServiceInit\n\n  constructor (components: FetchServiceComponents, init: FetchServiceInit) {\n    this.started = false\n    this.components = components\n    this.protocol = `/${init.protocolPrefix ?? 'libp2p'}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`\n    this.lookupFunctions = new Map() // Maps key prefix to value lookup function\n    this.handleMessage = this.handleMessage.bind(this)\n    this.init = init\n  }\n\n  async start () {\n    await this.components.registrar.handle(this.protocol, (data) => {\n      void this.handleMessage(data)\n        .catch(err => {\n          log.error(err)\n        })\n        .finally(() => {\n          data.stream.close()\n        })\n    }, {\n      maxInboundStreams: this.init.maxInboundStreams,\n      maxOutboundStreams: this.init.maxOutboundStreams\n    })\n    this.started = true\n  }\n\n  async stop () {\n    await this.components.registrar.unhandle(this.protocol)\n    this.started = false\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * Sends a request to fetch the value associated with the given key from the given peer\n   */\n  async fetch (peer: PeerId, key: string, options: AbortOptions = {}): Promise<Uint8Array | null> {\n    log('dialing %s to %p', this.protocol, peer)\n\n    const connection = await this.components.connectionManager.openConnection(peer, options)\n    let timeoutController\n    let signal = options.signal\n    let stream: Stream | undefined\n\n    // create a timeout if no abort signal passed\n    if (signal == null) {\n      log('using default timeout of %d ms', this.init.timeout)\n      timeoutController = new TimeoutController(this.init.timeout)\n      signal = timeoutController.signal\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal)\n      } catch {}\n    }\n\n    try {\n      stream = await connection.newStream(this.protocol, {\n        signal\n      })\n\n      // make stream abortable\n      const source = abortableDuplex(stream, signal)\n\n      log('fetch %s', key)\n\n      const result = await pipe(\n        [FetchRequest.encode({ identifier: key })],\n        lp.encode(),\n        source,\n        lp.decode(),\n        async function (source) {\n          const buf = await first(source)\n\n          if (buf == null) {\n            throw errCode(new Error('No data received'), codes.ERR_INVALID_MESSAGE)\n          }\n\n          const response = FetchResponse.decode(buf)\n\n          switch (response.status) {\n            case (FetchResponse.StatusCode.OK): {\n              log('received status for %s ok', key)\n              return response.data\n            }\n            case (FetchResponse.StatusCode.NOT_FOUND): {\n              log('received status for %s not found', key)\n              return null\n            }\n            case (FetchResponse.StatusCode.ERROR): {\n              log('received status for %s error', key)\n              const errmsg = uint8arrayToString(response.data)\n              throw errCode(new Error('Error in fetch protocol response: ' + errmsg), codes.ERR_INVALID_PARAMETERS)\n            }\n            default: {\n              log('received status for %s unknown', key)\n              throw errCode(new Error('Unknown response status'), codes.ERR_INVALID_MESSAGE)\n            }\n          }\n        }\n      )\n\n      return result ?? null\n    } finally {\n      if (timeoutController != null) {\n        timeoutController.clear()\n      }\n\n      if (stream != null) {\n        stream.close()\n      }\n    }\n  }\n\n  /**\n   * Invoked when a fetch request is received.  Reads the request message off the given stream and\n   * responds based on looking up the key in the request via the lookup callback that corresponds\n   * to the key's prefix.\n   */\n  async handleMessage (data: IncomingStreamData) {\n    const { stream } = data\n    const self = this\n\n    await pipe(\n      stream,\n      lp.decode(),\n      async function * (source) {\n        const buf = await first(source)\n\n        if (buf == null) {\n          throw errCode(new Error('No data received'), codes.ERR_INVALID_MESSAGE)\n        }\n\n        // for await (const buf of source) {\n        const request = FetchRequest.decode(buf)\n\n        let response: FetchResponse\n        const lookup = self._getLookupFunction(request.identifier)\n        if (lookup != null) {\n          log('look up data with identifier %s', request.identifier)\n          const data = await lookup(request.identifier)\n          if (data != null) {\n            log('sending status for %s ok', request.identifier)\n            response = { status: FetchResponse.StatusCode.OK, data }\n          } else {\n            log('sending status for %s not found', request.identifier)\n            response = { status: FetchResponse.StatusCode.NOT_FOUND, data: new Uint8Array(0) }\n          }\n        } else {\n          log('sending status for %s error', request.identifier)\n          const errmsg = uint8arrayFromString(`No lookup function registered for key: ${request.identifier}`)\n          response = { status: FetchResponse.StatusCode.ERROR, data: errmsg }\n        }\n\n        yield FetchResponse.encode(response)\n      },\n      lp.encode(),\n      stream\n    )\n  }\n\n  /**\n   * Given a key, finds the appropriate function for looking up its corresponding value, based on\n   * the key's prefix.\n   */\n  _getLookupFunction (key: string) {\n    for (const prefix of this.lookupFunctions.keys()) {\n      if (key.startsWith(prefix)) {\n        return this.lookupFunctions.get(prefix)\n      }\n    }\n  }\n\n  /**\n   * Registers a new lookup callback that can map keys to values, for a given set of keys that\n   * share the same prefix\n   *\n   * @example\n   *\n   * ```js\n   * // ...\n   * libp2p.fetchService.registerLookupFunction('/prefix', (key) => { ... })\n   * ```\n   */\n  registerLookupFunction (prefix: string, lookup: LookupFunction) {\n    if (this.lookupFunctions.has(prefix)) {\n      throw errCode(new Error(\"Fetch protocol handler for key prefix '\" + prefix + \"' already registered\"), codes.ERR_KEY_ALREADY_EXISTS)\n    }\n\n    this.lookupFunctions.set(prefix, lookup)\n  }\n\n  /**\n   * Registers a new lookup callback that can map keys to values, for a given set of keys that\n   * share the same prefix.\n   *\n   * @example\n   *\n   * ```js\n   * // ...\n   * libp2p.fetchService.unregisterLookupFunction('/prefix')\n   * ```\n   */\n  unregisterLookupFunction (prefix: string, lookup?: LookupFunction) {\n    if (lookup != null) {\n      const existingLookup = this.lookupFunctions.get(prefix)\n\n      if (existingLookup !== lookup) {\n        return\n      }\n    }\n\n    this.lookupFunctions.delete(prefix)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}