{"ast":null,"code":"import { upnpNat } from '@achingbrain/nat-port-mapper';\nimport { logger } from '@libp2p/logger';\nimport { fromNodeAddress } from '@multiformats/multiaddr';\nimport { isBrowser } from 'wherearewe';\nimport isPrivateIp from 'private-ip';\nimport * as pkg from './version.js';\nimport errCode from 'err-code';\nimport { codes } from './errors.js';\nimport { isLoopback } from '@libp2p/utils/multiaddr/is-loopback';\nconst log = logger('libp2p:nat');\nconst DEFAULT_TTL = 7200;\n\nfunction highPort() {\n  let min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n  let max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 65535;\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nexport class NatManager {\n  constructor(components, init) {\n    this.components = components;\n    this.started = false;\n    this.enabled = init.enabled;\n    this.externalAddress = init.externalAddress;\n    this.localAddress = init.localAddress;\n    this.description = init.description ?? `${pkg.name}@${pkg.version} ${this.components.peerId.toString()}`;\n    this.ttl = init.ttl ?? DEFAULT_TTL;\n    this.keepAlive = init.keepAlive ?? true;\n    this.gateway = init.gateway;\n\n    if (this.ttl < DEFAULT_TTL) {\n      throw errCode(new Error(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`), codes.ERR_INVALID_PARAMETERS);\n    }\n  }\n\n  isStarted() {\n    return this.started;\n  }\n\n  start() {}\n  /**\n   * Attempt to use uPnP to configure port mapping using the current gateway.\n   *\n   * Run after start to ensure the transport manager has all addresses configured.\n   */\n\n\n  afterStart() {\n    if (isBrowser || !this.enabled || this.started) {\n      return;\n    }\n\n    this.started = true; // done async to not slow down startup\n\n    void this._start().catch(err => {\n      // hole punching errors are non-fatal\n      log.error(err);\n    });\n  }\n\n  async _start() {\n    const addrs = this.components.transportManager.getAddrs();\n\n    for (const addr of addrs) {\n      // try to open uPnP ports for each thin waist address\n      const {\n        family,\n        host,\n        port,\n        transport\n      } = addr.toOptions();\n\n      if (!addr.isThinWaistAddress() || transport !== 'tcp') {\n        // only bare tcp addresses\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (isLoopback(addr)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (family !== 4) {\n        // ignore ipv6\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      const client = await this._getClient();\n      const publicIp = this.externalAddress ?? (await client.externalIp());\n      const isPrivate = isPrivateIp(publicIp);\n\n      if (isPrivate === true) {\n        throw new Error(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);\n      }\n\n      if (isPrivate == null) {\n        throw new Error(`${publicIp} is not an IP address`);\n      }\n\n      const publicPort = highPort();\n      log(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`);\n      await client.map({\n        publicPort,\n        localPort: port,\n        localAddress: this.localAddress,\n        protocol: transport.toUpperCase() === 'TCP' ? 'TCP' : 'UDP'\n      });\n      this.components.addressManager.addObservedAddr(fromNodeAddress({\n        family: 4,\n        address: publicIp,\n        port: publicPort\n      }, transport));\n    }\n  }\n\n  async _getClient() {\n    if (this.client != null) {\n      return this.client;\n    }\n\n    this.client = await upnpNat({\n      description: this.description,\n      ttl: this.ttl,\n      keepAlive: this.keepAlive,\n      gateway: this.gateway\n    });\n    return this.client;\n  }\n  /**\n   * Stops the NAT manager\n   */\n\n\n  async stop() {\n    if (isBrowser || this.client == null) {\n      return;\n    }\n\n    try {\n      await this.client.close();\n      this.client = undefined;\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["upnpNat","logger","fromNodeAddress","isBrowser","isPrivateIp","pkg","errCode","codes","isLoopback","log","DEFAULT_TTL","highPort","min","max","Math","floor","random","NatManager","constructor","components","init","started","enabled","externalAddress","localAddress","description","name","version","peerId","toString","ttl","keepAlive","gateway","Error","ERR_INVALID_PARAMETERS","isStarted","start","afterStart","_start","catch","err","error","addrs","transportManager","getAddrs","addr","family","host","port","transport","toOptions","isThinWaistAddress","client","_getClient","publicIp","externalIp","isPrivate","publicPort","map","localPort","protocol","toUpperCase","addressManager","addObservedAddr","address","stop","close","undefined"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\nat-manager.ts"],"sourcesContent":["import { upnpNat, NatAPI } from '@achingbrain/nat-port-mapper'\nimport { logger } from '@libp2p/logger'\nimport { fromNodeAddress } from '@multiformats/multiaddr'\nimport { isBrowser } from 'wherearewe'\nimport isPrivateIp from 'private-ip'\nimport * as pkg from './version.js'\nimport errCode from 'err-code'\nimport { codes } from './errors.js'\nimport { isLoopback } from '@libp2p/utils/multiaddr/is-loopback'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { TransportManager } from '@libp2p/interface-transport'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { AddressManager } from '@libp2p/interface-address-manager'\n\nconst log = logger('libp2p:nat')\nconst DEFAULT_TTL = 7200\n\nfunction highPort (min = 1024, max = 65535) {\n  return Math.floor(Math.random() * (max - min + 1) + min)\n}\n\nexport interface PMPOptions {\n  /**\n   * Whether to enable PMP as well as UPnP\n   */\n  enabled?: boolean\n}\n\nexport interface NatManagerInit {\n  /**\n   * Whether to enable the NAT manager\n   */\n  enabled: boolean\n\n  /**\n   * Pass a value to use instead of auto-detection\n   */\n  externalAddress?: string\n\n  /**\n   * Pass a value to use instead of auto-detection\n   */\n  localAddress?: string\n\n  /**\n   * A string value to use for the port mapping description on the gateway\n   */\n  description?: string\n\n  /**\n   * How long UPnP port mappings should last for in seconds (minimum 1200)\n   */\n  ttl?: number\n\n  /**\n   * Whether to automatically refresh UPnP port mappings when their TTL is reached\n   */\n  keepAlive: boolean\n\n  /**\n   * Pass a value to use instead of auto-detection\n   */\n  gateway?: string\n}\n\nexport interface NatManagerComponents {\n  peerId: PeerId\n  transportManager: TransportManager\n  addressManager: AddressManager\n}\n\nexport class NatManager implements Startable {\n  private readonly components: NatManagerComponents\n  private readonly enabled: boolean\n  private readonly externalAddress?: string\n  private readonly localAddress?: string\n  private readonly description: string\n  private readonly ttl: number\n  private readonly keepAlive: boolean\n  private readonly gateway?: string\n  private started: boolean\n  private client?: NatAPI\n\n  constructor (components: NatManagerComponents, init: NatManagerInit) {\n    this.components = components\n\n    this.started = false\n    this.enabled = init.enabled\n    this.externalAddress = init.externalAddress\n    this.localAddress = init.localAddress\n    this.description = init.description ?? `${pkg.name}@${pkg.version} ${this.components.peerId.toString()}`\n    this.ttl = init.ttl ?? DEFAULT_TTL\n    this.keepAlive = init.keepAlive ?? true\n    this.gateway = init.gateway\n\n    if (this.ttl < DEFAULT_TTL) {\n      throw errCode(new Error(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`), codes.ERR_INVALID_PARAMETERS)\n    }\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  start () {}\n\n  /**\n   * Attempt to use uPnP to configure port mapping using the current gateway.\n   *\n   * Run after start to ensure the transport manager has all addresses configured.\n   */\n  afterStart () {\n    if (isBrowser || !this.enabled || this.started) {\n      return\n    }\n\n    this.started = true\n\n    // done async to not slow down startup\n    void this._start().catch((err) => {\n      // hole punching errors are non-fatal\n      log.error(err)\n    })\n  }\n\n  async _start () {\n    const addrs = this.components.transportManager.getAddrs()\n\n    for (const addr of addrs) {\n      // try to open uPnP ports for each thin waist address\n      const { family, host, port, transport } = addr.toOptions()\n\n      if (!addr.isThinWaistAddress() || transport !== 'tcp') {\n        // only bare tcp addresses\n        // eslint-disable-next-line no-continue\n        continue\n      }\n\n      if (isLoopback(addr)) {\n        // eslint-disable-next-line no-continue\n        continue\n      }\n\n      if (family !== 4) {\n        // ignore ipv6\n        // eslint-disable-next-line no-continue\n        continue\n      }\n\n      const client = await this._getClient()\n      const publicIp = this.externalAddress ?? await client.externalIp()\n      const isPrivate = isPrivateIp(publicIp)\n\n      if (isPrivate === true) {\n        throw new Error(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`)\n      }\n\n      if (isPrivate == null) {\n        throw new Error(`${publicIp} is not an IP address`)\n      }\n\n      const publicPort = highPort()\n\n      log(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`)\n\n      await client.map({\n        publicPort,\n        localPort: port,\n        localAddress: this.localAddress,\n        protocol: transport.toUpperCase() === 'TCP' ? 'TCP' : 'UDP'\n      })\n\n      this.components.addressManager.addObservedAddr(fromNodeAddress({\n        family: 4,\n        address: publicIp,\n        port: publicPort\n      }, transport))\n    }\n  }\n\n  async _getClient () {\n    if (this.client != null) {\n      return this.client\n    }\n\n    this.client = await upnpNat({\n      description: this.description,\n      ttl: this.ttl,\n      keepAlive: this.keepAlive,\n      gateway: this.gateway\n    })\n\n    return this.client\n  }\n\n  /**\n   * Stops the NAT manager\n   */\n  async stop () {\n    if (isBrowser || this.client == null) {\n      return\n    }\n\n    try {\n      await this.client.close()\n      this.client = undefined\n    } catch (err: any) {\n      log.error(err)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}