{"ast":null,"code":"import { CodeError } from '@libp2p/interfaces/errors';\nimport { pipe } from 'it-pipe';\nimport * as lp from 'it-length-prefixed';\nimport drain from 'it-drain';\nimport first from 'it-first';\nimport { Message } from './message/index.js';\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';\nimport { dialingPeerEvent, sendingQueryEvent, peerResponseEvent, queryErrorEvent } from './query/events.js';\nimport { logger } from '@libp2p/logger';\nimport { abortableDuplex } from 'abortable-iterator';\n/**\n * Handle network operations for the dht\n */\n\nexport class Network extends EventEmitter {\n  /**\n   * Create a new network\n   */\n  constructor(components, init) {\n    super();\n    const {\n      protocol,\n      lan\n    } = init;\n    this.components = components;\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:network`);\n    this.running = false;\n    this.protocol = protocol;\n  }\n  /**\n   * Start the network\n   */\n\n\n  async start() {\n    if (this.running) {\n      return;\n    }\n\n    this.running = true;\n  }\n  /**\n   * Stop all network activity\n   */\n\n\n  async stop() {\n    this.running = false;\n  }\n  /**\n   * Is the network online?\n   */\n\n\n  isStarted() {\n    return this.running;\n  }\n  /**\n   * Send a request and record RTT for latency measurements\n   */\n\n\n  async *sendRequest(to, msg) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!this.running) {\n      return;\n    }\n\n    this.log('sending %s to %p', msg.type, to);\n    yield dialingPeerEvent({\n      peer: to\n    });\n    yield sendingQueryEvent({\n      to,\n      type: msg.type\n    });\n    let stream;\n\n    try {\n      const connection = await this.components.connectionManager.openConnection(to, options);\n      const stream = await connection.newStream(this.protocol, options);\n      const response = await this._writeReadMessage(stream, msg.serialize(), options);\n      yield peerResponseEvent({\n        from: to,\n        messageType: response.type,\n        closer: response.closerPeers,\n        providers: response.providerPeers,\n        record: response.record\n      });\n    } catch (err) {\n      yield queryErrorEvent({\n        from: to,\n        error: err\n      });\n    } finally {\n      if (stream != null) {\n        stream.close();\n      }\n    }\n  }\n  /**\n   * Sends a message without expecting an answer\n   */\n\n\n  async *sendMessage(to, msg) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!this.running) {\n      return;\n    }\n\n    this.log('sending %s to %p', msg.type, to);\n    yield dialingPeerEvent({\n      peer: to\n    });\n    yield sendingQueryEvent({\n      to,\n      type: msg.type\n    });\n    let stream;\n\n    try {\n      const connection = await this.components.connectionManager.openConnection(to, options);\n      const stream = await connection.newStream(this.protocol, options);\n      await this._writeMessage(stream, msg.serialize(), options);\n      yield peerResponseEvent({\n        from: to,\n        messageType: msg.type\n      });\n    } catch (err) {\n      yield queryErrorEvent({\n        from: to,\n        error: err\n      });\n    } finally {\n      if (stream != null) {\n        stream.close();\n      }\n    }\n  }\n  /**\n   * Write a message to the given stream\n   */\n\n\n  async _writeMessage(stream, msg, options) {\n    if (options.signal != null) {\n      stream = abortableDuplex(stream, options.signal);\n    }\n\n    await pipe([msg], lp.encode(), stream, drain);\n  }\n  /**\n   * Write a message and read its response.\n   * If no response is received after the specified timeout\n   * this will error out.\n   */\n\n\n  async _writeReadMessage(stream, msg, options) {\n    if (options.signal != null) {\n      stream = abortableDuplex(stream, options.signal);\n    }\n\n    const res = await pipe([msg], lp.encode(), stream, lp.decode(), async source => {\n      const buf = await first(source);\n\n      if (buf != null) {\n        return buf;\n      }\n\n      throw new CodeError('No message received', 'ERR_NO_MESSAGE_RECEIVED');\n    });\n    const message = Message.deserialize(res); // tell any listeners about new peers we've seen\n\n    message.closerPeers.forEach(peerData => {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: peerData\n      }));\n    });\n    message.providerPeers.forEach(peerData => {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: peerData\n      }));\n    });\n    return message;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["CodeError","pipe","lp","drain","first","Message","EventEmitter","CustomEvent","dialingPeerEvent","sendingQueryEvent","peerResponseEvent","queryErrorEvent","logger","abortableDuplex","Network","constructor","components","init","protocol","lan","log","running","start","stop","isStarted","sendRequest","to","msg","options","type","peer","stream","connection","connectionManager","openConnection","newStream","response","_writeReadMessage","serialize","from","messageType","closer","closerPeers","providers","providerPeers","record","err","error","close","sendMessage","_writeMessage","signal","encode","res","decode","source","buf","message","deserialize","forEach","peerData","dispatchEvent","detail"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\network.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport { pipe } from 'it-pipe'\nimport * as lp from 'it-length-prefixed'\nimport drain from 'it-drain'\nimport first from 'it-first'\nimport { Message } from './message/index.js'\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events'\nimport {\n  dialingPeerEvent,\n  sendingQueryEvent,\n  peerResponseEvent,\n  queryErrorEvent\n} from './query/events.js'\nimport { logger } from '@libp2p/logger'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { Logger } from '@libp2p/logger'\nimport type { Duplex } from 'it-stream-types'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { Stream } from '@libp2p/interface-connection'\nimport { abortableDuplex } from 'abortable-iterator'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { KadDHTComponents } from './index.js'\nimport type { QueryEvent } from '@libp2p/interface-dht'\n\nexport interface NetworkInit {\n  protocol: string\n  lan: boolean\n}\n\ninterface NetworkEvents {\n  'peer': CustomEvent<PeerInfo>\n}\n\n/**\n * Handle network operations for the dht\n */\nexport class Network extends EventEmitter<NetworkEvents> implements Startable {\n  private readonly log: Logger\n  private readonly protocol: string\n  private running: boolean\n  private readonly components: KadDHTComponents\n\n  /**\n   * Create a new network\n   */\n  constructor (components: KadDHTComponents, init: NetworkInit) {\n    super()\n\n    const { protocol, lan } = init\n    this.components = components\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:network`)\n    this.running = false\n    this.protocol = protocol\n  }\n\n  /**\n   * Start the network\n   */\n  async start (): Promise<void> {\n    if (this.running) {\n      return\n    }\n\n    this.running = true\n  }\n\n  /**\n   * Stop all network activity\n   */\n  async stop (): Promise<void> {\n    this.running = false\n  }\n\n  /**\n   * Is the network online?\n   */\n  isStarted (): boolean {\n    return this.running\n  }\n\n  /**\n   * Send a request and record RTT for latency measurements\n   */\n  async * sendRequest (to: PeerId, msg: Message, options: AbortOptions = {}): AsyncGenerator<QueryEvent> {\n    if (!this.running) {\n      return\n    }\n\n    this.log('sending %s to %p', msg.type, to)\n    yield dialingPeerEvent({ peer: to })\n    yield sendingQueryEvent({ to, type: msg.type })\n\n    let stream: Stream | undefined\n\n    try {\n      const connection = await this.components.connectionManager.openConnection(to, options)\n      const stream = await connection.newStream(this.protocol, options)\n\n      const response = await this._writeReadMessage(stream, msg.serialize(), options)\n\n      yield peerResponseEvent({\n        from: to,\n        messageType: response.type,\n        closer: response.closerPeers,\n        providers: response.providerPeers,\n        record: response.record\n      })\n    } catch (err: any) {\n      yield queryErrorEvent({ from: to, error: err })\n    } finally {\n      if (stream != null) {\n        stream.close()\n      }\n    }\n  }\n\n  /**\n   * Sends a message without expecting an answer\n   */\n  async * sendMessage (to: PeerId, msg: Message, options: AbortOptions = {}): AsyncGenerator<QueryEvent> {\n    if (!this.running) {\n      return\n    }\n\n    this.log('sending %s to %p', msg.type, to)\n    yield dialingPeerEvent({ peer: to })\n    yield sendingQueryEvent({ to, type: msg.type })\n\n    let stream: Stream | undefined\n\n    try {\n      const connection = await this.components.connectionManager.openConnection(to, options)\n      const stream = await connection.newStream(this.protocol, options)\n\n      await this._writeMessage(stream, msg.serialize(), options)\n\n      yield peerResponseEvent({ from: to, messageType: msg.type })\n    } catch (err: any) {\n      yield queryErrorEvent({ from: to, error: err })\n    } finally {\n      if (stream != null) {\n        stream.close()\n      }\n    }\n  }\n\n  /**\n   * Write a message to the given stream\n   */\n  async _writeMessage (stream: Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array>, msg: Uint8Array | Uint8ArrayList, options: AbortOptions): Promise<void> {\n    if (options.signal != null) {\n      stream = abortableDuplex(stream, options.signal)\n    }\n\n    await pipe(\n      [msg],\n      lp.encode(),\n      stream,\n      drain\n    )\n  }\n\n  /**\n   * Write a message and read its response.\n   * If no response is received after the specified timeout\n   * this will error out.\n   */\n  async _writeReadMessage (stream: Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array>, msg: Uint8Array | Uint8ArrayList, options: AbortOptions): Promise<Message> {\n    if (options.signal != null) {\n      stream = abortableDuplex(stream, options.signal)\n    }\n\n    const res = await pipe(\n      [msg],\n      lp.encode(),\n      stream,\n      lp.decode(),\n      async source => {\n        const buf = await first(source)\n\n        if (buf != null) {\n          return buf\n        }\n\n        throw new CodeError('No message received', 'ERR_NO_MESSAGE_RECEIVED')\n      }\n    )\n\n    const message = Message.deserialize(res)\n\n    // tell any listeners about new peers we've seen\n    message.closerPeers.forEach(peerData => {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: peerData\n      }))\n    })\n    message.providerPeers.forEach(peerData => {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: peerData\n      }))\n    })\n\n    return message\n  }\n}\n"]},"metadata":{},"sourceType":"module"}