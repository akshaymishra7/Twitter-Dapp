{"ast":null,"code":"import NanoDate from 'timestamp-nano';\nimport { Key } from 'interface-datastore/key';\nimport { unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport errCode from 'err-code';\nimport { base32upper } from 'multiformats/bases/base32';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { logger } from '@libp2p/logger';\nimport { createCborData, ipnsEntryDataForV1Sig, ipnsEntryDataForV2Sig } from './utils.js';\nimport * as ERRORS from './errors.js';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { IpnsEntry } from './pb/ipns.js';\nconst log = logger('ipns');\nconst ID_MULTIHASH_CODE = identity.code;\nexport const namespace = '/ipns/';\nexport const namespaceLength = namespace.length;\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {PeerId} peerId - peer id containing private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {number} lifetime - lifetime of the record (in milliseconds).\n */\n\nexport const create = async (peerId, value, seq, lifetime) => {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  const expirationDate = new NanoDate(Date.now() + Number(lifetime));\n  const validityType = IpnsEntry.ValidityType.EOL;\n  const [ms, ns] = lifetime.toString().split('.');\n  const lifetimeNs = BigInt(ms) * BigInt(100000) + BigInt(ns ?? '0');\n  return await _create(peerId, value, seq, validityType, expirationDate, lifetimeNs);\n};\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n *\n * @param {PeerId} peerId - PeerId containing private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {string} expiration - expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n */\n\nexport const createWithExpiration = async (peerId, value, seq, expiration) => {\n  const expirationDate = NanoDate.fromString(expiration);\n  const validityType = IpnsEntry.ValidityType.EOL;\n  const ttlMs = expirationDate.toDate().getTime() - Date.now();\n  const ttlNs = BigInt(ttlMs) * BigInt(100000) + BigInt(expirationDate.getNano());\n  return await _create(peerId, value, seq, validityType, expirationDate, ttlNs);\n};\n\nconst _create = async (peerId, value, seq, validityType, expirationDate, ttl) => {\n  seq = BigInt(seq);\n  const isoValidity = uint8ArrayFromString(expirationDate.toString());\n\n  if (peerId.privateKey == null) {\n    throw errCode(new Error('Missing private key'), ERRORS.ERR_MISSING_PRIVATE_KEY);\n  }\n\n  const privateKey = await unmarshalPrivateKey(peerId.privateKey);\n  const signatureV1 = await signLegacyV1(privateKey, value, validityType, isoValidity);\n  const data = createCborData(value, isoValidity, validityType, seq, ttl);\n  const sigData = ipnsEntryDataForV2Sig(data);\n  const signatureV2 = await privateKey.sign(sigData);\n  const entry = {\n    value,\n    signature: signatureV1,\n    validityType,\n    validity: isoValidity,\n    sequence: seq,\n    ttl,\n    signatureV2,\n    data\n  }; // if we cannot derive the public key from the PeerId (e.g. RSA PeerIDs),\n  // we have to embed it in the IPNS record\n\n  if (peerId.publicKey != null) {\n    const digest = Digest.decode(peerId.toBytes());\n\n    if (digest.code !== ID_MULTIHASH_CODE || !uint8ArrayEquals(peerId.publicKey, digest.digest)) {\n      entry.pubKey = peerId.publicKey;\n    }\n  }\n\n  log('ipns entry for %b created', value);\n  return entry;\n};\n/**\n * rawStdEncoding with RFC4648\n */\n\n\nconst rawStdEncoding = key => base32upper.encode(key).slice(1);\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Uint8Array} key - peer identifier object.\n */\n\n\nexport const getLocalKey = key => new Key(`/ipns/${rawStdEncoding(key)}`);\nexport { unmarshal } from './utils.js';\nexport { marshal } from './utils.js';\nexport { peerIdToRoutingKey } from './utils.js';\nexport { peerIdFromRoutingKey } from './utils.js';\n/**\n * Sign ipns record data using the legacy V1 signature scheme\n */\n\nconst signLegacyV1 = async (privateKey, value, validityType, validity) => {\n  try {\n    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n    return await privateKey.sign(dataForSignature);\n  } catch (error) {\n    log.error('record signature creation failed', error);\n    throw errCode(new Error('record signature creation failed'), ERRORS.ERR_SIGNATURE_CREATION);\n  }\n};","map":{"version":3,"mappings":"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","names":["NanoDate","Key","unmarshalPrivateKey","errCode","base32upper","fromString","uint8ArrayFromString","logger","createCborData","ipnsEntryDataForV1Sig","ipnsEntryDataForV2Sig","ERRORS","equals","uint8ArrayEquals","Digest","identity","IpnsEntry","log","ID_MULTIHASH_CODE","code","namespace","namespaceLength","length","create","peerId","value","seq","lifetime","expirationDate","Date","now","Number","validityType","ValidityType","EOL","ms","ns","toString","split","lifetimeNs","BigInt","_create","createWithExpiration","expiration","ttlMs","toDate","getTime","ttlNs","getNano","ttl","isoValidity","privateKey","Error","ERR_MISSING_PRIVATE_KEY","signatureV1","signLegacyV1","data","sigData","signatureV2","sign","entry","signature","validity","sequence","publicKey","digest","decode","toBytes","pubKey","rawStdEncoding","key","encode","slice","getLocalKey","unmarshal","marshal","peerIdToRoutingKey","peerIdFromRoutingKey","dataForSignature","error","ERR_SIGNATURE_CREATION"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\ipns\\src\\index.ts"],"sourcesContent":["import NanoDate from 'timestamp-nano'\nimport { Key } from 'interface-datastore/key'\nimport { unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport errCode from 'err-code'\nimport { base32upper } from 'multiformats/bases/base32'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { logger } from '@libp2p/logger'\nimport { createCborData, ipnsEntryDataForV1Sig, ipnsEntryDataForV2Sig } from './utils.js'\nimport * as ERRORS from './errors.js'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { identity } from 'multiformats/hashes/identity'\nimport { IpnsEntry } from './pb/ipns.js'\nimport type { PrivateKey } from '@libp2p/interface-keys'\nimport type { PeerId } from '@libp2p/interface-peer-id'\n\nconst log = logger('ipns')\nconst ID_MULTIHASH_CODE = identity.code\n\nexport const namespace = '/ipns/'\nexport const namespaceLength = namespace.length\n\nexport interface IPNSEntry {\n  value: Uint8Array\n  signature: Uint8Array // signature of the record\n  validityType: IpnsEntry.ValidityType // Type of validation being used\n  validity: Uint8Array // expiration datetime for the record in RFC3339 format\n  sequence: bigint // number representing the version of the record\n  ttl?: bigint // ttl in nanoseconds\n  pubKey?: Uint8Array // the public portion of the key that signed this record (only present if it was not embedded in the IPNS key)\n  signatureV2?: Uint8Array // the v2 signature of the record\n  data?: Uint8Array // extensible data\n}\n\nexport interface IPNSEntryData {\n  Value: Uint8Array\n  Validity: Uint8Array\n  ValidityType: IpnsEntry.ValidityType\n  Sequence: bigint\n  TTL: bigint\n}\n\nexport interface IDKeys {\n  routingPubKey: Key\n  pkKey: Key\n  routingKey: Key\n  ipnsKey: Key\n}\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {PeerId} peerId - peer id containing private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {number} lifetime - lifetime of the record (in milliseconds).\n */\nexport const create = async (peerId: PeerId, value: Uint8Array, seq: number | bigint, lifetime: number): Promise<IPNSEntry> => {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  const expirationDate = new NanoDate(Date.now() + Number(lifetime))\n  const validityType = IpnsEntry.ValidityType.EOL\n  const [ms, ns] = lifetime.toString().split('.')\n  const lifetimeNs = (BigInt(ms) * BigInt(100000)) + BigInt(ns ?? '0')\n\n  return await _create(peerId, value, seq, validityType, expirationDate, lifetimeNs)\n}\n\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n *\n * @param {PeerId} peerId - PeerId containing private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {string} expiration - expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n */\nexport const createWithExpiration = async (peerId: PeerId, value: Uint8Array, seq: number | bigint, expiration: string): Promise<IPNSEntry> => {\n  const expirationDate = NanoDate.fromString(expiration)\n  const validityType = IpnsEntry.ValidityType.EOL\n\n  const ttlMs = expirationDate.toDate().getTime() - Date.now()\n  const ttlNs = (BigInt(ttlMs) * BigInt(100000)) + BigInt(expirationDate.getNano())\n\n  return await _create(peerId, value, seq, validityType, expirationDate, ttlNs)\n}\n\nconst _create = async (peerId: PeerId, value: Uint8Array, seq: number | bigint, validityType: IpnsEntry.ValidityType, expirationDate: NanoDate, ttl: bigint): Promise<IPNSEntry> => {\n  seq = BigInt(seq)\n  const isoValidity = uint8ArrayFromString(expirationDate.toString())\n\n  if (peerId.privateKey == null) {\n    throw errCode(new Error('Missing private key'), ERRORS.ERR_MISSING_PRIVATE_KEY)\n  }\n\n  const privateKey = await unmarshalPrivateKey(peerId.privateKey)\n  const signatureV1 = await signLegacyV1(privateKey, value, validityType, isoValidity)\n  const data = createCborData(value, isoValidity, validityType, seq, ttl)\n  const sigData = ipnsEntryDataForV2Sig(data)\n  const signatureV2 = await privateKey.sign(sigData)\n\n  const entry: IPNSEntry = {\n    value,\n    signature: signatureV1,\n    validityType,\n    validity: isoValidity,\n    sequence: seq,\n    ttl,\n    signatureV2,\n    data\n  }\n\n  // if we cannot derive the public key from the PeerId (e.g. RSA PeerIDs),\n  // we have to embed it in the IPNS record\n  if (peerId.publicKey != null) {\n    const digest = Digest.decode(peerId.toBytes())\n\n    if (digest.code !== ID_MULTIHASH_CODE || !uint8ArrayEquals(peerId.publicKey, digest.digest)) {\n      entry.pubKey = peerId.publicKey\n    }\n  }\n\n  log('ipns entry for %b created', value)\n  return entry\n}\n\n/**\n * rawStdEncoding with RFC4648\n */\nconst rawStdEncoding = (key: Uint8Array): string => base32upper.encode(key).slice(1)\n\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Uint8Array} key - peer identifier object.\n */\nexport const getLocalKey = (key: Uint8Array): Key => new Key(`/ipns/${rawStdEncoding(key)}`)\n\nexport { unmarshal } from './utils.js'\nexport { marshal } from './utils.js'\nexport { peerIdToRoutingKey } from './utils.js'\nexport { peerIdFromRoutingKey } from './utils.js'\n\n/**\n * Sign ipns record data using the legacy V1 signature scheme\n */\nconst signLegacyV1 = async (privateKey: PrivateKey, value: Uint8Array, validityType: IpnsEntry.ValidityType, validity: Uint8Array): Promise<Uint8Array> => {\n  try {\n    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity)\n\n    return await privateKey.sign(dataForSignature)\n  } catch (error: any) {\n    log.error('record signature creation failed', error)\n    throw errCode(new Error('record signature creation failed'), ERRORS.ERR_SIGNATURE_CREATION)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}