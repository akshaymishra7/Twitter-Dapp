{"ast":null,"code":"import { BaseDatastore } from './base.js';\nimport * as Errors from './errors.js';\nimport { logger } from '@libp2p/logger';\nimport { pushable } from 'it-pushable';\nimport drain from 'it-drain';\nconst log = logger('datastore:core:tiered');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Key} Key\n * @typedef {import('interface-datastore').Pair} Pair\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\n\nexport class TieredDatastore extends BaseDatastore {\n  /**\n   * @param {Datastore[]} stores\n   */\n  constructor(stores) {\n    super();\n    this.stores = stores.slice();\n  }\n\n  async open() {\n    try {\n      await Promise.all(this.stores.map(store => store.open()));\n    } catch (\n    /** @type {any} */\n    err) {\n      throw Errors.dbOpenFailedError(err);\n    }\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n\n\n  async put(key, value, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.put(key, value, options)));\n    } catch (\n    /** @type {any} */\n    err) {\n      throw Errors.dbWriteFailedError(err);\n    }\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  async get(key, options) {\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key, options);\n        if (res) return res;\n      } catch (err) {\n        log.error(err);\n      }\n    }\n\n    throw Errors.notFoundError();\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  async has(key, options) {\n    for (const s of this.stores) {\n      if (await s.has(key, options)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  async delete(key, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.delete(key, options)));\n    } catch (\n    /** @type {any} */\n    err) {\n      throw Errors.dbDeleteFailedError(err);\n    }\n  }\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n\n\n  async *putMany(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let error;\n    const pushables = this.stores.map(store => {\n      const source = pushable({\n        objectMode: true\n      });\n      drain(store.putMany(source, options)).catch(err => {\n        // store threw while putting, make sure we bubble the error up\n        error = err;\n      });\n      return source;\n    });\n\n    try {\n      for await (const pair of source) {\n        if (error) {\n          throw error;\n        }\n\n        pushables.forEach(p => p.push(pair));\n        yield pair;\n      }\n    } finally {\n      pushables.forEach(p => p.end());\n    }\n  }\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n\n\n  async *deleteMany(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let error;\n    const pushables = this.stores.map(store => {\n      const source = pushable({\n        objectMode: true\n      });\n      drain(store.deleteMany(source, options)).catch(err => {\n        // store threw while deleting, make sure we bubble the error up\n        error = err;\n      });\n      return source;\n    });\n\n    try {\n      for await (const key of source) {\n        if (error) {\n          throw error;\n        }\n\n        pushables.forEach(p => p.push(key));\n        yield key;\n      }\n    } finally {\n      pushables.forEach(p => p.end());\n    }\n  }\n\n  async close() {\n    await Promise.all(this.stores.map(store => store.close()));\n  }\n  /**\n   * @returns {Batch}\n   */\n\n\n  batch() {\n    const batches = this.stores.map(store => store.batch());\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value));\n      },\n      delete: key => {\n        batches.forEach(b => b.delete(key));\n      },\n      commit: async options => {\n        for (const batch of batches) {\n          await batch.commit(options);\n        }\n      }\n    };\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    return this.stores[this.stores.length - 1].query(q, options);\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n\n\n  queryKeys(q, options) {\n    return this.stores[this.stores.length - 1].queryKeys(q, options);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/datastore-core/src/tiered.js"],"names":["BaseDatastore","Errors","logger","pushable","drain","log","TieredDatastore","constructor","stores","slice","open","Promise","all","map","store","err","dbOpenFailedError","put","key","value","options","dbWriteFailedError","get","res","error","notFoundError","has","s","delete","dbDeleteFailedError","putMany","source","pushables","objectMode","catch","pair","forEach","p","push","end","deleteMany","close","batch","batches","b","commit","query","q","length","queryKeys"],"mappings":"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","sourcesContent":["import { BaseDatastore } from './base.js'\nimport * as Errors from './errors.js'\nimport { logger } from '@libp2p/logger'\nimport { pushable } from 'it-pushable'\nimport drain from 'it-drain'\n\nconst log = logger('datastore:core:tiered')\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Key} Key\n * @typedef {import('interface-datastore').Pair} Pair\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\nexport class TieredDatastore extends BaseDatastore {\n  /**\n   * @param {Datastore[]} stores\n   */\n  constructor (stores) {\n    super()\n\n    this.stores = stores.slice()\n  }\n\n  async open () {\n    try {\n      await Promise.all(this.stores.map((store) => store.open()))\n    } catch (/** @type {any} */ err) {\n      throw Errors.dbOpenFailedError(err)\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n  async put (key, value, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.put(key, value, options)))\n    } catch (/** @type {any} */ err) {\n      throw Errors.dbWriteFailedError(err)\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  async get (key, options) {\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key, options)\n        if (res) return res\n      } catch (err) {\n        log.error(err)\n      }\n    }\n    throw Errors.notFoundError()\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  async has (key, options) {\n    for (const s of this.stores) {\n      if (await s.has(key, options)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  async delete (key, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.delete(key, options)))\n    } catch (/** @type {any} */ err) {\n      throw Errors.dbDeleteFailedError(err)\n    }\n  }\n\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n  async * putMany (source, options = {}) {\n    let error\n    const pushables = this.stores.map(store => {\n      const source = pushable({\n        objectMode: true\n      })\n\n      drain(store.putMany(source, options))\n        .catch(err => {\n          // store threw while putting, make sure we bubble the error up\n          error = err\n        })\n\n      return source\n    })\n\n    try {\n      for await (const pair of source) {\n        if (error) {\n          throw error\n        }\n\n        pushables.forEach(p => p.push(pair))\n\n        yield pair\n      }\n    } finally {\n      pushables.forEach(p => p.end())\n    }\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n  async * deleteMany (source, options = {}) {\n    let error\n    const pushables = this.stores.map(store => {\n      const source = pushable({\n        objectMode: true\n      })\n\n      drain(store.deleteMany(source, options))\n        .catch(err => {\n          // store threw while deleting, make sure we bubble the error up\n          error = err\n        })\n\n      return source\n    })\n\n    try {\n      for await (const key of source) {\n        if (error) {\n          throw error\n        }\n\n        pushables.forEach(p => p.push(key))\n\n        yield key\n      }\n    } finally {\n      pushables.forEach(p => p.end())\n    }\n  }\n\n  async close () {\n    await Promise.all(this.stores.map(store => store.close()))\n  }\n\n  /**\n   * @returns {Batch}\n   */\n  batch () {\n    const batches = this.stores.map(store => store.batch())\n\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value))\n      },\n      delete: (key) => {\n        batches.forEach(b => b.delete(key))\n      },\n      commit: async (options) => {\n        for (const batch of batches) {\n          await batch.commit(options)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query (q, options) {\n    return this.stores[this.stores.length - 1].query(q, options)\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys (q, options) {\n    return this.stores[this.stores.length - 1].queryKeys(q, options)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}