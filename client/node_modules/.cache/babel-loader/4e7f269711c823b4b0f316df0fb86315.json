{"ast":null,"code":"import errCode from 'err-code';\nimport parallel from 'it-parallel';\nimport map from 'it-map';\nimport filter from 'it-filter';\nimport { pipe } from 'it-pipe';\nimport { cleanCid } from './utils.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nconst BLOCK_RM_CONCURRENCY = 8;\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\nexport function createRm(_ref) {\n  let {\n    repo\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/block').API<{}>[\"rm\"]}\n   */\n  async function* rm(cids) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!Array.isArray(cids)) {\n      cids = [cids];\n    } // We need to take a write lock here to ensure that adding and removing\n    // blocks are exclusive operations\n\n\n    const release = await repo.gcLock.writeLock();\n\n    try {\n      yield* pipe(cids, source => map(source, cid => {\n        return async () => {\n          cid = cleanCid(cid);\n          /** @type {import('ipfs-core-types/src/block').RmResult} */\n\n          const result = {\n            cid\n          };\n\n          try {\n            const has = await repo.blocks.has(cid);\n\n            if (!has) {\n              throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND');\n            }\n\n            await repo.blocks.delete(cid);\n          } catch (\n          /** @type {any} */\n          err) {\n            if (!options.force) {\n              err.message = `cannot remove ${cid}: ${err.message}`;\n              result.error = err;\n            }\n          }\n\n          return result;\n        };\n      }), source => parallel(source, {\n        concurrency: BLOCK_RM_CONCURRENCY\n      }), source => filter(source, () => !options.quiet));\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption(rm);\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/block/rm.js"],"names":["errCode","parallel","map","filter","pipe","cleanCid","withTimeoutOption","BLOCK_RM_CONCURRENCY","createRm","repo","rm","cids","options","Array","isArray","release","gcLock","writeLock","source","cid","result","has","blocks","Error","delete","err","force","message","error","concurrency","quiet"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,UAApB;AACA,OAAOC,QAAP,MAAqB,aAArB;AACA,OAAOC,GAAP,MAAgB,QAAhB;AACA,OAAOC,MAAP,MAAmB,WAAnB;AACA,SAASC,IAAT,QAAqB,SAArB;AACA,SAASC,QAAT,QAAyB,YAAzB;AACA,SAASC,iBAAT,QAAkC,qCAAlC;AAEA,MAAMC,oBAAoB,GAAG,CAA7B;AAEA;AACA;AACA;AACA;;AACA,OAAO,SAASC,QAAT,OAA6B;AAAA,MAAV;AAAEC,IAAAA;AAAF,GAAU;;AAClC;AACF;AACA;AACE,kBAAiBC,EAAjB,CAAqBC,IAArB,EAAyC;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AACvC,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcH,IAAd,CAAL,EAA0B;AACxBA,MAAAA,IAAI,GAAG,CAACA,IAAD,CAAP;AACD,KAHsC,CAKvC;AACA;;;AACA,UAAMI,OAAO,GAAG,MAAMN,IAAI,CAACO,MAAL,CAAYC,SAAZ,EAAtB;;AAEA,QAAI;AACF,aAAQb,IAAI,CACVO,IADU,EAEVO,MAAM,IAAIhB,GAAG,CAACgB,MAAD,EAASC,GAAG,IAAI;AAC3B,eAAO,YAAY;AACjBA,UAAAA,GAAG,GAAGd,QAAQ,CAACc,GAAD,CAAd;AAEA;;AACA,gBAAMC,MAAM,GAAG;AAAED,YAAAA;AAAF,WAAf;;AAEA,cAAI;AACF,kBAAME,GAAG,GAAG,MAAMZ,IAAI,CAACa,MAAL,CAAYD,GAAZ,CAAgBF,GAAhB,CAAlB;;AAEA,gBAAI,CAACE,GAAL,EAAU;AACR,oBAAMrB,OAAO,CAAC,IAAIuB,KAAJ,CAAU,iBAAV,CAAD,EAA+B,qBAA/B,CAAb;AACD;;AAED,kBAAMd,IAAI,CAACa,MAAL,CAAYE,MAAZ,CAAmBL,GAAnB,CAAN;AACD,WARD,CAQE;AAAO;AAAmBM,UAAAA,GAA1B,EAA+B;AAC/B,gBAAI,CAACb,OAAO,CAACc,KAAb,EAAoB;AAClBD,cAAAA,GAAG,CAACE,OAAJ,GAAe,iBAAgBR,GAAI,KAAIM,GAAG,CAACE,OAAQ,EAAnD;AACAP,cAAAA,MAAM,CAACQ,KAAP,GAAeH,GAAf;AACD;AACF;;AAED,iBAAOL,MAAP;AACD,SAtBD;AAuBD,OAxBY,CAFH,EA2BVF,MAAM,IAAIjB,QAAQ,CAACiB,MAAD,EAAS;AAAEW,QAAAA,WAAW,EAAEtB;AAAf,OAAT,CA3BR,EA4BVW,MAAM,IAAIf,MAAM,CAACe,MAAD,EAAS,MAAM,CAACN,OAAO,CAACkB,KAAxB,CA5BN,CAAZ;AA8BD,KA/BD,SA+BU;AACRf,MAAAA,OAAO;AACR;AACF;;AAED,SAAOT,iBAAiB,CAACI,EAAD,CAAxB;AACD","sourcesContent":["import errCode from 'err-code'\nimport parallel from 'it-parallel'\nimport map from 'it-map'\nimport filter from 'it-filter'\nimport { pipe } from 'it-pipe'\nimport { cleanCid } from './utils.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\nconst BLOCK_RM_CONCURRENCY = 8\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nexport function createRm ({ repo }) {\n  /**\n   * @type {import('ipfs-core-types/src/block').API<{}>[\"rm\"]}\n   */\n  async function * rm (cids, options = {}) {\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n\n    // We need to take a write lock here to ensure that adding and removing\n    // blocks are exclusive operations\n    const release = await repo.gcLock.writeLock()\n\n    try {\n      yield * pipe(\n        cids,\n        source => map(source, cid => {\n          return async () => {\n            cid = cleanCid(cid)\n\n            /** @type {import('ipfs-core-types/src/block').RmResult} */\n            const result = { cid }\n\n            try {\n              const has = await repo.blocks.has(cid)\n\n              if (!has) {\n                throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND')\n              }\n\n              await repo.blocks.delete(cid)\n            } catch (/** @type {any} */ err) {\n              if (!options.force) {\n                err.message = `cannot remove ${cid}: ${err.message}`\n                result.error = err\n              }\n            }\n\n            return result\n          }\n        }),\n        source => parallel(source, { concurrency: BLOCK_RM_CONCURRENCY }),\n        source => filter(source, () => !options.quiet)\n      )\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(rm)\n}\n"]},"metadata":{},"sourceType":"module"}