{"ast":null,"code":"import 'node-forge/lib/asn1.js';\nimport 'node-forge/lib/pbe.js';\nimport { CodeError } from '@libp2p/interfaces/errors'; // @ts-expect-error types are missing\n\nimport forge from 'node-forge/lib/forge.js';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport * as Ed25519 from './ed25519-class.js';\nimport generateEphemeralKeyPair from './ephemeral-keys.js';\nimport { importer } from './importer.js';\nimport { keyStretcher } from './key-stretcher.js';\nimport * as keysPBM from './keys.js';\nimport * as RSA from './rsa-class.js';\nimport * as Secp256k1 from './secp256k1-class.js';\nexport { keyStretcher };\nexport { generateEphemeralKeyPair };\nexport { keysPBM };\nexport const supportedKeys = {\n  rsa: RSA,\n  ed25519: Ed25519,\n  secp256k1: Secp256k1\n};\n\nfunction unsupportedKey(type) {\n  const supported = Object.keys(supportedKeys).join(' / ');\n  return new CodeError(`invalid or unsupported key type ${type}. Must be ${supported}`, 'ERR_UNSUPPORTED_KEY_TYPE');\n}\n\nfunction typeToKey(type) {\n  type = type.toLowerCase();\n\n  if (type === 'rsa' || type === 'ed25519' || type === 'secp256k1') {\n    return supportedKeys[type];\n  }\n\n  throw unsupportedKey(type);\n} // Generates a keypair of the given type and bitsize\n\n\nexport async function generateKeyPair(type, bits) {\n  return typeToKey(type).generateKeyPair(bits ?? 2048);\n} // Generates a keypair of the given type and bitsize\n// seed is a 32 byte uint8array\n\nexport async function generateKeyPairFromSeed(type, seed, bits) {\n  if (type.toLowerCase() !== 'ed25519') {\n    throw new CodeError('Seed key derivation is unimplemented for RSA or secp256k1', 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE');\n  }\n\n  return Ed25519.generateKeyPairFromSeed(seed);\n} // Converts a protobuf serialized public key into its\n// representative object\n\nexport function unmarshalPublicKey(buf) {\n  const decoded = keysPBM.PublicKey.decode(buf);\n  const data = decoded.Data ?? new Uint8Array();\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data);\n\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);\n\n    case keysPBM.KeyType.Secp256k1:\n      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);\n\n    default:\n      throw unsupportedKey(decoded.Type ?? 'RSA');\n  }\n} // Converts a public key object into a protobuf serialized public key\n\nexport function marshalPublicKey(key, type) {\n  type = (type ?? 'rsa').toLowerCase();\n  typeToKey(type); // check type\n\n  return key.bytes;\n} // Converts a protobuf serialized private key into its\n// representative object\n\nexport async function unmarshalPrivateKey(buf) {\n  const decoded = keysPBM.PrivateKey.decode(buf);\n  const data = decoded.Data ?? new Uint8Array();\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPrivateKey(data);\n\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);\n\n    case keysPBM.KeyType.Secp256k1:\n      return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);\n\n    default:\n      throw unsupportedKey(decoded.Type ?? 'RSA');\n  }\n} // Converts a private key object into a protobuf serialized private key\n\nexport function marshalPrivateKey(key, type) {\n  type = (type ?? 'rsa').toLowerCase();\n  typeToKey(type); // check type\n\n  return key.bytes;\n}\n/**\n *\n * @param {string} encryptedKey\n * @param {string} password\n */\n\nexport async function importKey(encryptedKey, password) {\n  try {\n    const key = await importer(encryptedKey, password);\n    return await unmarshalPrivateKey(key);\n  } catch (_) {// Ignore and try the old pem decrypt\n  } // Only rsa supports pem right now\n\n\n  const key = forge.pki.decryptRsaPrivateKey(encryptedKey, password);\n\n  if (key === null) {\n    throw new CodeError('Cannot read the key, most likely the password is wrong or not a RSA key', 'ERR_CANNOT_DECRYPT_PEM');\n  }\n\n  let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));\n  der = uint8ArrayFromString(der.getBytes(), 'ascii');\n  return supportedKeys.rsa.unmarshalRsaPrivateKey(der);\n}","map":{"version":3,"mappings":"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","names":["CodeError","forge","fromString","uint8ArrayFromString","Ed25519","generateEphemeralKeyPair","importer","keyStretcher","keysPBM","RSA","Secp256k1","supportedKeys","rsa","ed25519","secp256k1","unsupportedKey","type","supported","Object","keys","join","typeToKey","toLowerCase","generateKeyPair","bits","generateKeyPairFromSeed","seed","unmarshalPublicKey","buf","decoded","PublicKey","decode","data","Data","Uint8Array","Type","KeyType","unmarshalRsaPublicKey","unmarshalEd25519PublicKey","unmarshalSecp256k1PublicKey","marshalPublicKey","key","bytes","unmarshalPrivateKey","PrivateKey","unmarshalRsaPrivateKey","unmarshalEd25519PrivateKey","unmarshalSecp256k1PrivateKey","marshalPrivateKey","importKey","encryptedKey","password","_","pki","decryptRsaPrivateKey","der","asn1","toDer","privateKeyToAsn1","getBytes"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\crypto\\src\\keys\\index.ts"],"sourcesContent":["import 'node-forge/lib/asn1.js'\nimport 'node-forge/lib/pbe.js'\nimport { CodeError } from '@libp2p/interfaces/errors'\n// @ts-expect-error types are missing\nimport forge from 'node-forge/lib/forge.js'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport * as Ed25519 from './ed25519-class.js'\nimport generateEphemeralKeyPair from './ephemeral-keys.js'\nimport { importer } from './importer.js'\nimport { keyStretcher } from './key-stretcher.js'\nimport * as keysPBM from './keys.js'\nimport * as RSA from './rsa-class.js'\nimport * as Secp256k1 from './secp256k1-class.js'\nimport type { PrivateKey, PublicKey } from '@libp2p/interface-keys'\n\nexport { keyStretcher }\nexport { generateEphemeralKeyPair }\nexport { keysPBM }\n\nexport type KeyTypes = 'RSA' | 'Ed25519' | 'secp256k1'\n\nexport const supportedKeys = {\n  rsa: RSA,\n  ed25519: Ed25519,\n  secp256k1: Secp256k1\n}\n\nfunction unsupportedKey (type: string): CodeError<Record<string, never>> {\n  const supported = Object.keys(supportedKeys).join(' / ')\n  return new CodeError(`invalid or unsupported key type ${type}. Must be ${supported}`, 'ERR_UNSUPPORTED_KEY_TYPE')\n}\n\nfunction typeToKey (type: string): typeof RSA | typeof Ed25519 | typeof Secp256k1 {\n  type = type.toLowerCase()\n\n  if (type === 'rsa' || type === 'ed25519' || type === 'secp256k1') {\n    return supportedKeys[type]\n  }\n\n  throw unsupportedKey(type)\n}\n\n// Generates a keypair of the given type and bitsize\nexport async function generateKeyPair (type: KeyTypes, bits?: number): Promise<PrivateKey> { // eslint-disable-line require-await\n  return typeToKey(type).generateKeyPair(bits ?? 2048)\n}\n\n// Generates a keypair of the given type and bitsize\n// seed is a 32 byte uint8array\nexport async function generateKeyPairFromSeed (type: KeyTypes, seed: Uint8Array, bits?: number): Promise<PrivateKey> { // eslint-disable-line require-await\n  if (type.toLowerCase() !== 'ed25519') {\n    throw new CodeError('Seed key derivation is unimplemented for RSA or secp256k1', 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE')\n  }\n\n  return Ed25519.generateKeyPairFromSeed(seed)\n}\n\n// Converts a protobuf serialized public key into its\n// representative object\nexport function unmarshalPublicKey (buf: Uint8Array): PublicKey {\n  const decoded = keysPBM.PublicKey.decode(buf)\n  const data = decoded.Data ?? new Uint8Array()\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data)\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data)\n    case keysPBM.KeyType.Secp256k1:\n      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data)\n    default:\n      throw unsupportedKey(decoded.Type ?? 'RSA')\n  }\n}\n\n// Converts a public key object into a protobuf serialized public key\nexport function marshalPublicKey (key: { bytes: Uint8Array }, type?: string): Uint8Array {\n  type = (type ?? 'rsa').toLowerCase()\n  typeToKey(type) // check type\n  return key.bytes\n}\n\n// Converts a protobuf serialized private key into its\n// representative object\nexport async function unmarshalPrivateKey (buf: Uint8Array): Promise<PrivateKey> { // eslint-disable-line require-await\n  const decoded = keysPBM.PrivateKey.decode(buf)\n  const data = decoded.Data ?? new Uint8Array()\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPrivateKey(data)\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data)\n    case keysPBM.KeyType.Secp256k1:\n      return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data)\n    default:\n      throw unsupportedKey(decoded.Type ?? 'RSA')\n  }\n}\n\n// Converts a private key object into a protobuf serialized private key\nexport function marshalPrivateKey (key: { bytes: Uint8Array }, type?: string): Uint8Array {\n  type = (type ?? 'rsa').toLowerCase()\n  typeToKey(type) // check type\n  return key.bytes\n}\n\n/**\n *\n * @param {string} encryptedKey\n * @param {string} password\n */\nexport async function importKey (encryptedKey: string, password: string): Promise<PrivateKey> { // eslint-disable-line require-await\n  try {\n    const key = await importer(encryptedKey, password)\n    return await unmarshalPrivateKey(key)\n  } catch (_) {\n    // Ignore and try the old pem decrypt\n  }\n\n  // Only rsa supports pem right now\n  const key = forge.pki.decryptRsaPrivateKey(encryptedKey, password)\n  if (key === null) {\n    throw new CodeError('Cannot read the key, most likely the password is wrong or not a RSA key', 'ERR_CANNOT_DECRYPT_PEM')\n  }\n  let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key))\n  der = uint8ArrayFromString(der.getBytes(), 'ascii')\n  return supportedKeys.rsa.unmarshalRsaPrivateKey(der)\n}\n"]},"metadata":{},"sourceType":"module"}