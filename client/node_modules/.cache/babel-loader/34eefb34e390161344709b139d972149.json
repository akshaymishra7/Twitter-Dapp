{"ast":null,"code":"const RateLimiterAbstract = require('./RateLimiterAbstract');\n\nconst BlockedKeys = require('./component/BlockedKeys');\n\nconst RateLimiterRes = require('./RateLimiterRes');\n\nmodule.exports = class RateLimiterStoreAbstract extends RateLimiterAbstract {\n  /**\n   *\n   * @param opts Object Defaults {\n   *   ... see other in RateLimiterAbstract\n   *\n   *   inMemoryBlockOnConsumed: 40, // Number of points when key is blocked\n   *   inMemoryBlockDuration: 10, // Block duration in seconds\n   *   insuranceLimiter: RateLimiterAbstract\n   * }\n   */\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(opts);\n    this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed || opts.inmemoryBlockOnConsumed;\n    this.inMemoryBlockDuration = opts.inMemoryBlockDuration || opts.inmemoryBlockDuration;\n    this.insuranceLimiter = opts.insuranceLimiter;\n    this._inMemoryBlockedKeys = new BlockedKeys();\n  }\n\n  get client() {\n    return this._client;\n  }\n\n  set client(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('storeClient is not set');\n    }\n\n    this._client = value;\n  }\n  /**\n   * Have to be launched after consume\n   * It blocks key and execute evenly depending on result from store\n   *\n   * It uses _getRateLimiterRes function to prepare RateLimiterRes from store result\n   *\n   * @param resolve\n   * @param reject\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @param {Object} options\n   * @private\n   */\n\n\n  _afterConsume(resolve, reject, rlKey, changedPoints, storeResult) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n    const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);\n\n    if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0) && res.consumedPoints >= this.inMemoryBlockOnConsumed) {\n      this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);\n\n      if (res.consumedPoints > this.points) {\n        return reject(res);\n      } else {\n        return resolve(res);\n      }\n    } else if (res.consumedPoints > this.points) {\n      let blockPromise = Promise.resolve(); // Block only first time when consumed more than points\n\n      if (this.blockDuration > 0 && res.consumedPoints <= this.points + changedPoints) {\n        res.msBeforeNext = this.msBlockDuration;\n        blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);\n      }\n\n      if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {\n        // Block key for this.inMemoryBlockDuration seconds\n        this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);\n\n        res.msBeforeNext = this.msInMemoryBlockDuration;\n      }\n\n      blockPromise.then(() => {\n        reject(res);\n      }).catch(err => {\n        reject(err);\n      });\n    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n      let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n\n      if (delay < this.execEvenlyMinDelayMs) {\n        delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n      }\n\n      setTimeout(resolve, delay, res);\n    } else {\n      resolve(res);\n    }\n  }\n\n  _handleError(err, funcName, resolve, reject, key) {\n    let data = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    let options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n    if (!(this.insuranceLimiter instanceof RateLimiterAbstract)) {\n      reject(err);\n    } else {\n      this.insuranceLimiter[funcName](key, data, options).then(res => {\n        resolve(res);\n      }).catch(res => {\n        reject(res);\n      });\n    }\n  }\n  /**\n   * @deprecated Use camelCase version\n   * @returns {BlockedKeys}\n   * @private\n   */\n\n\n  get _inmemoryBlockedKeys() {\n    return this._inMemoryBlockedKeys;\n  }\n  /**\n   * @deprecated Use camelCase version\n   * @param rlKey\n   * @returns {number}\n   */\n\n\n  getInmemoryBlockMsBeforeExpire(rlKey) {\n    return this.getInMemoryBlockMsBeforeExpire(rlKey);\n  }\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number|number}\n   */\n\n\n  get inmemoryBlockOnConsumed() {\n    return this.inMemoryBlockOnConsumed;\n  }\n  /**\n   * @deprecated Use camelCase version\n   * @param value\n   */\n\n\n  set inmemoryBlockOnConsumed(value) {\n    this.inMemoryBlockOnConsumed = value;\n  }\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number|number}\n   */\n\n\n  get inmemoryBlockDuration() {\n    return this.inMemoryBlockDuration;\n  }\n  /**\n   * @deprecated Use camelCase version\n   * @param value\n   */\n\n\n  set inmemoryBlockDuration(value) {\n    this.inMemoryBlockDuration = value;\n  }\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number}\n   */\n\n\n  get msInmemoryBlockDuration() {\n    return this.inMemoryBlockDuration * 1000;\n  }\n\n  getInMemoryBlockMsBeforeExpire(rlKey) {\n    if (this.inMemoryBlockOnConsumed > 0) {\n      return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);\n    }\n\n    return 0;\n  }\n\n  get inMemoryBlockOnConsumed() {\n    return this._inMemoryBlockOnConsumed;\n  }\n\n  set inMemoryBlockOnConsumed(value) {\n    this._inMemoryBlockOnConsumed = value ? parseInt(value) : 0;\n\n    if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {\n      throw new Error('inMemoryBlockOnConsumed option must be greater or equal \"points\" option');\n    }\n  }\n\n  get inMemoryBlockDuration() {\n    return this._inMemoryBlockDuration;\n  }\n\n  set inMemoryBlockDuration(value) {\n    this._inMemoryBlockDuration = value ? parseInt(value) : 0;\n\n    if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {\n      throw new Error('inMemoryBlockOnConsumed option must be set up');\n    }\n  }\n\n  get msInMemoryBlockDuration() {\n    return this._inMemoryBlockDuration * 1000;\n  }\n\n  get insuranceLimiter() {\n    return this._insuranceLimiter;\n  }\n\n  set insuranceLimiter(value) {\n    if (typeof value !== 'undefined' && !(value instanceof RateLimiterAbstract)) {\n      throw new Error('insuranceLimiter must be instance of RateLimiterAbstract');\n    }\n\n    this._insuranceLimiter = value;\n\n    if (this._insuranceLimiter) {\n      this._insuranceLimiter.blockDuration = this.blockDuration;\n      this._insuranceLimiter.execEvenly = this.execEvenly;\n    }\n  }\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n\n\n  block(key, secDuration) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const msDuration = secDuration * 1000;\n    return this._block(this.getKey(key), this.points + 1, msDuration, options);\n  }\n  /**\n   * Set points by key for any duration\n   *\n   * @param key\n   * @param points\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n\n\n  set(key, points, secDuration) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n    return this._block(this.getKey(key), points, msDuration, options);\n  }\n  /**\n   *\n   * @param key\n   * @param pointsToConsume\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n\n\n  consume(key) {\n    let pointsToConsume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new Promise((resolve, reject) => {\n      const rlKey = this.getKey(key);\n      const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);\n\n      if (inMemoryBlockMsBeforeExpire > 0) {\n        return reject(new RateLimiterRes(0, inMemoryBlockMsBeforeExpire));\n      }\n\n      this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1000, false, options).then(res => {\n        this._afterConsume(resolve, reject, rlKey, pointsToConsume, res);\n      }).catch(err => {\n        this._handleError(err, 'consume', resolve, reject, key, pointsToConsume, options);\n      });\n    });\n  }\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n\n\n  penalty(key) {\n    let points = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, points, this._getKeySecDuration(options) * 1000, false, options).then(res => {\n        resolve(this._getRateLimiterRes(rlKey, points, res));\n      }).catch(err => {\n        this._handleError(err, 'penalty', resolve, reject, key, points, options);\n      });\n    });\n  }\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n\n\n  reward(key) {\n    let points = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1000, false, options).then(res => {\n        resolve(this._getRateLimiterRes(rlKey, -points, res));\n      }).catch(err => {\n        this._handleError(err, 'reward', resolve, reject, key, points, options);\n      });\n    });\n  }\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>|null\n   */\n\n\n  get(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._get(rlKey, options).then(res => {\n        if (res === null || typeof res === 'undefined') {\n          resolve(null);\n        } else {\n          resolve(this._getRateLimiterRes(rlKey, 0, res));\n        }\n      }).catch(err => {\n        this._handleError(err, 'get', resolve, reject, key, options);\n      });\n    });\n  }\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<boolean>\n   */\n\n\n  delete(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._delete(rlKey, options).then(res => {\n        this._inMemoryBlockedKeys.delete(rlKey);\n\n        resolve(res);\n      }).catch(err => {\n        this._handleError(err, 'delete', resolve, reject, key, options);\n      });\n    });\n  }\n  /**\n   * Cleanup keys no-matter expired or not.\n   */\n\n\n  deleteInMemoryBlockedAll() {\n    this._inMemoryBlockedKeys.delete();\n  }\n  /**\n   * Get RateLimiterRes object filled depending on storeResult, which specific for exact store\n   *\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @private\n   */\n\n\n  _getRateLimiterRes(rlKey, changedPoints, storeResult) {\n    // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_getRateLimiterRes'!\");\n  }\n  /**\n   * Block key for this.msBlockDuration milliseconds\n   * Usually, it just prolongs lifetime of key\n   *\n   * @param rlKey\n   * @param initPoints\n   * @param msDuration\n   * @param {Object} options\n   *\n   * @return Promise<any>\n   */\n\n\n  _block(rlKey, initPoints, msDuration) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, initPoints, msDuration, true, options).then(() => {\n        resolve(new RateLimiterRes(0, msDuration > 0 ? msDuration : -1, initPoints));\n      }).catch(err => {\n        this._handleError(err, 'block', resolve, reject, this.parseKey(rlKey), msDuration / 1000, options);\n      });\n    });\n  }\n  /**\n   * Have to be implemented in every limiter\n   * Resolve with raw result from Store OR null if rlKey is not set\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n\n\n  _get(rlKey) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_get'!\");\n  }\n  /**\n   * Have to be implemented\n   * Resolve with true OR false if rlKey doesn't exist\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n\n\n  _delete(rlKey) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_delete'!\");\n  }\n  /**\n   * Have to be implemented\n   * Resolve with object used for {@link _getRateLimiterRes} to generate {@link RateLimiterRes}\n   *\n   * @param {string} rlKey\n   * @param {number} points\n   * @param {number} msDuration\n   * @param {boolean} forceExpire\n   * @param {Object} options\n   * @abstract\n   *\n   * @return Promise<Object>\n   */\n\n\n  _upsert(rlKey, points, msDuration) {\n    let forceExpire = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    throw new Error(\"You have to implement the method '_upsert'!\");\n  }\n\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/rate-limiter-flexible/lib/RateLimiterStoreAbstract.js"],"names":["RateLimiterAbstract","require","BlockedKeys","RateLimiterRes","module","exports","RateLimiterStoreAbstract","constructor","opts","inMemoryBlockOnConsumed","inmemoryBlockOnConsumed","inMemoryBlockDuration","inmemoryBlockDuration","insuranceLimiter","_inMemoryBlockedKeys","client","_client","value","Error","_afterConsume","resolve","reject","rlKey","changedPoints","storeResult","options","res","_getRateLimiterRes","consumedPoints","addMs","msBeforeNext","points","blockPromise","Promise","blockDuration","msBlockDuration","_block","add","msInMemoryBlockDuration","then","catch","err","execEvenly","isFirstInDuration","delay","Math","ceil","remainingPoints","execEvenlyMinDelayMs","setTimeout","_handleError","funcName","key","data","_inmemoryBlockedKeys","getInmemoryBlockMsBeforeExpire","getInMemoryBlockMsBeforeExpire","msInmemoryBlockDuration","msBeforeExpire","_inMemoryBlockOnConsumed","parseInt","_inMemoryBlockDuration","_insuranceLimiter","block","secDuration","msDuration","getKey","set","duration","consume","pointsToConsume","inMemoryBlockMsBeforeExpire","_upsert","_getKeySecDuration","penalty","reward","get","_get","delete","_delete","deleteInMemoryBlockedAll","initPoints","parseKey","forceExpire"],"mappings":"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","sourcesContent":["const RateLimiterAbstract = require('./RateLimiterAbstract');\nconst BlockedKeys = require('./component/BlockedKeys');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nmodule.exports = class RateLimiterStoreAbstract extends RateLimiterAbstract {\n  /**\n   *\n   * @param opts Object Defaults {\n   *   ... see other in RateLimiterAbstract\n   *\n   *   inMemoryBlockOnConsumed: 40, // Number of points when key is blocked\n   *   inMemoryBlockDuration: 10, // Block duration in seconds\n   *   insuranceLimiter: RateLimiterAbstract\n   * }\n   */\n  constructor(opts = {}) {\n    super(opts);\n\n    this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed || opts.inmemoryBlockOnConsumed;\n    this.inMemoryBlockDuration = opts.inMemoryBlockDuration || opts.inmemoryBlockDuration;\n    this.insuranceLimiter = opts.insuranceLimiter;\n    this._inMemoryBlockedKeys = new BlockedKeys();\n  }\n\n  get client() {\n    return this._client;\n  }\n\n  set client(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('storeClient is not set');\n    }\n    this._client = value;\n  }\n\n  /**\n   * Have to be launched after consume\n   * It blocks key and execute evenly depending on result from store\n   *\n   * It uses _getRateLimiterRes function to prepare RateLimiterRes from store result\n   *\n   * @param resolve\n   * @param reject\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @param {Object} options\n   * @private\n   */\n  _afterConsume(resolve, reject, rlKey, changedPoints, storeResult, options = {}) {\n    const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);\n\n    if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0)\n      && res.consumedPoints >= this.inMemoryBlockOnConsumed\n    ) {\n      this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);\n      if (res.consumedPoints > this.points) {\n        return reject(res);\n      } else {\n        return resolve(res)\n      }\n    } else if (res.consumedPoints > this.points) {\n      let blockPromise = Promise.resolve();\n      // Block only first time when consumed more than points\n      if (this.blockDuration > 0 && res.consumedPoints <= (this.points + changedPoints)) {\n        res.msBeforeNext = this.msBlockDuration;\n        blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);\n      }\n\n      if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {\n        // Block key for this.inMemoryBlockDuration seconds\n        this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);\n        res.msBeforeNext = this.msInMemoryBlockDuration;\n      }\n\n      blockPromise\n        .then(() => {\n          reject(res);\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n      let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n      if (delay < this.execEvenlyMinDelayMs) {\n        delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n      }\n\n      setTimeout(resolve, delay, res);\n    } else {\n      resolve(res);\n    }\n  }\n\n  _handleError(err, funcName, resolve, reject, key, data = false, options = {}) {\n    if (!(this.insuranceLimiter instanceof RateLimiterAbstract)) {\n      reject(err);\n    } else {\n      this.insuranceLimiter[funcName](key, data, options)\n        .then((res) => {\n          resolve(res);\n        })\n        .catch((res) => {\n          reject(res);\n        });\n    }\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {BlockedKeys}\n   * @private\n   */\n  get _inmemoryBlockedKeys() {\n    return this._inMemoryBlockedKeys\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @param rlKey\n   * @returns {number}\n   */\n  getInmemoryBlockMsBeforeExpire(rlKey) {\n    return this.getInMemoryBlockMsBeforeExpire(rlKey)\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number|number}\n   */\n  get inmemoryBlockOnConsumed() {\n    return this.inMemoryBlockOnConsumed;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @param value\n   */\n  set inmemoryBlockOnConsumed(value) {\n    this.inMemoryBlockOnConsumed = value;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number|number}\n   */\n  get inmemoryBlockDuration() {\n    return this.inMemoryBlockDuration;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @param value\n   */\n  set inmemoryBlockDuration(value) {\n    this.inMemoryBlockDuration = value\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number}\n   */\n  get msInmemoryBlockDuration() {\n    return this.inMemoryBlockDuration * 1000;\n  }\n\n  getInMemoryBlockMsBeforeExpire(rlKey) {\n    if (this.inMemoryBlockOnConsumed > 0) {\n      return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);\n    }\n\n    return 0;\n  }\n\n  get inMemoryBlockOnConsumed() {\n    return this._inMemoryBlockOnConsumed;\n  }\n\n  set inMemoryBlockOnConsumed(value) {\n    this._inMemoryBlockOnConsumed = value ? parseInt(value) : 0;\n    if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {\n      throw new Error('inMemoryBlockOnConsumed option must be greater or equal \"points\" option');\n    }\n  }\n\n  get inMemoryBlockDuration() {\n    return this._inMemoryBlockDuration;\n  }\n\n  set inMemoryBlockDuration(value) {\n    this._inMemoryBlockDuration = value ? parseInt(value) : 0;\n    if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {\n      throw new Error('inMemoryBlockOnConsumed option must be set up');\n    }\n  }\n\n  get msInMemoryBlockDuration() {\n    return this._inMemoryBlockDuration * 1000;\n  }\n\n  get insuranceLimiter() {\n    return this._insuranceLimiter;\n  }\n\n  set insuranceLimiter(value) {\n    if (typeof value !== 'undefined' && !(value instanceof RateLimiterAbstract)) {\n      throw new Error('insuranceLimiter must be instance of RateLimiterAbstract');\n    }\n    this._insuranceLimiter = value;\n    if (this._insuranceLimiter) {\n      this._insuranceLimiter.blockDuration = this.blockDuration;\n      this._insuranceLimiter.execEvenly = this.execEvenly;\n    }\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n  block(key, secDuration, options = {}) {\n    const msDuration = secDuration * 1000;\n    return this._block(this.getKey(key), this.points + 1, msDuration, options);\n  }\n\n  /**\n   * Set points by key for any duration\n   *\n   * @param key\n   * @param points\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n  set(key, points, secDuration, options = {}) {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n    return this._block(this.getKey(key), points, msDuration, options);\n  }\n\n  /**\n   *\n   * @param key\n   * @param pointsToConsume\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const rlKey = this.getKey(key);\n\n      const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);\n      if (inMemoryBlockMsBeforeExpire > 0) {\n        return reject(new RateLimiterRes(0, inMemoryBlockMsBeforeExpire));\n      }\n\n      this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          this._afterConsume(resolve, reject, rlKey, pointsToConsume, res);\n        })\n        .catch((err) => {\n          this._handleError(err, 'consume', resolve, reject, key, pointsToConsume, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  penalty(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, points, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          resolve(this._getRateLimiterRes(rlKey, points, res));\n        })\n        .catch((err) => {\n          this._handleError(err, 'penalty', resolve, reject, key, points, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  reward(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          resolve(this._getRateLimiterRes(rlKey, -points, res));\n        })\n        .catch((err) => {\n          this._handleError(err, 'reward', resolve, reject, key, points, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>|null\n   */\n  get(key, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._get(rlKey, options)\n        .then((res) => {\n          if (res === null || typeof res === 'undefined') {\n            resolve(null);\n          } else {\n            resolve(this._getRateLimiterRes(rlKey, 0, res));\n          }\n        })\n        .catch((err) => {\n          this._handleError(err, 'get', resolve, reject, key, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<boolean>\n   */\n  delete(key, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._delete(rlKey, options)\n        .then((res) => {\n          this._inMemoryBlockedKeys.delete(rlKey);\n          resolve(res);\n        })\n        .catch((err) => {\n          this._handleError(err, 'delete', resolve, reject, key, options);\n        });\n    });\n  }\n\n  /**\n   * Cleanup keys no-matter expired or not.\n   */\n  deleteInMemoryBlockedAll() {\n    this._inMemoryBlockedKeys.delete();\n  }\n\n  /**\n   * Get RateLimiterRes object filled depending on storeResult, which specific for exact store\n   *\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @private\n   */\n  _getRateLimiterRes(rlKey, changedPoints, storeResult) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_getRateLimiterRes'!\");\n  }\n\n  /**\n   * Block key for this.msBlockDuration milliseconds\n   * Usually, it just prolongs lifetime of key\n   *\n   * @param rlKey\n   * @param initPoints\n   * @param msDuration\n   * @param {Object} options\n   *\n   * @return Promise<any>\n   */\n  _block(rlKey, initPoints, msDuration, options = {}) {\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, initPoints, msDuration, true, options)\n        .then(() => {\n          resolve(new RateLimiterRes(0, msDuration > 0 ? msDuration : -1, initPoints));\n        })\n        .catch((err) => {\n          this._handleError(err, 'block', resolve, reject, this.parseKey(rlKey), msDuration / 1000, options);\n        });\n    });\n  }\n\n  /**\n   * Have to be implemented in every limiter\n   * Resolve with raw result from Store OR null if rlKey is not set\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n  _get(rlKey, options = {}) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_get'!\");\n  }\n\n  /**\n   * Have to be implemented\n   * Resolve with true OR false if rlKey doesn't exist\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n  _delete(rlKey, options = {}) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_delete'!\");\n  }\n\n  /**\n   * Have to be implemented\n   * Resolve with object used for {@link _getRateLimiterRes} to generate {@link RateLimiterRes}\n   *\n   * @param {string} rlKey\n   * @param {number} points\n   * @param {number} msDuration\n   * @param {boolean} forceExpire\n   * @param {Object} options\n   * @abstract\n   *\n   * @return Promise<Object>\n   */\n  _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {\n    throw new Error(\"You have to implement the method '_upsert'!\");\n  }\n};\n"]},"metadata":{},"sourceType":"script"}