{"ast":null,"code":"// MaxRecordAge specifies the maximum time that any node will hold onto a record\n// from the time its received. This does not apply to any other forms of validity that\n// the record may contain.\n// For example, a record may contain an ipns entry with an EOL saying its valid\n// until the year 2020 (a great time in the future). For that record to stick around\n// it must be rebroadcasted more frequently than once every 'MaxRecordAge'\nexport const second = 1000;\nexport const minute = 60 * second;\nexport const hour = 60 * minute;\nexport const MAX_RECORD_AGE = 36 * hour;\nexport const LAN_PREFIX = '/lan';\nexport const PROTOCOL_PREFIX = '/ipfs';\nexport const PROTOCOL_DHT = '/kad/1.0.0';\nexport const RECORD_KEY_PREFIX = '/dht/record';\nexport const PROVIDER_KEY_PREFIX = '/dht/provider';\nexport const PROVIDERS_LRU_CACHE_SIZE = 256;\nexport const PROVIDERS_VALIDITY = 24 * hour;\nexport const PROVIDERS_CLEANUP_INTERVAL = hour;\nexport const READ_MESSAGE_TIMEOUT = 10 * second; // The number of records that will be retrieved on a call to getMany()\n\nexport const GET_MANY_RECORD_COUNT = 16; // K is the maximum number of requests to perform before returning failure\n\nexport const K = 20; // Alpha is the concurrency for asynchronous requests\n\nexport const ALPHA = 3; // How often we look for our closest DHT neighbours\n\nexport const QUERY_SELF_INTERVAL = Number(5 * minute); // How long to look for our closest DHT neighbours for\n\nexport const QUERY_SELF_TIMEOUT = Number(30 * second); // How often we try to find new peers\n\nexport const TABLE_REFRESH_INTERVAL = Number(5 * minute); // How how long to look for new peers for\n\nexport const TABLE_REFRESH_QUERY_TIMEOUT = Number(30 * second); // When a timeout is not specified, run a query for this long\n\nexport const DEFAULT_QUERY_TIMEOUT = Number(30 * second);","map":{"version":3,"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAO,MAAMA,MAAM,GAAG,IAAf;AACP,OAAO,MAAMC,MAAM,GAAG,KAAKD,MAApB;AACP,OAAO,MAAME,IAAI,GAAG,KAAKD,MAAlB;AAEP,OAAO,MAAME,cAAc,GAAG,KAAKD,IAA5B;AAEP,OAAO,MAAME,UAAU,GAAG,MAAnB;AAEP,OAAO,MAAMC,eAAe,GAAG,OAAxB;AAEP,OAAO,MAAMC,YAAY,GAAG,YAArB;AAEP,OAAO,MAAMC,iBAAiB,GAAG,aAA1B;AAEP,OAAO,MAAMC,mBAAmB,GAAG,eAA5B;AAEP,OAAO,MAAMC,wBAAwB,GAAG,GAAjC;AAEP,OAAO,MAAMC,kBAAkB,GAAG,KAAKR,IAAhC;AAEP,OAAO,MAAMS,0BAA0B,GAAGT,IAAnC;AAEP,OAAO,MAAMU,oBAAoB,GAAG,KAAKZ,MAAlC,C,CAEP;;AACA,OAAO,MAAMa,qBAAqB,GAAG,EAA9B,C,CAEP;;AACA,OAAO,MAAMC,CAAC,GAAG,EAAV,C,CAEP;;AACA,OAAO,MAAMC,KAAK,GAAG,CAAd,C,CAEP;;AACA,OAAO,MAAMC,mBAAmB,GAAGC,MAAM,CAAC,IAAIhB,MAAL,CAAlC,C,CAEP;;AACA,OAAO,MAAMiB,kBAAkB,GAAGD,MAAM,CAAC,KAAKjB,MAAN,CAAjC,C,CAEP;;AACA,OAAO,MAAMmB,sBAAsB,GAAGF,MAAM,CAAC,IAAIhB,MAAL,CAArC,C,CAEP;;AACA,OAAO,MAAMmB,2BAA2B,GAAGH,MAAM,CAAC,KAAKjB,MAAN,CAA1C,C,CAEP;;AACA,OAAO,MAAMqB,qBAAqB,GAAGJ,MAAM,CAAC,KAAKjB,MAAN,CAApC","names":["second","minute","hour","MAX_RECORD_AGE","LAN_PREFIX","PROTOCOL_PREFIX","PROTOCOL_DHT","RECORD_KEY_PREFIX","PROVIDER_KEY_PREFIX","PROVIDERS_LRU_CACHE_SIZE","PROVIDERS_VALIDITY","PROVIDERS_CLEANUP_INTERVAL","READ_MESSAGE_TIMEOUT","GET_MANY_RECORD_COUNT","K","ALPHA","QUERY_SELF_INTERVAL","Number","QUERY_SELF_TIMEOUT","TABLE_REFRESH_INTERVAL","TABLE_REFRESH_QUERY_TIMEOUT","DEFAULT_QUERY_TIMEOUT"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\constants.ts"],"sourcesContent":["// MaxRecordAge specifies the maximum time that any node will hold onto a record\n// from the time its received. This does not apply to any other forms of validity that\n// the record may contain.\n// For example, a record may contain an ipns entry with an EOL saying its valid\n// until the year 2020 (a great time in the future). For that record to stick around\n// it must be rebroadcasted more frequently than once every 'MaxRecordAge'\n\nexport const second = 1000\nexport const minute = 60 * second\nexport const hour = 60 * minute\n\nexport const MAX_RECORD_AGE = 36 * hour\n\nexport const LAN_PREFIX = '/lan'\n\nexport const PROTOCOL_PREFIX = '/ipfs'\n\nexport const PROTOCOL_DHT = '/kad/1.0.0'\n\nexport const RECORD_KEY_PREFIX = '/dht/record'\n\nexport const PROVIDER_KEY_PREFIX = '/dht/provider'\n\nexport const PROVIDERS_LRU_CACHE_SIZE = 256\n\nexport const PROVIDERS_VALIDITY = 24 * hour\n\nexport const PROVIDERS_CLEANUP_INTERVAL = hour\n\nexport const READ_MESSAGE_TIMEOUT = 10 * second\n\n// The number of records that will be retrieved on a call to getMany()\nexport const GET_MANY_RECORD_COUNT = 16\n\n// K is the maximum number of requests to perform before returning failure\nexport const K = 20\n\n// Alpha is the concurrency for asynchronous requests\nexport const ALPHA = 3\n\n// How often we look for our closest DHT neighbours\nexport const QUERY_SELF_INTERVAL = Number(5 * minute)\n\n// How long to look for our closest DHT neighbours for\nexport const QUERY_SELF_TIMEOUT = Number(30 * second)\n\n// How often we try to find new peers\nexport const TABLE_REFRESH_INTERVAL = Number(5 * minute)\n\n// How how long to look for new peers for\nexport const TABLE_REFRESH_QUERY_TIMEOUT = Number(30 * second)\n\n// When a timeout is not specified, run a query for this long\nexport const DEFAULT_QUERY_TIMEOUT = Number(30 * second)\n"]},"metadata":{},"sourceType":"module"}