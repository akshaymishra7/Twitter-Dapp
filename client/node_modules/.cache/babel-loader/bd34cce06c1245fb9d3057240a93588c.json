{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { validateAddrs } from './utils.js';\nimport { StreamHandler } from './stream-handler.js';\nimport { CircuitRelay as CircuitPB } from '../pb/index.js';\nimport { pipe } from 'it-pipe';\nimport { codes as Errors } from '../../errors.js';\nimport { stop } from './stop.js';\nimport { RELAY_CODEC } from '../multicodec.js';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nconst log = logger('libp2p:circuit:hop');\nexport async function handleHop(hopRequest) {\n  const {\n    connection,\n    request,\n    streamHandler,\n    circuit,\n    connectionManager\n  } = hopRequest; // Ensure hop is enabled\n\n  if (!circuit.hopEnabled()) {\n    log('HOP request received but we are not acting as a relay');\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n    });\n  } // Validate the HOP request has the required input\n\n\n  try {\n    validateAddrs(request, streamHandler);\n  } catch (err) {\n    log.error('invalid hop request via peer %p %o', connection.remotePeer, err);\n    return;\n  }\n\n  if (request.dstPeer == null) {\n    log('HOP request received but we do not receive a dstPeer');\n    return;\n  } // Get the connection to the destination (stop) peer\n\n\n  const destinationPeer = peerIdFromBytes(request.dstPeer.id);\n  const destinationConnections = connectionManager.getConnections(destinationPeer);\n\n  if (destinationConnections.length === 0 && !circuit.hopActive()) {\n    log('HOP request received but we are not connected to the destination peer');\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n    });\n  } // TODO: Handle being an active relay\n\n\n  if (destinationConnections.length === 0) {\n    log('did not have connection to remote peer');\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n    });\n  } // Handle the incoming HOP request by performing a STOP request\n\n\n  const stopRequest = {\n    type: CircuitPB.Type.STOP,\n    dstPeer: request.dstPeer,\n    srcPeer: request.srcPeer\n  };\n  let destinationStream;\n\n  try {\n    log('performing STOP request');\n    const result = await stop({\n      connection: destinationConnections[0],\n      request: stopRequest\n    });\n\n    if (result == null) {\n      throw new Error('Could not stop');\n    }\n\n    destinationStream = result;\n  } catch (err) {\n    log.error(err);\n    return;\n  }\n\n  log('hop request from %p is valid', connection.remotePeer);\n  streamHandler.write({\n    type: CircuitPB.Type.STATUS,\n    code: CircuitPB.Status.SUCCESS\n  });\n  const sourceStream = streamHandler.rest();\n  log('creating related connections'); // Short circuit the two streams to create the relayed connection\n\n  return await pipe(sourceStream, destinationStream, sourceStream);\n}\n/**\n * Performs a HOP request to a relay peer, to request a connection to another\n * peer. A new, virtual, connection will be created between the two via the relay.\n */\n\nexport async function hop(options) {\n  const {\n    connection,\n    request,\n    signal\n  } = options; // Create a new stream to the relay\n\n  const stream = await connection.newStream(RELAY_CODEC, {\n    signal\n  }); // Send the HOP request\n\n  const streamHandler = new StreamHandler({\n    stream\n  });\n  streamHandler.write(request);\n  const response = await streamHandler.read();\n\n  if (response == null) {\n    throw errCode(new Error('HOP request had no response'), Errors.ERR_HOP_REQUEST_FAILED);\n  }\n\n  if (response.code === CircuitPB.Status.SUCCESS) {\n    log('hop request was successful');\n    return streamHandler.rest();\n  }\n\n  log('hop request failed with code %d, closing stream', response.code);\n  streamHandler.close();\n  throw errCode(new Error(`HOP request failed with code \"${response.code ?? 'unknown'}\"`), Errors.ERR_HOP_REQUEST_FAILED);\n}\n/**\n * Performs a CAN_HOP request to a relay peer, in order to understand its capabilities\n */\n\nexport async function canHop(options) {\n  const {\n    connection,\n    signal\n  } = options; // Create a new stream to the relay\n\n  const stream = await connection.newStream(RELAY_CODEC, {\n    signal\n  }); // Send the HOP request\n\n  const streamHandler = new StreamHandler({\n    stream\n  });\n  streamHandler.write({\n    type: CircuitPB.Type.CAN_HOP\n  });\n  const response = await streamHandler.read();\n  await streamHandler.close();\n\n  if (response == null || response.code !== CircuitPB.Status.SUCCESS) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Creates an unencoded CAN_HOP response based on the Circuits configuration\n */\n\nexport function handleCanHop(options) {\n  const {\n    connection,\n    streamHandler,\n    circuit\n  } = options;\n  const canHop = circuit.hopEnabled();\n  log('can hop (%s) request from %p', canHop, connection.remotePeer);\n  streamHandler.end({\n    type: CircuitPB.Type.STATUS,\n    code: canHop ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n  });\n}","map":{"version":3,"mappings":"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","names":["logger","errCode","validateAddrs","StreamHandler","CircuitRelay","CircuitPB","pipe","codes","Errors","stop","RELAY_CODEC","peerIdFromBytes","log","handleHop","hopRequest","connection","request","streamHandler","circuit","connectionManager","hopEnabled","end","type","Type","STATUS","code","Status","HOP_CANT_SPEAK_RELAY","err","error","remotePeer","dstPeer","destinationPeer","id","destinationConnections","getConnections","length","hopActive","HOP_NO_CONN_TO_DST","stopRequest","STOP","srcPeer","destinationStream","result","Error","write","SUCCESS","sourceStream","rest","hop","options","signal","stream","newStream","response","read","ERR_HOP_REQUEST_FAILED","close","canHop","CAN_HOP","handleCanHop"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\circuit\\circuit\\hop.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { validateAddrs } from './utils.js'\nimport { StreamHandler } from './stream-handler.js'\nimport { CircuitRelay as CircuitPB } from '../pb/index.js'\nimport { pipe } from 'it-pipe'\nimport { codes as Errors } from '../../errors.js'\nimport { stop } from './stop.js'\nimport { RELAY_CODEC } from '../multicodec.js'\nimport type { Connection } from '@libp2p/interface-connection'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport type { Duplex } from 'it-stream-types'\nimport type { Circuit } from '../transport.js'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst log = logger('libp2p:circuit:hop')\n\nexport interface HopRequest {\n  connection: Connection\n  request: CircuitPB\n  streamHandler: StreamHandler\n  circuit: Circuit\n  connectionManager: ConnectionManager\n}\n\nexport async function handleHop (hopRequest: HopRequest): Promise<void> {\n  const {\n    connection,\n    request,\n    streamHandler,\n    circuit,\n    connectionManager\n  } = hopRequest\n\n  // Ensure hop is enabled\n  if (!circuit.hopEnabled()) {\n    log('HOP request received but we are not acting as a relay')\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n    })\n  }\n\n  // Validate the HOP request has the required input\n  try {\n    validateAddrs(request, streamHandler)\n  } catch (err: any) {\n    log.error('invalid hop request via peer %p %o', connection.remotePeer, err)\n\n    return\n  }\n\n  if (request.dstPeer == null) {\n    log('HOP request received but we do not receive a dstPeer')\n    return\n  }\n\n  // Get the connection to the destination (stop) peer\n  const destinationPeer = peerIdFromBytes(request.dstPeer.id)\n\n  const destinationConnections = connectionManager.getConnections(destinationPeer)\n  if (destinationConnections.length === 0 && !circuit.hopActive()) {\n    log('HOP request received but we are not connected to the destination peer')\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n    })\n  }\n\n  // TODO: Handle being an active relay\n  if (destinationConnections.length === 0) {\n    log('did not have connection to remote peer')\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n    })\n  }\n\n  // Handle the incoming HOP request by performing a STOP request\n  const stopRequest = {\n    type: CircuitPB.Type.STOP,\n    dstPeer: request.dstPeer,\n    srcPeer: request.srcPeer\n  }\n\n  let destinationStream: Duplex<Uint8ArrayList>\n  try {\n    log('performing STOP request')\n    const result = await stop({\n      connection: destinationConnections[0],\n      request: stopRequest\n    })\n\n    if (result == null) {\n      throw new Error('Could not stop')\n    }\n\n    destinationStream = result\n  } catch (err: any) {\n    log.error(err)\n\n    return\n  }\n\n  log('hop request from %p is valid', connection.remotePeer)\n  streamHandler.write({\n    type: CircuitPB.Type.STATUS,\n    code: CircuitPB.Status.SUCCESS\n  })\n  const sourceStream = streamHandler.rest()\n\n  log('creating related connections')\n  // Short circuit the two streams to create the relayed connection\n  return await pipe(\n    sourceStream,\n    destinationStream,\n    sourceStream\n  )\n}\n\nexport interface HopConfig extends AbortOptions {\n  connection: Connection\n  request: CircuitPB\n}\n\n/**\n * Performs a HOP request to a relay peer, to request a connection to another\n * peer. A new, virtual, connection will be created between the two via the relay.\n */\nexport async function hop (options: HopConfig): Promise<Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array>> {\n  const {\n    connection,\n    request,\n    signal\n  } = options\n\n  // Create a new stream to the relay\n  const stream = await connection.newStream(RELAY_CODEC, {\n    signal\n  })\n  // Send the HOP request\n  const streamHandler = new StreamHandler({ stream })\n  streamHandler.write(request)\n\n  const response = await streamHandler.read()\n\n  if (response == null) {\n    throw errCode(new Error('HOP request had no response'), Errors.ERR_HOP_REQUEST_FAILED)\n  }\n\n  if (response.code === CircuitPB.Status.SUCCESS) {\n    log('hop request was successful')\n\n    return streamHandler.rest()\n  }\n\n  log('hop request failed with code %d, closing stream', response.code)\n  streamHandler.close()\n\n  throw errCode(new Error(`HOP request failed with code \"${response.code ?? 'unknown'}\"`), Errors.ERR_HOP_REQUEST_FAILED)\n}\n\nexport interface CanHopOptions extends AbortOptions {\n  connection: Connection\n}\n\n/**\n * Performs a CAN_HOP request to a relay peer, in order to understand its capabilities\n */\nexport async function canHop (options: CanHopOptions) {\n  const {\n    connection,\n    signal\n  } = options\n\n  // Create a new stream to the relay\n  const stream = await connection.newStream(RELAY_CODEC, {\n    signal\n  })\n\n  // Send the HOP request\n  const streamHandler = new StreamHandler({ stream })\n  streamHandler.write({\n    type: CircuitPB.Type.CAN_HOP\n  })\n\n  const response = await streamHandler.read()\n  await streamHandler.close()\n\n  if (response == null || response.code !== CircuitPB.Status.SUCCESS) {\n    return false\n  }\n\n  return true\n}\n\nexport interface HandleCanHopOptions {\n  connection: Connection\n  streamHandler: StreamHandler\n  circuit: Circuit\n}\n\n/**\n * Creates an unencoded CAN_HOP response based on the Circuits configuration\n */\nexport function handleCanHop (options: HandleCanHopOptions) {\n  const {\n    connection,\n    streamHandler,\n    circuit\n  } = options\n  const canHop = circuit.hopEnabled()\n  log('can hop (%s) request from %p', canHop, connection.remotePeer)\n  streamHandler.end({\n    type: CircuitPB.Type.STATUS,\n    code: canHop ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n  })\n}\n"]},"metadata":{},"sourceType":"module"}