{"ast":null,"code":"import { abortableSource } from 'abortable-iterator';\nimport { CLOSE_TIMEOUT } from './constants.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:webrtc-star:socket');\n/**\n * Convert a socket into a MultiaddrConnection\n * https://github.com/libp2p/js-libp2p-interfaces/tree/master/src/transport#multiaddrconnection\n */\n\nexport function toMultiaddrConnection(socket, options) {\n  const {\n    sink,\n    source\n  } = socket;\n  const maConn = {\n    remoteAddr: options.remoteAddr,\n\n    async sink(source) {\n      if (options.signal != null) {\n        source = abortableSource(source, options.signal);\n      }\n\n      try {\n        await sink(source);\n      } catch (err) {\n        // If aborted we can safely ignore\n        if (err.type !== 'aborted') {\n          // If the source errored the socket will already have been destroyed by\n          // toIterable.duplex(). If the socket errored it will already be\n          // destroyed. There's nothing to do here except log the error & return.\n          log.error(err);\n        }\n      }\n    },\n\n    source: options.signal != null ? abortableSource(source, options.signal) : source,\n    timeline: {\n      open: Date.now()\n    },\n\n    async close() {\n      if (socket.closed) {\n        return;\n      }\n\n      const start = Date.now(); // Attempt to end the socket. If it takes longer to close than the\n      // timeout, destroy it manually.\n\n      const timeout = setTimeout(() => {\n        if (maConn.remoteAddr != null) {\n          const {\n            host,\n            port\n          } = maConn.remoteAddr.toOptions();\n          log('timeout closing socket to %s:%s after %dms, destroying it manually', host, port, Date.now() - start);\n        }\n\n        if (!socket.closed) {\n          socket.close().catch(err => {\n            log.error('could not close socket', err);\n          });\n        }\n      }, CLOSE_TIMEOUT);\n\n      try {\n        await socket.close();\n      } finally {\n        clearTimeout(timeout);\n      }\n    }\n\n  };\n  socket.addEventListener('close', () => {\n    // In instances where `close` was not explicitly called,\n    // such as an iterable stream ending, ensure we have set the close\n    // timeline\n    if (maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now();\n    }\n  }, {\n    once: true\n  });\n  return maConn;\n}","map":{"version":3,"mappings":"AAAA,SAASA,eAAT,QAAgC,oBAAhC;AACA,SAASC,aAAT,QAA8B,gBAA9B;AACA,SAASC,MAAT,QAAuB,gBAAvB;AAMA,MAAMC,GAAG,GAAGD,MAAM,CAAC,2BAAD,CAAlB;AAMA;;;;;AAIA,OAAM,SAAUE,qBAAV,CAAiCC,MAAjC,EAAqDC,OAArD,EAA0F;AAC9F,QAAM;AAAEC,QAAF;AAAQC;AAAR,MAAmBH,MAAzB;AAEA,QAAMI,MAAM,GAAwB;AAClCC,cAAU,EAAEJ,OAAO,CAACI,UADc;;AAGlC,UAAMH,IAAN,CAAYC,MAAZ,EAAkB;AAChB,UAAIF,OAAO,CAACK,MAAR,IAAkB,IAAtB,EAA4B;AAC1BH,cAAM,GAAGR,eAAe,CAACQ,MAAD,EAASF,OAAO,CAACK,MAAjB,CAAxB;AACD;;AAED,UAAI;AACF,cAAMJ,IAAI,CAACC,MAAD,CAAV;AACD,OAFD,CAEE,OAAOI,GAAP,EAAiB;AACjB;AACA,YAAIA,GAAG,CAACC,IAAJ,KAAa,SAAjB,EAA4B;AAC1B;AACA;AACA;AACAV,aAAG,CAACW,KAAJ,CAAUF,GAAV;AACD;AACF;AACF,KAnBiC;;AAqBlCJ,UAAM,EAAGF,OAAO,CAACK,MAAR,IAAkB,IAAnB,GAA2BX,eAAe,CAACQ,MAAD,EAASF,OAAO,CAACK,MAAjB,CAA1C,GAAqEH,MArB3C;AAuBlCO,YAAQ,EAAE;AAAEC,UAAI,EAAEC,IAAI,CAACC,GAAL;AAAR,KAvBwB;;AAyBlC,UAAMC,KAAN,GAAW;AACT,UAAId,MAAM,CAACe,MAAX,EAAmB;AACjB;AACD;;AAED,YAAMC,KAAK,GAAGJ,IAAI,CAACC,GAAL,EAAd,CALS,CAOT;AACA;;AACA,YAAMI,OAAO,GAAGC,UAAU,CAAC,MAAK;AAC9B,YAAId,MAAM,CAACC,UAAP,IAAqB,IAAzB,EAA+B;AAC7B,gBAAM;AAAEc,gBAAF;AAAQC;AAAR,cAAiBhB,MAAM,CAACC,UAAP,CAAkBgB,SAAlB,EAAvB;AACAvB,aAAG,CAAC,oEAAD,EACDqB,IADC,EACKC,IADL,EACWR,IAAI,CAACC,GAAL,KAAaG,KADxB,CAAH;AAED;;AAED,YAAI,CAAChB,MAAM,CAACe,MAAZ,EAAoB;AAClBf,gBAAM,CAACc,KAAP,GAAeQ,KAAf,CAAqBf,GAAG,IAAG;AACzBT,eAAG,CAACW,KAAJ,CAAU,wBAAV,EAAoCF,GAApC;AACD,WAFD;AAGD;AACF,OAZyB,EAYvBX,aAZuB,CAA1B;;AAcA,UAAI;AACF,cAAMI,MAAM,CAACc,KAAP,EAAN;AACD,OAFD,SAEU;AACRS,oBAAY,CAACN,OAAD,CAAZ;AACD;AACF;;AArDiC,GAApC;AAwDAjB,QAAM,CAACwB,gBAAP,CAAwB,OAAxB,EAAiC,MAAK;AACpC;AACA;AACA;AACA,QAAIpB,MAAM,CAACM,QAAP,CAAgBI,KAAhB,IAAyB,IAA7B,EAAmC;AACjCV,YAAM,CAACM,QAAP,CAAgBI,KAAhB,GAAwBF,IAAI,CAACC,GAAL,EAAxB;AACD;AACF,GAPD,EAOG;AACDY,QAAI,EAAE;AADL,GAPH;AAWA,SAAOrB,MAAP;AACD","names":["abortableSource","CLOSE_TIMEOUT","logger","log","toMultiaddrConnection","socket","options","sink","source","maConn","remoteAddr","signal","err","type","error","timeline","open","Date","now","close","closed","start","timeout","setTimeout","host","port","toOptions","catch","clearTimeout","addEventListener","once"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\webrtc-star\\src\\socket-to-conn.ts"],"sourcesContent":["import { abortableSource } from 'abortable-iterator'\nimport { CLOSE_TIMEOUT } from './constants.js'\nimport { logger } from '@libp2p/logger'\nimport type { MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { WebRTCPeer } from '@libp2p/webrtc-peer'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst log = logger('libp2p:webrtc-star:socket')\n\nexport interface ToMultiaddrConnectionOptions extends AbortOptions {\n  remoteAddr: Multiaddr\n}\n\n/**\n * Convert a socket into a MultiaddrConnection\n * https://github.com/libp2p/js-libp2p-interfaces/tree/master/src/transport#multiaddrconnection\n */\nexport function toMultiaddrConnection (socket: WebRTCPeer, options: ToMultiaddrConnectionOptions): MultiaddrConnection {\n  const { sink, source } = socket\n\n  const maConn: MultiaddrConnection = {\n    remoteAddr: options.remoteAddr,\n\n    async sink (source) {\n      if (options.signal != null) {\n        source = abortableSource(source, options.signal)\n      }\n\n      try {\n        await sink(source)\n      } catch (err: any) {\n        // If aborted we can safely ignore\n        if (err.type !== 'aborted') {\n          // If the source errored the socket will already have been destroyed by\n          // toIterable.duplex(). If the socket errored it will already be\n          // destroyed. There's nothing to do here except log the error & return.\n          log.error(err)\n        }\n      }\n    },\n\n    source: (options.signal != null) ? abortableSource(source, options.signal) : source,\n\n    timeline: { open: Date.now() },\n\n    async close () {\n      if (socket.closed) {\n        return\n      }\n\n      const start = Date.now()\n\n      // Attempt to end the socket. If it takes longer to close than the\n      // timeout, destroy it manually.\n      const timeout = setTimeout(() => {\n        if (maConn.remoteAddr != null) {\n          const { host, port } = maConn.remoteAddr.toOptions()\n          log('timeout closing socket to %s:%s after %dms, destroying it manually',\n            host, port, Date.now() - start)\n        }\n\n        if (!socket.closed) {\n          socket.close().catch(err => {\n            log.error('could not close socket', err)\n          })\n        }\n      }, CLOSE_TIMEOUT)\n\n      try {\n        await socket.close()\n      } finally {\n        clearTimeout(timeout)\n      }\n    }\n  }\n\n  socket.addEventListener('close', () => {\n    // In instances where `close` was not explicitly called,\n    // such as an iterable stream ending, ensure we have set the close\n    // timeline\n    if (maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now()\n    }\n  }, {\n    once: true\n  })\n\n  return maConn\n}\n"]},"metadata":{},"sourceType":"module"}