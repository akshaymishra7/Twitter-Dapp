{"ast":null,"code":"/* eslint-disable no-unreachable */\nimport * as isIpfs from 'is-ipfs';\nimport { CID } from 'multiformats/cid';\nimport { Key } from 'interface-datastore/key';\nimport errCode from 'err-code';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { toCidAndPath } from 'ipfs-core-utils/to-cid-and-path';\nimport * as dagPB from '@ipld/dag-pb';\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH';\nexport const OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\nexport const MFS_ROOT_KEY = new Key('/local/filesroot');\nexport const MFS_MAX_CHUNK_SIZE = 262144;\nexport const MFS_MAX_LINKS = 174;\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {string | CID} pathStr - An ipfs-path, or ipns-path or a cid\n * @returns {string} - ipfs-path or ipns-path\n * @throws on an invalid @param pathStr\n */\n\nexport const normalizePath = pathStr => {\n  const cid = CID.asCID(pathStr);\n\n  if (cid) {\n    return `/ipfs/${pathStr}`;\n  }\n\n  const str = pathStr.toString();\n\n  try {\n    return `/ipfs/${CID.parse(str)}`;\n  } catch {}\n\n  if (isIpfs.path(str)) {\n    return str;\n  } else {\n    throw errCode(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH);\n  }\n}; // TODO: do we need both normalizePath and normalizeCidPath?\n// TODO: don't forget ipfs-core-utils/src/to-cid-and-path\n\n/**\n * @param {Uint8Array|CID|string} path\n */\n\nexport const normalizeCidPath = path => {\n  if (path instanceof Uint8Array) {\n    return CID.decode(path).toString();\n  }\n\n  path = path.toString();\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n};\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID | string | Uint8Array} ipfsPath - A CID or IPFS path\n * @param {{ path?: string, signal?: AbortSignal }} [options] - Optional options passed directly to dag.resolve\n * @returns {Promise<{ cid: CID, remainderPath: string}>}\n */\n\nexport const resolvePath = async function (repo, codecs, ipfsPath) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath);\n\n  if (path) {\n    options.path = path;\n  }\n\n  let lastCid = cid;\n  let lastRemainderPath = options.path || '';\n\n  if (lastRemainderPath.startsWith('/')) {\n    lastRemainderPath = lastRemainderPath.substring(1);\n  }\n\n  if (options.path) {\n    try {\n      for await (const {\n        value,\n        remainderPath\n      } of resolve(cid, options.path, codecs, repo, {\n        signal: options.signal\n      })) {\n        if (!CID.asCID(value)) {\n          break;\n        }\n\n        lastRemainderPath = remainderPath;\n        lastCid = value;\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      // TODO: add error codes to IPLD\n      if (err.message.startsWith('Object has no property')) {\n        err.message = `no link named \"${lastRemainderPath.split('/')[0]}\" under ${lastCid}`;\n        err.code = 'ERR_NO_LINK';\n      }\n\n      throw err;\n    }\n  }\n\n  return {\n    cid: lastCid,\n    remainderPath: lastRemainderPath || ''\n  };\n};\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n *\n * @param {UnixFSEntry} file\n */\n\nexport const mapFile = file => {\n  if (file.type !== 'file' && file.type !== 'directory' && file.type !== 'raw') {\n    // file.type === object | identity not supported yet\n    throw new Error(`Unknown node type '${file.type}'`);\n  }\n  /** @type {import('ipfs-core-types/src/root').IPFSEntry} */\n\n\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    type: 'file'\n  };\n\n  if (file.type === 'directory') {\n    // @ts-expect-error - TS type can't be changed from File to Directory\n    output.type = 'dir';\n  }\n\n  if (file.type === 'file') {\n    output.size = file.unixfs.fileSize();\n  }\n\n  if (file.type === 'file' || file.type === 'directory') {\n    output.mode = file.unixfs.mode;\n\n    if (file.unixfs.mtime !== undefined) {\n      output.mtime = file.unixfs.mtime;\n    }\n  }\n\n  return output;\n};\nexport const withTimeout = withTimeoutOption(\n/**\n * @template T\n * @param {Promise<T>|T} promise\n * @param {AbortOptions} [_options]\n * @returns {Promise<T>}\n */\nasync (promise, _options) => await promise);\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs').Multicodecs} codecs\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {AbortOptions} [options]\n */\n\nexport const resolve = async function* (cid, path, codecs, repo, options) {\n  /**\n   * @param {CID} cid\n   */\n  const load = async cid => {\n    const codec = await codecs.getCodec(cid.code);\n    const block = await repo.blocks.get(cid, options);\n    return codec.decode(block);\n  };\n\n  const parts = path.split('/').filter(Boolean);\n  let value = await load(cid);\n  let lastCid = cid; // End iteration if there isn't a CID to follow any more\n\n  while (parts.length) {\n    const key = parts.shift();\n\n    if (!key) {\n      throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH');\n    } // special case for dag-pb, use the link name as the path segment\n\n\n    if (cid.code === dagPB.code && Array.isArray(value.Links)) {\n      const link = value.Links.find((\n      /** @type {PBLink} */\n      l) => l.Name === key);\n\n      if (link) {\n        yield {\n          value: link.Hash,\n          remainderPath: parts.join('/')\n        };\n        value = await load(link.Hash);\n        lastCid = link.Hash;\n        continue;\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key];\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      };\n    } else {\n      throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK');\n    }\n\n    if (CID.asCID(value)) {\n      lastCid = value;\n      value = await load(value);\n    }\n  }\n\n  yield {\n    value,\n    remainderPath: ''\n  };\n};","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/utils.js"],"names":["isIpfs","CID","Key","errCode","withTimeoutOption","toCidAndPath","dagPB","ERR_BAD_PATH","OFFLINE_ERROR","MFS_ROOT_KEY","MFS_MAX_CHUNK_SIZE","MFS_MAX_LINKS","normalizePath","pathStr","cid","asCID","str","toString","parse","path","Error","normalizeCidPath","Uint8Array","decode","indexOf","substring","length","charAt","resolvePath","repo","codecs","ipfsPath","options","lastCid","lastRemainderPath","startsWith","value","remainderPath","resolve","signal","err","message","split","code","mapFile","file","type","output","name","size","unixfs","fileSize","mode","mtime","undefined","withTimeout","promise","_options","load","codec","getCodec","block","blocks","get","parts","filter","Boolean","key","shift","Array","isArray","Links","link","find","l","Name","Hash","join","Object","prototype","hasOwnProperty","call"],"mappings":"AAAA;AAEA,OAAO,KAAKA,MAAZ,MAAwB,SAAxB;AACA,SAASC,GAAT,QAAoB,kBAApB;AACA,SAASC,GAAT,QAAoB,yBAApB;AACA,OAAOC,OAAP,MAAoB,UAApB;AACA,SAASC,iBAAT,QAAkC,qCAAlC;AACA,SAASC,YAAT,QAA6B,iCAA7B;AACA,OAAO,KAAKC,KAAZ,MAAuB,cAAvB;AAEA;AACA;AACA;AACA;;AAEA,MAAMC,YAAY,GAAG,cAArB;AAEA,OAAO,MAAMC,aAAa,GAAG,6EAAtB;AACP,OAAO,MAAMC,YAAY,GAAG,IAAIP,GAAJ,CAAQ,kBAAR,CAArB;AACP,OAAO,MAAMQ,kBAAkB,GAAG,MAA3B;AACP,OAAO,MAAMC,aAAa,GAAG,GAAtB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,aAAa,GAAIC,OAAD,IAAa;AACxC,QAAMC,GAAG,GAAGb,GAAG,CAACc,KAAJ,CAAUF,OAAV,CAAZ;;AAEA,MAAIC,GAAJ,EAAS;AACP,WAAQ,SAAQD,OAAQ,EAAxB;AACD;;AAED,QAAMG,GAAG,GAAGH,OAAO,CAACI,QAAR,EAAZ;;AAEA,MAAI;AACF,WAAQ,SAAQhB,GAAG,CAACiB,KAAJ,CAAUF,GAAV,CAAe,EAA/B;AACD,GAFD,CAEE,MAAM,CAAE;;AAEV,MAAIhB,MAAM,CAACmB,IAAP,CAAYH,GAAZ,CAAJ,EAAsB;AACpB,WAAOA,GAAP;AACD,GAFD,MAEO;AACL,UAAMb,OAAO,CAAC,IAAIiB,KAAJ,CAAW,iBAAgBP,OAAQ,EAAnC,CAAD,EAAwCN,YAAxC,CAAb;AACD;AACF,CAlBM,C,CAoBP;AACA;;AACA;AACA;AACA;;AACA,OAAO,MAAMc,gBAAgB,GAAIF,IAAD,IAAU;AACxC,MAAIA,IAAI,YAAYG,UAApB,EAAgC;AAC9B,WAAOrB,GAAG,CAACsB,MAAJ,CAAWJ,IAAX,EAAiBF,QAAjB,EAAP;AACD;;AAEDE,EAAAA,IAAI,GAAGA,IAAI,CAACF,QAAL,EAAP;;AAEA,MAAIE,IAAI,CAACK,OAAL,CAAa,QAAb,MAA2B,CAA/B,EAAkC;AAChCL,IAAAA,IAAI,GAAGA,IAAI,CAACM,SAAL,CAAe,SAASC,MAAxB,CAAP;AACD;;AAED,MAAIP,IAAI,CAACQ,MAAL,CAAYR,IAAI,CAACO,MAAL,GAAc,CAA1B,MAAiC,GAArC,EAA0C;AACxCP,IAAAA,IAAI,GAAGA,IAAI,CAACM,SAAL,CAAe,CAAf,EAAkBN,IAAI,CAACO,MAAL,GAAc,CAAhC,CAAP;AACD;;AAED,SAAOP,IAAP;AACD,CAhBM;AAkBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMS,WAAW,GAAG,gBAAgBC,IAAhB,EAAsBC,MAAtB,EAA8BC,QAA9B,EAAsD;AAAA,MAAdC,OAAc,uEAAJ,EAAI;AAC/E,QAAM;AACJlB,IAAAA,GADI;AAEJK,IAAAA;AAFI,MAGFd,YAAY,CAAC0B,QAAD,CAHhB;;AAKA,MAAIZ,IAAJ,EAAU;AACRa,IAAAA,OAAO,CAACb,IAAR,GAAeA,IAAf;AACD;;AAED,MAAIc,OAAO,GAAGnB,GAAd;AACA,MAAIoB,iBAAiB,GAAGF,OAAO,CAACb,IAAR,IAAgB,EAAxC;;AAEA,MAAIe,iBAAiB,CAACC,UAAlB,CAA6B,GAA7B,CAAJ,EAAuC;AACrCD,IAAAA,iBAAiB,GAAGA,iBAAiB,CAACT,SAAlB,CAA4B,CAA5B,CAApB;AACD;;AAED,MAAIO,OAAO,CAACb,IAAZ,EAAkB;AAChB,QAAI;AACF,iBAAW,MAAM;AAAEiB,QAAAA,KAAF;AAASC,QAAAA;AAAT,OAAjB,IAA6CC,OAAO,CAACxB,GAAD,EAAMkB,OAAO,CAACb,IAAd,EAAoBW,MAApB,EAA4BD,IAA5B,EAAkC;AACpFU,QAAAA,MAAM,EAAEP,OAAO,CAACO;AADoE,OAAlC,CAApD,EAEI;AACF,YAAI,CAACtC,GAAG,CAACc,KAAJ,CAAUqB,KAAV,CAAL,EAAuB;AACrB;AACD;;AAEDF,QAAAA,iBAAiB,GAAGG,aAApB;AACAJ,QAAAA,OAAO,GAAGG,KAAV;AACD;AACF,KAXD,CAWE;AAAO;AAAmBI,IAAAA,GAA1B,EAA+B;AAC/B;AACA,UAAIA,GAAG,CAACC,OAAJ,CAAYN,UAAZ,CAAuB,wBAAvB,CAAJ,EAAsD;AACpDK,QAAAA,GAAG,CAACC,OAAJ,GAAe,kBAAiBP,iBAAiB,CAACQ,KAAlB,CAAwB,GAAxB,EAA6B,CAA7B,CAAgC,WAAUT,OAAQ,EAAlF;AACAO,QAAAA,GAAG,CAACG,IAAJ,GAAW,aAAX;AACD;;AACD,YAAMH,GAAN;AACD;AACF;;AAED,SAAO;AACL1B,IAAAA,GAAG,EAAEmB,OADA;AAELI,IAAAA,aAAa,EAAEH,iBAAiB,IAAI;AAF/B,GAAP;AAID,CA3CM;AA6CP;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMU,OAAO,GAAIC,IAAD,IAAU;AAC/B,MAAIA,IAAI,CAACC,IAAL,KAAc,MAAd,IAAwBD,IAAI,CAACC,IAAL,KAAc,WAAtC,IAAqDD,IAAI,CAACC,IAAL,KAAc,KAAvE,EAA8E;AAC5E;AACA,UAAM,IAAI1B,KAAJ,CAAW,sBAAqByB,IAAI,CAACC,IAAK,GAA1C,CAAN;AACD;AAED;;;AACA,QAAMC,MAAM,GAAG;AACbjC,IAAAA,GAAG,EAAE+B,IAAI,CAAC/B,GADG;AAEbK,IAAAA,IAAI,EAAE0B,IAAI,CAAC1B,IAFE;AAGb6B,IAAAA,IAAI,EAAEH,IAAI,CAACG,IAHE;AAIbC,IAAAA,IAAI,EAAEJ,IAAI,CAACI,IAJE;AAKbH,IAAAA,IAAI,EAAE;AALO,GAAf;;AAQA,MAAID,IAAI,CAACC,IAAL,KAAc,WAAlB,EAA+B;AAC7B;AACAC,IAAAA,MAAM,CAACD,IAAP,GAAc,KAAd;AACD;;AAED,MAAID,IAAI,CAACC,IAAL,KAAc,MAAlB,EAA0B;AACxBC,IAAAA,MAAM,CAACE,IAAP,GAAcJ,IAAI,CAACK,MAAL,CAAYC,QAAZ,EAAd;AACD;;AAED,MAAIN,IAAI,CAACC,IAAL,KAAc,MAAd,IAAwBD,IAAI,CAACC,IAAL,KAAc,WAA1C,EAAuD;AACrDC,IAAAA,MAAM,CAACK,IAAP,GAAcP,IAAI,CAACK,MAAL,CAAYE,IAA1B;;AAEA,QAAIP,IAAI,CAACK,MAAL,CAAYG,KAAZ,KAAsBC,SAA1B,EAAqC;AACnCP,MAAAA,MAAM,CAACM,KAAP,GAAeR,IAAI,CAACK,MAAL,CAAYG,KAA3B;AACD;AACF;;AAED,SAAON,MAAP;AACD,CAjCM;AAmCP,OAAO,MAAMQ,WAAW,GAAGnD,iBAAiB;AAC1C;AACF;AACA;AACA;AACA;AACA;AACE,OAAOoD,OAAP,EAAgBC,QAAhB,KAA6B,MAAMD,OAPO,CAArC;AAUP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMlB,OAAO,GAAG,iBAAkBxB,GAAlB,EAAuBK,IAAvB,EAA6BW,MAA7B,EAAqCD,IAArC,EAA2CG,OAA3C,EAAoD;AACzE;AACF;AACA;AACE,QAAM0B,IAAI,GAAG,MAAO5C,GAAP,IAAe;AAC1B,UAAM6C,KAAK,GAAG,MAAM7B,MAAM,CAAC8B,QAAP,CAAgB9C,GAAG,CAAC6B,IAApB,CAApB;AACA,UAAMkB,KAAK,GAAG,MAAMhC,IAAI,CAACiC,MAAL,CAAYC,GAAZ,CAAgBjD,GAAhB,EAAqBkB,OAArB,CAApB;AAEA,WAAO2B,KAAK,CAACpC,MAAN,CAAasC,KAAb,CAAP;AACD,GALD;;AAOA,QAAMG,KAAK,GAAG7C,IAAI,CAACuB,KAAL,CAAW,GAAX,EAAgBuB,MAAhB,CAAuBC,OAAvB,CAAd;AACA,MAAI9B,KAAK,GAAG,MAAMsB,IAAI,CAAC5C,GAAD,CAAtB;AACA,MAAImB,OAAO,GAAGnB,GAAd,CAbyE,CAezE;;AACA,SAAOkD,KAAK,CAACtC,MAAb,EAAqB;AACnB,UAAMyC,GAAG,GAAGH,KAAK,CAACI,KAAN,EAAZ;;AAEA,QAAI,CAACD,GAAL,EAAU;AACR,YAAMhE,OAAO,CAAC,IAAIiB,KAAJ,CAAW,2BAA0BD,IAAK,GAA1C,CAAD,EAAgD,kBAAhD,CAAb;AACD,KALkB,CAOnB;;;AACA,QAAIL,GAAG,CAAC6B,IAAJ,KAAarC,KAAK,CAACqC,IAAnB,IAA2B0B,KAAK,CAACC,OAAN,CAAclC,KAAK,CAACmC,KAApB,CAA/B,EAA2D;AACzD,YAAMC,IAAI,GAAGpC,KAAK,CAACmC,KAAN,CAAYE,IAAZ,CAAiB;AAAC;AAAsBC,MAAAA,CAAvB,KAA6BA,CAAC,CAACC,IAAF,KAAWR,GAAzD,CAAb;;AAEA,UAAIK,IAAJ,EAAU;AACR,cAAM;AACJpC,UAAAA,KAAK,EAAEoC,IAAI,CAACI,IADR;AAEJvC,UAAAA,aAAa,EAAE2B,KAAK,CAACa,IAAN,CAAW,GAAX;AAFX,SAAN;AAKAzC,QAAAA,KAAK,GAAG,MAAMsB,IAAI,CAACc,IAAI,CAACI,IAAN,CAAlB;AACA3C,QAAAA,OAAO,GAAGuC,IAAI,CAACI,IAAf;AAEA;AACD;AACF;;AAED,QAAIE,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqC7C,KAArC,EAA4C+B,GAA5C,CAAJ,EAAsD;AACpD/B,MAAAA,KAAK,GAAGA,KAAK,CAAC+B,GAAD,CAAb;AAEA,YAAM;AACJ/B,QAAAA,KADI;AAEJC,QAAAA,aAAa,EAAE2B,KAAK,CAACa,IAAN,CAAW,GAAX;AAFX,OAAN;AAID,KAPD,MAOO;AACL,YAAM1E,OAAO,CAAC,IAAIiB,KAAJ,CAAW,kBAAiB+C,GAAI,WAAUlC,OAAQ,EAAlD,CAAD,EAAuD,aAAvD,CAAb;AACD;;AAED,QAAIhC,GAAG,CAACc,KAAJ,CAAUqB,KAAV,CAAJ,EAAsB;AACpBH,MAAAA,OAAO,GAAGG,KAAV;AACAA,MAAAA,KAAK,GAAG,MAAMsB,IAAI,CAACtB,KAAD,CAAlB;AACD;AACF;;AAED,QAAM;AACJA,IAAAA,KADI;AAEJC,IAAAA,aAAa,EAAE;AAFX,GAAN;AAID,CA7DM","sourcesContent":["/* eslint-disable no-unreachable */\n\nimport * as isIpfs from 'is-ipfs'\nimport { CID } from 'multiformats/cid'\nimport { Key } from 'interface-datastore/key'\nimport errCode from 'err-code'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { toCidAndPath } from 'ipfs-core-utils/to-cid-and-path'\nimport * as dagPB from '@ipld/dag-pb'\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH'\n\nexport const OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.'\nexport const MFS_ROOT_KEY = new Key('/local/filesroot')\nexport const MFS_MAX_CHUNK_SIZE = 262144\nexport const MFS_MAX_LINKS = 174\n\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {string | CID} pathStr - An ipfs-path, or ipns-path or a cid\n * @returns {string} - ipfs-path or ipns-path\n * @throws on an invalid @param pathStr\n */\nexport const normalizePath = (pathStr) => {\n  const cid = CID.asCID(pathStr)\n\n  if (cid) {\n    return `/ipfs/${pathStr}`\n  }\n\n  const str = pathStr.toString()\n\n  try {\n    return `/ipfs/${CID.parse(str)}`\n  } catch {}\n\n  if (isIpfs.path(str)) {\n    return str\n  } else {\n    throw errCode(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH)\n  }\n}\n\n// TODO: do we need both normalizePath and normalizeCidPath?\n// TODO: don't forget ipfs-core-utils/src/to-cid-and-path\n/**\n * @param {Uint8Array|CID|string} path\n */\nexport const normalizeCidPath = (path) => {\n  if (path instanceof Uint8Array) {\n    return CID.decode(path).toString()\n  }\n\n  path = path.toString()\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length)\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1)\n  }\n\n  return path\n}\n\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID | string | Uint8Array} ipfsPath - A CID or IPFS path\n * @param {{ path?: string, signal?: AbortSignal }} [options] - Optional options passed directly to dag.resolve\n * @returns {Promise<{ cid: CID, remainderPath: string}>}\n */\nexport const resolvePath = async function (repo, codecs, ipfsPath, options = {}) {\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath)\n\n  if (path) {\n    options.path = path\n  }\n\n  let lastCid = cid\n  let lastRemainderPath = options.path || ''\n\n  if (lastRemainderPath.startsWith('/')) {\n    lastRemainderPath = lastRemainderPath.substring(1)\n  }\n\n  if (options.path) {\n    try {\n      for await (const { value, remainderPath } of resolve(cid, options.path, codecs, repo, {\n        signal: options.signal\n      })) {\n        if (!CID.asCID(value)) {\n          break\n        }\n\n        lastRemainderPath = remainderPath\n        lastCid = value\n      }\n    } catch (/** @type {any} */ err) {\n      // TODO: add error codes to IPLD\n      if (err.message.startsWith('Object has no property')) {\n        err.message = `no link named \"${lastRemainderPath.split('/')[0]}\" under ${lastCid}`\n        err.code = 'ERR_NO_LINK'\n      }\n      throw err\n    }\n  }\n\n  return {\n    cid: lastCid,\n    remainderPath: lastRemainderPath || ''\n  }\n}\n\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n *\n * @param {UnixFSEntry} file\n */\nexport const mapFile = (file) => {\n  if (file.type !== 'file' && file.type !== 'directory' && file.type !== 'raw') {\n    // file.type === object | identity not supported yet\n    throw new Error(`Unknown node type '${file.type}'`)\n  }\n\n  /** @type {import('ipfs-core-types/src/root').IPFSEntry} */\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    type: 'file'\n  }\n\n  if (file.type === 'directory') {\n    // @ts-expect-error - TS type can't be changed from File to Directory\n    output.type = 'dir'\n  }\n\n  if (file.type === 'file') {\n    output.size = file.unixfs.fileSize()\n  }\n\n  if (file.type === 'file' || file.type === 'directory') {\n    output.mode = file.unixfs.mode\n\n    if (file.unixfs.mtime !== undefined) {\n      output.mtime = file.unixfs.mtime\n    }\n  }\n\n  return output\n}\n\nexport const withTimeout = withTimeoutOption(\n  /**\n   * @template T\n   * @param {Promise<T>|T} promise\n   * @param {AbortOptions} [_options]\n   * @returns {Promise<T>}\n   */\n  async (promise, _options) => await promise\n)\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs').Multicodecs} codecs\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {AbortOptions} [options]\n */\nexport const resolve = async function * (cid, path, codecs, repo, options) {\n  /**\n   * @param {CID} cid\n   */\n  const load = async (cid) => {\n    const codec = await codecs.getCodec(cid.code)\n    const block = await repo.blocks.get(cid, options)\n\n    return codec.decode(block)\n  }\n\n  const parts = path.split('/').filter(Boolean)\n  let value = await load(cid)\n  let lastCid = cid\n\n  // End iteration if there isn't a CID to follow any more\n  while (parts.length) {\n    const key = parts.shift()\n\n    if (!key) {\n      throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH')\n    }\n\n    // special case for dag-pb, use the link name as the path segment\n    if (cid.code === dagPB.code && Array.isArray(value.Links)) {\n      const link = value.Links.find((/** @type {PBLink} */ l) => l.Name === key)\n\n      if (link) {\n        yield {\n          value: link.Hash,\n          remainderPath: parts.join('/')\n        }\n\n        value = await load(link.Hash)\n        lastCid = link.Hash\n\n        continue\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key]\n\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      }\n    } else {\n      throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK')\n    }\n\n    if (CID.asCID(value)) {\n      lastCid = value\n      value = await load(value)\n    }\n  }\n\n  yield {\n    value,\n    remainderPath: ''\n  }\n}\n"]},"metadata":{},"sourceType":"module"}