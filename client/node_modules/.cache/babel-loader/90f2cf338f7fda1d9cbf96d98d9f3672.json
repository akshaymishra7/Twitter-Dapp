{"ast":null,"code":"export const symbol = Symbol.for('@libp2p/transport');\nexport function isTransport(other) {\n  return other != null && Boolean(other[symbol]);\n}\n/**\n * Enum Transport Manager Fault Tolerance values\n */\n\nexport var FaultTolerance;\n\n(function (FaultTolerance) {\n  /**\n   * should be used for failing in any listen circumstance\n   */\n  FaultTolerance[FaultTolerance[\"FATAL_ALL\"] = 0] = \"FATAL_ALL\";\n  /**\n   * should be used for not failing when not listening\n   */\n\n  FaultTolerance[FaultTolerance[\"NO_FATAL\"] = 1] = \"NO_FATAL\";\n})(FaultTolerance || (FaultTolerance = {}));","map":{"version":3,"mappings":"AAOA,OAAO,MAAMA,MAAM,GAAGC,MAAM,CAACC,GAAP,CAAW,mBAAX,CAAf;AAgGP,OAAM,SAAUC,WAAV,CAAuBC,KAAvB,EAAiC;AACrC,SAAOA,KAAK,IAAI,IAAT,IAAiBC,OAAO,CAACD,KAAK,CAACJ,MAAD,CAAN,CAA/B;AACD;AAkBD;;;;AAGA,WAAYM,cAAZ;;AAAA,WAAYA,cAAZ,EAA0B;AACxB;;;AAGAA;AAEA;;;;AAGAA;AACD,CAVD,EAAYA,cAAc,KAAdA,cAAc,MAA1B","names":["symbol","Symbol","for","isTransport","other","Boolean","FaultTolerance"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\interface-transport\\src\\index.ts"],"sourcesContent":["import type { AbortOptions } from '@libp2p/interfaces'\nimport type { EventEmitter } from '@libp2p/interfaces/events'\nimport type { StreamMuxerFactory } from '@libp2p/interface-stream-muxer'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Connection, MultiaddrConnection } from '@libp2p/interface-connection'\nimport type { Duplex } from 'it-stream-types'\n\nexport const symbol = Symbol.for('@libp2p/transport')\n\nexport interface ConnectionHandler { (connection: Connection): void }\n\nexport interface MultiaddrFilter { (multiaddrs: Multiaddr[]): Multiaddr[] }\n\nexport interface CreateListenerOptions {\n  handler?: ConnectionHandler\n  upgrader: Upgrader\n}\n\nexport interface DialOptions extends AbortOptions {\n  upgrader: Upgrader\n}\n\n/**\n * A libp2p transport is understood as something that offers a dial and listen interface to establish connections.\n */\nexport interface Transport {\n  /**\n   * Used to identify the transport\n   */\n  [Symbol.toStringTag]: string\n\n  /**\n   * Used by the isTransport function\n   */\n  [symbol]: true\n\n  /**\n   * Dial a given multiaddr.\n   */\n  dial: (ma: Multiaddr, options: DialOptions) => Promise<Connection>\n\n  /**\n   * Create transport listeners.\n   */\n  createListener: (options: CreateListenerOptions) => Listener\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid addresses for the transport\n   */\n  filter: MultiaddrFilter\n}\n\nexport interface ListenerEvents {\n  'connection': CustomEvent<Connection>\n  'listening': CustomEvent\n  'error': CustomEvent<Error>\n  'close': CustomEvent\n}\n\nexport interface Listener extends EventEmitter<ListenerEvents> {\n  /**\n   * Start a listener\n   */\n  listen: (multiaddr: Multiaddr) => Promise<void>\n  /**\n   * Get listen addresses\n   */\n  getAddrs: () => Multiaddr[]\n  /**\n   * Close listener\n   *\n   * @returns {Promise<void>}\n   */\n  close: () => Promise<void>\n}\n\nexport interface UpgraderEvents {\n  'connection': CustomEvent<Connection>\n  'connectionEnd': CustomEvent<Connection>\n}\n\nexport interface UpgraderOptions {\n  skipEncryption?: boolean\n  skipProtection?: boolean\n  muxerFactory?: StreamMuxerFactory\n}\n\nexport interface Upgrader extends EventEmitter<UpgraderEvents> {\n  /**\n   * Upgrades an outbound connection on `transport.dial`.\n   */\n  upgradeOutbound: (maConn: MultiaddrConnection, opts?: UpgraderOptions) => Promise<Connection>\n\n  /**\n   * Upgrades an inbound connection on transport listener.\n   */\n  upgradeInbound: (maConn: MultiaddrConnection, opts?: UpgraderOptions) => Promise<Connection>\n}\n\nexport interface ProtocolHandler {\n  (stream: Duplex<Uint8Array>, connection: Connection): void\n}\n\nexport function isTransport (other: any): other is Transport {\n  return other != null && Boolean(other[symbol])\n}\n\nexport interface TransportManagerEvents {\n  'listener:listening': CustomEvent<Listener>\n  'listener:close': CustomEvent<Listener>\n}\n\nexport interface TransportManager extends EventEmitter<TransportManagerEvents> {\n  add: (transport: Transport) => void\n  dial: (ma: Multiaddr, options?: any) => Promise<Connection>\n  getAddrs: () => Multiaddr[]\n  getTransports: () => Transport[]\n  transportForMultiaddr: (ma: Multiaddr) => Transport | undefined\n  listen: (addrs: Multiaddr[]) => Promise<void>\n  remove: (key: string) => Promise<void>\n  removeAll: () => Promise<void>\n}\n\n/**\n * Enum Transport Manager Fault Tolerance values\n */\nexport enum FaultTolerance {\n  /**\n   * should be used for failing in any listen circumstance\n   */\n  FATAL_ALL = 0,\n\n  /**\n   * should be used for not failing when not listening\n   */\n  NO_FATAL\n}\n"]},"metadata":{},"sourceType":"module"}