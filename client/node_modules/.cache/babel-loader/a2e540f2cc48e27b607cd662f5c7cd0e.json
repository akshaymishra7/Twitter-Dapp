{"ast":null,"code":"var _a;\n\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { fromString as uint8arraysFromString } from 'uint8arrays/from-string';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { unmarshalPrivateKey, unmarshalPublicKey } from '@libp2p/crypto/keys';\nimport { codes } from '../errors.js';\nimport { Envelope as Protobuf } from './envelope.js';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { unsigned } from 'uint8-varint';\nexport class RecordEnvelope {\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   */\n  constructor(init) {\n    const {\n      peerId,\n      payloadType,\n      payload,\n      signature\n    } = init;\n    this.peerId = peerId;\n    this.payloadType = payloadType;\n    this.payload = payload;\n    this.signature = signature;\n  }\n  /**\n   * Marshal the envelope content\n   */\n\n\n  marshal() {\n    if (this.peerId.publicKey == null) {\n      throw new Error('Missing public key');\n    }\n\n    if (this.marshaled == null) {\n      this.marshaled = Protobuf.encode({\n        publicKey: this.peerId.publicKey,\n        payloadType: this.payloadType,\n        payload: this.payload.subarray(),\n        signature: this.signature\n      });\n    }\n\n    return this.marshaled;\n  }\n  /**\n   * Verifies if the other Envelope is identical to this one\n   */\n\n\n  equals(other) {\n    return uint8ArrayEquals(this.marshal(), other.marshal());\n  }\n  /**\n   * Validate envelope data signature for the given domain\n   */\n\n\n  async validate(domain) {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);\n\n    if (this.peerId.publicKey == null) {\n      throw new Error('Missing public key');\n    }\n\n    const key = unmarshalPublicKey(this.peerId.publicKey);\n    return await key.verify(signData.subarray(), this.signature);\n  }\n\n}\n_a = RecordEnvelope;\n/**\n * Unmarshal a serialized Envelope protobuf message\n */\n\nRecordEnvelope.createFromProtobuf = async data => {\n  const envelopeData = Protobuf.decode(data);\n  const peerId = await peerIdFromKeys(envelopeData.publicKey);\n  return new RecordEnvelope({\n    peerId,\n    payloadType: envelopeData.payloadType,\n    payload: envelopeData.payload,\n    signature: envelopeData.signature\n  });\n};\n/**\n * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n * and signs it with the given peerId's private key\n */\n\n\nRecordEnvelope.seal = async (record, peerId) => {\n  if (peerId.privateKey == null) {\n    throw new Error('Missing private key');\n  }\n\n  const domain = record.domain;\n  const payloadType = record.codec;\n  const payload = record.marshal();\n  const signData = formatSignaturePayload(domain, payloadType, payload);\n  const key = await unmarshalPrivateKey(peerId.privateKey);\n  const signature = await key.sign(signData.subarray());\n  return new RecordEnvelope({\n    peerId,\n    payloadType,\n    payload,\n    signature\n  });\n};\n/**\n * Open and certify a given marshalled envelope.\n * Data is unmarshalled and the signature validated for the given domain.\n */\n\n\nRecordEnvelope.openAndCertify = async (data, domain) => {\n  const envelope = await RecordEnvelope.createFromProtobuf(data);\n  const valid = await envelope.validate(domain);\n\n  if (!valid) {\n    throw new CodeError('envelope signature is not valid for the given domain', codes.ERR_SIGNATURE_NOT_VALID);\n  }\n\n  return envelope;\n};\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature\n */\n\n\nconst formatSignaturePayload = (domain, payloadType, payload) => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n  const domainUint8Array = uint8arraysFromString(domain);\n  const domainLength = unsigned.encode(domainUint8Array.byteLength);\n  const payloadTypeLength = unsigned.encode(payloadType.length);\n  const payloadLength = unsigned.encode(payload.length);\n  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);\n};","map":{"version":3,"mappings":";;AAAA,SAASA,SAAT,QAA0B,2BAA1B;AACA,SAASC,UAAU,IAAIC,qBAAvB,QAAoD,yBAApD;AACA,SAASC,MAAM,IAAIC,gBAAnB,QAA2C,oBAA3C;AACA,SAASC,mBAAT,EAA8BC,kBAA9B,QAAwD,qBAAxD;AACA,SAASC,KAAT,QAAsB,cAAtB;AACA,SAASC,QAAQ,IAAIC,QAArB,QAAqC,eAArC;AACA,SAASC,cAAT,QAA+B,iBAA/B;AAGA,SAASC,cAAT,QAA+B,gBAA/B;AACA,SAASC,QAAT,QAAyB,cAAzB;AASA,OAAM,MAAOC,cAAP,CAAqB;AA6DzB;;;;AAIAC,cAAaC,IAAb,EAAqC;AACnC,UAAM;AAAEC,YAAF;AAAUC,iBAAV;AAAuBC,aAAvB;AAAgCC;AAAhC,QAA8CJ,IAApD;AAEA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACD;AAED;;;;;AAGAC,SAAO;AACL,QAAI,KAAKJ,MAAL,CAAYK,SAAZ,IAAyB,IAA7B,EAAmC;AACjC,YAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;AACD;;AAED,QAAI,KAAKC,SAAL,IAAkB,IAAtB,EAA4B;AAC1B,WAAKA,SAAL,GAAiBd,QAAQ,CAACe,MAAT,CAAgB;AAC/BH,iBAAS,EAAE,KAAKL,MAAL,CAAYK,SADQ;AAE/BJ,mBAAW,EAAE,KAAKA,WAFa;AAG/BC,eAAO,EAAE,KAAKA,OAAL,CAAaO,QAAb,EAHsB;AAI/BN,iBAAS,EAAE,KAAKA;AAJe,OAAhB,CAAjB;AAMD;;AAED,WAAO,KAAKI,SAAZ;AACD;AAED;;;;;AAGApB,QAAM,CAAEuB,KAAF,EAAiB;AACrB,WAAOtB,gBAAgB,CAAC,KAAKgB,OAAL,EAAD,EAAiBM,KAAK,CAACN,OAAN,EAAjB,CAAvB;AACD;AAED;;;;;AAGc,QAARO,QAAQ,CAAEC,MAAF,EAAgB;AAC5B,UAAMC,QAAQ,GAAGC,sBAAsB,CAACF,MAAD,EAAS,KAAKX,WAAd,EAA2B,KAAKC,OAAhC,CAAvC;;AAEA,QAAI,KAAKF,MAAL,CAAYK,SAAZ,IAAyB,IAA7B,EAAmC;AACjC,YAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;AACD;;AAED,UAAMS,GAAG,GAAGzB,kBAAkB,CAAC,KAAKU,MAAL,CAAYK,SAAb,CAA9B;AAEA,WAAO,MAAMU,GAAG,CAACC,MAAJ,CAAWH,QAAQ,CAACJ,QAAT,EAAX,EAAgC,KAAKN,SAArC,CAAb;AACD;;AAlHwB;;AACzB;;;;AAGON,oCAAqB,MAAOoB,IAAP,IAAqE;AAC/F,QAAMC,YAAY,GAAGzB,QAAQ,CAAC0B,MAAT,CAAgBF,IAAhB,CAArB;AACA,QAAMjB,MAAM,GAAG,MAAMN,cAAc,CAACwB,YAAY,CAACb,SAAd,CAAnC;AAEA,SAAO,IAAIR,cAAJ,CAAmB;AACxBG,UADwB;AAExBC,eAAW,EAAEiB,YAAY,CAACjB,WAFF;AAGxBC,WAAO,EAAEgB,YAAY,CAAChB,OAHE;AAIxBC,aAAS,EAAEe,YAAY,CAACf;AAJA,GAAnB,CAAP;AAMD,CAVM;AAYP;;;;;;AAION,sBAAO,OAAOuB,MAAP,EAAuBpB,MAAvB,KAAkE;AAC9E,MAAIA,MAAM,CAACqB,UAAP,IAAqB,IAAzB,EAA+B;AAC7B,UAAM,IAAIf,KAAJ,CAAU,qBAAV,CAAN;AACD;;AAED,QAAMM,MAAM,GAAGQ,MAAM,CAACR,MAAtB;AACA,QAAMX,WAAW,GAAGmB,MAAM,CAACE,KAA3B;AACA,QAAMpB,OAAO,GAAGkB,MAAM,CAAChB,OAAP,EAAhB;AACA,QAAMS,QAAQ,GAAGC,sBAAsB,CAACF,MAAD,EAASX,WAAT,EAAsBC,OAAtB,CAAvC;AACA,QAAMa,GAAG,GAAG,MAAM1B,mBAAmB,CAACW,MAAM,CAACqB,UAAR,CAArC;AACA,QAAMlB,SAAS,GAAG,MAAMY,GAAG,CAACQ,IAAJ,CAASV,QAAQ,CAACJ,QAAT,EAAT,CAAxB;AAEA,SAAO,IAAIZ,cAAJ,CAAmB;AACxBG,UADwB;AAExBC,eAFwB;AAGxBC,WAHwB;AAIxBC;AAJwB,GAAnB,CAAP;AAMD,CAlBM;AAoBP;;;;;;AAION,gCAAiB,OAAOoB,IAAP,EAA0CL,MAA1C,KAAqF;AAC3G,QAAMY,QAAQ,GAAG,MAAM3B,cAAc,CAAC4B,kBAAf,CAAkCR,IAAlC,CAAvB;AACA,QAAMS,KAAK,GAAG,MAAMF,QAAQ,CAACb,QAAT,CAAkBC,MAAlB,CAApB;;AAEA,MAAI,CAACc,KAAL,EAAY;AACV,UAAM,IAAI1C,SAAJ,CAAc,sDAAd,EAAsEO,KAAK,CAACoC,uBAA5E,CAAN;AACD;;AAED,SAAOH,QAAP;AACD,CATM;AAyET;;;;;AAGA,MAAMV,sBAAsB,GAAG,CAACF,MAAD,EAAiBX,WAAjB,EAA0CC,OAA1C,KAAkG;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,QAAM0B,gBAAgB,GAAG1C,qBAAqB,CAAC0B,MAAD,CAA9C;AACA,QAAMiB,YAAY,GAAGjC,QAAQ,CAACY,MAAT,CAAgBoB,gBAAgB,CAACE,UAAjC,CAArB;AACA,QAAMC,iBAAiB,GAAGnC,QAAQ,CAACY,MAAT,CAAgBP,WAAW,CAAC+B,MAA5B,CAA1B;AACA,QAAMC,aAAa,GAAGrC,QAAQ,CAACY,MAAT,CAAgBN,OAAO,CAAC8B,MAAxB,CAAtB;AAEA,SAAO,IAAIrC,cAAJ,CACLkC,YADK,EAELD,gBAFK,EAGLG,iBAHK,EAIL9B,WAJK,EAKLgC,aALK,EAML/B,OANK,CAAP;AAQD,CAtBD","names":["CodeError","fromString","uint8arraysFromString","equals","uint8ArrayEquals","unmarshalPrivateKey","unmarshalPublicKey","codes","Envelope","Protobuf","peerIdFromKeys","Uint8ArrayList","unsigned","RecordEnvelope","constructor","init","peerId","payloadType","payload","signature","marshal","publicKey","Error","marshaled","encode","subarray","other","validate","domain","signData","formatSignaturePayload","key","verify","data","envelopeData","decode","record","privateKey","codec","sign","envelope","createFromProtobuf","valid","ERR_SIGNATURE_NOT_VALID","domainUint8Array","domainLength","byteLength","payloadTypeLength","length","payloadLength"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\peer-record\\src\\envelope\\index.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport { fromString as uint8arraysFromString } from 'uint8arrays/from-string'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { unmarshalPrivateKey, unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { codes } from '../errors.js'\nimport { Envelope as Protobuf } from './envelope.js'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Record, Envelope } from '@libp2p/interface-record'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { unsigned } from 'uint8-varint'\n\nexport interface RecordEnvelopeInit {\n  peerId: PeerId\n  payloadType: Uint8Array\n  payload: Uint8Array\n  signature: Uint8Array\n}\n\nexport class RecordEnvelope implements Envelope {\n  /**\n   * Unmarshal a serialized Envelope protobuf message\n   */\n  static createFromProtobuf = async (data: Uint8Array | Uint8ArrayList): Promise<RecordEnvelope> => {\n    const envelopeData = Protobuf.decode(data)\n    const peerId = await peerIdFromKeys(envelopeData.publicKey)\n\n    return new RecordEnvelope({\n      peerId,\n      payloadType: envelopeData.payloadType,\n      payload: envelopeData.payload,\n      signature: envelopeData.signature\n    })\n  }\n\n  /**\n   * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n   * and signs it with the given peerId's private key\n   */\n  static seal = async (record: Record, peerId: PeerId): Promise<RecordEnvelope> => {\n    if (peerId.privateKey == null) {\n      throw new Error('Missing private key')\n    }\n\n    const domain = record.domain\n    const payloadType = record.codec\n    const payload = record.marshal()\n    const signData = formatSignaturePayload(domain, payloadType, payload)\n    const key = await unmarshalPrivateKey(peerId.privateKey)\n    const signature = await key.sign(signData.subarray())\n\n    return new RecordEnvelope({\n      peerId,\n      payloadType,\n      payload,\n      signature\n    })\n  }\n\n  /**\n   * Open and certify a given marshalled envelope.\n   * Data is unmarshalled and the signature validated for the given domain.\n   */\n  static openAndCertify = async (data: Uint8Array | Uint8ArrayList, domain: string): Promise<RecordEnvelope> => {\n    const envelope = await RecordEnvelope.createFromProtobuf(data)\n    const valid = await envelope.validate(domain)\n\n    if (!valid) {\n      throw new CodeError('envelope signature is not valid for the given domain', codes.ERR_SIGNATURE_NOT_VALID)\n    }\n\n    return envelope\n  }\n\n  public peerId: PeerId\n  public payloadType: Uint8Array\n  public payload: Uint8Array\n  public signature: Uint8Array\n  public marshaled?: Uint8Array\n\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   */\n  constructor (init: RecordEnvelopeInit) {\n    const { peerId, payloadType, payload, signature } = init\n\n    this.peerId = peerId\n    this.payloadType = payloadType\n    this.payload = payload\n    this.signature = signature\n  }\n\n  /**\n   * Marshal the envelope content\n   */\n  marshal (): Uint8Array {\n    if (this.peerId.publicKey == null) {\n      throw new Error('Missing public key')\n    }\n\n    if (this.marshaled == null) {\n      this.marshaled = Protobuf.encode({\n        publicKey: this.peerId.publicKey,\n        payloadType: this.payloadType,\n        payload: this.payload.subarray(),\n        signature: this.signature\n      })\n    }\n\n    return this.marshaled\n  }\n\n  /**\n   * Verifies if the other Envelope is identical to this one\n   */\n  equals (other: Envelope): boolean {\n    return uint8ArrayEquals(this.marshal(), other.marshal())\n  }\n\n  /**\n   * Validate envelope data signature for the given domain\n   */\n  async validate (domain: string): Promise<boolean> {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload)\n\n    if (this.peerId.publicKey == null) {\n      throw new Error('Missing public key')\n    }\n\n    const key = unmarshalPublicKey(this.peerId.publicKey)\n\n    return await key.verify(signData.subarray(), this.signature)\n  }\n}\n\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature\n */\nconst formatSignaturePayload = (domain: string, payloadType: Uint8Array, payload: Uint8Array | Uint8ArrayList): Uint8ArrayList => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n\n  const domainUint8Array = uint8arraysFromString(domain)\n  const domainLength = unsigned.encode(domainUint8Array.byteLength)\n  const payloadTypeLength = unsigned.encode(payloadType.length)\n  const payloadLength = unsigned.encode(payload.length)\n\n  return new Uint8ArrayList(\n    domainLength,\n    domainUint8Array,\n    payloadTypeLength,\n    payloadType,\n    payloadLength,\n    payload\n  )\n}\n"]},"metadata":{},"sourceType":"module"}