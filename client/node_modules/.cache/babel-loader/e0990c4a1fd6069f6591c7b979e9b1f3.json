{"ast":null,"code":"/* eslint-disable import/export */\n\n/* eslint-disable complexity */\n\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var KeyType;\n\n(function (KeyType) {\n  KeyType[\"RSA\"] = \"RSA\";\n  KeyType[\"Ed25519\"] = \"Ed25519\";\n  KeyType[\"Secp256k1\"] = \"Secp256k1\";\n})(KeyType || (KeyType = {}));\n\nvar __KeyTypeValues;\n\n(function (__KeyTypeValues) {\n  __KeyTypeValues[__KeyTypeValues[\"RSA\"] = 0] = \"RSA\";\n  __KeyTypeValues[__KeyTypeValues[\"Ed25519\"] = 1] = \"Ed25519\";\n  __KeyTypeValues[__KeyTypeValues[\"Secp256k1\"] = 2] = \"Secp256k1\";\n})(__KeyTypeValues || (__KeyTypeValues = {}));\n\n(function (KeyType) {\n  KeyType.codec = () => {\n    return enumeration(__KeyTypeValues);\n  };\n})(KeyType || (KeyType = {}));\n\nexport var PublicKey;\n\n(function (PublicKey) {\n  let _codec;\n\n  PublicKey.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8);\n          KeyType.codec().encode(obj.Type, w);\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18);\n          w.bytes(obj.Data);\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {};\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Type = KeyType.codec().decode(reader);\n              break;\n\n            case 2:\n              obj.Data = reader.bytes();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  PublicKey.encode = obj => {\n    return encodeMessage(obj, PublicKey.codec());\n  };\n\n  PublicKey.decode = buf => {\n    return decodeMessage(buf, PublicKey.codec());\n  };\n})(PublicKey || (PublicKey = {}));\n\nexport var PrivateKey;\n\n(function (PrivateKey) {\n  let _codec;\n\n  PrivateKey.codec = () => {\n    if (_codec == null) {\n      _codec = message(function (obj, w) {\n        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (opts.lengthDelimited !== false) {\n          w.fork();\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8);\n          KeyType.codec().encode(obj.Type, w);\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18);\n          w.bytes(obj.Data);\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim();\n        }\n      }, (reader, length) => {\n        const obj = {};\n        const end = length == null ? reader.len : reader.pos + length;\n\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Type = KeyType.codec().decode(reader);\n              break;\n\n            case 2:\n              obj.Data = reader.bytes();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return obj;\n      });\n    }\n\n    return _codec;\n  };\n\n  PrivateKey.encode = obj => {\n    return encodeMessage(obj, PrivateKey.codec());\n  };\n\n  PrivateKey.decode = buf => {\n    return decodeMessage(buf, PrivateKey.codec());\n  };\n})(PrivateKey || (PrivateKey = {}));","map":{"version":3,"mappings":"AAAA;;AACA;;AACA;;AACA;;AACA;AAEA,SAASA,WAAT,EAAsBC,aAAtB,EAAqCC,aAArC,EAAoDC,OAApD,QAAmE,iBAAnE;AAIA,WAAYC,OAAZ;;AAAA,WAAYA,OAAZ,EAAmB;AACjBA;AACAA;AACAA;AACD,CAJD,EAAYA,OAAO,KAAPA,OAAO,MAAnB;;AAMA,IAAKC,eAAL;;AAAA,WAAKA,eAAL,EAAoB;AAClBA;AACAA;AACAA;AACD,CAJD,EAAKA,eAAe,KAAfA,eAAe,MAApB;;AAMA,WAAiBD,OAAjB,EAAwB;AACTA,kBAAQ,MAAqB;AACxC,WAAOJ,WAAW,CAAUK,eAAV,CAAlB;AACD,GAFY;AAGd,CAJD,EAAiBD,OAAO,KAAPA,OAAO,MAAxB;;AAUA,OAAM,IAAWE,SAAX;;AAAN,WAAiBA,SAAjB,EAA0B;AACxB,MAAIC,MAAJ;;AAEaD,oBAAQ,MAAuB;AAC1C,QAAIC,MAAM,IAAI,IAAd,EAAoB;AAClBA,YAAM,GAAGJ,OAAO,CAAY,UAACK,GAAD,EAAMC,CAAN,EAAsB;AAAA,YAAbC,IAAa,uEAAN,EAAM;;AAChD,YAAIA,IAAI,CAACC,eAAL,KAAyB,KAA7B,EAAoC;AAClCF,WAAC,CAACG,IAAF;AACD;;AAED,YAAIJ,GAAG,CAACK,IAAJ,IAAY,IAAhB,EAAsB;AACpBJ,WAAC,CAACK,MAAF,CAAS,CAAT;AACAV,iBAAO,CAACW,KAAR,GAAgBC,MAAhB,CAAuBR,GAAG,CAACK,IAA3B,EAAiCJ,CAAjC;AACD;;AAED,YAAID,GAAG,CAACS,IAAJ,IAAY,IAAhB,EAAsB;AACpBR,WAAC,CAACK,MAAF,CAAS,EAAT;AACAL,WAAC,CAACS,KAAF,CAAQV,GAAG,CAACS,IAAZ;AACD;;AAED,YAAIP,IAAI,CAACC,eAAL,KAAyB,KAA7B,EAAoC;AAClCF,WAAC,CAACU,MAAF;AACD;AACF,OAlBe,EAkBb,CAACC,MAAD,EAASC,MAAT,KAAmB;AACpB,cAAMb,GAAG,GAAQ,EAAjB;AAEA,cAAMc,GAAG,GAAGD,MAAM,IAAI,IAAV,GAAiBD,MAAM,CAACG,GAAxB,GAA8BH,MAAM,CAACI,GAAP,GAAaH,MAAvD;;AAEA,eAAOD,MAAM,CAACI,GAAP,GAAaF,GAApB,EAAyB;AACvB,gBAAMG,GAAG,GAAGL,MAAM,CAACN,MAAP,EAAZ;;AAEA,kBAAQW,GAAG,KAAK,CAAhB;AACE,iBAAK,CAAL;AACEjB,iBAAG,CAACK,IAAJ,GAAWT,OAAO,CAACW,KAAR,GAAgBW,MAAhB,CAAuBN,MAAvB,CAAX;AACA;;AACF,iBAAK,CAAL;AACEZ,iBAAG,CAACS,IAAJ,GAAWG,MAAM,CAACF,KAAP,EAAX;AACA;;AACF;AACEE,oBAAM,CAACO,QAAP,CAAgBF,GAAG,GAAG,CAAtB;AACA;AATJ;AAWD;;AAED,eAAOjB,GAAP;AACD,OAxCe,CAAhB;AAyCD;;AAED,WAAOD,MAAP;AACD,GA9CY;;AAgDAD,qBAAUE,GAAD,IAAwC;AAC5D,WAAOP,aAAa,CAACO,GAAD,EAAMF,SAAS,CAACS,KAAV,EAAN,CAApB;AACD,GAFY;;AAIAT,qBAAUsB,GAAD,IAAgD;AACpE,WAAO1B,aAAa,CAAC0B,GAAD,EAAMtB,SAAS,CAACS,KAAV,EAAN,CAApB;AACD,GAFY;AAGd,CA1DD,EAAiBT,SAAS,KAATA,SAAS,MAA1B;;AAiEA,OAAM,IAAWuB,UAAX;;AAAN,WAAiBA,UAAjB,EAA2B;AACzB,MAAItB,MAAJ;;AAEasB,qBAAQ,MAAwB;AAC3C,QAAItB,MAAM,IAAI,IAAd,EAAoB;AAClBA,YAAM,GAAGJ,OAAO,CAAa,UAACK,GAAD,EAAMC,CAAN,EAAsB;AAAA,YAAbC,IAAa,uEAAN,EAAM;;AACjD,YAAIA,IAAI,CAACC,eAAL,KAAyB,KAA7B,EAAoC;AAClCF,WAAC,CAACG,IAAF;AACD;;AAED,YAAIJ,GAAG,CAACK,IAAJ,IAAY,IAAhB,EAAsB;AACpBJ,WAAC,CAACK,MAAF,CAAS,CAAT;AACAV,iBAAO,CAACW,KAAR,GAAgBC,MAAhB,CAAuBR,GAAG,CAACK,IAA3B,EAAiCJ,CAAjC;AACD;;AAED,YAAID,GAAG,CAACS,IAAJ,IAAY,IAAhB,EAAsB;AACpBR,WAAC,CAACK,MAAF,CAAS,EAAT;AACAL,WAAC,CAACS,KAAF,CAAQV,GAAG,CAACS,IAAZ;AACD;;AAED,YAAIP,IAAI,CAACC,eAAL,KAAyB,KAA7B,EAAoC;AAClCF,WAAC,CAACU,MAAF;AACD;AACF,OAlBe,EAkBb,CAACC,MAAD,EAASC,MAAT,KAAmB;AACpB,cAAMb,GAAG,GAAQ,EAAjB;AAEA,cAAMc,GAAG,GAAGD,MAAM,IAAI,IAAV,GAAiBD,MAAM,CAACG,GAAxB,GAA8BH,MAAM,CAACI,GAAP,GAAaH,MAAvD;;AAEA,eAAOD,MAAM,CAACI,GAAP,GAAaF,GAApB,EAAyB;AACvB,gBAAMG,GAAG,GAAGL,MAAM,CAACN,MAAP,EAAZ;;AAEA,kBAAQW,GAAG,KAAK,CAAhB;AACE,iBAAK,CAAL;AACEjB,iBAAG,CAACK,IAAJ,GAAWT,OAAO,CAACW,KAAR,GAAgBW,MAAhB,CAAuBN,MAAvB,CAAX;AACA;;AACF,iBAAK,CAAL;AACEZ,iBAAG,CAACS,IAAJ,GAAWG,MAAM,CAACF,KAAP,EAAX;AACA;;AACF;AACEE,oBAAM,CAACO,QAAP,CAAgBF,GAAG,GAAG,CAAtB;AACA;AATJ;AAWD;;AAED,eAAOjB,GAAP;AACD,OAxCe,CAAhB;AAyCD;;AAED,WAAOD,MAAP;AACD,GA9CY;;AAgDAsB,sBAAUrB,GAAD,IAAyC;AAC7D,WAAOP,aAAa,CAACO,GAAD,EAAMqB,UAAU,CAACd,KAAX,EAAN,CAApB;AACD,GAFY;;AAIAc,sBAAUD,GAAD,IAAiD;AACrE,WAAO1B,aAAa,CAAC0B,GAAD,EAAMC,UAAU,CAACd,KAAX,EAAN,CAApB;AACD,GAFY;AAGd,CA1DD,EAAiBc,UAAU,KAAVA,UAAU,MAA3B","names":["enumeration","encodeMessage","decodeMessage","message","KeyType","__KeyTypeValues","PublicKey","_codec","obj","w","opts","lengthDelimited","fork","Type","uint32","codec","encode","Data","bytes","ldelim","reader","length","end","len","pos","tag","decode","skipType","buf","PrivateKey"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\crypto\\src\\keys\\keys.ts"],"sourcesContent":["/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport enum KeyType {\n  RSA = 'RSA',\n  Ed25519 = 'Ed25519',\n  Secp256k1 = 'Secp256k1'\n}\n\nenum __KeyTypeValues {\n  RSA = 0,\n  Ed25519 = 1,\n  Secp256k1 = 2\n}\n\nexport namespace KeyType {\n  export const codec = (): Codec<KeyType> => {\n    return enumeration<KeyType>(__KeyTypeValues)\n  }\n}\nexport interface PublicKey {\n  Type?: KeyType\n  Data?: Uint8Array\n}\n\nexport namespace PublicKey {\n  let _codec: Codec<PublicKey>\n\n  export const codec = (): Codec<PublicKey> => {\n    if (_codec == null) {\n      _codec = message<PublicKey>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          KeyType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Type = KeyType.codec().decode(reader)\n              break\n            case 2:\n              obj.Data = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PublicKey>): Uint8Array => {\n    return encodeMessage(obj, PublicKey.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PublicKey => {\n    return decodeMessage(buf, PublicKey.codec())\n  }\n}\n\nexport interface PrivateKey {\n  Type?: KeyType\n  Data?: Uint8Array\n}\n\nexport namespace PrivateKey {\n  let _codec: Codec<PrivateKey>\n\n  export const codec = (): Codec<PrivateKey> => {\n    if (_codec == null) {\n      _codec = message<PrivateKey>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          KeyType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Type = KeyType.codec().decode(reader)\n              break\n            case 2:\n              obj.Data = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PrivateKey>): Uint8Array => {\n    return encodeMessage(obj, PrivateKey.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PrivateKey => {\n    return decodeMessage(buf, PrivateKey.codec())\n  }\n}\n"]},"metadata":{},"sourceType":"module"}