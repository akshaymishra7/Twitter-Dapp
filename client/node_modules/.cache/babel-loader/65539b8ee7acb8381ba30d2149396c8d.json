{"ast":null,"code":"import { CodeError } from '@libp2p/interfaces/errors';\nimport { verifyRecord } from '@libp2p/record/validators';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { Message, MESSAGE_TYPE } from '../message/index.js';\nimport * as utils from '../utils.js';\nimport { queryErrorEvent, finalPeerEvent, valueEvent } from '../query/events.js';\nimport { PeerDistanceList } from '../peer-list/peer-distance-list.js';\nimport { Libp2pRecord } from '@libp2p/record';\nimport { logger } from '@libp2p/logger';\nimport { keys } from '@libp2p/crypto';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nexport class PeerRouting {\n  constructor(components, init) {\n    const {\n      routingTable,\n      network,\n      validators,\n      queryManager,\n      lan\n    } = init;\n    this.components = components;\n    this.routingTable = routingTable;\n    this.network = network;\n    this.validators = validators;\n    this.queryManager = queryManager;\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:peer-routing`);\n  }\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   */\n\n\n  async findPeerLocal(peer) {\n    let peerData;\n    const p = await this.routingTable.find(peer);\n\n    if (p != null) {\n      this.log('findPeerLocal found %p in routing table', peer);\n\n      try {\n        peerData = await this.components.peerStore.get(p);\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n      }\n    }\n\n    if (peerData == null) {\n      try {\n        peerData = await this.components.peerStore.get(peer);\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n      }\n    }\n\n    if (peerData != null) {\n      this.log('findPeerLocal found %p in peer store', peer);\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map(address => address.multiaddr),\n        protocols: []\n      };\n    }\n\n    return undefined;\n  }\n  /**\n   * Get a value via rpc call for the given parameters\n   */\n\n\n  async *_getValueSingle(peer, key) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const msg = new Message(MESSAGE_TYPE.GET_VALUE, key, 0);\n    yield* this.network.sendRequest(peer, msg, options);\n  }\n  /**\n   * Get the public key directly from a node\n   */\n\n\n  async *getPublicKeyFromNode(peer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const pkKey = utils.keyForPublicKey(peer);\n\n    for await (const event of this._getValueSingle(peer, pkKey, options)) {\n      yield event;\n\n      if (event.name === 'PEER_RESPONSE' && event.record != null) {\n        const recPeer = await peerIdFromKeys(keys.marshalPublicKey({\n          bytes: event.record.value\n        })); // compare hashes of the pub key\n\n        if (!recPeer.equals(peer)) {\n          throw new CodeError('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n        }\n\n        if (recPeer.publicKey == null) {\n          throw new CodeError('public key missing', 'ERR_PUBLIC_KEY_MISSING');\n        }\n\n        yield valueEvent({\n          from: peer,\n          value: recPeer.publicKey\n        });\n      }\n    }\n\n    throw new CodeError(`Node not responding with its public key: ${peer.toString()}`, 'ERR_INVALID_RECORD');\n  }\n  /**\n   * Search for a peer with the given ID\n   */\n\n\n  async *findPeer(id) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.log('findPeer %p', id); // Try to find locally\n\n    const pi = await this.findPeerLocal(id); // already got it\n\n    if (pi != null) {\n      this.log('found local');\n      yield finalPeerEvent({\n        from: this.components.peerId,\n        peer: pi\n      });\n      return;\n    }\n\n    const key = await utils.convertPeerId(id);\n    const peers = this.routingTable.closestPeers(key); // sanity check\n\n    const match = peers.find(p => p.equals(id));\n\n    if (match != null) {\n      try {\n        const peer = await this.components.peerStore.get(id);\n        this.log('found in peerStore');\n        yield finalPeerEvent({\n          from: this.components.peerId,\n          peer: {\n            id: peer.id,\n            multiaddrs: peer.addresses.map(address => address.multiaddr),\n            protocols: []\n          }\n        });\n        return;\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n      }\n    }\n\n    const self = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\n    const findPeerQuery = async function* (_ref) {\n      let {\n        peer,\n        signal\n      } = _ref;\n      const request = new Message(MESSAGE_TYPE.FIND_NODE, id.toBytes(), 0);\n\n      for await (const event of self.network.sendRequest(peer, request, {\n        signal\n      })) {\n        yield event;\n\n        if (event.name === 'PEER_RESPONSE') {\n          const match = event.closer.find(p => p.id.equals(id)); // found the peer\n\n          if (match != null) {\n            yield finalPeerEvent({\n              from: event.from,\n              peer: match\n            });\n          }\n        }\n      }\n    };\n\n    let foundPeer = false;\n\n    for await (const event of this.queryManager.run(id.toBytes(), peers, findPeerQuery, options)) {\n      if (event.name === 'FINAL_PEER') {\n        foundPeer = true;\n      }\n\n      yield event;\n    }\n\n    if (!foundPeer) {\n      yield queryErrorEvent({\n        from: this.components.peerId,\n        error: new CodeError('Not found', 'ERR_NOT_FOUND')\n      });\n    }\n  }\n  /**\n   * Kademlia 'node lookup' operation on a key, which could be a the\n   * bytes from a multihash or a peer ID\n   */\n\n\n  async *getClosestPeers(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.log('getClosestPeers to %b', key);\n    const id = await utils.convertBuffer(key);\n    const tablePeers = this.routingTable.closestPeers(id);\n    const self = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\n    const peers = new PeerDistanceList(id, this.routingTable.kBucketSize);\n    await Promise.all(tablePeers.map(async peer => {\n      await peers.add(peer);\n    }));\n\n    const getCloserPeersQuery = async function* (_ref2) {\n      let {\n        peer,\n        signal\n      } = _ref2;\n      self.log('closerPeersSingle %s from %p', uint8ArrayToString(key, 'base32'), peer);\n      const request = new Message(MESSAGE_TYPE.FIND_NODE, key, 0);\n      yield* self.network.sendRequest(peer, request, {\n        signal\n      });\n    };\n\n    for await (const event of this.queryManager.run(key, tablePeers, getCloserPeersQuery, options)) {\n      yield event;\n\n      if (event.name === 'PEER_RESPONSE') {\n        await Promise.all(event.closer.map(async peerData => {\n          await peers.add(peerData.id);\n        }));\n      }\n    }\n\n    this.log('found %d peers close to %b', peers.length, key);\n\n    for (const peer of peers.peers) {\n      yield finalPeerEvent({\n        from: this.components.peerId,\n        peer: {\n          id: peer,\n          multiaddrs: ((await this.components.peerStore.addressBook.get(peer)) ?? []).map(addr => addr.multiaddr),\n          protocols: []\n        }\n      });\n    }\n  }\n  /**\n   * Query a particular peer for the value for the given key.\n   * It will either return the value or a list of closer peers.\n   *\n   * Note: The peerStore is updated with new addresses found for the given peer.\n   */\n\n\n  async *getValueOrPeers(peer, key) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for await (const event of this._getValueSingle(peer, key, options)) {\n      if (event.name === 'PEER_RESPONSE') {\n        if (event.record != null) {\n          // We have a record\n          try {\n            await this._verifyRecordOnline(event.record);\n          } catch (err) {\n            const errMsg = 'invalid record received, discarded';\n            this.log(errMsg);\n            yield queryErrorEvent({\n              from: event.from,\n              error: new CodeError(errMsg, 'ERR_INVALID_RECORD')\n            });\n            continue;\n          }\n        }\n      }\n\n      yield event;\n    }\n  }\n  /**\n   * Verify a record, fetching missing public keys from the network.\n   * Throws an error if the record is invalid.\n   */\n\n\n  async _verifyRecordOnline(record) {\n    if (record.timeReceived == null) {\n      throw new CodeError('invalid record received', 'ERR_INVALID_RECORD');\n    }\n\n    await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived));\n  }\n  /**\n   * Get the nearest peers to the given query, but if closer\n   * than self\n   */\n\n\n  async getCloserPeersOffline(key, closerThan) {\n    const id = await utils.convertBuffer(key);\n    const ids = this.routingTable.closestPeers(id);\n    const output = [];\n\n    for (const peerId of ids) {\n      if (peerId.equals(closerThan)) {\n        continue;\n      }\n\n      try {\n        const addresses = await this.components.peerStore.addressBook.get(peerId);\n        const protocols = await this.components.peerStore.protoBook.get(peerId);\n        output.push({\n          id: peerId,\n          multiaddrs: addresses.map(address => address.multiaddr),\n          protocols\n        });\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n      }\n    }\n\n    if (output.length > 0) {\n      this.log('getCloserPeersOffline found %d peer(s) closer to %b than %p', output.length, key, closerThan);\n    } else {\n      this.log('getCloserPeersOffline could not find peer closer to %b than %p', key, closerThan);\n    }\n\n    return output;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["CodeError","verifyRecord","toString","uint8ArrayToString","Message","MESSAGE_TYPE","utils","queryErrorEvent","finalPeerEvent","valueEvent","PeerDistanceList","Libp2pRecord","logger","keys","peerIdFromKeys","PeerRouting","constructor","components","init","routingTable","network","validators","queryManager","lan","log","findPeerLocal","peer","peerData","p","find","peerStore","get","err","code","id","multiaddrs","addresses","map","address","multiaddr","protocols","undefined","_getValueSingle","key","options","msg","GET_VALUE","sendRequest","getPublicKeyFromNode","pkKey","keyForPublicKey","event","name","record","recPeer","marshalPublicKey","bytes","value","equals","publicKey","from","findPeer","pi","peerId","convertPeerId","peers","closestPeers","match","self","findPeerQuery","signal","request","FIND_NODE","toBytes","closer","foundPeer","run","error","getClosestPeers","convertBuffer","tablePeers","kBucketSize","Promise","all","add","getCloserPeersQuery","length","addressBook","addr","getValueOrPeers","_verifyRecordOnline","errMsg","timeReceived","getCloserPeersOffline","closerThan","ids","output","protoBook","push"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\peer-routing\\index.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interfaces/errors'\nimport { verifyRecord } from '@libp2p/record/validators'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { Message, MESSAGE_TYPE } from '../message/index.js'\nimport * as utils from '../utils.js'\nimport {\n  queryErrorEvent,\n  finalPeerEvent,\n  valueEvent\n} from '../query/events.js'\nimport { PeerDistanceList } from '../peer-list/peer-distance-list.js'\nimport { Libp2pRecord } from '@libp2p/record'\nimport { logger } from '@libp2p/logger'\nimport { keys } from '@libp2p/crypto'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport type { DHTRecord, DialingPeerEvent, FinalPeerEvent, QueryEvent, QueryOptions, Validators } from '@libp2p/interface-dht'\nimport type { RoutingTable } from '../routing-table/index.js'\nimport type { QueryManager } from '../query/manager.js'\nimport type { Network } from '../network.js'\nimport type { Logger } from '@libp2p/logger'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { QueryFunc } from '../query/types.js'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { KadDHTComponents } from '../index.js'\n\nexport interface PeerRoutingInit {\n  routingTable: RoutingTable\n  network: Network\n  validators: Validators\n  queryManager: QueryManager\n  lan: boolean\n}\n\nexport class PeerRouting {\n  private readonly components: KadDHTComponents\n  private readonly log: Logger\n  private readonly routingTable: RoutingTable\n  private readonly network: Network\n  private readonly validators: Validators\n  private readonly queryManager: QueryManager\n\n  constructor (components: KadDHTComponents, init: PeerRoutingInit) {\n    const { routingTable, network, validators, queryManager, lan } = init\n\n    this.components = components\n    this.routingTable = routingTable\n    this.network = network\n    this.validators = validators\n    this.queryManager = queryManager\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:peer-routing`)\n  }\n\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   */\n  async findPeerLocal (peer: PeerId): Promise<PeerInfo | undefined> {\n    let peerData\n    const p = await this.routingTable.find(peer)\n\n    if (p != null) {\n      this.log('findPeerLocal found %p in routing table', peer)\n\n      try {\n        peerData = await this.components.peerStore.get(p)\n      } catch (err: any) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n    }\n\n    if (peerData == null) {\n      try {\n        peerData = await this.components.peerStore.get(peer)\n      } catch (err: any) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n    }\n\n    if (peerData != null) {\n      this.log('findPeerLocal found %p in peer store', peer)\n\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr),\n        protocols: []\n      }\n    }\n\n    return undefined\n  }\n\n  /**\n   * Get a value via rpc call for the given parameters\n   */\n  async * _getValueSingle (peer: PeerId, key: Uint8Array, options: AbortOptions = {}): AsyncGenerator<QueryEvent> {\n    const msg = new Message(MESSAGE_TYPE.GET_VALUE, key, 0)\n    yield * this.network.sendRequest(peer, msg, options)\n  }\n\n  /**\n   * Get the public key directly from a node\n   */\n  async * getPublicKeyFromNode (peer: PeerId, options: AbortOptions = {}): AsyncGenerator<QueryEvent> {\n    const pkKey = utils.keyForPublicKey(peer)\n\n    for await (const event of this._getValueSingle(peer, pkKey, options)) {\n      yield event\n\n      if (event.name === 'PEER_RESPONSE' && event.record != null) {\n        const recPeer = await peerIdFromKeys(keys.marshalPublicKey({ bytes: event.record.value }))\n\n        // compare hashes of the pub key\n        if (!recPeer.equals(peer)) {\n          throw new CodeError('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID')\n        }\n\n        if (recPeer.publicKey == null) {\n          throw new CodeError('public key missing', 'ERR_PUBLIC_KEY_MISSING')\n        }\n\n        yield valueEvent({ from: peer, value: recPeer.publicKey })\n      }\n    }\n\n    throw new CodeError(`Node not responding with its public key: ${peer.toString()}`, 'ERR_INVALID_RECORD')\n  }\n\n  /**\n   * Search for a peer with the given ID\n   */\n  async * findPeer (id: PeerId, options: QueryOptions = {}): AsyncGenerator<FinalPeerEvent | QueryEvent> {\n    this.log('findPeer %p', id)\n\n    // Try to find locally\n    const pi = await this.findPeerLocal(id)\n\n    // already got it\n    if (pi != null) {\n      this.log('found local')\n      yield finalPeerEvent({\n        from: this.components.peerId,\n        peer: pi\n      })\n      return\n    }\n\n    const key = await utils.convertPeerId(id)\n    const peers = this.routingTable.closestPeers(key)\n\n    // sanity check\n    const match = peers.find((p) => p.equals(id))\n\n    if (match != null) {\n      try {\n        const peer = await this.components.peerStore.get(id)\n\n        this.log('found in peerStore')\n        yield finalPeerEvent({\n          from: this.components.peerId,\n          peer: {\n            id: peer.id,\n            multiaddrs: peer.addresses.map((address) => address.multiaddr),\n            protocols: []\n          }\n        })\n\n        return\n      } catch (err: any) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n    }\n\n    const self = this // eslint-disable-line @typescript-eslint/no-this-alias\n\n    const findPeerQuery: QueryFunc = async function * ({ peer, signal }) {\n      const request = new Message(MESSAGE_TYPE.FIND_NODE, id.toBytes(), 0)\n\n      for await (const event of self.network.sendRequest(peer, request, { signal })) {\n        yield event\n\n        if (event.name === 'PEER_RESPONSE') {\n          const match = event.closer.find((p) => p.id.equals(id))\n\n          // found the peer\n          if (match != null) {\n            yield finalPeerEvent({ from: event.from, peer: match })\n          }\n        }\n      }\n    }\n\n    let foundPeer = false\n\n    for await (const event of this.queryManager.run(id.toBytes(), peers, findPeerQuery, options)) {\n      if (event.name === 'FINAL_PEER') {\n        foundPeer = true\n      }\n\n      yield event\n    }\n\n    if (!foundPeer) {\n      yield queryErrorEvent({ from: this.components.peerId, error: new CodeError('Not found', 'ERR_NOT_FOUND') })\n    }\n  }\n\n  /**\n   * Kademlia 'node lookup' operation on a key, which could be a the\n   * bytes from a multihash or a peer ID\n   */\n  async * getClosestPeers (key: Uint8Array, options: QueryOptions = {}): AsyncGenerator<DialingPeerEvent | QueryEvent> {\n    this.log('getClosestPeers to %b', key)\n    const id = await utils.convertBuffer(key)\n    const tablePeers = this.routingTable.closestPeers(id)\n    const self = this // eslint-disable-line @typescript-eslint/no-this-alias\n\n    const peers = new PeerDistanceList(id, this.routingTable.kBucketSize)\n    await Promise.all(tablePeers.map(async peer => { await peers.add(peer) }))\n\n    const getCloserPeersQuery: QueryFunc = async function * ({ peer, signal }) {\n      self.log('closerPeersSingle %s from %p', uint8ArrayToString(key, 'base32'), peer)\n      const request = new Message(MESSAGE_TYPE.FIND_NODE, key, 0)\n\n      yield * self.network.sendRequest(peer, request, { signal })\n    }\n\n    for await (const event of this.queryManager.run(key, tablePeers, getCloserPeersQuery, options)) {\n      yield event\n\n      if (event.name === 'PEER_RESPONSE') {\n        await Promise.all(event.closer.map(async peerData => { await peers.add(peerData.id) }))\n      }\n    }\n\n    this.log('found %d peers close to %b', peers.length, key)\n\n    for (const peer of peers.peers) {\n      yield finalPeerEvent({\n        from: this.components.peerId,\n        peer: {\n          id: peer,\n          multiaddrs: (await (this.components.peerStore.addressBook.get(peer)) ?? []).map(addr => addr.multiaddr),\n          protocols: []\n        }\n      })\n    }\n  }\n\n  /**\n   * Query a particular peer for the value for the given key.\n   * It will either return the value or a list of closer peers.\n   *\n   * Note: The peerStore is updated with new addresses found for the given peer.\n   */\n  async * getValueOrPeers (peer: PeerId, key: Uint8Array, options: AbortOptions = {}): AsyncGenerator<DialingPeerEvent | QueryEvent> {\n    for await (const event of this._getValueSingle(peer, key, options)) {\n      if (event.name === 'PEER_RESPONSE') {\n        if (event.record != null) {\n          // We have a record\n          try {\n            await this._verifyRecordOnline(event.record)\n          } catch (err: any) {\n            const errMsg = 'invalid record received, discarded'\n            this.log(errMsg)\n\n            yield queryErrorEvent({ from: event.from, error: new CodeError(errMsg, 'ERR_INVALID_RECORD') })\n            continue\n          }\n        }\n      }\n\n      yield event\n    }\n  }\n\n  /**\n   * Verify a record, fetching missing public keys from the network.\n   * Throws an error if the record is invalid.\n   */\n  async _verifyRecordOnline (record: DHTRecord): Promise<void> {\n    if (record.timeReceived == null) {\n      throw new CodeError('invalid record received', 'ERR_INVALID_RECORD')\n    }\n\n    await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived))\n  }\n\n  /**\n   * Get the nearest peers to the given query, but if closer\n   * than self\n   */\n  async getCloserPeersOffline (key: Uint8Array, closerThan: PeerId): Promise<PeerInfo[]> {\n    const id = await utils.convertBuffer(key)\n    const ids = this.routingTable.closestPeers(id)\n    const output: PeerInfo[] = []\n\n    for (const peerId of ids) {\n      if (peerId.equals(closerThan)) {\n        continue\n      }\n\n      try {\n        const addresses = await this.components.peerStore.addressBook.get(peerId)\n        const protocols = await this.components.peerStore.protoBook.get(peerId)\n\n        output.push({\n          id: peerId,\n          multiaddrs: addresses.map((address) => address.multiaddr),\n          protocols\n        })\n      } catch (err: any) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n    }\n\n    if (output.length > 0) {\n      this.log('getCloserPeersOffline found %d peer(s) closer to %b than %p', output.length, key, closerThan)\n    } else {\n      this.log('getCloserPeersOffline could not find peer closer to %b than %p', key, closerThan)\n    }\n\n    return output\n  }\n}\n"]},"metadata":{},"sourceType":"module"}