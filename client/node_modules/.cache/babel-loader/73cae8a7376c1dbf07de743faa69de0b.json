{"ast":null,"code":"/**\n * @param {Uint8Array} block\n * @param {number} blockStart\n * @param {number} requestedStart\n * @param {number} requestedEnd\n */\nfunction extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {\n  const blockLength = block.length;\n  const blockEnd = blockStart + blockLength;\n\n  if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n    // If we are looking for a byte range that is starts after the start of the block,\n    // return an empty block.  This can happen when internal nodes contain data\n    return new Uint8Array(0);\n  }\n\n  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n    // If the end byte is in the current block, truncate the block to the end byte\n    block = block.subarray(0, requestedEnd - blockStart);\n  }\n\n  if (requestedStart >= blockStart && requestedStart < blockEnd) {\n    // If the start byte is in the current block, skip to the start byte\n    block = block.subarray(requestedStart - blockStart);\n  }\n\n  return block;\n}\n\nexport default extractDataFromBlock;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.js"],"names":["extractDataFromBlock","block","blockStart","requestedStart","requestedEnd","blockLength","length","blockEnd","Uint8Array","subarray"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,oBAAT,CAA+BC,KAA/B,EAAsCC,UAAtC,EAAkDC,cAAlD,EAAkEC,YAAlE,EAAgF;AAC9E,QAAMC,WAAW,GAAGJ,KAAK,CAACK,MAA1B;AACA,QAAMC,QAAQ,GAAGL,UAAU,GAAGG,WAA9B;;AAEA,MAAIF,cAAc,IAAII,QAAlB,IAA8BH,YAAY,GAAGF,UAAjD,EAA6D;AAC3D;AACA;AACA,WAAO,IAAIM,UAAJ,CAAe,CAAf,CAAP;AACD;;AAED,MAAIJ,YAAY,IAAIF,UAAhB,IAA8BE,YAAY,GAAGG,QAAjD,EAA2D;AACzD;AACAN,IAAAA,KAAK,GAAGA,KAAK,CAACQ,QAAN,CAAe,CAAf,EAAkBL,YAAY,GAAGF,UAAjC,CAAR;AACD;;AAED,MAAIC,cAAc,IAAID,UAAlB,IAAgCC,cAAc,GAAGI,QAArD,EAA+D;AAC7D;AACAN,IAAAA,KAAK,GAAGA,KAAK,CAACQ,QAAN,CAAeN,cAAc,GAAGD,UAAhC,CAAR;AACD;;AAED,SAAOD,KAAP;AACD;;AAED,eAAeD,oBAAf","sourcesContent":["/**\n * @param {Uint8Array} block\n * @param {number} blockStart\n * @param {number} requestedStart\n * @param {number} requestedEnd\n */\nfunction extractDataFromBlock (block, blockStart, requestedStart, requestedEnd) {\n  const blockLength = block.length\n  const blockEnd = blockStart + blockLength\n\n  if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n    // If we are looking for a byte range that is starts after the start of the block,\n    // return an empty block.  This can happen when internal nodes contain data\n    return new Uint8Array(0)\n  }\n\n  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n    // If the end byte is in the current block, truncate the block to the end byte\n    block = block.subarray(0, requestedEnd - blockStart)\n  }\n\n  if (requestedStart >= blockStart && requestedStart < blockEnd) {\n    // If the start byte is in the current block, skip to the start byte\n    block = block.subarray(requestedStart - blockStart)\n  }\n\n  return block\n}\n\nexport default extractDataFromBlock\n"]},"metadata":{},"sourceType":"module"}