{"ast":null,"code":"import cache from 'hashlru';\nimport varint from 'varint';\nimport { Key } from 'interface-datastore/key';\nimport Queue from 'p-queue';\nimport { PROVIDERS_CLEANUP_INTERVAL, PROVIDERS_VALIDITY, PROVIDERS_LRU_CACHE_SIZE, PROVIDER_KEY_PREFIX } from './constants.js';\nimport { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { peerIdFromString } from '@libp2p/peer-id';\nconst log = logger('libp2p:kad-dht:providers');\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\n\nexport class Providers {\n  constructor(components) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      cacheSize,\n      cleanupInterval,\n      provideValidity\n    } = init;\n    this.components = components;\n    this.cleanupInterval = cleanupInterval ?? PROVIDERS_CLEANUP_INTERVAL;\n    this.provideValidity = provideValidity ?? PROVIDERS_VALIDITY;\n    this.cache = cache(cacheSize ?? PROVIDERS_LRU_CACHE_SIZE);\n    this.syncQueue = new Queue({\n      concurrency: 1\n    });\n    this.started = false;\n  }\n\n  isStarted() {\n    return this.started;\n  }\n  /**\n   * Start the provider cleanup service\n   */\n\n\n  async start() {\n    if (this.started) {\n      return;\n    }\n\n    this.started = true;\n    this.cleaner = setInterval(() => {\n      this._cleanup().catch(err => {\n        log.error(err);\n      });\n    }, this.cleanupInterval);\n  }\n  /**\n   * Release any resources.\n   */\n\n\n  async stop() {\n    this.started = false;\n\n    if (this.cleaner != null) {\n      clearInterval(this.cleaner);\n      this.cleaner = undefined;\n    }\n  }\n  /**\n   * Check all providers if they are still valid, and if not delete them\n   */\n\n\n  async _cleanup() {\n    await this.syncQueue.add(async () => {\n      const start = Date.now();\n      let count = 0;\n      let deleteCount = 0;\n      const deleted = new Map();\n      const batch = this.components.datastore.batch(); // Get all provider entries from the datastore\n\n      const query = this.components.datastore.query({\n        prefix: PROVIDER_KEY_PREFIX\n      });\n\n      for await (const entry of query) {\n        try {\n          // Add a delete to the batch for each expired entry\n          const {\n            cid,\n            peerId\n          } = parseProviderKey(entry.key);\n          const time = readTime(entry.value).getTime();\n          const now = Date.now();\n          const delta = now - time;\n          const expired = delta > this.provideValidity;\n          log('comparing: %d - %d = %d > %d %s', now, time, delta, this.provideValidity, expired ? '(expired)' : '');\n\n          if (expired) {\n            deleteCount++;\n            batch.delete(entry.key);\n            const peers = deleted.get(cid) ?? new Set();\n            peers.add(peerId);\n            deleted.set(cid, peers);\n          }\n\n          count++;\n        } catch (err) {\n          log.error(err.message);\n        }\n      } // Commit the deletes to the datastore\n\n\n      if (deleted.size > 0) {\n        log('deleting %d / %d entries', deleteCount, count);\n        await batch.commit();\n      } else {\n        log('nothing to delete');\n      } // Clear expired entries from the cache\n\n\n      for (const [cid, peers] of deleted) {\n        const key = makeProviderKey(cid);\n        const provs = this.cache.get(key);\n\n        if (provs != null) {\n          for (const peerId of peers) {\n            provs.delete(peerId);\n          }\n\n          if (provs.size === 0) {\n            this.cache.remove(key);\n          } else {\n            this.cache.set(key, provs);\n          }\n        }\n      }\n\n      log('Cleanup successful (%dms)', Date.now() - start);\n    });\n  }\n  /**\n   * Get the currently known provider peer ids for a given CID\n   */\n\n\n  async _getProvidersMap(cid) {\n    const cacheKey = makeProviderKey(cid);\n    let provs = this.cache.get(cacheKey);\n\n    if (provs == null) {\n      provs = await loadProviders(this.components.datastore, cid);\n      this.cache.set(cacheKey, provs);\n    }\n\n    return provs;\n  }\n  /**\n   * Add a new provider for the given CID\n   */\n\n\n  async addProvider(cid, provider) {\n    await this.syncQueue.add(async () => {\n      log('%p provides %s', provider, cid);\n      const provs = await this._getProvidersMap(cid);\n      log('loaded %s provs', provs.size);\n      const now = new Date();\n      provs.set(provider.toString(), now);\n      const dsKey = makeProviderKey(cid);\n      this.cache.set(dsKey, provs);\n      await writeProviderEntry(this.components.datastore, cid, provider, now);\n    });\n  }\n  /**\n   * Get a list of providers for the given CID\n   */\n\n\n  async getProviders(cid) {\n    return await this.syncQueue.add(async () => {\n      log('get providers for %s', cid);\n      const provs = await this._getProvidersMap(cid);\n      return [...provs.keys()].map(peerIdStr => {\n        return peerIdFromString(peerIdStr);\n      });\n    }, {\n      // no timeout is specified for this queue so it will not\n      // throw, but this is required to get the right return\n      // type since p-queue@7.3.4\n      throwOnTimeout: true\n    });\n  }\n\n}\n/**\n * Encode the given key its matching datastore key\n */\n\nfunction makeProviderKey(cid) {\n  const cidStr = typeof cid === 'string' ? cid : uint8ArrayToString(cid.multihash.bytes, 'base32');\n  return `${PROVIDER_KEY_PREFIX}/${cidStr}`;\n}\n/**\n * Write a provider into the given store\n */\n\n\nasync function writeProviderEntry(store, cid, peer, time) {\n  const dsKey = [makeProviderKey(cid), '/', peer.toString()].join('');\n  const key = new Key(dsKey);\n  const buffer = Uint8Array.from(varint.encode(time.getTime()));\n  await store.put(key, buffer);\n}\n/**\n * Parse the CID and provider peer id from the key\n */\n\n\nfunction parseProviderKey(key) {\n  const parts = key.toString().split('/');\n\n  if (parts.length !== 5) {\n    throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);\n  }\n\n  return {\n    cid: parts[3],\n    peerId: parts[4]\n  };\n}\n/**\n * Load providers for the given CID from the store\n */\n\n\nasync function loadProviders(store, cid) {\n  const providers = new Map();\n  const query = store.query({\n    prefix: makeProviderKey(cid)\n  });\n\n  for await (const entry of query) {\n    const {\n      peerId\n    } = parseProviderKey(entry.key);\n    providers.set(peerId, readTime(entry.value));\n  }\n\n  return providers;\n}\n\nfunction readTime(buf) {\n  return new Date(varint.decode(buf));\n}","map":{"version":3,"mappings":"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","names":["cache","varint","Key","Queue","PROVIDERS_CLEANUP_INTERVAL","PROVIDERS_VALIDITY","PROVIDERS_LRU_CACHE_SIZE","PROVIDER_KEY_PREFIX","logger","toString","uint8ArrayToString","peerIdFromString","log","Providers","constructor","components","init","cacheSize","cleanupInterval","provideValidity","syncQueue","concurrency","started","isStarted","start","cleaner","setInterval","_cleanup","catch","err","error","stop","clearInterval","undefined","add","Date","now","count","deleteCount","deleted","Map","batch","datastore","query","prefix","entry","cid","peerId","parseProviderKey","key","time","readTime","value","getTime","delta","expired","delete","peers","get","Set","set","message","size","commit","makeProviderKey","provs","remove","_getProvidersMap","cacheKey","loadProviders","addProvider","provider","dsKey","writeProviderEntry","getProviders","keys","map","peerIdStr","throwOnTimeout","cidStr","multihash","bytes","store","peer","join","buffer","Uint8Array","from","encode","put","parts","split","length","Error","providers","buf","decode"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\providers.ts"],"sourcesContent":["import cache from 'hashlru'\nimport varint from 'varint'\nimport { Key } from 'interface-datastore/key'\nimport Queue from 'p-queue'\nimport {\n  PROVIDERS_CLEANUP_INTERVAL,\n  PROVIDERS_VALIDITY,\n  PROVIDERS_LRU_CACHE_SIZE,\n  PROVIDER_KEY_PREFIX\n} from './constants.js'\nimport { logger } from '@libp2p/logger'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport type { Datastore } from 'interface-datastore'\nimport type { Startable } from '@libp2p/interfaces/startable'\nimport type { CID } from 'multiformats'\nimport type { PeerId } from '@libp2p/interface-peer-id'\n\nconst log = logger('libp2p:kad-dht:providers')\n\nexport interface ProvidersInit {\n  cacheSize?: number\n  /**\n   * How often invalid records are cleaned. (in seconds)\n   */\n  cleanupInterval?: number\n  /**\n   * How long is a provider valid for. (in seconds)\n   */\n  provideValidity?: number\n}\n\nexport interface ProvidersComponents {\n  datastore: Datastore\n}\n\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\nexport class Providers implements Startable {\n  private readonly components: ProvidersComponents\n  private readonly cache: ReturnType<typeof cache>\n  private readonly cleanupInterval: number\n  private readonly provideValidity: number\n  private readonly syncQueue: Queue\n  private started: boolean\n  private cleaner?: NodeJS.Timer\n\n  constructor (components: ProvidersComponents, init: ProvidersInit = {}) {\n    const { cacheSize, cleanupInterval, provideValidity } = init\n\n    this.components = components\n    this.cleanupInterval = cleanupInterval ?? PROVIDERS_CLEANUP_INTERVAL\n    this.provideValidity = provideValidity ?? PROVIDERS_VALIDITY\n    this.cache = cache(cacheSize ?? PROVIDERS_LRU_CACHE_SIZE)\n    this.syncQueue = new Queue({ concurrency: 1 })\n    this.started = false\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  /**\n   * Start the provider cleanup service\n   */\n  async start (): Promise<void> {\n    if (this.started) {\n      return\n    }\n\n    this.started = true\n\n    this.cleaner = setInterval(\n      () => {\n        this._cleanup().catch(err => {\n          log.error(err)\n        })\n      },\n      this.cleanupInterval\n    )\n  }\n\n  /**\n   * Release any resources.\n   */\n  async stop (): Promise<void> {\n    this.started = false\n\n    if (this.cleaner != null) {\n      clearInterval(this.cleaner)\n      this.cleaner = undefined\n    }\n  }\n\n  /**\n   * Check all providers if they are still valid, and if not delete them\n   */\n  async _cleanup (): Promise<void> {\n    await this.syncQueue.add(async () => {\n      const start = Date.now()\n\n      let count = 0\n      let deleteCount = 0\n      const deleted = new Map<string, Set<string>>()\n      const batch = this.components.datastore.batch()\n\n      // Get all provider entries from the datastore\n      const query = this.components.datastore.query({ prefix: PROVIDER_KEY_PREFIX })\n\n      for await (const entry of query) {\n        try {\n          // Add a delete to the batch for each expired entry\n          const { cid, peerId } = parseProviderKey(entry.key)\n          const time = readTime(entry.value).getTime()\n          const now = Date.now()\n          const delta = now - time\n          const expired = delta > this.provideValidity\n\n          log('comparing: %d - %d = %d > %d %s', now, time, delta, this.provideValidity, expired ? '(expired)' : '')\n\n          if (expired) {\n            deleteCount++\n            batch.delete(entry.key)\n            const peers = deleted.get(cid) ?? new Set<string>()\n            peers.add(peerId)\n            deleted.set(cid, peers)\n          }\n          count++\n        } catch (err: any) {\n          log.error(err.message)\n        }\n      }\n\n      // Commit the deletes to the datastore\n      if (deleted.size > 0) {\n        log('deleting %d / %d entries', deleteCount, count)\n        await batch.commit()\n      } else {\n        log('nothing to delete')\n      }\n\n      // Clear expired entries from the cache\n      for (const [cid, peers] of deleted) {\n        const key = makeProviderKey(cid)\n        const provs = this.cache.get(key)\n\n        if (provs != null) {\n          for (const peerId of peers) {\n            provs.delete(peerId)\n          }\n\n          if (provs.size === 0) {\n            this.cache.remove(key)\n          } else {\n            this.cache.set(key, provs)\n          }\n        }\n      }\n\n      log('Cleanup successful (%dms)', Date.now() - start)\n    })\n  }\n\n  /**\n   * Get the currently known provider peer ids for a given CID\n   */\n  async _getProvidersMap (cid: CID): Promise<Map<string, Date>> {\n    const cacheKey = makeProviderKey(cid)\n    let provs: Map<string, Date> = this.cache.get(cacheKey)\n\n    if (provs == null) {\n      provs = await loadProviders(this.components.datastore, cid)\n      this.cache.set(cacheKey, provs)\n    }\n\n    return provs\n  }\n\n  /**\n   * Add a new provider for the given CID\n   */\n  async addProvider (cid: CID, provider: PeerId): Promise<void> {\n    await this.syncQueue.add(async () => {\n      log('%p provides %s', provider, cid)\n      const provs = await this._getProvidersMap(cid)\n\n      log('loaded %s provs', provs.size)\n      const now = new Date()\n      provs.set(provider.toString(), now)\n\n      const dsKey = makeProviderKey(cid)\n      this.cache.set(dsKey, provs)\n\n      await writeProviderEntry(this.components.datastore, cid, provider, now)\n    })\n  }\n\n  /**\n   * Get a list of providers for the given CID\n   */\n  async getProviders (cid: CID): Promise<PeerId[]> {\n    return await this.syncQueue.add(async () => {\n      log('get providers for %s', cid)\n      const provs = await this._getProvidersMap(cid)\n\n      return [...provs.keys()].map(peerIdStr => {\n        return peerIdFromString(peerIdStr)\n      })\n    }, {\n      // no timeout is specified for this queue so it will not\n      // throw, but this is required to get the right return\n      // type since p-queue@7.3.4\n      throwOnTimeout: true\n    })\n  }\n}\n\n/**\n * Encode the given key its matching datastore key\n */\nfunction makeProviderKey (cid: CID | string): string {\n  const cidStr = typeof cid === 'string' ? cid : uint8ArrayToString(cid.multihash.bytes, 'base32')\n\n  return `${PROVIDER_KEY_PREFIX}/${cidStr}`\n}\n\n/**\n * Write a provider into the given store\n */\nasync function writeProviderEntry (store: Datastore, cid: CID, peer: PeerId, time: Date): Promise<void> {\n  const dsKey = [\n    makeProviderKey(cid),\n    '/',\n    peer.toString()\n  ].join('')\n\n  const key = new Key(dsKey)\n  const buffer = Uint8Array.from(varint.encode(time.getTime()))\n\n  await store.put(key, buffer)\n}\n\n/**\n * Parse the CID and provider peer id from the key\n */\nfunction parseProviderKey (key: Key): { cid: string, peerId: string } {\n  const parts = key.toString().split('/')\n\n  if (parts.length !== 5) {\n    throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`)\n  }\n\n  return {\n    cid: parts[3],\n    peerId: parts[4]\n  }\n}\n\n/**\n * Load providers for the given CID from the store\n */\nasync function loadProviders (store: Datastore, cid: CID): Promise<Map<string, Date>> {\n  const providers = new Map<string, Date>()\n  const query = store.query({ prefix: makeProviderKey(cid) })\n\n  for await (const entry of query) {\n    const { peerId } = parseProviderKey(entry.key)\n    providers.set(peerId, readTime(entry.value))\n  }\n\n  return providers\n}\n\nfunction readTime (buf: Uint8Array): Date {\n  return new Date(varint.decode(buf))\n}\n"]},"metadata":{},"sourceType":"module"}