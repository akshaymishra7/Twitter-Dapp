{"ast":null,"code":"import { pipe } from 'it-pipe';\nimport { RecordEnvelope } from '@libp2p/peer-record';\nimport { peerIdFromBytes, peerIdFromString } from '@libp2p/peer-id';\nimport { logger } from '@libp2p/logger';\nimport { createTopology } from '@libp2p/topology';\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { MessageCache } from './message-cache.js';\nimport { RPC } from './message/rpc.js';\nimport * as constants from './constants.js';\nimport { shuffle, messageIdToString } from './utils/index.js';\nimport { PeerScore, createPeerScoreParams, createPeerScoreThresholds } from './score/index.js';\nimport { IWantTracer } from './tracer.js';\nimport { SimpleTimeCache } from './utils/time-cache.js';\nimport { ACCEPT_FROM_WHITELIST_DURATION_MS, ACCEPT_FROM_WHITELIST_MAX_MESSAGES, ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE } from './constants.js';\nimport { ChurnReason, getMetrics, IHaveIgnoreReason, InclusionReason, ScorePenalty } from './metrics.js';\nimport { ValidateError, MessageStatus, RejectReason, rejectReasonFromAcceptance } from './types.js';\nimport { buildRawMessage, validateToRawMessage } from './utils/buildRawMessage.js';\nimport { msgIdFnStrictNoSign, msgIdFnStrictSign } from './utils/msgIdFn.js';\nimport { computeAllPeersScoreWeights } from './score/scoreMetrics.js';\nimport { getPublishConfigFromPeerId } from './utils/publishConfig.js';\nimport { StrictNoSign, StrictSign, TopicValidatorResult } from '@libp2p/interface-pubsub';\nimport { removeFirstNItemsFromSet, removeItemsFromSet } from './utils/set.js';\nimport { pushable } from 'it-pushable';\nimport { InboundStream, OutboundStream } from './stream.js';\nimport { decodeRpc, defaultDecodeRpcLimits } from './message/decodeRpc.js';\nimport { multiaddrToIPStr } from './utils/multiaddr.js';\nexport const multicodec = constants.GossipsubIDv11;\nvar GossipStatusCode;\n\n(function (GossipStatusCode) {\n  GossipStatusCode[GossipStatusCode[\"started\"] = 0] = \"started\";\n  GossipStatusCode[GossipStatusCode[\"stopped\"] = 1] = \"stopped\";\n})(GossipStatusCode || (GossipStatusCode = {}));\n\nexport class GossipSub extends EventEmitter {\n  constructor(components) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10]; // State\n\n    this.peers = new Set();\n    this.streamsInbound = new Map();\n    this.streamsOutbound = new Map();\n    /** Ensures outbound streams are created sequentially */\n\n    this.outboundInflightQueue = pushable({\n      objectMode: true\n    });\n    /** Direct peers */\n\n    this.direct = new Set();\n    /** Floodsub peers */\n\n    this.floodsubPeers = new Set();\n    /**\n     * Map of peer id and AcceptRequestWhileListEntry\n     */\n\n    this.acceptFromWhitelist = new Map();\n    /**\n     * Map of topics to which peers are subscribed to\n     */\n\n    this.topics = new Map();\n    /**\n     * List of our subscriptions\n     */\n\n    this.subscriptions = new Set();\n    /**\n     * Map of topic meshes\n     * topic => peer id set\n     */\n\n    this.mesh = new Map();\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     * topic => peer id set\n     */\n\n    this.fanout = new Map();\n    /**\n     * Map of last publish time for fanout topics\n     * topic => last publish time\n     */\n\n    this.fanoutLastpub = new Map();\n    /**\n     * Map of pending messages to gossip\n     * peer id => control messages\n     */\n\n    this.gossip = new Map();\n    /**\n     * Map of control messages\n     * peer id => control message\n     */\n\n    this.control = new Map();\n    /**\n     * Number of IHAVEs received from peer in the last heartbeat\n     */\n\n    this.peerhave = new Map();\n    /** Number of messages we have asked from peer in the last heartbeat */\n\n    this.iasked = new Map();\n    /** Prune backoff map */\n\n    this.backoff = new Map();\n    /**\n     * Connection direction cache, marks peers with outbound connections\n     * peer id => direction\n     */\n\n    this.outbound = new Map();\n    /**\n     * Custom validator function per topic.\n     * Must return or resolve quickly (< 100ms) to prevent causing penalties for late messages.\n     * If you need to apply validation that may require longer times use `asyncValidation` option and callback the\n     * validation result through `Gossipsub.reportValidationResult`\n     */\n\n    this.topicValidators = new Map();\n    /**\n     * Number of heartbeats since the beginning of time\n     * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n     */\n\n    this.heartbeatTicks = 0;\n    this.directPeerInitial = null;\n    this.status = {\n      code: GossipStatusCode.stopped\n    };\n    this.heartbeatTimer = null;\n\n    this.runHeartbeat = () => {\n      const timer = this.metrics?.heartbeatDuration.startTimer();\n      this.heartbeat().catch(err => {\n        this.log('Error running heartbeat', err);\n      }).finally(() => {\n        if (timer != null) {\n          timer();\n        } // Schedule the next run if still in started status\n\n\n        if (this.status.code === GossipStatusCode.started) {\n          // Clear previous timeout before overwriting `status.heartbeatTimeout`, it should be completed tho.\n          clearTimeout(this.status.heartbeatTimeout); // NodeJS setInterval function is innexact, calls drift by a few miliseconds on each call.\n          // To run the heartbeat precisely setTimeout() must be used recomputing the delay on every loop.\n\n          let msToNextHeartbeat = this.opts.heartbeatInterval - (Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval; // If too close to next heartbeat, skip one\n\n          if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {\n            msToNextHeartbeat += this.opts.heartbeatInterval;\n            this.metrics?.heartbeatSkipped.inc();\n          }\n\n          this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat);\n        }\n      });\n    };\n\n    const opts = {\n      fallbackToFloodsub: true,\n      floodPublish: true,\n      doPX: false,\n      directPeers: [],\n      D: constants.GossipsubD,\n      Dlo: constants.GossipsubDlo,\n      Dhi: constants.GossipsubDhi,\n      Dscore: constants.GossipsubDscore,\n      Dout: constants.GossipsubDout,\n      Dlazy: constants.GossipsubDlazy,\n      heartbeatInterval: constants.GossipsubHeartbeatInterval,\n      fanoutTTL: constants.GossipsubFanoutTTL,\n      mcacheLength: constants.GossipsubHistoryLength,\n      mcacheGossip: constants.GossipsubHistoryGossip,\n      seenTTL: constants.GossipsubSeenTTL,\n      gossipsubIWantFollowupMs: constants.GossipsubIWantFollowupTime,\n      prunePeers: constants.GossipsubPrunePeers,\n      pruneBackoff: constants.GossipsubPruneBackoff,\n      graftFloodThreshold: constants.GossipsubGraftFloodThreshold,\n      opportunisticGraftPeers: constants.GossipsubOpportunisticGraftPeers,\n      opportunisticGraftTicks: constants.GossipsubOpportunisticGraftTicks,\n      directConnectTicks: constants.GossipsubDirectConnectTicks,\n      ...options,\n      scoreParams: createPeerScoreParams(options.scoreParams),\n      scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)\n    };\n    this.components = components;\n    this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits;\n    this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign; // Also wants to get notified of peers connected using floodsub\n\n    if (opts.fallbackToFloodsub) {\n      this.multicodecs.push(constants.FloodsubID);\n    } // From pubsub\n\n\n    this.log = logger(opts.debugName ?? 'libp2p:gossipsub'); // Gossipsub\n\n    this.opts = opts;\n    this.direct = new Set(opts.directPeers.map(p => p.id.toString()));\n    this.seenCache = new SimpleTimeCache({\n      validityMs: opts.seenTTL\n    });\n    this.publishedMessageIds = new SimpleTimeCache({\n      validityMs: opts.seenTTL\n    });\n\n    if (options.msgIdFn) {\n      // Use custom function\n      this.msgIdFn = options.msgIdFn;\n    } else {\n      switch (this.globalSignaturePolicy) {\n        case StrictSign:\n          this.msgIdFn = msgIdFnStrictSign;\n          break;\n\n        case StrictNoSign:\n          this.msgIdFn = msgIdFnStrictNoSign;\n          break;\n      }\n    }\n\n    if (options.fastMsgIdFn) {\n      this.fastMsgIdFn = options.fastMsgIdFn;\n      this.fastMsgIdCache = new SimpleTimeCache({\n        validityMs: opts.seenTTL\n      });\n    } // By default, gossipsub only provide a browser friendly function to convert Uint8Array message id to string.\n\n\n    this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString;\n    this.mcache = options.messageCache || new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn);\n\n    if (options.dataTransform) {\n      this.dataTransform = options.dataTransform;\n    }\n\n    if (options.metricsRegister) {\n      if (!options.metricsTopicStrToLabel) {\n        throw Error('Must set metricsTopicStrToLabel with metrics');\n      } // in theory, each topic has its own meshMessageDeliveriesWindow param\n      // however in lodestar, we configure it mostly the same so just pick the max of positive ones\n      // (some topics have meshMessageDeliveriesWindow as 0)\n\n\n      const maxMeshMessageDeliveriesWindowMs = Math.max(...Object.values(opts.scoreParams.topics).map(topicParam => topicParam.meshMessageDeliveriesWindow), constants.DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS);\n      const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {\n        gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1000,\n        behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,\n        maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1000\n      });\n      metrics.mcacheSize.addCollect(() => this.onScrapeMetrics(metrics));\n\n      for (const protocol of this.multicodecs) {\n        metrics.protocolsEnabled.set({\n          protocol\n        }, 1);\n      }\n\n      this.metrics = metrics;\n    } else {\n      this.metrics = null;\n    }\n\n    this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics);\n    /**\n     * libp2p\n     */\n\n    this.score = new PeerScore(this.opts.scoreParams, this.metrics, {\n      scoreCacheValidityMs: opts.heartbeatInterval\n    });\n    this.maxInboundStreams = options.maxInboundStreams;\n    this.maxOutboundStreams = options.maxOutboundStreams;\n    this.allowedTopics = opts.allowedTopics ? new Set(opts.allowedTopics) : null;\n  }\n\n  getPeers() {\n    return [...this.peers.keys()].map(str => peerIdFromString(str));\n  }\n\n  isStarted() {\n    return this.status.code === GossipStatusCode.started;\n  } // LIFECYCLE METHODS\n\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   */\n\n\n  async start() {\n    // From pubsub\n    if (this.isStarted()) {\n      return;\n    }\n\n    this.log('starting');\n    this.publishConfig = await getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId); // Create the outbound inflight queue\n    // This ensures that outbound stream creation happens sequentially\n\n    this.outboundInflightQueue = pushable({\n      objectMode: true\n    });\n    pipe(this.outboundInflightQueue, async source => {\n      for await (const {\n        peerId,\n        connection\n      } of source) {\n        await this.createOutboundStream(peerId, connection);\n      }\n    }).catch(e => this.log.error('outbound inflight queue error', e)); // set direct peer addresses in the address book\n\n    await Promise.all(this.opts.directPeers.map(async p => {\n      await this.components.peerStore.addressBook.add(p.id, p.addrs);\n    }));\n    const registrar = this.components.registrar; // Incoming streams\n    // Called after a peer dials us\n\n    await Promise.all(this.multicodecs.map(multicodec => registrar.handle(multicodec, this.onIncomingStream.bind(this), {\n      maxInboundStreams: this.maxInboundStreams,\n      maxOutboundStreams: this.maxOutboundStreams\n    }))); // # How does Gossipsub interact with libp2p? Rough guide from Mar 2022\n    //\n    // ## Setup:\n    // Gossipsub requests libp2p to callback, TBD\n    //\n    // `this.libp2p.handle()` registers a handler for `/meshsub/1.1.0` and other Gossipsub protocols\n    // The handler callback is registered in libp2p Upgrader.protocols map.\n    //\n    // Upgrader receives an inbound connection from some transport and (`Upgrader.upgradeInbound`):\n    // - Adds encryption (NOISE in our case)\n    // - Multiplex stream\n    // - Create a muxer and register that for each new stream call Upgrader.protocols handler\n    //\n    // ## Topology\n    // - new instance of Topology (unlinked to libp2p) with handlers\n    // - registar.register(topology)\n    // register protocol with topology\n    // Topology callbacks called on connection manager changes\n\n    const topology = createTopology({\n      onConnect: this.onPeerConnected.bind(this),\n      onDisconnect: this.onPeerDisconnected.bind(this)\n    });\n    const registrarTopologyIds = await Promise.all(this.multicodecs.map(multicodec => registrar.register(multicodec, topology))); // Schedule to start heartbeat after `GossipsubHeartbeatInitialDelay`\n\n    const heartbeatTimeout = setTimeout(this.runHeartbeat, constants.GossipsubHeartbeatInitialDelay); // Then, run heartbeat every `heartbeatInterval` offset by `GossipsubHeartbeatInitialDelay`\n\n    this.status = {\n      code: GossipStatusCode.started,\n      registrarTopologyIds,\n      heartbeatTimeout: heartbeatTimeout,\n      hearbeatStartMs: Date.now() + constants.GossipsubHeartbeatInitialDelay\n    };\n    this.score.start(); // connect to direct peers\n\n    this.directPeerInitial = setTimeout(() => {\n      Promise.resolve().then(async () => {\n        await Promise.all(Array.from(this.direct).map(async id => await this.connect(id)));\n      }).catch(err => {\n        this.log(err);\n      });\n    }, constants.GossipsubDirectConnectInitialDelay);\n    this.log('started');\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   */\n\n\n  async stop() {\n    this.log('stopping'); // From pubsub\n\n    if (this.status.code !== GossipStatusCode.started) {\n      return;\n    }\n\n    const {\n      registrarTopologyIds\n    } = this.status;\n    this.status = {\n      code: GossipStatusCode.stopped\n    }; // unregister protocol and handlers\n\n    const registrar = this.components.registrar;\n    registrarTopologyIds.forEach(id => registrar.unregister(id));\n    this.outboundInflightQueue.end();\n\n    for (const outboundStream of this.streamsOutbound.values()) {\n      outboundStream.close();\n    }\n\n    this.streamsOutbound.clear();\n\n    for (const inboundStream of this.streamsInbound.values()) {\n      inboundStream.close();\n    }\n\n    this.streamsInbound.clear();\n    this.peers.clear();\n    this.subscriptions.clear(); // Gossipsub\n\n    if (this.heartbeatTimer) {\n      this.heartbeatTimer.cancel();\n      this.heartbeatTimer = null;\n    }\n\n    this.score.stop();\n    this.mesh.clear();\n    this.fanout.clear();\n    this.fanoutLastpub.clear();\n    this.gossip.clear();\n    this.control.clear();\n    this.peerhave.clear();\n    this.iasked.clear();\n    this.backoff.clear();\n    this.outbound.clear();\n    this.gossipTracer.clear();\n    this.seenCache.clear();\n    if (this.fastMsgIdCache) this.fastMsgIdCache.clear();\n    if (this.directPeerInitial) clearTimeout(this.directPeerInitial);\n    this.log('stopped');\n  }\n  /** FOR DEBUG ONLY - Dump peer stats for all peers. Data is cloned, safe to mutate */\n\n\n  dumpPeerScoreStats() {\n    return this.score.dumpPeerScoreStats();\n  }\n  /**\n   * On an inbound stream opened\n   */\n\n\n  onIncomingStream(_ref) {\n    let {\n      stream,\n      connection\n    } = _ref;\n\n    if (!this.isStarted()) {\n      return;\n    }\n\n    const peerId = connection.remotePeer; // add peer to router\n\n    this.addPeer(peerId, connection.stat.direction, connection.remoteAddr); // create inbound stream\n\n    this.createInboundStream(peerId, stream); // attempt to create outbound stream\n\n    this.outboundInflightQueue.push({\n      peerId,\n      connection\n    });\n  }\n  /**\n   * Registrar notifies an established connection with pubsub protocol\n   */\n\n\n  onPeerConnected(peerId, connection) {\n    this.metrics?.newConnectionCount.inc({\n      status: connection.stat.status\n    }); // libp2p may emit a closed connection and never issue peer:disconnect event\n    // see https://github.com/ChainSafe/js-libp2p-gossipsub/issues/398\n\n    if (!this.isStarted() || connection.stat.status !== 'OPEN') {\n      return;\n    }\n\n    this.addPeer(peerId, connection.stat.direction, connection.remoteAddr);\n    this.outboundInflightQueue.push({\n      peerId,\n      connection\n    });\n  }\n  /**\n   * Registrar notifies a closing connection with pubsub protocol\n   */\n\n\n  onPeerDisconnected(peerId) {\n    this.log('connection ended %p', peerId);\n    this.removePeer(peerId);\n  }\n\n  async createOutboundStream(peerId, connection) {\n    if (!this.isStarted()) {\n      return;\n    }\n\n    const id = peerId.toString();\n\n    if (!this.peers.has(id)) {\n      return;\n    } // TODO make this behavior more robust\n    // This behavior is different than for inbound streams\n    // If an outbound stream already exists, don't create a new stream\n\n\n    if (this.streamsOutbound.has(id)) {\n      return;\n    }\n\n    try {\n      const stream = new OutboundStream(await connection.newStream(this.multicodecs), e => this.log.error('outbound pipe error', e), {\n        maxBufferSize: this.opts.maxOutboundBufferSize\n      });\n      this.log('create outbound stream %p', peerId);\n      this.streamsOutbound.set(id, stream);\n      const protocol = stream.protocol;\n\n      if (protocol === constants.FloodsubID) {\n        this.floodsubPeers.add(id);\n      }\n\n      this.metrics?.peersPerProtocol.inc({\n        protocol\n      }, 1); // Immediately send own subscriptions via the newly attached stream\n\n      if (this.subscriptions.size > 0) {\n        this.log('send subscriptions to', id);\n        this.sendSubscriptions(id, Array.from(this.subscriptions), true);\n      }\n    } catch (e) {\n      this.log.error('createOutboundStream error', e);\n    }\n  }\n\n  async createInboundStream(peerId, stream) {\n    if (!this.isStarted()) {\n      return;\n    }\n\n    const id = peerId.toString();\n\n    if (!this.peers.has(id)) {\n      return;\n    } // TODO make this behavior more robust\n    // This behavior is different than for outbound streams\n    // If a peer initiates a new inbound connection\n    // we assume that one is the new canonical inbound stream\n\n\n    const priorInboundStream = this.streamsInbound.get(id);\n\n    if (priorInboundStream !== undefined) {\n      this.log('replacing existing inbound steam %s', id);\n      priorInboundStream.close();\n    }\n\n    this.log('create inbound stream %s', id);\n    const inboundStream = new InboundStream(stream, {\n      maxDataLength: this.opts.maxInboundDataLength\n    });\n    this.streamsInbound.set(id, inboundStream);\n    this.pipePeerReadStream(peerId, inboundStream.source).catch(err => this.log(err));\n  }\n  /**\n   * Add a peer to the router\n   */\n\n\n  addPeer(peerId, direction, addr) {\n    const id = peerId.toString();\n\n    if (!this.peers.has(id)) {\n      this.log('new peer %p', peerId);\n      this.peers.add(id); // Add to peer scoring\n\n      this.score.addPeer(id);\n      const currentIP = multiaddrToIPStr(addr);\n\n      if (currentIP !== null) {\n        this.score.addIP(id, currentIP);\n      } else {\n        this.log('Added peer has no IP in current address %s %s', id, addr.toString());\n      } // track the connection direction. Don't allow to unset outbound\n\n\n      if (!this.outbound.has(id)) {\n        this.outbound.set(id, direction === 'outbound');\n      }\n    }\n  }\n  /**\n   * Removes a peer from the router\n   */\n\n\n  removePeer(peerId) {\n    const id = peerId.toString();\n\n    if (!this.peers.has(id)) {\n      return;\n    } // delete peer\n\n\n    this.log('delete peer %p', peerId);\n    this.peers.delete(id);\n    const outboundStream = this.streamsOutbound.get(id);\n    const inboundStream = this.streamsInbound.get(id);\n\n    if (outboundStream) {\n      this.metrics?.peersPerProtocol.inc({\n        protocol: outboundStream.protocol\n      }, -1);\n    } // close streams\n\n\n    outboundStream?.close();\n    inboundStream?.close(); // remove streams\n\n    this.streamsOutbound.delete(id);\n    this.streamsInbound.delete(id); // remove peer from topics map\n\n    for (const peers of this.topics.values()) {\n      peers.delete(id);\n    } // Remove this peer from the mesh\n\n\n    for (const [topicStr, peers] of this.mesh) {\n      if (peers.delete(id) === true) {\n        this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1);\n      }\n    } // Remove this peer from the fanout\n\n\n    for (const peers of this.fanout.values()) {\n      peers.delete(id);\n    } // Remove from floodsubPeers\n\n\n    this.floodsubPeers.delete(id); // Remove from gossip mapping\n\n    this.gossip.delete(id); // Remove from control mapping\n\n    this.control.delete(id); // Remove from backoff mapping\n\n    this.outbound.delete(id); // Remove from peer scoring\n\n    this.score.removePeer(id);\n    this.acceptFromWhitelist.delete(id);\n  } // API METHODS\n\n\n  get started() {\n    return this.status.code === GossipStatusCode.started;\n  }\n  /**\n   * Get a the peer-ids in a topic mesh\n   */\n\n\n  getMeshPeers(topic) {\n    const peersInTopic = this.mesh.get(topic);\n    return peersInTopic ? Array.from(peersInTopic) : [];\n  }\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   */\n\n\n  getSubscribers(topic) {\n    const peersInTopic = this.topics.get(topic);\n    return (peersInTopic ? Array.from(peersInTopic) : []).map(str => peerIdFromString(str));\n  }\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   */\n\n\n  getTopics() {\n    return Array.from(this.subscriptions);\n  } // TODO: Reviewing Pubsub API\n  // MESSAGE METHODS\n\n  /**\n   * Responsible for processing each RPC message received by other peers.\n   */\n\n\n  async pipePeerReadStream(peerId, stream) {\n    try {\n      await pipe(stream, async source => {\n        for await (const data of source) {\n          try {\n            // TODO: Check max gossip message size, before decodeRpc()\n            const rpcBytes = data.subarray(); // Note: This function may throw, it must be wrapped in a try {} catch {} to prevent closing the stream.\n            // TODO: What should we do if the entire RPC is invalid?\n\n            const rpc = decodeRpc(rpcBytes, this.decodeRpcLimits);\n            this.metrics?.onRpcRecv(rpc, rpcBytes.length); // Since processRpc may be overridden entirely in unsafe ways,\n            // the simplest/safest option here is to wrap in a function and capture all errors\n            // to prevent a top-level unhandled exception\n            // This processing of rpc messages should happen without awaiting full validation/execution of prior messages\n\n            if (this.opts.awaitRpcHandler) {\n              try {\n                await this.handleReceivedRpc(peerId, rpc);\n              } catch (err) {\n                this.metrics?.onRpcRecvError();\n                this.log(err);\n              }\n            } else {\n              this.handleReceivedRpc(peerId, rpc).catch(err => {\n                this.metrics?.onRpcRecvError();\n                this.log(err);\n              });\n            }\n          } catch (e) {\n            this.metrics?.onRpcDataError();\n            this.log(e);\n          }\n        }\n      });\n    } catch (err) {\n      this.metrics?.onPeerReadStreamError();\n      this.handlePeerReadStreamError(err, peerId);\n    }\n  }\n  /**\n   * Handle error when read stream pipe throws, less of the functional use but more\n   * to for testing purposes to spy on the error handling\n   * */\n\n\n  handlePeerReadStreamError(err, peerId) {\n    this.log.error(err);\n    this.onPeerDisconnected(peerId);\n  }\n  /**\n   * Handles an rpc request from a peer\n   */\n\n\n  async handleReceivedRpc(from, rpc) {\n    // Check if peer is graylisted in which case we ignore the event\n    if (!this.acceptFrom(from.toString())) {\n      this.log('received message from unacceptable peer %p', from);\n      this.metrics?.rpcRecvNotAccepted.inc();\n      return;\n    }\n\n    const subscriptions = rpc.subscriptions ? rpc.subscriptions.length : 0;\n    const messages = rpc.messages ? rpc.messages.length : 0;\n    let ihave = 0;\n    let iwant = 0;\n    let graft = 0;\n    let prune = 0;\n\n    if (rpc.control) {\n      if (rpc.control.ihave) ihave = rpc.control.ihave.length;\n      if (rpc.control.iwant) iwant = rpc.control.iwant.length;\n      if (rpc.control.graft) graft = rpc.control.graft.length;\n      if (rpc.control.prune) prune = rpc.control.prune.length;\n    }\n\n    this.log(`rpc.from ${from.toString()} subscriptions ${subscriptions} messages ${messages} ihave ${ihave} iwant ${iwant} graft ${graft} prune ${prune}`); // Handle received subscriptions\n\n    if (rpc.subscriptions && rpc.subscriptions.length > 0) {\n      // update peer subscriptions\n      const subscriptions = [];\n      rpc.subscriptions.forEach(subOpt => {\n        const topic = subOpt.topic;\n        const subscribe = subOpt.subscribe === true;\n\n        if (topic != null) {\n          if (this.allowedTopics && !this.allowedTopics.has(topic)) {\n            // Not allowed: subscription data-structures are not bounded by topic count\n            // TODO: Should apply behaviour penalties?\n            return;\n          }\n\n          this.handleReceivedSubscription(from, topic, subscribe);\n          subscriptions.push({\n            topic,\n            subscribe\n          });\n        }\n      });\n      this.dispatchEvent(new CustomEvent('subscription-change', {\n        detail: {\n          peerId: from,\n          subscriptions\n        }\n      }));\n    } // Handle messages\n    // TODO: (up to limit)\n\n\n    if (rpc.messages) {\n      for (const message of rpc.messages) {\n        if (this.allowedTopics && !this.allowedTopics.has(message.topic)) {\n          // Not allowed: message cache data-structures are not bounded by topic count\n          // TODO: Should apply behaviour penalties?\n          continue;\n        }\n\n        const handleReceivedMessagePromise = this.handleReceivedMessage(from, message) // Should never throw, but handle just in case\n        .catch(err => {\n          this.metrics?.onMsgRecvError(message.topic);\n          this.log(err);\n        });\n\n        if (this.opts.awaitRpcMessageHandler) {\n          await handleReceivedMessagePromise;\n        }\n      }\n    } // Handle control messages\n\n\n    if (rpc.control) {\n      await this.handleControlMessage(from.toString(), rpc.control);\n    }\n  }\n  /**\n   * Handles a subscription change from a peer\n   */\n\n\n  handleReceivedSubscription(from, topic, subscribe) {\n    this.log('subscription update from %p topic %s', from, topic);\n    let topicSet = this.topics.get(topic);\n\n    if (topicSet == null) {\n      topicSet = new Set();\n      this.topics.set(topic, topicSet);\n    }\n\n    if (subscribe) {\n      // subscribe peer to new topic\n      topicSet.add(from.toString());\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(from.toString());\n    } // TODO: rust-libp2p has A LOT more logic here\n\n  }\n  /**\n   * Handles a newly received message from an RPC.\n   * May forward to all peers in the mesh.\n   */\n\n\n  async handleReceivedMessage(from, rpcMsg) {\n    this.metrics?.onMsgRecvPreValidation(rpcMsg.topic);\n    const validationResult = await this.validateReceivedMessage(from, rpcMsg);\n    this.metrics?.onMsgRecvResult(rpcMsg.topic, validationResult.code);\n\n    switch (validationResult.code) {\n      case MessageStatus.duplicate:\n        // Report the duplicate\n        this.score.duplicateMessage(from.toString(), validationResult.msgIdStr, rpcMsg.topic); // due to the collision of fastMsgIdFn, 2 different messages may end up the same fastMsgId\n        // so we need to also mark the duplicate message as delivered or the promise is not resolved\n        // and peer gets penalized. See https://github.com/ChainSafe/js-libp2p-gossipsub/pull/385\n\n        this.gossipTracer.deliverMessage(validationResult.msgIdStr, true);\n        this.mcache.observeDuplicate(validationResult.msgIdStr, from.toString());\n        return;\n\n      case MessageStatus.invalid:\n        // invalid messages received\n        // metrics.register_invalid_message(&raw_message.topic)\n        // Tell peer_score about reject\n        // Reject the original source, and any duplicates we've seen from other peers.\n        if (validationResult.msgIdStr) {\n          const msgIdStr = validationResult.msgIdStr;\n          this.score.rejectMessage(from.toString(), msgIdStr, rpcMsg.topic, validationResult.reason);\n          this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason);\n        } else {\n          this.score.rejectInvalidMessage(from.toString(), rpcMsg.topic);\n        }\n\n        this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult);\n        return;\n\n      case MessageStatus.valid:\n        // Tells score that message arrived (but is maybe not fully validated yet).\n        // Consider the message as delivered for gossip promises.\n        this.score.validateMessage(validationResult.messageId.msgIdStr);\n        this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr); // Add the message to our memcache\n        // if no validation is required, mark the message as validated\n\n        this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation); // Dispatch the message to the user if we are subscribed to the topic\n\n        if (this.subscriptions.has(rpcMsg.topic)) {\n          const isFromSelf = this.components.peerId.equals(from);\n\n          if (!isFromSelf || this.opts.emitSelf) {\n            super.dispatchEvent(new CustomEvent('gossipsub:message', {\n              detail: {\n                propagationSource: from,\n                msgId: validationResult.messageId.msgIdStr,\n                msg: validationResult.msg\n              }\n            })); // TODO: Add option to switch between emit per topic or all messages in one\n\n            super.dispatchEvent(new CustomEvent('message', {\n              detail: validationResult.msg\n            }));\n          }\n        } // Forward the message to mesh peers, if no validation is required\n        // If asyncValidation is ON, expect the app layer to call reportMessageValidationResult(), then forward\n\n\n        if (!this.opts.asyncValidation) {\n          // TODO: in rust-libp2p\n          // .forward_msg(&msg_id, raw_message, Some(propagation_source))\n          this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from.toString());\n        }\n\n    }\n  }\n  /**\n   * Handles a newly received message from an RPC.\n   * May forward to all peers in the mesh.\n   */\n\n\n  async validateReceivedMessage(propagationSource, rpcMsg) {\n    // Fast message ID stuff\n    const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg);\n    const msgIdCached = fastMsgIdStr !== undefined ? this.fastMsgIdCache?.get(fastMsgIdStr) : undefined;\n\n    if (msgIdCached) {\n      // This message has been seen previously. Ignore it\n      return {\n        code: MessageStatus.duplicate,\n        msgIdStr: msgIdCached\n      };\n    } // Perform basic validation on message and convert to RawGossipsubMessage for fastMsgIdFn()\n\n\n    const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg);\n\n    if (!validationResult.valid) {\n      return {\n        code: MessageStatus.invalid,\n        reason: RejectReason.Error,\n        error: validationResult.error\n      };\n    }\n\n    const msg = validationResult.message; // Try and perform the data transform to the message. If it fails, consider it invalid.\n\n    try {\n      if (this.dataTransform) {\n        msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data);\n      }\n    } catch (e) {\n      this.log('Invalid message, transform failed', e);\n      return {\n        code: MessageStatus.invalid,\n        reason: RejectReason.Error,\n        error: ValidateError.TransformFailed\n      };\n    } // TODO: Check if message is from a blacklisted source or propagation origin\n    // - Reject any message from a blacklisted peer\n    // - Also reject any message that originated from a blacklisted peer\n    // - reject messages claiming to be from ourselves but not locally published\n    // Calculate the message id on the transformed data.\n\n\n    const msgId = await this.msgIdFn(msg);\n    const msgIdStr = this.msgIdToStrFn(msgId);\n    const messageId = {\n      msgId,\n      msgIdStr\n    }; // Add the message to the duplicate caches\n\n    if (fastMsgIdStr !== undefined && this.fastMsgIdCache) {\n      const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr);\n\n      if (collision) {\n        this.metrics?.fastMsgIdCacheCollision.inc();\n      }\n    }\n\n    if (this.seenCache.has(msgIdStr)) {\n      return {\n        code: MessageStatus.duplicate,\n        msgIdStr\n      };\n    } else {\n      this.seenCache.put(msgIdStr);\n    } // (Optional) Provide custom validation here with dynamic validators per topic\n    // NOTE: This custom topicValidator() must resolve fast (< 100ms) to allow scores\n    // to not penalize peers for long validation times.\n\n\n    const topicValidator = this.topicValidators.get(rpcMsg.topic);\n\n    if (topicValidator != null) {\n      let acceptance; // Use try {} catch {} in case topicValidator() is synchronous\n\n      try {\n        acceptance = await topicValidator(propagationSource, msg);\n      } catch (e) {\n        const errCode = e.code;\n        if (errCode === constants.ERR_TOPIC_VALIDATOR_IGNORE) acceptance = TopicValidatorResult.Ignore;\n        if (errCode === constants.ERR_TOPIC_VALIDATOR_REJECT) acceptance = TopicValidatorResult.Reject;else acceptance = TopicValidatorResult.Ignore;\n      }\n\n      if (acceptance !== TopicValidatorResult.Accept) {\n        return {\n          code: MessageStatus.invalid,\n          reason: rejectReasonFromAcceptance(acceptance),\n          msgIdStr\n        };\n      }\n    }\n\n    return {\n      code: MessageStatus.valid,\n      messageId,\n      msg\n    };\n  }\n  /**\n   * Return score of a peer.\n   */\n\n\n  getScore(peerId) {\n    return this.score.score(peerId);\n  }\n  /**\n   * Send an rpc object to a peer with subscriptions\n   */\n\n\n  sendSubscriptions(toPeer, topics, subscribe) {\n    this.sendRpc(toPeer, {\n      subscriptions: topics.map(topic => ({\n        topic,\n        subscribe\n      }))\n    });\n  }\n  /**\n   * Handles an rpc control message from a peer\n   */\n\n\n  async handleControlMessage(id, controlMsg) {\n    if (controlMsg === undefined) {\n      return;\n    }\n\n    const iwant = controlMsg.ihave ? this.handleIHave(id, controlMsg.ihave) : [];\n    const ihave = controlMsg.iwant ? this.handleIWant(id, controlMsg.iwant) : [];\n    const prune = controlMsg.graft ? await this.handleGraft(id, controlMsg.graft) : [];\n    controlMsg.prune && (await this.handlePrune(id, controlMsg.prune));\n\n    if (!iwant.length && !ihave.length && !prune.length) {\n      return;\n    }\n\n    const sent = this.sendRpc(id, {\n      messages: ihave,\n      control: {\n        iwant,\n        prune\n      }\n    });\n    const iwantMessageIds = iwant[0]?.messageIDs;\n\n    if (iwantMessageIds) {\n      if (sent) {\n        this.gossipTracer.addPromise(id, iwantMessageIds);\n      } else {\n        this.metrics?.iwantPromiseUntracked.inc(1);\n      }\n    }\n  }\n  /**\n   * Whether to accept a message from a peer\n   */\n\n\n  acceptFrom(id) {\n    if (this.direct.has(id)) {\n      return true;\n    }\n\n    const now = Date.now();\n    const entry = this.acceptFromWhitelist.get(id);\n\n    if (entry && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {\n      entry.messagesAccepted += 1;\n      return true;\n    }\n\n    const score = this.score.score(id);\n\n    if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {\n      // peer is unlikely to be able to drop its score to `graylistThreshold`\n      // after 128 messages or 1s\n      this.acceptFromWhitelist.set(id, {\n        messagesAccepted: 0,\n        acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS\n      });\n    } else {\n      this.acceptFromWhitelist.delete(id);\n    }\n\n    return score >= this.opts.scoreThresholds.graylistThreshold;\n  }\n  /**\n   * Handles IHAVE messages\n   */\n\n\n  handleIHave(id, ihave) {\n    if (!ihave.length) {\n      return [];\n    } // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n\n\n    const score = this.score.score(id);\n\n    if (score < this.opts.scoreThresholds.gossipThreshold) {\n      this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score);\n      this.metrics?.ihaveRcvIgnored.inc({\n        reason: IHaveIgnoreReason.LowScore\n      });\n      return [];\n    } // IHAVE flood protection\n\n\n    const peerhave = (this.peerhave.get(id) ?? 0) + 1;\n    this.peerhave.set(id, peerhave);\n\n    if (peerhave > constants.GossipsubMaxIHaveMessages) {\n      this.log('IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring', id, peerhave);\n      this.metrics?.ihaveRcvIgnored.inc({\n        reason: IHaveIgnoreReason.MaxIhave\n      });\n      return [];\n    }\n\n    const iasked = this.iasked.get(id) ?? 0;\n\n    if (iasked >= constants.GossipsubMaxIHaveLength) {\n      this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked);\n      this.metrics?.ihaveRcvIgnored.inc({\n        reason: IHaveIgnoreReason.MaxIasked\n      });\n      return [];\n    } // string msgId => msgId\n\n\n    const iwant = new Map();\n    ihave.forEach(_ref2 => {\n      let {\n        topicID,\n        messageIDs\n      } = _ref2;\n\n      if (!topicID || !messageIDs || !this.mesh.has(topicID)) {\n        return;\n      }\n\n      let idonthave = 0;\n      messageIDs.forEach(msgId => {\n        const msgIdStr = this.msgIdToStrFn(msgId);\n\n        if (!this.seenCache.has(msgIdStr)) {\n          iwant.set(msgIdStr, msgId);\n          idonthave++;\n        }\n      });\n      this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave);\n    });\n\n    if (!iwant.size) {\n      return [];\n    }\n\n    let iask = iwant.size;\n\n    if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n      iask = constants.GossipsubMaxIHaveLength - iasked;\n    }\n\n    this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id);\n    let iwantList = Array.from(iwant.values()); // ask in random order\n\n    shuffle(iwantList); // truncate to the messages we are actually asking for and update the iasked counter\n\n    iwantList = iwantList.slice(0, iask);\n    this.iasked.set(id, iasked + iask); // do not add gossipTracer promise here until a successful sendRpc()\n\n    return [{\n      messageIDs: iwantList\n    }];\n  }\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   */\n\n\n  handleIWant(id, iwant) {\n    if (!iwant.length) {\n      return [];\n    } // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n\n\n    const score = this.score.score(id);\n\n    if (score < this.opts.scoreThresholds.gossipThreshold) {\n      this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score);\n      return [];\n    }\n\n    const ihave = new Map();\n    const iwantByTopic = new Map();\n    let iwantDonthave = 0;\n    iwant.forEach(_ref3 => {\n      let {\n        messageIDs\n      } = _ref3;\n      messageIDs && messageIDs.forEach(msgId => {\n        const msgIdStr = this.msgIdToStrFn(msgId);\n        const entry = this.mcache.getWithIWantCount(msgIdStr, id);\n\n        if (entry == null) {\n          iwantDonthave++;\n          return;\n        }\n\n        iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0));\n\n        if (entry.count > constants.GossipsubGossipRetransmission) {\n          this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgId);\n          return;\n        }\n\n        ihave.set(msgIdStr, entry.msg);\n      });\n    });\n    this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave);\n\n    if (!ihave.size) {\n      this.log('IWANT: Could not provide any wanted messages to %s', id);\n      return [];\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, id);\n    return Array.from(ihave.values());\n  }\n  /**\n   * Handles Graft messages\n   */\n\n\n  async handleGraft(id, graft) {\n    const prune = [];\n    const score = this.score.score(id);\n    const now = Date.now();\n    let doPX = this.opts.doPX;\n    graft.forEach(_ref4 => {\n      let {\n        topicID\n      } = _ref4;\n\n      if (!topicID) {\n        return;\n      }\n\n      const peersInMesh = this.mesh.get(topicID);\n\n      if (!peersInMesh) {\n        // don't do PX when there is an unknown topic to avoid leaking our peers\n        doPX = false; // spam hardening: ignore GRAFTs for unknown topics\n\n        return;\n      } // check if peer is already in the mesh; if so do nothing\n\n\n      if (peersInMesh.has(id)) {\n        return;\n      } // we don't GRAFT to/from direct peers; complain loudly if this happens\n\n\n      if (this.direct.has(id)) {\n        this.log('GRAFT: ignoring request from direct peer %s', id); // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n\n        prune.push(topicID); // but don't px\n\n        doPX = false;\n        return;\n      } // make sure we are not backing off that peer\n\n\n      const expire = this.backoff.get(topicID)?.get(id);\n\n      if (typeof expire === 'number' && now < expire) {\n        this.log('GRAFT: ignoring backed off peer %s', id); // add behavioral penalty\n\n        this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff); // no PX\n\n        doPX = false; // check the flood cutoff -- is the GRAFT coming too fast?\n\n        const floodCutoff = expire + this.opts.graftFloodThreshold - this.opts.pruneBackoff;\n\n        if (now < floodCutoff) {\n          // extra penalty\n          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);\n        } // refresh the backoff\n\n\n        this.addBackoff(id, topicID);\n        prune.push(topicID);\n        return;\n      } // check the score\n\n\n      if (score < 0) {\n        // we don't GRAFT peers with negative score\n        this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID); // we do send them PRUNE however, because it's a matter of protocol correctness\n\n        prune.push(topicID); // but we won't PX to them\n\n        doPX = false; // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n\n        this.addBackoff(id, topicID);\n        return;\n      } // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n      // from peers with outbound connections; this is a defensive check to restrict potential\n      // mesh takeover attacks combined with love bombing\n\n\n      if (peersInMesh.size >= this.opts.Dhi && !this.outbound.get(id)) {\n        prune.push(topicID);\n        this.addBackoff(id, topicID);\n        return;\n      }\n\n      this.log('GRAFT: Add mesh link from %s in %s', id, topicID);\n      this.score.graft(id, topicID);\n      peersInMesh.add(id);\n      this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1);\n    });\n\n    if (!prune.length) {\n      return [];\n    }\n\n    return await Promise.all(prune.map(topic => this.makePrune(id, topic, doPX)));\n  }\n  /**\n   * Handles Prune messages\n   */\n\n\n  async handlePrune(id, prune) {\n    const score = this.score.score(id);\n\n    for (const {\n      topicID,\n      backoff,\n      peers\n    } of prune) {\n      if (topicID == null) {\n        continue;\n      }\n\n      const peersInMesh = this.mesh.get(topicID);\n\n      if (!peersInMesh) {\n        return;\n      }\n\n      this.log('PRUNE: Remove mesh link to %s in %s', id, topicID);\n      this.score.prune(id, topicID);\n\n      if (peersInMesh.has(id)) {\n        peersInMesh.delete(id);\n        this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Unsub, 1);\n      } // is there a backoff specified by the peer? if so obey it\n\n\n      if (typeof backoff === 'number' && backoff > 0) {\n        this.doAddBackoff(id, topicID, backoff * 1000);\n      } else {\n        this.addBackoff(id, topicID);\n      } // PX\n\n\n      if (peers && peers.length) {\n        // we ignore PX from peers with insufficient scores\n        if (score < this.opts.scoreThresholds.acceptPXThreshold) {\n          this.log('PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]', id, score, topicID);\n          continue;\n        }\n\n        await this.pxConnect(peers);\n      }\n    }\n  }\n  /**\n   * Add standard backoff log for a peer in a topic\n   */\n\n\n  addBackoff(id, topic) {\n    this.doAddBackoff(id, topic, this.opts.pruneBackoff);\n  }\n  /**\n   * Add backoff expiry interval for a peer in a topic\n   *\n   * @param id\n   * @param topic\n   * @param interval - backoff duration in milliseconds\n   */\n\n\n  doAddBackoff(id, topic, interval) {\n    let backoff = this.backoff.get(topic);\n\n    if (!backoff) {\n      backoff = new Map();\n      this.backoff.set(topic, backoff);\n    }\n\n    const expire = Date.now() + interval;\n    const existingExpire = backoff.get(id) ?? 0;\n\n    if (existingExpire < expire) {\n      backoff.set(id, expire);\n    }\n  }\n  /**\n   * Apply penalties from broken IHAVE/IWANT promises\n   */\n\n\n  applyIwantPenalties() {\n    this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n      this.log(\"peer %s didn't follow up in %d IWANT requests; adding penalty\", p, count);\n      this.score.addPenalty(p, count, ScorePenalty.BrokenPromise);\n    });\n  }\n  /**\n   * Clear expired backoff expiries\n   */\n\n\n  clearBackoff() {\n    // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n    if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n      return;\n    }\n\n    const now = Date.now();\n    this.backoff.forEach((backoff, topic) => {\n      backoff.forEach((expire, id) => {\n        if (expire < now) {\n          backoff.delete(id);\n        }\n      });\n\n      if (backoff.size === 0) {\n        this.backoff.delete(topic);\n      }\n    });\n  }\n  /**\n   * Maybe reconnect to direct peers\n   */\n\n\n  async directConnect() {\n    const toconnect = [];\n    this.direct.forEach(id => {\n      if (!this.streamsOutbound.has(id)) {\n        toconnect.push(id);\n      }\n    });\n    await Promise.all(toconnect.map(async id => await this.connect(id)));\n  }\n  /**\n   * Maybe attempt connection given signed peer records\n   */\n\n\n  async pxConnect(peers) {\n    if (peers.length > this.opts.prunePeers) {\n      shuffle(peers);\n      peers = peers.slice(0, this.opts.prunePeers);\n    }\n\n    const toconnect = [];\n    await Promise.all(peers.map(async pi => {\n      if (!pi.peerID) {\n        return;\n      }\n\n      const p = peerIdFromBytes(pi.peerID).toString();\n\n      if (this.peers.has(p)) {\n        return;\n      }\n\n      if (!pi.signedPeerRecord) {\n        toconnect.push(p);\n        return;\n      } // The peer sent us a signed record\n      // This is not a record from the peer who sent the record, but another peer who is connected with it\n      // Ensure that it is valid\n\n\n      try {\n        const envelope = await RecordEnvelope.openAndCertify(pi.signedPeerRecord, 'libp2p-peer-record');\n        const eid = envelope.peerId;\n\n        if (!envelope.peerId.equals(p)) {\n          this.log(\"bogus peer record obtained through px: peer ID %p doesn't match expected peer %p\", eid, p);\n          return;\n        }\n\n        if (!(await this.components.peerStore.addressBook.consumePeerRecord(envelope))) {\n          this.log('bogus peer record obtained through px: could not add peer record to address book');\n          return;\n        }\n\n        toconnect.push(p);\n      } catch (e) {\n        this.log('bogus peer record obtained through px: invalid signature or not a peer record');\n      }\n    }));\n\n    if (!toconnect.length) {\n      return;\n    }\n\n    await Promise.all(toconnect.map(async id => await this.connect(id)));\n  }\n  /**\n   * Connect to a peer using the gossipsub protocol\n   */\n\n\n  async connect(id) {\n    this.log('Initiating connection with %s', id);\n    const peerId = peerIdFromString(id);\n    const connection = await this.components.connectionManager.openConnection(peerId);\n\n    for (const multicodec of this.multicodecs) {\n      for (const topology of this.components.registrar.getTopologies(multicodec)) {\n        topology.onConnect(peerId, connection);\n      }\n    }\n  }\n  /**\n   * Subscribes to a topic\n   */\n\n\n  subscribe(topic) {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Pubsub has not started');\n    }\n\n    if (!this.subscriptions.has(topic)) {\n      this.subscriptions.add(topic);\n\n      for (const peerId of this.peers.keys()) {\n        this.sendSubscriptions(peerId, [topic], true);\n      }\n    }\n\n    this.join(topic);\n  }\n  /**\n   * Unsubscribe to a topic\n   */\n\n\n  unsubscribe(topic) {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Pubsub is not started');\n    }\n\n    const wasSubscribed = this.subscriptions.delete(topic);\n    this.log('unsubscribe from %s - am subscribed %s', topic, wasSubscribed);\n\n    if (wasSubscribed) {\n      for (const peerId of this.peers.keys()) {\n        this.sendSubscriptions(peerId, [topic], false);\n      }\n    }\n\n    this.leave(topic);\n  }\n  /**\n   * Join topic\n   */\n\n\n  join(topic) {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Gossipsub has not started');\n    } // if we are already in the mesh, return\n\n\n    if (this.mesh.has(topic)) {\n      return;\n    }\n\n    this.log('JOIN %s', topic);\n    this.metrics?.onJoin(topic);\n    const toAdd = new Set(); // check if we have mesh_n peers in fanout[topic] and add them to the mesh if we do,\n    // removing the fanout entry.\n\n    const fanoutPeers = this.fanout.get(topic);\n\n    if (fanoutPeers) {\n      // Remove fanout entry and the last published time\n      this.fanout.delete(topic);\n      this.fanoutLastpub.delete(topic); // remove explicit peers, peers with negative scores, and backoffed peers\n\n      fanoutPeers.forEach(id => {\n        // TODO:rust-libp2p checks `self.backoffs.is_backoff_with_slack()`\n        if (!this.direct.has(id) && this.score.score(id) >= 0) {\n          toAdd.add(id);\n        }\n      });\n      this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size);\n    } // check if we need to get more peers, which we randomly select\n\n\n    if (toAdd.size < this.opts.D) {\n      const fanoutCount = toAdd.size;\n      const newPeers = this.getRandomGossipPeers(topic, this.opts.D, id => // filter direct peers and peers with negative score\n      !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0);\n      newPeers.forEach(peer => {\n        toAdd.add(peer);\n      });\n      this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount);\n    }\n\n    this.mesh.set(topic, toAdd);\n    toAdd.forEach(id => {\n      this.log('JOIN: Add mesh link to %s in %s', id, topic);\n      this.sendGraft(id, topic); // rust-libp2p\n      // - peer_score.graft()\n      // - Self::control_pool_add()\n      // - peer_added_to_mesh()\n    });\n  }\n  /**\n   * Leave topic\n   */\n\n\n  leave(topic) {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Gossipsub has not started');\n    }\n\n    this.log('LEAVE %s', topic);\n    this.metrics?.onLeave(topic); // Send PRUNE to mesh peers\n\n    const meshPeers = this.mesh.get(topic);\n\n    if (meshPeers) {\n      Promise.all(Array.from(meshPeers).map(async id => {\n        this.log('LEAVE: Remove mesh link to %s in %s', id, topic);\n        return await this.sendPrune(id, topic);\n      })).catch(err => {\n        this.log('Error sending prunes to mesh peers', err);\n      });\n      this.mesh.delete(topic);\n    }\n  }\n\n  selectPeersToForward(topic, propagationSource, excludePeers) {\n    const tosend = new Set(); // Add explicit peers\n\n    const peersInTopic = this.topics.get(topic);\n\n    if (peersInTopic) {\n      this.direct.forEach(peer => {\n        if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer)) {\n          tosend.add(peer);\n        }\n      }); // As of Mar 2022, spec + golang-libp2p include this while rust-libp2p does not\n      // rust-libp2p: https://github.com/libp2p/rust-libp2p/blob/6cc3b4ec52c922bfcf562a29b5805c3150e37c75/protocols/gossipsub/src/behaviour.rs#L2693\n      // spec: https://github.com/libp2p/specs/blob/10712c55ab309086a52eec7d25f294df4fa96528/pubsub/gossipsub/gossipsub-v1.0.md?plain=1#L361\n\n      this.floodsubPeers.forEach(peer => {\n        if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer) && this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold) {\n          tosend.add(peer);\n        }\n      });\n    } // add mesh peers\n\n\n    const meshPeers = this.mesh.get(topic);\n\n    if (meshPeers && meshPeers.size > 0) {\n      meshPeers.forEach(peer => {\n        if (propagationSource !== peer && !excludePeers?.has(peer)) {\n          tosend.add(peer);\n        }\n      });\n    }\n\n    return tosend;\n  }\n\n  selectPeersToPublish(topic) {\n    const tosend = new Set();\n    const tosendCount = {\n      direct: 0,\n      floodsub: 0,\n      mesh: 0,\n      fanout: 0\n    };\n    const peersInTopic = this.topics.get(topic);\n\n    if (peersInTopic) {\n      // flood-publish behavior\n      // send to direct peers and _all_ peers meeting the publishThreshold\n      if (this.opts.floodPublish) {\n        peersInTopic.forEach(id => {\n          if (this.direct.has(id)) {\n            tosend.add(id);\n            tosendCount.direct++;\n          } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n            tosend.add(id);\n            tosendCount.floodsub++;\n          }\n        });\n      } else {\n        // non-flood-publish behavior\n        // send to direct peers, subscribed floodsub peers\n        // and some mesh peers above publishThreshold\n        // direct peers (if subscribed)\n        this.direct.forEach(id => {\n          if (peersInTopic.has(id)) {\n            tosend.add(id);\n            tosendCount.direct++;\n          }\n        }); // floodsub peers\n        // Note: if there are no floodsub peers, we save a loop through peersInTopic Map\n\n        this.floodsubPeers.forEach(id => {\n          if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n            tosend.add(id);\n            tosendCount.floodsub++;\n          }\n        }); // Gossipsub peers handling\n\n        const meshPeers = this.mesh.get(topic);\n\n        if (meshPeers && meshPeers.size > 0) {\n          meshPeers.forEach(peer => {\n            tosend.add(peer);\n            tosendCount.mesh++;\n          });\n        } // We are not in the mesh for topic, use fanout peers\n        else {\n          const fanoutPeers = this.fanout.get(topic);\n\n          if (fanoutPeers && fanoutPeers.size > 0) {\n            fanoutPeers.forEach(peer => {\n              tosend.add(peer);\n              tosendCount.fanout++;\n            });\n          } // We have no fanout peers, select mesh_n of them and add them to the fanout\n          else {\n            // If we are not in the fanout, then pick peers in topic above the publishThreshold\n            const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, id => {\n              return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;\n            });\n\n            if (newFanoutPeers.size > 0) {\n              // eslint-disable-line max-depth\n              this.fanout.set(topic, newFanoutPeers);\n              newFanoutPeers.forEach(peer => {\n                // eslint-disable-line max-depth\n                tosend.add(peer);\n                tosendCount.fanout++;\n              });\n            }\n          } // We are publishing to fanout peers - update the time we published\n\n\n          this.fanoutLastpub.set(topic, Date.now());\n        }\n      }\n    }\n\n    return {\n      tosend,\n      tosendCount\n    };\n  }\n  /**\n   * Forwards a message from our peers.\n   *\n   * For messages published by us (the app layer), this class uses `publish`\n   */\n\n\n  forwardMessage(msgIdStr, rawMsg, propagationSource, excludePeers) {\n    // message is fully validated inform peer_score\n    if (propagationSource) {\n      this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic);\n    }\n\n    const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers); // Note: Don't throw if tosend is empty, we can have a mesh with a single peer\n    // forward the message to peers\n\n    tosend.forEach(id => {\n      // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n      this.sendRpc(id, {\n        messages: [rawMsg]\n      });\n    });\n    this.metrics?.onForwardMsg(rawMsg.topic, tosend.size);\n  }\n  /**\n   * App layer publishes a message to peers, return number of peers this message is published to\n   * Note: `async` due to crypto only if `StrictSign`, otherwise it's a sync fn.\n   *\n   * For messages not from us, this class uses `forwardMessage`.\n   */\n\n\n  async publish(topic, data, opts) {\n    const transformedData = this.dataTransform ? this.dataTransform.outboundTransform(topic, data) : data;\n\n    if (this.publishConfig == null) {\n      throw Error('PublishError.Uninitialized');\n    } // Prepare raw message with user's publishConfig\n\n\n    const {\n      raw: rawMsg,\n      msg\n    } = await buildRawMessage(this.publishConfig, topic, data, transformedData); // calculate the message id from the un-transformed data\n\n    const msgId = await this.msgIdFn(msg);\n    const msgIdStr = this.msgIdToStrFn(msgId); // Current publish opt takes precedence global opts, while preserving false value\n\n    const ignoreDuplicatePublishError = opts?.ignoreDuplicatePublishError ?? this.opts.ignoreDuplicatePublishError;\n\n    if (this.seenCache.has(msgIdStr)) {\n      // This message has already been seen. We don't re-publish messages that have already\n      // been published on the network.\n      if (ignoreDuplicatePublishError) {\n        this.metrics?.onPublishDuplicateMsg(topic);\n        return {\n          recipients: []\n        };\n      }\n\n      throw Error('PublishError.Duplicate');\n    }\n\n    const {\n      tosend,\n      tosendCount\n    } = this.selectPeersToPublish(topic);\n    const willSendToSelf = this.opts.emitSelf === true && this.subscriptions.has(topic); // Current publish opt takes precedence global opts, while preserving false value\n\n    const allowPublishToZeroPeers = opts?.allowPublishToZeroPeers ?? this.opts.allowPublishToZeroPeers;\n\n    if (tosend.size === 0 && !allowPublishToZeroPeers && !willSendToSelf) {\n      throw Error('PublishError.InsufficientPeers');\n    } // If the message isn't a duplicate and we have sent it to some peers add it to the\n    // duplicate cache and memcache.\n\n\n    this.seenCache.put(msgIdStr); // all published messages are valid\n\n    this.mcache.put({\n      msgId,\n      msgIdStr\n    }, rawMsg, true); // If the message is anonymous or has a random author add it to the published message ids cache.\n\n    this.publishedMessageIds.put(msgIdStr); // Send to set of peers aggregated from direct, mesh, fanout\n\n    for (const id of tosend) {\n      // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n      const sent = this.sendRpc(id, {\n        messages: [rawMsg]\n      }); // did not actually send the message\n\n      if (!sent) {\n        tosend.delete(id);\n      }\n    }\n\n    this.metrics?.onPublishMsg(topic, tosendCount, tosend.size, rawMsg.data != null ? rawMsg.data.length : 0); // Dispatch the message to the user if we are subscribed to the topic\n\n    if (willSendToSelf) {\n      tosend.add(this.components.peerId.toString());\n      super.dispatchEvent(new CustomEvent('gossipsub:message', {\n        detail: {\n          propagationSource: this.components.peerId,\n          msgId: msgIdStr,\n          msg\n        }\n      })); // TODO: Add option to switch between emit per topic or all messages in one\n\n      super.dispatchEvent(new CustomEvent('message', {\n        detail: msg\n      }));\n    }\n\n    return {\n      recipients: Array.from(tosend.values()).map(str => peerIdFromString(str))\n    };\n  }\n  /**\n   * This function should be called when `asyncValidation` is `true` after\n   * the message got validated by the caller. Messages are stored in the `mcache` and\n   * validation is expected to be fast enough that the messages should still exist in the cache.\n   * There are three possible validation outcomes and the outcome is given in acceptance.\n   *\n   * If acceptance = `MessageAcceptance.Accept` the message will get propagated to the\n   * network. The `propagation_source` parameter indicates who the message was received by and\n   * will not be forwarded back to that peer.\n   *\n   * If acceptance = `MessageAcceptance.Reject` the message will be deleted from the memcache\n   * and the P₄ penalty will be applied to the `propagationSource`.\n   *\n   * If acceptance = `MessageAcceptance.Ignore` the message will be deleted from the memcache\n   * but no P₄ penalty will be applied.\n   *\n   * This function will return true if the message was found in the cache and false if was not\n   * in the cache anymore.\n   *\n   * This should only be called once per message.\n   */\n\n\n  reportMessageValidationResult(msgId, propagationSource, acceptance) {\n    if (acceptance === TopicValidatorResult.Accept) {\n      const cacheEntry = this.mcache.validate(msgId);\n      this.metrics?.onReportValidationMcacheHit(cacheEntry !== null);\n\n      if (cacheEntry != null) {\n        const {\n          message: rawMsg,\n          originatingPeers\n        } = cacheEntry; // message is fully validated inform peer_score\n\n        this.score.deliverMessage(propagationSource.toString(), msgId, rawMsg.topic);\n        this.forwardMessage(msgId, cacheEntry.message, propagationSource.toString(), originatingPeers);\n        this.metrics?.onReportValidation(rawMsg.topic, acceptance);\n      } // else, Message not in cache. Ignoring forwarding\n\n    } // Not valid\n    else {\n      const cacheEntry = this.mcache.remove(msgId);\n      this.metrics?.onReportValidationMcacheHit(cacheEntry !== null);\n\n      if (cacheEntry) {\n        const rejectReason = rejectReasonFromAcceptance(acceptance);\n        const {\n          message: rawMsg,\n          originatingPeers\n        } = cacheEntry; // Tell peer_score about reject\n        // Reject the original source, and any duplicates we've seen from other peers.\n\n        this.score.rejectMessage(propagationSource.toString(), msgId, rawMsg.topic, rejectReason);\n\n        for (const peer of originatingPeers) {\n          this.score.rejectMessage(peer, msgId, rawMsg.topic, rejectReason);\n        }\n\n        this.metrics?.onReportValidation(rawMsg.topic, acceptance);\n      } // else, Message not in cache. Ignoring forwarding\n\n    }\n  }\n  /**\n   * Sends a GRAFT message to a peer\n   */\n\n\n  sendGraft(id, topic) {\n    const graft = [{\n      topicID: topic\n    }];\n    this.sendRpc(id, {\n      control: {\n        graft\n      }\n    });\n  }\n  /**\n   * Sends a PRUNE message to a peer\n   */\n\n\n  async sendPrune(id, topic) {\n    const prune = [await this.makePrune(id, topic, this.opts.doPX)];\n    this.sendRpc(id, {\n      control: {\n        prune\n      }\n    });\n  }\n  /**\n   * Send an rpc object to a peer\n   */\n\n\n  sendRpc(id, rpc) {\n    const outboundStream = this.streamsOutbound.get(id);\n\n    if (!outboundStream) {\n      this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);\n      return false;\n    } // piggyback control message retries\n\n\n    const ctrl = this.control.get(id);\n\n    if (ctrl) {\n      this.piggybackControl(id, rpc, ctrl);\n      this.control.delete(id);\n    } // piggyback gossip\n\n\n    const ihave = this.gossip.get(id);\n\n    if (ihave) {\n      this.piggybackGossip(id, rpc, ihave);\n      this.gossip.delete(id);\n    }\n\n    const rpcBytes = RPC.encode(rpc).finish();\n\n    try {\n      outboundStream.push(rpcBytes);\n    } catch (e) {\n      this.log.error(`Cannot send rpc to ${id}`, e); // if the peer had control messages or gossip, re-attach\n\n      if (ctrl) {\n        this.control.set(id, ctrl);\n      }\n\n      if (ihave) {\n        this.gossip.set(id, ihave);\n      }\n\n      return false;\n    }\n\n    this.metrics?.onRpcSent(rpc, rpcBytes.length);\n    return true;\n  }\n  /** Mutates `outRpc` adding graft and prune control messages */\n\n\n  piggybackControl(id, outRpc, ctrl) {\n    if (ctrl.graft) {\n      if (!outRpc.control) outRpc.control = {};\n      if (!outRpc.control.graft) outRpc.control.graft = [];\n\n      for (const graft of ctrl.graft) {\n        if (graft.topicID && this.mesh.get(graft.topicID)?.has(id)) {\n          outRpc.control.graft.push(graft);\n        }\n      }\n    }\n\n    if (ctrl.prune) {\n      if (!outRpc.control) outRpc.control = {};\n      if (!outRpc.control.prune) outRpc.control.prune = [];\n\n      for (const prune of ctrl.prune) {\n        if (prune.topicID && !this.mesh.get(prune.topicID)?.has(id)) {\n          outRpc.control.prune.push(prune);\n        }\n      }\n    }\n  }\n  /** Mutates `outRpc` adding ihave control messages */\n\n\n  piggybackGossip(id, outRpc, ihave) {\n    if (!outRpc.control) outRpc.control = {};\n    outRpc.control.ihave = ihave;\n  }\n  /**\n   * Send graft and prune messages\n   *\n   * @param tograft - peer id => topic[]\n   * @param toprune - peer id => topic[]\n   */\n\n\n  async sendGraftPrune(tograft, toprune, noPX) {\n    const doPX = this.opts.doPX;\n\n    for (const [id, topics] of tograft) {\n      const graft = topics.map(topicID => ({\n        topicID\n      }));\n      let prune = []; // If a peer also has prunes, process them now\n\n      const pruning = toprune.get(id);\n\n      if (pruning) {\n        prune = await Promise.all(pruning.map(async topicID => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false))));\n        toprune.delete(id);\n      }\n\n      this.sendRpc(id, {\n        control: {\n          graft,\n          prune\n        }\n      });\n    }\n\n    for (const [id, topics] of toprune) {\n      const prune = await Promise.all(topics.map(async topicID => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false))));\n      this.sendRpc(id, {\n        control: {\n          prune\n        }\n      });\n    }\n  }\n  /**\n   * Emits gossip - Send IHAVE messages to a random set of gossip peers\n   */\n\n\n  emitGossip(peersToGossipByTopic) {\n    const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()));\n\n    for (const [topic, peersToGossip] of peersToGossipByTopic) {\n      this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? []);\n    }\n  }\n  /**\n   * Send gossip messages to GossipFactor peers above threshold with a minimum of D_lazy\n   * Peers are randomly selected from the heartbeat which exclude mesh + fanout peers\n   * We also exclude direct peers, as there is no reason to emit gossip to them\n   * @param topic\n   * @param candidateToGossip - peers to gossip\n   * @param messageIDs - message ids to gossip\n   */\n\n\n  doEmitGossip(topic, candidateToGossip, messageIDs) {\n    if (!messageIDs.length) {\n      return;\n    } // shuffle to emit in random order\n\n\n    shuffle(messageIDs); // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n\n    if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n      // we do the truncation (with shuffling) per peer below\n      this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n    }\n\n    if (!candidateToGossip.size) return;\n    let target = this.opts.Dlazy;\n    const factor = constants.GossipsubGossipFactor * candidateToGossip.size;\n    let peersToGossip = candidateToGossip;\n\n    if (factor > target) {\n      target = factor;\n    }\n\n    if (target > peersToGossip.size) {\n      target = peersToGossip.size;\n    } else {\n      // only shuffle if needed\n      peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target);\n    } // Emit the IHAVE gossip to the selected peers up to the target\n\n\n    peersToGossip.forEach(id => {\n      let peerMessageIDs = messageIDs;\n\n      if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n        // shuffle and slice message IDs per peer so that we emit a different set for each peer\n        // we have enough reduncancy in the system that this will significantly increase the message\n        // coverage when we do truncate\n        peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);\n      }\n\n      this.pushGossip(id, {\n        topicID: topic,\n        messageIDs: peerMessageIDs\n      });\n    });\n  }\n  /**\n   * Flush gossip and control messages\n   */\n\n\n  flush() {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer);\n      this.sendRpc(peer, {\n        control: {\n          ihave\n        }\n      });\n    } // send the remaining control messages\n\n\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer);\n      this.sendRpc(peer, {\n        control: {\n          graft: control.graft,\n          prune: control.prune\n        }\n      });\n    }\n  }\n  /**\n   * Adds new IHAVE messages to pending gossip\n   */\n\n\n  pushGossip(id, controlIHaveMsgs) {\n    this.log('Add gossip to %s', id);\n    const gossip = this.gossip.get(id) || [];\n    this.gossip.set(id, gossip.concat(controlIHaveMsgs));\n  }\n  /**\n   * Make a PRUNE control message for a peer in a topic\n   */\n\n\n  async makePrune(id, topic, doPX) {\n    this.score.prune(id, topic);\n\n    if (this.streamsOutbound.get(id).protocol === constants.GossipsubIDv10) {\n      // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n      return {\n        topicID: topic,\n        peers: []\n      };\n    } // backoff is measured in seconds\n    // GossipsubPruneBackoff is measured in milliseconds\n    // The protobuf has it as a uint64\n\n\n    const backoff = this.opts.pruneBackoff / 1000;\n\n    if (!doPX) {\n      return {\n        topicID: topic,\n        peers: [],\n        backoff: backoff\n      };\n    } // select peers for Peer eXchange\n\n\n    const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, xid => {\n      return xid !== id && this.score.score(xid) >= 0;\n    });\n    const px = await Promise.all(Array.from(peers).map(async peerId => {\n      // see if we have a signed record to send back; if we don't, just send\n      // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n      // unsigned address records through PX anyways\n      // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n      const id = peerIdFromString(peerId);\n      return {\n        peerID: id.toBytes(),\n        signedPeerRecord: await this.components.peerStore.addressBook.getRawEnvelope(id)\n      };\n    }));\n    return {\n      topicID: topic,\n      peers: px,\n      backoff: backoff\n    };\n  }\n  /**\n   * Maintains the mesh and fanout maps in gossipsub.\n   */\n\n\n  async heartbeat() {\n    const {\n      D,\n      Dlo,\n      Dhi,\n      Dscore,\n      Dout,\n      fanoutTTL\n    } = this.opts;\n    this.heartbeatTicks++; // cache scores throught the heartbeat\n\n    const scores = new Map();\n\n    const getScore = id => {\n      let s = scores.get(id);\n\n      if (s === undefined) {\n        s = this.score.score(id);\n        scores.set(id, s);\n      }\n\n      return s;\n    }; // peer id => topic[]\n\n\n    const tograft = new Map(); // peer id => topic[]\n\n    const toprune = new Map(); // peer id => don't px\n\n    const noPX = new Map(); // clean up expired backoffs\n\n    this.clearBackoff(); // clean up peerhave/iasked counters\n\n    this.peerhave.clear();\n    this.metrics?.cacheSize.set({\n      cache: 'iasked'\n    }, this.iasked.size);\n    this.iasked.clear(); // apply IWANT request penalties\n\n    this.applyIwantPenalties(); // ensure direct peers are connected\n\n    if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {\n      // we only do this every few ticks to allow pending connections to complete and account for restarts/downtime\n      await this.directConnect();\n    } // EXTRA: Prune caches\n\n\n    this.fastMsgIdCache?.prune();\n    this.seenCache.prune();\n    this.gossipTracer.prune();\n    this.publishedMessageIds.prune();\n    /**\n     * Instead of calling getRandomGossipPeers multiple times to:\n     *   + get more mesh peers\n     *   + more outbound peers\n     *   + oppportunistic grafting\n     *   + emitGossip\n     *\n     * We want to loop through the topic peers only a single time and prepare gossip peers for all topics to improve the performance\n     */\n\n    const peersToGossipByTopic = new Map(); // maintain the mesh for topics we have joined\n\n    this.mesh.forEach((peers, topic) => {\n      const peersInTopic = this.topics.get(topic);\n      const candidateMeshPeers = new Set();\n      const peersToGossip = new Set();\n      peersToGossipByTopic.set(topic, peersToGossip);\n\n      if (peersInTopic) {\n        const shuffledPeers = shuffle(Array.from(peersInTopic));\n        const backoff = this.backoff.get(topic);\n\n        for (const id of shuffledPeers) {\n          const peerStreams = this.streamsOutbound.get(id);\n\n          if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !peers.has(id) && !this.direct.has(id)) {\n            const score = getScore(id);\n            if ((!backoff || !backoff.has(id)) && score >= 0) candidateMeshPeers.add(id); // instead of having to find gossip peers after heartbeat which require another loop\n            // we prepare peers to gossip in a topic within heartbeat to improve performance\n\n            if (score >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id);\n          }\n        }\n      } // prune/graft helper functions (defined per topic)\n\n\n      const prunePeer = (id, reason) => {\n        this.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic); // no need to update peer score here as we do it in makePrune\n        // add prune backoff record\n\n        this.addBackoff(id, topic); // remove peer from mesh\n\n        peers.delete(id); // after pruning a peer from mesh, we want to gossip topic to it if its score meet the gossip threshold\n\n        if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id);\n        this.metrics?.onRemoveFromMesh(topic, reason, 1); // add to toprune\n\n        const topics = toprune.get(id);\n\n        if (!topics) {\n          toprune.set(id, [topic]);\n        } else {\n          topics.push(topic);\n        }\n      };\n\n      const graftPeer = (id, reason) => {\n        this.log('HEARTBEAT: Add mesh link to %s in %s', id, topic); // update peer score\n\n        this.score.graft(id, topic); // add peer to mesh\n\n        peers.add(id); // when we add a new mesh peer, we don't want to gossip messages to it\n\n        peersToGossip.delete(id);\n        this.metrics?.onAddToMesh(topic, reason, 1); // add to tograft\n\n        const topics = tograft.get(id);\n\n        if (!topics) {\n          tograft.set(id, [topic]);\n        } else {\n          topics.push(topic);\n        }\n      }; // drop all peers with negative score, without PX\n\n\n      peers.forEach(id => {\n        const score = getScore(id); // Record the score\n\n        if (score < 0) {\n          this.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);\n          prunePeer(id, ChurnReason.BadScore);\n          noPX.set(id, true);\n        }\n      }); // do we have enough peers?\n\n      if (peers.size < Dlo) {\n        const ineed = D - peers.size; // slice up to first `ineed` items and remove them from candidateMeshPeers\n        // same to `const newMeshPeers = candidateMeshPeers.slice(0, ineed)`\n\n        const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed);\n        newMeshPeers.forEach(p => {\n          graftPeer(p, InclusionReason.NotEnough);\n        });\n      } // do we have to many peers?\n\n\n      if (peers.size > Dhi) {\n        let peersArray = Array.from(peers); // sort by score\n\n        peersArray.sort((a, b) => getScore(b) - getScore(a)); // We keep the first D_score peers by score and the remaining up to D randomly\n        // under the constraint that we keep D_out peers in the mesh (if we have that many)\n\n        peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore))); // count the outbound peers we are keeping\n\n        let outbound = 0;\n        peersArray.slice(0, D).forEach(p => {\n          if (this.outbound.get(p)) {\n            outbound++;\n          }\n        }); // if it's less than D_out, bubble up some outbound peers from the random selection\n\n        if (outbound < Dout) {\n          const rotate = i => {\n            // rotate the peersArray to the right and put the ith peer in the front\n            const p = peersArray[i];\n\n            for (let j = i; j > 0; j--) {\n              peersArray[j] = peersArray[j - 1];\n            }\n\n            peersArray[0] = p;\n          }; // first bubble up all outbound peers already in the selection to the front\n\n\n          if (outbound > 0) {\n            let ihave = outbound;\n\n            for (let i = 1; i < D && ihave > 0; i++) {\n              if (this.outbound.get(peersArray[i])) {\n                rotate(i);\n                ihave--;\n              }\n            }\n          } // now bubble up enough outbound peers outside the selection to the front\n\n\n          let ineed = D - outbound;\n\n          for (let i = D; i < peersArray.length && ineed > 0; i++) {\n            if (this.outbound.get(peersArray[i])) {\n              rotate(i);\n              ineed--;\n            }\n          }\n        } // prune the excess peers\n\n\n        peersArray.slice(D).forEach(p => {\n          prunePeer(p, ChurnReason.Excess);\n        });\n      } // do we have enough outbound peers?\n\n\n      if (peers.size >= Dlo) {\n        // count the outbound peers we have\n        let outbound = 0;\n        peers.forEach(p => {\n          if (this.outbound.get(p)) {\n            outbound++;\n          }\n        }); // if it's less than D_out, select some peers with outbound connections and graft them\n\n        if (outbound < Dout) {\n          const ineed = Dout - outbound;\n          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, id => this.outbound.get(id) === true);\n          newMeshPeers.forEach(p => {\n            graftPeer(p, InclusionReason.Outbound);\n          });\n        }\n      } // should we try to improve the mesh with opportunistic grafting?\n\n\n      if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {\n        // Opportunistic grafting works as follows: we check the median score of peers in the\n        // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n        // random with score over the median.\n        // The intention is to (slowly) improve an underperforming mesh by introducing good\n        // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n        // situations where we are stuck with poor peers and also recover from churn of good peers.\n        // now compute the median peer score in the mesh\n        const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));\n        const medianIndex = Math.floor(peers.size / 2);\n        const medianScore = getScore(peersList[medianIndex]); // if the median score is below the threshold, select a better peer (if any) and GRAFT\n\n        if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {\n          const ineed = this.opts.opportunisticGraftPeers;\n          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, id => getScore(id) > medianScore);\n\n          for (const id of newMeshPeers) {\n            this.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);\n            graftPeer(id, InclusionReason.Opportunistic);\n          }\n        }\n      }\n    }); // expire fanout for topics we haven't published to in a while\n\n    const now = Date.now();\n    this.fanoutLastpub.forEach((lastpb, topic) => {\n      if (lastpb + fanoutTTL < now) {\n        this.fanout.delete(topic);\n        this.fanoutLastpub.delete(topic);\n      }\n    }); // maintain our fanout for topics we are publishing but we have not joined\n\n    this.fanout.forEach((fanoutPeers, topic) => {\n      // checks whether our peers are still in the topic and have a score above the publish threshold\n      const topicPeers = this.topics.get(topic);\n      fanoutPeers.forEach(id => {\n        if (!topicPeers.has(id) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {\n          fanoutPeers.delete(id);\n        }\n      });\n      const peersInTopic = this.topics.get(topic);\n      const candidateFanoutPeers = []; // the fanout map contains topics to which we are not subscribed.\n\n      const peersToGossip = new Set();\n      peersToGossipByTopic.set(topic, peersToGossip);\n\n      if (peersInTopic) {\n        const shuffledPeers = shuffle(Array.from(peersInTopic));\n\n        for (const id of shuffledPeers) {\n          const peerStreams = this.streamsOutbound.get(id);\n\n          if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !fanoutPeers.has(id) && !this.direct.has(id)) {\n            const score = getScore(id);\n            if (score >= this.opts.scoreThresholds.publishThreshold) candidateFanoutPeers.push(id); // instead of having to find gossip peers after heartbeat which require another loop\n            // we prepare peers to gossip in a topic within heartbeat to improve performance\n\n            if (score >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id);\n          }\n        }\n      } // do we need more peers?\n\n\n      if (fanoutPeers.size < D) {\n        const ineed = D - fanoutPeers.size;\n        candidateFanoutPeers.slice(0, ineed).forEach(id => {\n          fanoutPeers.add(id);\n          peersToGossip?.delete(id);\n        });\n      }\n    });\n    this.emitGossip(peersToGossipByTopic); // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n\n    await this.sendGraftPrune(tograft, toprune, noPX); // flush pending gossip that wasn't piggybacked above\n\n    this.flush(); // advance the message history window\n\n    this.mcache.shift();\n    this.dispatchEvent(new CustomEvent('gossipsub:heartbeat'));\n  }\n  /**\n   * Given a topic, returns up to count peers subscribed to that topic\n   * that pass an optional filter function\n   *\n   * @param topic\n   * @param count\n   * @param filter - a function to filter acceptable peers\n   */\n\n\n  getRandomGossipPeers(topic, count) {\n    let filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => true;\n    const peersInTopic = this.topics.get(topic);\n\n    if (!peersInTopic) {\n      return new Set();\n    } // Adds all peers using our protocol\n    // that also pass the filter function\n\n\n    let peers = [];\n    peersInTopic.forEach(id => {\n      const peerStreams = this.streamsOutbound.get(id);\n\n      if (!peerStreams) {\n        return;\n      }\n\n      if (this.multicodecs.includes(peerStreams.protocol) && filter(id)) {\n        peers.push(id);\n      }\n    }); // Pseudo-randomly shuffles peers\n\n    peers = shuffle(peers);\n\n    if (count > 0 && peers.length > count) {\n      peers = peers.slice(0, count);\n    }\n\n    return new Set(peers);\n  }\n\n  onScrapeMetrics(metrics) {\n    /* Data structure sizes */\n    metrics.mcacheSize.set(this.mcache.size);\n    metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount); // Arbitrary size\n\n    metrics.cacheSize.set({\n      cache: 'direct'\n    }, this.direct.size);\n    metrics.cacheSize.set({\n      cache: 'seenCache'\n    }, this.seenCache.size);\n    metrics.cacheSize.set({\n      cache: 'fastMsgIdCache'\n    }, this.fastMsgIdCache?.size ?? 0);\n    metrics.cacheSize.set({\n      cache: 'publishedMessageIds'\n    }, this.publishedMessageIds.size);\n    metrics.cacheSize.set({\n      cache: 'mcache'\n    }, this.mcache.size);\n    metrics.cacheSize.set({\n      cache: 'score'\n    }, this.score.size);\n    metrics.cacheSize.set({\n      cache: 'gossipTracer.promises'\n    }, this.gossipTracer.size);\n    metrics.cacheSize.set({\n      cache: 'gossipTracer.requests'\n    }, this.gossipTracer.requestMsByMsgSize); // Bounded by topic\n\n    metrics.cacheSize.set({\n      cache: 'topics'\n    }, this.topics.size);\n    metrics.cacheSize.set({\n      cache: 'subscriptions'\n    }, this.subscriptions.size);\n    metrics.cacheSize.set({\n      cache: 'mesh'\n    }, this.mesh.size);\n    metrics.cacheSize.set({\n      cache: 'fanout'\n    }, this.fanout.size); // Bounded by peer\n\n    metrics.cacheSize.set({\n      cache: 'peers'\n    }, this.peers.size);\n    metrics.cacheSize.set({\n      cache: 'streamsOutbound'\n    }, this.streamsOutbound.size);\n    metrics.cacheSize.set({\n      cache: 'streamsInbound'\n    }, this.streamsInbound.size);\n    metrics.cacheSize.set({\n      cache: 'acceptFromWhitelist'\n    }, this.acceptFromWhitelist.size);\n    metrics.cacheSize.set({\n      cache: 'gossip'\n    }, this.gossip.size);\n    metrics.cacheSize.set({\n      cache: 'control'\n    }, this.control.size);\n    metrics.cacheSize.set({\n      cache: 'peerhave'\n    }, this.peerhave.size);\n    metrics.cacheSize.set({\n      cache: 'outbound'\n    }, this.outbound.size); // 2D nested data structure\n\n    let backoffSize = 0;\n\n    for (const backoff of this.backoff.values()) {\n      backoffSize += backoff.size;\n    }\n\n    metrics.cacheSize.set({\n      cache: 'backoff'\n    }, backoffSize); // Peer counts\n\n    for (const [topicStr, peers] of this.topics) {\n      metrics.topicPeersCount.set({\n        topicStr\n      }, peers.size);\n    }\n\n    for (const [topicStr, peers] of this.mesh) {\n      metrics.meshPeerCounts.set({\n        topicStr\n      }, peers.size);\n    } // Peer scores\n\n\n    const scores = [];\n    const scoreByPeer = new Map();\n    metrics.behaviourPenalty.reset();\n\n    for (const peerIdStr of this.peers.keys()) {\n      const score = this.score.score(peerIdStr);\n      scores.push(score);\n      scoreByPeer.set(peerIdStr, score);\n      metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0);\n    }\n\n    metrics.registerScores(scores, this.opts.scoreThresholds); // Breakdown score per mesh topicLabel\n\n    metrics.registerScorePerMesh(this.mesh, scoreByPeer); // Breakdown on each score weight\n\n    const sw = computeAllPeersScoreWeights(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, metrics.topicStrToLabel);\n    metrics.registerScoreWeights(sw);\n  }\n\n}\nGossipSub.multicodec = constants.GossipsubIDv11;\nexport function gossipsub() {\n  let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return components => new GossipSub(components, init);\n}","map":{"version":3,"mappings":"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","names":["pipe","RecordEnvelope","peerIdFromBytes","peerIdFromString","logger","createTopology","CustomEvent","EventEmitter","MessageCache","RPC","constants","shuffle","messageIdToString","PeerScore","createPeerScoreParams","createPeerScoreThresholds","IWantTracer","SimpleTimeCache","ACCEPT_FROM_WHITELIST_DURATION_MS","ACCEPT_FROM_WHITELIST_MAX_MESSAGES","ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE","ChurnReason","getMetrics","IHaveIgnoreReason","InclusionReason","ScorePenalty","ValidateError","MessageStatus","RejectReason","rejectReasonFromAcceptance","buildRawMessage","validateToRawMessage","msgIdFnStrictNoSign","msgIdFnStrictSign","computeAllPeersScoreWeights","getPublishConfigFromPeerId","StrictNoSign","StrictSign","TopicValidatorResult","removeFirstNItemsFromSet","removeItemsFromSet","pushable","InboundStream","OutboundStream","decodeRpc","defaultDecodeRpcLimits","multiaddrToIPStr","multicodec","GossipsubIDv11","GossipStatusCode","GossipSub","constructor","components","options","GossipsubIDv10","Set","Map","objectMode","code","stopped","timer","metrics","heartbeatDuration","startTimer","heartbeat","catch","err","log","finally","status","started","clearTimeout","heartbeatTimeout","msToNextHeartbeat","opts","heartbeatInterval","Date","now","hearbeatStartMs","heartbeatSkipped","inc","setTimeout","runHeartbeat","fallbackToFloodsub","floodPublish","doPX","directPeers","D","GossipsubD","Dlo","GossipsubDlo","Dhi","GossipsubDhi","Dscore","GossipsubDscore","Dout","GossipsubDout","Dlazy","GossipsubDlazy","GossipsubHeartbeatInterval","fanoutTTL","GossipsubFanoutTTL","mcacheLength","GossipsubHistoryLength","mcacheGossip","GossipsubHistoryGossip","seenTTL","GossipsubSeenTTL","gossipsubIWantFollowupMs","GossipsubIWantFollowupTime","prunePeers","GossipsubPrunePeers","pruneBackoff","GossipsubPruneBackoff","graftFloodThreshold","GossipsubGraftFloodThreshold","opportunisticGraftPeers","GossipsubOpportunisticGraftPeers","opportunisticGraftTicks","GossipsubOpportunisticGraftTicks","directConnectTicks","GossipsubDirectConnectTicks","scoreParams","scoreThresholds","decodeRpcLimits","globalSignaturePolicy","multicodecs","push","FloodsubID","debugName","direct","map","p","id","toString","seenCache","validityMs","publishedMessageIds","msgIdFn","fastMsgIdFn","fastMsgIdCache","msgIdToStrFn","mcache","messageCache","dataTransform","metricsRegister","metricsTopicStrToLabel","Error","maxMeshMessageDeliveriesWindowMs","Math","max","Object","values","topics","topicParam","meshMessageDeliveriesWindow","DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS","gossipPromiseExpireSec","behaviourPenaltyThreshold","maxMeshMessageDeliveriesWindowSec","mcacheSize","addCollect","onScrapeMetrics","protocol","protocolsEnabled","set","gossipTracer","score","scoreCacheValidityMs","maxInboundStreams","maxOutboundStreams","allowedTopics","getPeers","peers","keys","str","isStarted","start","publishConfig","peerId","outboundInflightQueue","source","connection","createOutboundStream","e","error","Promise","all","peerStore","addressBook","add","addrs","registrar","handle","onIncomingStream","bind","topology","onConnect","onPeerConnected","onDisconnect","onPeerDisconnected","registrarTopologyIds","register","GossipsubHeartbeatInitialDelay","directPeerInitial","resolve","then","Array","from","connect","GossipsubDirectConnectInitialDelay","stop","forEach","unregister","end","outboundStream","streamsOutbound","close","clear","inboundStream","streamsInbound","subscriptions","heartbeatTimer","cancel","mesh","fanout","fanoutLastpub","gossip","control","peerhave","iasked","backoff","outbound","dumpPeerScoreStats","stream","remotePeer","addPeer","stat","direction","remoteAddr","createInboundStream","newConnectionCount","removePeer","has","newStream","maxBufferSize","maxOutboundBufferSize","floodsubPeers","peersPerProtocol","size","sendSubscriptions","priorInboundStream","get","undefined","maxDataLength","maxInboundDataLength","pipePeerReadStream","addr","currentIP","addIP","delete","topicStr","onRemoveFromMesh","Dc","acceptFromWhitelist","getMeshPeers","topic","peersInTopic","getSubscribers","getTopics","data","rpcBytes","subarray","rpc","onRpcRecv","length","awaitRpcHandler","handleReceivedRpc","onRpcRecvError","onRpcDataError","onPeerReadStreamError","handlePeerReadStreamError","acceptFrom","rpcRecvNotAccepted","messages","ihave","iwant","graft","prune","subOpt","subscribe","handleReceivedSubscription","dispatchEvent","detail","message","handleReceivedMessagePromise","handleReceivedMessage","onMsgRecvError","awaitRpcMessageHandler","handleControlMessage","topicSet","rpcMsg","onMsgRecvPreValidation","validationResult","validateReceivedMessage","onMsgRecvResult","duplicate","duplicateMessage","msgIdStr","deliverMessage","observeDuplicate","invalid","rejectMessage","reason","rejectInvalidMessage","onMsgRecvInvalid","valid","validateMessage","messageId","put","asyncValidation","isFromSelf","equals","emitSelf","propagationSource","msgId","msg","forwardMessage","fastMsgIdStr","msgIdCached","inboundTransform","TransformFailed","collision","fastMsgIdCacheCollision","topicValidator","topicValidators","acceptance","errCode","ERR_TOPIC_VALIDATOR_IGNORE","Ignore","ERR_TOPIC_VALIDATOR_REJECT","Reject","Accept","getScore","toPeer","sendRpc","controlMsg","handleIHave","handleIWant","handleGraft","handlePrune","sent","iwantMessageIds","messageIDs","addPromise","iwantPromiseUntracked","entry","messagesAccepted","acceptUntil","graylistThreshold","gossipThreshold","ihaveRcvIgnored","LowScore","GossipsubMaxIHaveMessages","MaxIhave","GossipsubMaxIHaveLength","MaxIasked","topicID","idonthave","onIhaveRcv","iask","iwantList","slice","iwantByTopic","iwantDonthave","getWithIWantCount","count","GossipsubGossipRetransmission","onIwantRcv","peersInMesh","expire","addPenalty","GraftBackoff","floodCutoff","addBackoff","onAddToMesh","Subscribed","makePrune","Unsub","doAddBackoff","acceptPXThreshold","pxConnect","interval","existingExpire","applyIwantPenalties","getBrokenPromises","BrokenPromise","clearBackoff","heartbeatTicks","GossipsubPruneBackoffTicks","directConnect","toconnect","pi","peerID","signedPeerRecord","envelope","openAndCertify","eid","consumePeerRecord","connectionManager","openConnection","getTopologies","join","unsubscribe","wasSubscribed","leave","onJoin","toAdd","fanoutPeers","Fanout","fanoutCount","newPeers","getRandomGossipPeers","peer","Random","sendGraft","onLeave","meshPeers","sendPrune","selectPeersToForward","excludePeers","tosend","publishThreshold","selectPeersToPublish","tosendCount","floodsub","newFanoutPeers","rawMsg","onForwardMsg","publish","transformedData","outboundTransform","raw","ignoreDuplicatePublishError","onPublishDuplicateMsg","recipients","willSendToSelf","allowPublishToZeroPeers","onPublishMsg","reportMessageValidationResult","cacheEntry","validate","onReportValidationMcacheHit","originatingPeers","onReportValidation","remove","rejectReason","ctrl","piggybackControl","piggybackGossip","encode","finish","onRpcSent","outRpc","sendGraftPrune","tograft","toprune","noPX","pruning","emitGossip","peersToGossipByTopic","gossipIDsByTopic","getGossipIDs","peersToGossip","doEmitGossip","candidateToGossip","target","factor","GossipsubGossipFactor","peerMessageIDs","pushGossip","flush","entries","controlIHaveMsgs","concat","xid","px","toBytes","getRawEnvelope","scores","s","cacheSize","cache","candidateMeshPeers","shuffledPeers","peerStreams","includes","prunePeer","graftPeer","BadScore","ineed","newMeshPeers","NotEnough","peersArray","sort","a","b","rotate","i","j","Excess","Outbound","peersList","medianIndex","floor","medianScore","opportunisticGraftThreshold","Opportunistic","lastpb","topicPeers","candidateFanoutPeers","shift","filter","mcacheNotValidatedCount","notValidatedCount","requestMsByMsgSize","backoffSize","topicPeersCount","meshPeerCounts","scoreByPeer","behaviourPenalty","reset","peerIdStr","observe","peerStats","registerScores","registerScorePerMesh","sw","params","peerIPs","topicStrToLabel","registerScoreWeights","gossipsub","init"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-gossipsub\\src\\index.ts"],"sourcesContent":["import { pipe } from 'it-pipe'\nimport type { Connection, Stream } from '@libp2p/interface-connection'\nimport { RecordEnvelope } from '@libp2p/peer-record'\nimport { peerIdFromBytes, peerIdFromString } from '@libp2p/peer-id'\nimport { Logger, logger } from '@libp2p/logger'\nimport { createTopology } from '@libp2p/topology'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events'\n\nimport { MessageCache } from './message-cache.js'\nimport { RPC, IRPC } from './message/rpc.js'\nimport * as constants from './constants.js'\nimport { shuffle, messageIdToString } from './utils/index.js'\nimport {\n  PeerScore,\n  PeerScoreParams,\n  PeerScoreThresholds,\n  createPeerScoreParams,\n  createPeerScoreThresholds,\n  PeerScoreStatsDump\n} from './score/index.js'\nimport { IWantTracer } from './tracer.js'\nimport { SimpleTimeCache } from './utils/time-cache.js'\nimport {\n  ACCEPT_FROM_WHITELIST_DURATION_MS,\n  ACCEPT_FROM_WHITELIST_MAX_MESSAGES,\n  ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE\n} from './constants.js'\nimport {\n  ChurnReason,\n  getMetrics,\n  IHaveIgnoreReason,\n  InclusionReason,\n  Metrics,\n  MetricsRegister,\n  ScorePenalty,\n  TopicStrToLabel,\n  ToSendGroupCount\n} from './metrics.js'\nimport {\n  MsgIdFn,\n  PublishConfig,\n  TopicStr,\n  MsgIdStr,\n  ValidateError,\n  PeerIdStr,\n  MessageStatus,\n  RejectReason,\n  RejectReasonObj,\n  FastMsgIdFn,\n  AddrInfo,\n  DataTransform,\n  rejectReasonFromAcceptance,\n  MsgIdToStrFn,\n  MessageId,\n  PublishOpts\n} from './types.js'\nimport { buildRawMessage, validateToRawMessage } from './utils/buildRawMessage.js'\nimport { msgIdFnStrictNoSign, msgIdFnStrictSign } from './utils/msgIdFn.js'\nimport { computeAllPeersScoreWeights } from './score/scoreMetrics.js'\nimport { getPublishConfigFromPeerId } from './utils/publishConfig.js'\nimport type { GossipsubOptsSpec } from './config.js'\nimport {\n  Message,\n  PublishResult,\n  PubSub,\n  PubSubEvents,\n  PubSubInit,\n  StrictNoSign,\n  StrictSign,\n  SubscriptionChangeData,\n  TopicValidatorFn,\n  TopicValidatorResult\n} from '@libp2p/interface-pubsub'\nimport type { IncomingStreamData, Registrar } from '@libp2p/interface-registrar'\nimport { removeFirstNItemsFromSet, removeItemsFromSet } from './utils/set.js'\nimport { pushable } from 'it-pushable'\nimport { InboundStream, OutboundStream } from './stream.js'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { decodeRpc, DecodeRPCLimits, defaultDecodeRpcLimits } from './message/decodeRpc.js'\nimport { ConnectionManager } from '@libp2p/interface-connection-manager'\nimport { PeerStore } from '@libp2p/interface-peer-store'\nimport { Multiaddr } from '@multiformats/multiaddr'\nimport { multiaddrToIPStr } from './utils/multiaddr.js'\n\ntype ConnectionDirection = 'inbound' | 'outbound'\n\ntype ReceivedMessageResult =\n  | { code: MessageStatus.duplicate; msgIdStr: MsgIdStr }\n  | ({ code: MessageStatus.invalid; msgIdStr?: MsgIdStr } & RejectReasonObj)\n  | { code: MessageStatus.valid; messageId: MessageId; msg: Message }\n\nexport const multicodec: string = constants.GossipsubIDv11\n\nexport interface GossipsubOpts extends GossipsubOptsSpec, PubSubInit {\n  /** if dial should fallback to floodsub */\n  fallbackToFloodsub: boolean\n  /** if self-published messages should be sent to all peers */\n  floodPublish: boolean\n  /** whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes. */\n  doPX: boolean\n  /** peers with which we will maintain direct connections */\n  directPeers: AddrInfo[]\n  /**\n   * If true will not forward messages to mesh peers until reportMessageValidationResult() is called.\n   * Messages will be cached in mcache for some time after which they are evicted. Calling\n   * reportMessageValidationResult() after the message is dropped from mcache won't forward the message.\n   */\n  asyncValidation: boolean\n  /** Do not throw `InsufficientPeers` error if publishing to zero peers */\n  allowPublishToZeroPeers: boolean\n  /** Do not throw `PublishError.Duplicate` if publishing duplicate messages */\n  ignoreDuplicatePublishError: boolean\n  /** For a single stream, await processing each RPC before processing the next */\n  awaitRpcHandler: boolean\n  /** For a single RPC, await processing each message before processing the next */\n  awaitRpcMessageHandler: boolean\n\n  /** message id function */\n  msgIdFn: MsgIdFn\n  /** fast message id function */\n  fastMsgIdFn: FastMsgIdFn\n  /** Uint8Array message id to string function */\n  msgIdToStrFn: MsgIdToStrFn\n  /** override the default MessageCache */\n  messageCache: MessageCache\n  /** peer score parameters */\n  scoreParams: Partial<PeerScoreParams>\n  /** peer score thresholds */\n  scoreThresholds: Partial<PeerScoreThresholds>\n  /** customize GossipsubIWantFollowupTime in order not to apply IWANT penalties */\n  gossipsubIWantFollowupMs: number\n\n  /** override constants for fine tuning */\n  prunePeers?: number\n  pruneBackoff?: number\n  graftFloodThreshold?: number\n  opportunisticGraftPeers?: number\n  opportunisticGraftTicks?: number\n  directConnectTicks?: number\n\n  dataTransform?: DataTransform\n  metricsRegister?: MetricsRegister | null\n  metricsTopicStrToLabel?: TopicStrToLabel\n\n  // Debug\n  /** Prefix tag for debug logs */\n  debugName?: string\n\n  /**\n   * Specify the maximum number of inbound gossipsub protocol\n   * streams that are allowed to be open concurrently\n   */\n  maxInboundStreams?: number\n\n  /**\n   * Specify the maximum number of outbound gossipsub protocol\n   * streams that are allowed to be open concurrently\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * Specify max buffer size in bytes for OutboundStream.\n   * If full it will throw and reject sending any more data.\n   */\n  maxOutboundBufferSize?: number\n\n  /**\n   * Specify max size to skip decoding messages whose data\n   * section exceeds this size.\n   *\n   */\n  maxInboundDataLength?: number\n\n  /**\n   * If provided, only allow topics in this list\n   */\n  allowedTopics?: string[] | Set<string>\n\n  /**\n   * Limits to bound protobuf decoding\n   */\n  decodeRpcLimits?: DecodeRPCLimits\n}\n\nexport interface GossipsubMessage {\n  propagationSource: PeerId\n  msgId: MsgIdStr\n  msg: Message\n}\n\nexport interface GossipsubEvents extends PubSubEvents {\n  'gossipsub:heartbeat': CustomEvent\n  'gossipsub:message': CustomEvent<GossipsubMessage>\n}\n\nenum GossipStatusCode {\n  started,\n  stopped\n}\n\ntype GossipStatus =\n  | {\n      code: GossipStatusCode.started\n      registrarTopologyIds: string[]\n      heartbeatTimeout: ReturnType<typeof setTimeout>\n      hearbeatStartMs: number\n    }\n  | {\n      code: GossipStatusCode.stopped\n    }\n\ninterface GossipOptions extends GossipsubOpts {\n  scoreParams: PeerScoreParams\n  scoreThresholds: PeerScoreThresholds\n}\n\ninterface AcceptFromWhitelistEntry {\n  /** number of messages accepted since recomputing the peer's score */\n  messagesAccepted: number\n  /** have to recompute score after this time */\n  acceptUntil: number\n}\n\nexport interface GossipSubComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  registrar: Registrar\n  connectionManager: ConnectionManager\n}\n\nexport class GossipSub extends EventEmitter<GossipsubEvents> implements PubSub<GossipsubEvents> {\n  /**\n   * The signature policy to follow by default\n   */\n  public readonly globalSignaturePolicy: typeof StrictSign | typeof StrictNoSign\n  public multicodecs: string[] = [constants.GossipsubIDv11, constants.GossipsubIDv10]\n\n  private publishConfig: PublishConfig | undefined\n\n  private readonly dataTransform: DataTransform | undefined\n\n  // State\n\n  public readonly peers = new Set<PeerIdStr>()\n  public readonly streamsInbound = new Map<PeerIdStr, InboundStream>()\n  public readonly streamsOutbound = new Map<PeerIdStr, OutboundStream>()\n\n  /** Ensures outbound streams are created sequentially */\n  private outboundInflightQueue = pushable<{ peerId: PeerId; connection: Connection }>({ objectMode: true })\n\n  /** Direct peers */\n  public readonly direct = new Set<PeerIdStr>()\n\n  /** Floodsub peers */\n  private readonly floodsubPeers = new Set<PeerIdStr>()\n\n  /** Cache of seen messages */\n  private readonly seenCache: SimpleTimeCache<void>\n\n  /**\n   * Map of peer id and AcceptRequestWhileListEntry\n   */\n  private readonly acceptFromWhitelist = new Map<PeerIdStr, AcceptFromWhitelistEntry>()\n\n  /**\n   * Map of topics to which peers are subscribed to\n   */\n  private readonly topics = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * List of our subscriptions\n   */\n  private readonly subscriptions = new Set<TopicStr>()\n\n  /**\n   * Map of topic meshes\n   * topic => peer id set\n   */\n  public readonly mesh = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n   * topic => peer id set\n   */\n  public readonly fanout = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * Map of last publish time for fanout topics\n   * topic => last publish time\n   */\n  private readonly fanoutLastpub = new Map<TopicStr, number>()\n\n  /**\n   * Map of pending messages to gossip\n   * peer id => control messages\n   */\n  public readonly gossip = new Map<PeerIdStr, RPC.IControlIHave[]>()\n\n  /**\n   * Map of control messages\n   * peer id => control message\n   */\n  public readonly control = new Map<PeerIdStr, RPC.IControlMessage>()\n\n  /**\n   * Number of IHAVEs received from peer in the last heartbeat\n   */\n  private readonly peerhave = new Map<PeerIdStr, number>()\n\n  /** Number of messages we have asked from peer in the last heartbeat */\n  private readonly iasked = new Map<PeerIdStr, number>()\n\n  /** Prune backoff map */\n  private readonly backoff = new Map<TopicStr, Map<PeerIdStr, number>>()\n\n  /**\n   * Connection direction cache, marks peers with outbound connections\n   * peer id => direction\n   */\n  private readonly outbound = new Map<PeerIdStr, boolean>()\n  private readonly msgIdFn: MsgIdFn\n\n  /**\n   * A fast message id function used for internal message de-duplication\n   */\n  private readonly fastMsgIdFn: FastMsgIdFn | undefined\n\n  private readonly msgIdToStrFn: MsgIdToStrFn\n\n  /** Maps fast message-id to canonical message-id */\n  private readonly fastMsgIdCache: SimpleTimeCache<MsgIdStr> | undefined\n\n  /**\n   * Short term cache for published message ids. This is used for penalizing peers sending\n   * our own messages back if the messages are anonymous or use a random author.\n   */\n  private readonly publishedMessageIds: SimpleTimeCache<void>\n\n  /**\n   * A message cache that contains the messages for last few heartbeat ticks\n   */\n  private readonly mcache: MessageCache\n\n  /** Peer score tracking */\n  public readonly score: PeerScore\n\n  /**\n   * Custom validator function per topic.\n   * Must return or resolve quickly (< 100ms) to prevent causing penalties for late messages.\n   * If you need to apply validation that may require longer times use `asyncValidation` option and callback the\n   * validation result through `Gossipsub.reportValidationResult`\n   */\n  public readonly topicValidators = new Map<TopicStr, TopicValidatorFn>()\n\n  /**\n   * Make this protected so child class may want to redirect to its own log.\n   */\n  protected readonly log: Logger\n\n  /**\n   * Number of heartbeats since the beginning of time\n   * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n   */\n  private heartbeatTicks = 0\n\n  /**\n   * Tracks IHAVE/IWANT promises broken by peers\n   */\n  readonly gossipTracer: IWantTracer\n\n  private readonly components: GossipSubComponents\n\n  private directPeerInitial: ReturnType<typeof setTimeout> | null = null\n\n  public static multicodec: string = constants.GossipsubIDv11\n\n  // Options\n  readonly opts: Required<GossipOptions>\n  private readonly decodeRpcLimits: DecodeRPCLimits\n\n  private readonly metrics: Metrics | null\n  private status: GossipStatus = { code: GossipStatusCode.stopped }\n  private maxInboundStreams?: number\n  private maxOutboundStreams?: number\n  private allowedTopics: Set<TopicStr> | null\n\n  private heartbeatTimer: {\n    _intervalId: ReturnType<typeof setInterval> | undefined\n    runPeriodically: (fn: () => void, period: number) => void\n    cancel: () => void\n  } | null = null\n\n  constructor(components: GossipSubComponents, options: Partial<GossipsubOpts> = {}) {\n    super()\n\n    const opts = {\n      fallbackToFloodsub: true,\n      floodPublish: true,\n      doPX: false,\n      directPeers: [],\n      D: constants.GossipsubD,\n      Dlo: constants.GossipsubDlo,\n      Dhi: constants.GossipsubDhi,\n      Dscore: constants.GossipsubDscore,\n      Dout: constants.GossipsubDout,\n      Dlazy: constants.GossipsubDlazy,\n      heartbeatInterval: constants.GossipsubHeartbeatInterval,\n      fanoutTTL: constants.GossipsubFanoutTTL,\n      mcacheLength: constants.GossipsubHistoryLength,\n      mcacheGossip: constants.GossipsubHistoryGossip,\n      seenTTL: constants.GossipsubSeenTTL,\n      gossipsubIWantFollowupMs: constants.GossipsubIWantFollowupTime,\n      prunePeers: constants.GossipsubPrunePeers,\n      pruneBackoff: constants.GossipsubPruneBackoff,\n      graftFloodThreshold: constants.GossipsubGraftFloodThreshold,\n      opportunisticGraftPeers: constants.GossipsubOpportunisticGraftPeers,\n      opportunisticGraftTicks: constants.GossipsubOpportunisticGraftTicks,\n      directConnectTicks: constants.GossipsubDirectConnectTicks,\n      ...options,\n      scoreParams: createPeerScoreParams(options.scoreParams),\n      scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)\n    }\n\n    this.components = components\n    this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits\n\n    this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign\n\n    // Also wants to get notified of peers connected using floodsub\n    if (opts.fallbackToFloodsub) {\n      this.multicodecs.push(constants.FloodsubID)\n    }\n\n    // From pubsub\n    this.log = logger(opts.debugName ?? 'libp2p:gossipsub')\n\n    // Gossipsub\n\n    this.opts = opts as Required<GossipOptions>\n    this.direct = new Set(opts.directPeers.map((p) => p.id.toString()))\n    this.seenCache = new SimpleTimeCache<void>({ validityMs: opts.seenTTL })\n    this.publishedMessageIds = new SimpleTimeCache<void>({ validityMs: opts.seenTTL })\n\n    if (options.msgIdFn) {\n      // Use custom function\n      this.msgIdFn = options.msgIdFn\n    } else {\n      switch (this.globalSignaturePolicy) {\n        case StrictSign:\n          this.msgIdFn = msgIdFnStrictSign\n          break\n        case StrictNoSign:\n          this.msgIdFn = msgIdFnStrictNoSign\n          break\n      }\n    }\n\n    if (options.fastMsgIdFn) {\n      this.fastMsgIdFn = options.fastMsgIdFn\n      this.fastMsgIdCache = new SimpleTimeCache<MsgIdStr>({ validityMs: opts.seenTTL })\n    }\n\n    // By default, gossipsub only provide a browser friendly function to convert Uint8Array message id to string.\n    this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString\n\n    this.mcache = options.messageCache || new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn)\n\n    if (options.dataTransform) {\n      this.dataTransform = options.dataTransform\n    }\n\n    if (options.metricsRegister) {\n      if (!options.metricsTopicStrToLabel) {\n        throw Error('Must set metricsTopicStrToLabel with metrics')\n      }\n\n      // in theory, each topic has its own meshMessageDeliveriesWindow param\n      // however in lodestar, we configure it mostly the same so just pick the max of positive ones\n      // (some topics have meshMessageDeliveriesWindow as 0)\n      const maxMeshMessageDeliveriesWindowMs = Math.max(\n        ...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow),\n        constants.DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS\n      )\n\n      const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {\n        gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1000,\n        behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,\n        maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1000\n      })\n\n      metrics.mcacheSize.addCollect(() => this.onScrapeMetrics(metrics))\n      for (const protocol of this.multicodecs) {\n        metrics.protocolsEnabled.set({ protocol }, 1)\n      }\n\n      this.metrics = metrics\n    } else {\n      this.metrics = null\n    }\n\n    this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics)\n\n    /**\n     * libp2p\n     */\n    this.score = new PeerScore(this.opts.scoreParams, this.metrics, {\n      scoreCacheValidityMs: opts.heartbeatInterval\n    })\n\n    this.maxInboundStreams = options.maxInboundStreams\n    this.maxOutboundStreams = options.maxOutboundStreams\n\n    this.allowedTopics = opts.allowedTopics ? new Set(opts.allowedTopics) : null\n  }\n\n  getPeers(): PeerId[] {\n    return [...this.peers.keys()].map((str) => peerIdFromString(str))\n  }\n\n  isStarted(): boolean {\n    return this.status.code === GossipStatusCode.started\n  }\n\n  // LIFECYCLE METHODS\n\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   */\n  async start(): Promise<void> {\n    // From pubsub\n    if (this.isStarted()) {\n      return\n    }\n\n    this.log('starting')\n\n    this.publishConfig = await getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId)\n\n    // Create the outbound inflight queue\n    // This ensures that outbound stream creation happens sequentially\n    this.outboundInflightQueue = pushable({ objectMode: true })\n    pipe(this.outboundInflightQueue, async (source) => {\n      for await (const { peerId, connection } of source) {\n        await this.createOutboundStream(peerId, connection)\n      }\n    }).catch((e) => this.log.error('outbound inflight queue error', e))\n\n    // set direct peer addresses in the address book\n    await Promise.all(\n      this.opts.directPeers.map(async (p) => {\n        await this.components.peerStore.addressBook.add(p.id, p.addrs)\n      })\n    )\n\n    const registrar = this.components.registrar\n    // Incoming streams\n    // Called after a peer dials us\n    await Promise.all(\n      this.multicodecs.map((multicodec) =>\n        registrar.handle(multicodec, this.onIncomingStream.bind(this), {\n          maxInboundStreams: this.maxInboundStreams,\n          maxOutboundStreams: this.maxOutboundStreams\n        })\n      )\n    )\n\n    // # How does Gossipsub interact with libp2p? Rough guide from Mar 2022\n    //\n    // ## Setup:\n    // Gossipsub requests libp2p to callback, TBD\n    //\n    // `this.libp2p.handle()` registers a handler for `/meshsub/1.1.0` and other Gossipsub protocols\n    // The handler callback is registered in libp2p Upgrader.protocols map.\n    //\n    // Upgrader receives an inbound connection from some transport and (`Upgrader.upgradeInbound`):\n    // - Adds encryption (NOISE in our case)\n    // - Multiplex stream\n    // - Create a muxer and register that for each new stream call Upgrader.protocols handler\n    //\n    // ## Topology\n    // - new instance of Topology (unlinked to libp2p) with handlers\n    // - registar.register(topology)\n\n    // register protocol with topology\n    // Topology callbacks called on connection manager changes\n    const topology = createTopology({\n      onConnect: this.onPeerConnected.bind(this),\n      onDisconnect: this.onPeerDisconnected.bind(this)\n    })\n    const registrarTopologyIds = await Promise.all(\n      this.multicodecs.map((multicodec) => registrar.register(multicodec, topology))\n    )\n\n    // Schedule to start heartbeat after `GossipsubHeartbeatInitialDelay`\n    const heartbeatTimeout = setTimeout(this.runHeartbeat, constants.GossipsubHeartbeatInitialDelay)\n    // Then, run heartbeat every `heartbeatInterval` offset by `GossipsubHeartbeatInitialDelay`\n\n    this.status = {\n      code: GossipStatusCode.started,\n      registrarTopologyIds,\n      heartbeatTimeout: heartbeatTimeout,\n      hearbeatStartMs: Date.now() + constants.GossipsubHeartbeatInitialDelay\n    }\n\n    this.score.start()\n    // connect to direct peers\n    this.directPeerInitial = setTimeout(() => {\n      Promise.resolve()\n        .then(async () => {\n          await Promise.all(Array.from(this.direct).map(async (id) => await this.connect(id)))\n        })\n        .catch((err) => {\n          this.log(err)\n        })\n    }, constants.GossipsubDirectConnectInitialDelay)\n\n    this.log('started')\n  }\n\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   */\n  async stop(): Promise<void> {\n    this.log('stopping')\n    // From pubsub\n\n    if (this.status.code !== GossipStatusCode.started) {\n      return\n    }\n\n    const { registrarTopologyIds } = this.status\n    this.status = { code: GossipStatusCode.stopped }\n\n    // unregister protocol and handlers\n    const registrar = this.components.registrar\n    registrarTopologyIds.forEach((id) => registrar.unregister(id))\n\n    this.outboundInflightQueue.end()\n\n    for (const outboundStream of this.streamsOutbound.values()) {\n      outboundStream.close()\n    }\n    this.streamsOutbound.clear()\n\n    for (const inboundStream of this.streamsInbound.values()) {\n      inboundStream.close()\n    }\n    this.streamsInbound.clear()\n\n    this.peers.clear()\n    this.subscriptions.clear()\n\n    // Gossipsub\n\n    if (this.heartbeatTimer) {\n      this.heartbeatTimer.cancel()\n      this.heartbeatTimer = null\n    }\n\n    this.score.stop()\n\n    this.mesh.clear()\n    this.fanout.clear()\n    this.fanoutLastpub.clear()\n    this.gossip.clear()\n    this.control.clear()\n    this.peerhave.clear()\n    this.iasked.clear()\n    this.backoff.clear()\n    this.outbound.clear()\n    this.gossipTracer.clear()\n    this.seenCache.clear()\n    if (this.fastMsgIdCache) this.fastMsgIdCache.clear()\n    if (this.directPeerInitial) clearTimeout(this.directPeerInitial)\n\n    this.log('stopped')\n  }\n\n  /** FOR DEBUG ONLY - Dump peer stats for all peers. Data is cloned, safe to mutate */\n  dumpPeerScoreStats(): PeerScoreStatsDump {\n    return this.score.dumpPeerScoreStats()\n  }\n\n  /**\n   * On an inbound stream opened\n   */\n  private onIncomingStream({ stream, connection }: IncomingStreamData) {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const peerId = connection.remotePeer\n    // add peer to router\n    this.addPeer(peerId, connection.stat.direction, connection.remoteAddr)\n    // create inbound stream\n    this.createInboundStream(peerId, stream)\n    // attempt to create outbound stream\n    this.outboundInflightQueue.push({ peerId, connection })\n  }\n\n  /**\n   * Registrar notifies an established connection with pubsub protocol\n   */\n  private onPeerConnected(peerId: PeerId, connection: Connection): void {\n    this.metrics?.newConnectionCount.inc({ status: connection.stat.status })\n    // libp2p may emit a closed connection and never issue peer:disconnect event\n    // see https://github.com/ChainSafe/js-libp2p-gossipsub/issues/398\n    if (!this.isStarted() || connection.stat.status !== 'OPEN') {\n      return\n    }\n\n    this.addPeer(peerId, connection.stat.direction, connection.remoteAddr)\n    this.outboundInflightQueue.push({ peerId, connection })\n  }\n\n  /**\n   * Registrar notifies a closing connection with pubsub protocol\n   */\n  private onPeerDisconnected(peerId: PeerId): void {\n    this.log('connection ended %p', peerId)\n    this.removePeer(peerId)\n  }\n\n  private async createOutboundStream(peerId: PeerId, connection: Connection): Promise<void> {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // TODO make this behavior more robust\n    // This behavior is different than for inbound streams\n    // If an outbound stream already exists, don't create a new stream\n    if (this.streamsOutbound.has(id)) {\n      return\n    }\n\n    try {\n      const stream = new OutboundStream(\n        await connection.newStream(this.multicodecs),\n        (e) => this.log.error('outbound pipe error', e),\n        { maxBufferSize: this.opts.maxOutboundBufferSize }\n      )\n\n      this.log('create outbound stream %p', peerId)\n\n      this.streamsOutbound.set(id, stream)\n\n      const protocol = stream.protocol\n      if (protocol === constants.FloodsubID) {\n        this.floodsubPeers.add(id)\n      }\n      this.metrics?.peersPerProtocol.inc({ protocol }, 1)\n\n      // Immediately send own subscriptions via the newly attached stream\n      if (this.subscriptions.size > 0) {\n        this.log('send subscriptions to', id)\n        this.sendSubscriptions(id, Array.from(this.subscriptions), true)\n      }\n    } catch (e) {\n      this.log.error('createOutboundStream error', e)\n    }\n  }\n\n  private async createInboundStream(peerId: PeerId, stream: Stream): Promise<void> {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // TODO make this behavior more robust\n    // This behavior is different than for outbound streams\n    // If a peer initiates a new inbound connection\n    // we assume that one is the new canonical inbound stream\n    const priorInboundStream = this.streamsInbound.get(id)\n    if (priorInboundStream !== undefined) {\n      this.log('replacing existing inbound steam %s', id)\n      priorInboundStream.close()\n    }\n\n    this.log('create inbound stream %s', id)\n\n    const inboundStream = new InboundStream(stream, { maxDataLength: this.opts.maxInboundDataLength })\n    this.streamsInbound.set(id, inboundStream)\n\n    this.pipePeerReadStream(peerId, inboundStream.source).catch((err) => this.log(err))\n  }\n\n  /**\n   * Add a peer to the router\n   */\n  private addPeer(peerId: PeerId, direction: ConnectionDirection, addr: Multiaddr): void {\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      this.log('new peer %p', peerId)\n\n      this.peers.add(id)\n\n      // Add to peer scoring\n      this.score.addPeer(id)\n      const currentIP = multiaddrToIPStr(addr)\n      if (currentIP !== null) {\n        this.score.addIP(id, currentIP)\n      } else {\n        this.log('Added peer has no IP in current address %s %s', id, addr.toString())\n      }\n\n      // track the connection direction. Don't allow to unset outbound\n      if (!this.outbound.has(id)) {\n        this.outbound.set(id, direction === 'outbound')\n      }\n    }\n  }\n\n  /**\n   * Removes a peer from the router\n   */\n  private removePeer(peerId: PeerId): void {\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // delete peer\n    this.log('delete peer %p', peerId)\n    this.peers.delete(id)\n\n    const outboundStream = this.streamsOutbound.get(id)\n    const inboundStream = this.streamsInbound.get(id)\n\n    if (outboundStream) {\n      this.metrics?.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1)\n    }\n\n    // close streams\n    outboundStream?.close()\n    inboundStream?.close()\n\n    // remove streams\n    this.streamsOutbound.delete(id)\n    this.streamsInbound.delete(id)\n\n    // remove peer from topics map\n    for (const peers of this.topics.values()) {\n      peers.delete(id)\n    }\n\n    // Remove this peer from the mesh\n    for (const [topicStr, peers] of this.mesh) {\n      if (peers.delete(id) === true) {\n        this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1)\n      }\n    }\n\n    // Remove this peer from the fanout\n    for (const peers of this.fanout.values()) {\n      peers.delete(id)\n    }\n\n    // Remove from floodsubPeers\n    this.floodsubPeers.delete(id)\n    // Remove from gossip mapping\n    this.gossip.delete(id)\n    // Remove from control mapping\n    this.control.delete(id)\n    // Remove from backoff mapping\n    this.outbound.delete(id)\n\n    // Remove from peer scoring\n    this.score.removePeer(id)\n\n    this.acceptFromWhitelist.delete(id)\n  }\n\n  // API METHODS\n\n  get started(): boolean {\n    return this.status.code === GossipStatusCode.started\n  }\n\n  /**\n   * Get a the peer-ids in a topic mesh\n   */\n  getMeshPeers(topic: TopicStr): PeerIdStr[] {\n    const peersInTopic = this.mesh.get(topic)\n    return peersInTopic ? Array.from(peersInTopic) : []\n  }\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   */\n  getSubscribers(topic: TopicStr): PeerId[] {\n    const peersInTopic = this.topics.get(topic)\n    return (peersInTopic ? Array.from(peersInTopic) : []).map((str) => peerIdFromString(str))\n  }\n\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   */\n  getTopics(): TopicStr[] {\n    return Array.from(this.subscriptions)\n  }\n\n  // TODO: Reviewing Pubsub API\n\n  // MESSAGE METHODS\n\n  /**\n   * Responsible for processing each RPC message received by other peers.\n   */\n  private async pipePeerReadStream(peerId: PeerId, stream: AsyncIterable<Uint8ArrayList>): Promise<void> {\n    try {\n      await pipe(stream, async (source) => {\n        for await (const data of source) {\n          try {\n            // TODO: Check max gossip message size, before decodeRpc()\n            const rpcBytes = data.subarray()\n            // Note: This function may throw, it must be wrapped in a try {} catch {} to prevent closing the stream.\n            // TODO: What should we do if the entire RPC is invalid?\n            const rpc = decodeRpc(rpcBytes, this.decodeRpcLimits)\n\n            this.metrics?.onRpcRecv(rpc, rpcBytes.length)\n\n            // Since processRpc may be overridden entirely in unsafe ways,\n            // the simplest/safest option here is to wrap in a function and capture all errors\n            // to prevent a top-level unhandled exception\n            // This processing of rpc messages should happen without awaiting full validation/execution of prior messages\n            if (this.opts.awaitRpcHandler) {\n              try {\n                await this.handleReceivedRpc(peerId, rpc)\n              } catch (err) {\n                this.metrics?.onRpcRecvError()\n                this.log(err)\n              }\n            } else {\n              this.handleReceivedRpc(peerId, rpc).catch((err) => {\n                this.metrics?.onRpcRecvError()\n                this.log(err)\n              })\n            }\n          } catch (e) {\n            this.metrics?.onRpcDataError()\n            this.log(e as Error)\n          }\n        }\n      })\n    } catch (err) {\n      this.metrics?.onPeerReadStreamError()\n      this.handlePeerReadStreamError(err as Error, peerId)\n    }\n  }\n\n  /**\n   * Handle error when read stream pipe throws, less of the functional use but more\n   * to for testing purposes to spy on the error handling\n   * */\n  private handlePeerReadStreamError(err: Error, peerId: PeerId): void {\n    this.log.error(err)\n    this.onPeerDisconnected(peerId)\n  }\n\n  /**\n   * Handles an rpc request from a peer\n   */\n  public async handleReceivedRpc(from: PeerId, rpc: IRPC): Promise<void> {\n    // Check if peer is graylisted in which case we ignore the event\n    if (!this.acceptFrom(from.toString())) {\n      this.log('received message from unacceptable peer %p', from)\n      this.metrics?.rpcRecvNotAccepted.inc()\n      return\n    }\n\n    const subscriptions = rpc.subscriptions ? rpc.subscriptions.length : 0\n    const messages = rpc.messages ? rpc.messages.length : 0\n    let ihave = 0\n    let iwant = 0\n    let graft = 0\n    let prune = 0\n    if (rpc.control) {\n      if (rpc.control.ihave) ihave = rpc.control.ihave.length\n      if (rpc.control.iwant) iwant = rpc.control.iwant.length\n      if (rpc.control.graft) graft = rpc.control.graft.length\n      if (rpc.control.prune) prune = rpc.control.prune.length\n    }\n    this.log(\n      `rpc.from ${from.toString()} subscriptions ${subscriptions} messages ${messages} ihave ${ihave} iwant ${iwant} graft ${graft} prune ${prune}`\n    )\n\n    // Handle received subscriptions\n    if (rpc.subscriptions && rpc.subscriptions.length > 0) {\n      // update peer subscriptions\n\n      const subscriptions: { topic: TopicStr; subscribe: boolean }[] = []\n\n      rpc.subscriptions.forEach((subOpt) => {\n        const topic = subOpt.topic\n        const subscribe = subOpt.subscribe === true\n\n        if (topic != null) {\n          if (this.allowedTopics && !this.allowedTopics.has(topic)) {\n            // Not allowed: subscription data-structures are not bounded by topic count\n            // TODO: Should apply behaviour penalties?\n            return\n          }\n\n          this.handleReceivedSubscription(from, topic, subscribe)\n\n          subscriptions.push({ topic, subscribe })\n        }\n      })\n\n      this.dispatchEvent(\n        new CustomEvent<SubscriptionChangeData>('subscription-change', {\n          detail: { peerId: from, subscriptions }\n        })\n      )\n    }\n\n    // Handle messages\n    // TODO: (up to limit)\n    if (rpc.messages) {\n      for (const message of rpc.messages) {\n        if (this.allowedTopics && !this.allowedTopics.has(message.topic)) {\n          // Not allowed: message cache data-structures are not bounded by topic count\n          // TODO: Should apply behaviour penalties?\n          continue\n        }\n\n        const handleReceivedMessagePromise = this.handleReceivedMessage(from, message)\n          // Should never throw, but handle just in case\n          .catch((err) => {\n            this.metrics?.onMsgRecvError(message.topic)\n            this.log(err)\n          })\n\n        if (this.opts.awaitRpcMessageHandler) {\n          await handleReceivedMessagePromise\n        }\n      }\n    }\n\n    // Handle control messages\n    if (rpc.control) {\n      await this.handleControlMessage(from.toString(), rpc.control)\n    }\n  }\n\n  /**\n   * Handles a subscription change from a peer\n   */\n  private handleReceivedSubscription(from: PeerId, topic: TopicStr, subscribe: boolean): void {\n    this.log('subscription update from %p topic %s', from, topic)\n\n    let topicSet = this.topics.get(topic)\n    if (topicSet == null) {\n      topicSet = new Set()\n      this.topics.set(topic, topicSet)\n    }\n\n    if (subscribe) {\n      // subscribe peer to new topic\n      topicSet.add(from.toString())\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(from.toString())\n    }\n\n    // TODO: rust-libp2p has A LOT more logic here\n  }\n\n  /**\n   * Handles a newly received message from an RPC.\n   * May forward to all peers in the mesh.\n   */\n  private async handleReceivedMessage(from: PeerId, rpcMsg: RPC.IMessage): Promise<void> {\n    this.metrics?.onMsgRecvPreValidation(rpcMsg.topic)\n\n    const validationResult = await this.validateReceivedMessage(from, rpcMsg)\n\n    this.metrics?.onMsgRecvResult(rpcMsg.topic, validationResult.code)\n\n    switch (validationResult.code) {\n      case MessageStatus.duplicate:\n        // Report the duplicate\n        this.score.duplicateMessage(from.toString(), validationResult.msgIdStr, rpcMsg.topic)\n        // due to the collision of fastMsgIdFn, 2 different messages may end up the same fastMsgId\n        // so we need to also mark the duplicate message as delivered or the promise is not resolved\n        // and peer gets penalized. See https://github.com/ChainSafe/js-libp2p-gossipsub/pull/385\n        this.gossipTracer.deliverMessage(validationResult.msgIdStr, true)\n        this.mcache.observeDuplicate(validationResult.msgIdStr, from.toString())\n        return\n\n      case MessageStatus.invalid:\n        // invalid messages received\n        // metrics.register_invalid_message(&raw_message.topic)\n        // Tell peer_score about reject\n        // Reject the original source, and any duplicates we've seen from other peers.\n        if (validationResult.msgIdStr) {\n          const msgIdStr = validationResult.msgIdStr\n          this.score.rejectMessage(from.toString(), msgIdStr, rpcMsg.topic, validationResult.reason)\n          this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason)\n        } else {\n          this.score.rejectInvalidMessage(from.toString(), rpcMsg.topic)\n        }\n\n        this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult)\n        return\n\n      case MessageStatus.valid:\n        // Tells score that message arrived (but is maybe not fully validated yet).\n        // Consider the message as delivered for gossip promises.\n        this.score.validateMessage(validationResult.messageId.msgIdStr)\n        this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr)\n\n        // Add the message to our memcache\n        // if no validation is required, mark the message as validated\n        this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation)\n\n        // Dispatch the message to the user if we are subscribed to the topic\n        if (this.subscriptions.has(rpcMsg.topic)) {\n          const isFromSelf = this.components.peerId.equals(from)\n\n          if (!isFromSelf || this.opts.emitSelf) {\n            super.dispatchEvent(\n              new CustomEvent<GossipsubMessage>('gossipsub:message', {\n                detail: {\n                  propagationSource: from,\n                  msgId: validationResult.messageId.msgIdStr,\n                  msg: validationResult.msg\n                }\n              })\n            )\n            // TODO: Add option to switch between emit per topic or all messages in one\n            super.dispatchEvent(new CustomEvent<Message>('message', { detail: validationResult.msg }))\n          }\n        }\n\n        // Forward the message to mesh peers, if no validation is required\n        // If asyncValidation is ON, expect the app layer to call reportMessageValidationResult(), then forward\n        if (!this.opts.asyncValidation) {\n          // TODO: in rust-libp2p\n          // .forward_msg(&msg_id, raw_message, Some(propagation_source))\n          this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from.toString())\n        }\n    }\n  }\n\n  /**\n   * Handles a newly received message from an RPC.\n   * May forward to all peers in the mesh.\n   */\n  private async validateReceivedMessage(\n    propagationSource: PeerId,\n    rpcMsg: RPC.IMessage\n  ): Promise<ReceivedMessageResult> {\n    // Fast message ID stuff\n    const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg)\n    const msgIdCached = fastMsgIdStr !== undefined ? this.fastMsgIdCache?.get(fastMsgIdStr) : undefined\n\n    if (msgIdCached) {\n      // This message has been seen previously. Ignore it\n      return { code: MessageStatus.duplicate, msgIdStr: msgIdCached }\n    }\n\n    // Perform basic validation on message and convert to RawGossipsubMessage for fastMsgIdFn()\n    const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg)\n\n    if (!validationResult.valid) {\n      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error }\n    }\n\n    const msg = validationResult.message\n\n    // Try and perform the data transform to the message. If it fails, consider it invalid.\n    try {\n      if (this.dataTransform) {\n        msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data)\n      }\n    } catch (e) {\n      this.log('Invalid message, transform failed', e)\n      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed }\n    }\n\n    // TODO: Check if message is from a blacklisted source or propagation origin\n    // - Reject any message from a blacklisted peer\n    // - Also reject any message that originated from a blacklisted peer\n    // - reject messages claiming to be from ourselves but not locally published\n\n    // Calculate the message id on the transformed data.\n    const msgId = await this.msgIdFn(msg)\n    const msgIdStr = this.msgIdToStrFn(msgId)\n    const messageId = { msgId, msgIdStr }\n\n    // Add the message to the duplicate caches\n    if (fastMsgIdStr !== undefined && this.fastMsgIdCache) {\n      const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr)\n      if (collision) {\n        this.metrics?.fastMsgIdCacheCollision.inc()\n      }\n    }\n\n    if (this.seenCache.has(msgIdStr)) {\n      return { code: MessageStatus.duplicate, msgIdStr }\n    } else {\n      this.seenCache.put(msgIdStr)\n    }\n\n    // (Optional) Provide custom validation here with dynamic validators per topic\n    // NOTE: This custom topicValidator() must resolve fast (< 100ms) to allow scores\n    // to not penalize peers for long validation times.\n    const topicValidator = this.topicValidators.get(rpcMsg.topic)\n    if (topicValidator != null) {\n      let acceptance: TopicValidatorResult\n      // Use try {} catch {} in case topicValidator() is synchronous\n      try {\n        acceptance = await topicValidator(propagationSource, msg)\n      } catch (e) {\n        const errCode = (e as { code: string }).code\n        if (errCode === constants.ERR_TOPIC_VALIDATOR_IGNORE) acceptance = TopicValidatorResult.Ignore\n        if (errCode === constants.ERR_TOPIC_VALIDATOR_REJECT) acceptance = TopicValidatorResult.Reject\n        else acceptance = TopicValidatorResult.Ignore\n      }\n\n      if (acceptance !== TopicValidatorResult.Accept) {\n        return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr }\n      }\n    }\n\n    return { code: MessageStatus.valid, messageId, msg }\n  }\n\n  /**\n   * Return score of a peer.\n   */\n  getScore(peerId: PeerIdStr): number {\n    return this.score.score(peerId)\n  }\n\n  /**\n   * Send an rpc object to a peer with subscriptions\n   */\n  private sendSubscriptions(toPeer: PeerIdStr, topics: string[], subscribe: boolean): void {\n    this.sendRpc(toPeer, {\n      subscriptions: topics.map((topic) => ({ topic, subscribe }))\n    })\n  }\n\n  /**\n   * Handles an rpc control message from a peer\n   */\n  private async handleControlMessage(id: PeerIdStr, controlMsg: RPC.IControlMessage): Promise<void> {\n    if (controlMsg === undefined) {\n      return\n    }\n\n    const iwant = controlMsg.ihave ? this.handleIHave(id, controlMsg.ihave) : []\n    const ihave = controlMsg.iwant ? this.handleIWant(id, controlMsg.iwant) : []\n    const prune = controlMsg.graft ? await this.handleGraft(id, controlMsg.graft) : []\n    controlMsg.prune && (await this.handlePrune(id, controlMsg.prune))\n\n    if (!iwant.length && !ihave.length && !prune.length) {\n      return\n    }\n\n    const sent = this.sendRpc(id, { messages: ihave, control: { iwant, prune } })\n    const iwantMessageIds = iwant[0]?.messageIDs\n    if (iwantMessageIds) {\n      if (sent) {\n        this.gossipTracer.addPromise(id, iwantMessageIds)\n      } else {\n        this.metrics?.iwantPromiseUntracked.inc(1)\n      }\n    }\n  }\n\n  /**\n   * Whether to accept a message from a peer\n   */\n  public acceptFrom(id: PeerIdStr): boolean {\n    if (this.direct.has(id)) {\n      return true\n    }\n\n    const now = Date.now()\n    const entry = this.acceptFromWhitelist.get(id)\n\n    if (entry && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {\n      entry.messagesAccepted += 1\n      return true\n    }\n\n    const score = this.score.score(id)\n    if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {\n      // peer is unlikely to be able to drop its score to `graylistThreshold`\n      // after 128 messages or 1s\n      this.acceptFromWhitelist.set(id, {\n        messagesAccepted: 0,\n        acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS\n      })\n    } else {\n      this.acceptFromWhitelist.delete(id)\n    }\n\n    return score >= this.opts.scoreThresholds.graylistThreshold\n  }\n\n  /**\n   * Handles IHAVE messages\n   */\n  private handleIHave(id: PeerIdStr, ihave: RPC.IControlIHave[]): RPC.IControlIWant[] {\n    if (!ihave.length) {\n      return []\n    }\n\n    // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n    const score = this.score.score(id)\n    if (score < this.opts.scoreThresholds.gossipThreshold) {\n      this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score)\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore })\n      return []\n    }\n\n    // IHAVE flood protection\n    const peerhave = (this.peerhave.get(id) ?? 0) + 1\n    this.peerhave.set(id, peerhave)\n    if (peerhave > constants.GossipsubMaxIHaveMessages) {\n      this.log(\n        'IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring',\n        id,\n        peerhave\n      )\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave })\n      return []\n    }\n\n    const iasked = this.iasked.get(id) ?? 0\n    if (iasked >= constants.GossipsubMaxIHaveLength) {\n      this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked)\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked })\n      return []\n    }\n\n    // string msgId => msgId\n    const iwant = new Map<MsgIdStr, Uint8Array>()\n\n    ihave.forEach(({ topicID, messageIDs }) => {\n      if (!topicID || !messageIDs || !this.mesh.has(topicID)) {\n        return\n      }\n\n      let idonthave = 0\n\n      messageIDs.forEach((msgId) => {\n        const msgIdStr = this.msgIdToStrFn(msgId)\n        if (!this.seenCache.has(msgIdStr)) {\n          iwant.set(msgIdStr, msgId)\n          idonthave++\n        }\n      })\n\n      this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave)\n    })\n\n    if (!iwant.size) {\n      return []\n    }\n\n    let iask = iwant.size\n    if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n      iask = constants.GossipsubMaxIHaveLength - iasked\n    }\n\n    this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id)\n\n    let iwantList = Array.from(iwant.values())\n    // ask in random order\n    shuffle(iwantList)\n\n    // truncate to the messages we are actually asking for and update the iasked counter\n    iwantList = iwantList.slice(0, iask)\n    this.iasked.set(id, iasked + iask)\n\n    // do not add gossipTracer promise here until a successful sendRpc()\n\n    return [\n      {\n        messageIDs: iwantList\n      }\n    ]\n  }\n\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   */\n  private handleIWant(id: PeerIdStr, iwant: RPC.IControlIWant[]): RPC.IMessage[] {\n    if (!iwant.length) {\n      return []\n    }\n\n    // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n    const score = this.score.score(id)\n    if (score < this.opts.scoreThresholds.gossipThreshold) {\n      this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score)\n      return []\n    }\n\n    const ihave = new Map<MsgIdStr, RPC.IMessage>()\n    const iwantByTopic = new Map<TopicStr, number>()\n    let iwantDonthave = 0\n\n    iwant.forEach(({ messageIDs }) => {\n      messageIDs &&\n        messageIDs.forEach((msgId) => {\n          const msgIdStr = this.msgIdToStrFn(msgId)\n          const entry = this.mcache.getWithIWantCount(msgIdStr, id)\n          if (entry == null) {\n            iwantDonthave++\n            return\n          }\n\n          iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0))\n\n          if (entry.count > constants.GossipsubGossipRetransmission) {\n            this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgId)\n            return\n          }\n\n          ihave.set(msgIdStr, entry.msg)\n        })\n    })\n\n    this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave)\n\n    if (!ihave.size) {\n      this.log('IWANT: Could not provide any wanted messages to %s', id)\n      return []\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, id)\n\n    return Array.from(ihave.values())\n  }\n\n  /**\n   * Handles Graft messages\n   */\n  private async handleGraft(id: PeerIdStr, graft: RPC.IControlGraft[]): Promise<RPC.IControlPrune[]> {\n    const prune: TopicStr[] = []\n    const score = this.score.score(id)\n    const now = Date.now()\n    let doPX = this.opts.doPX\n\n    graft.forEach(({ topicID }) => {\n      if (!topicID) {\n        return\n      }\n      const peersInMesh = this.mesh.get(topicID)\n      if (!peersInMesh) {\n        // don't do PX when there is an unknown topic to avoid leaking our peers\n        doPX = false\n        // spam hardening: ignore GRAFTs for unknown topics\n        return\n      }\n\n      // check if peer is already in the mesh; if so do nothing\n      if (peersInMesh.has(id)) {\n        return\n      }\n\n      // we don't GRAFT to/from direct peers; complain loudly if this happens\n      if (this.direct.has(id)) {\n        this.log('GRAFT: ignoring request from direct peer %s', id)\n        // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n        prune.push(topicID)\n        // but don't px\n        doPX = false\n        return\n      }\n\n      // make sure we are not backing off that peer\n      const expire = this.backoff.get(topicID)?.get(id)\n      if (typeof expire === 'number' && now < expire) {\n        this.log('GRAFT: ignoring backed off peer %s', id)\n        // add behavioral penalty\n        this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff)\n        // no PX\n        doPX = false\n        // check the flood cutoff -- is the GRAFT coming too fast?\n        const floodCutoff = expire + this.opts.graftFloodThreshold - this.opts.pruneBackoff\n        if (now < floodCutoff) {\n          // extra penalty\n          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff)\n        }\n        // refresh the backoff\n        this.addBackoff(id, topicID)\n        prune.push(topicID)\n        return\n      }\n\n      // check the score\n      if (score < 0) {\n        // we don't GRAFT peers with negative score\n        this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID)\n        // we do send them PRUNE however, because it's a matter of protocol correctness\n        prune.push(topicID)\n        // but we won't PX to them\n        doPX = false\n        // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n        this.addBackoff(id, topicID)\n        return\n      }\n\n      // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n      // from peers with outbound connections; this is a defensive check to restrict potential\n      // mesh takeover attacks combined with love bombing\n      if (peersInMesh.size >= this.opts.Dhi && !this.outbound.get(id)) {\n        prune.push(topicID)\n        this.addBackoff(id, topicID)\n        return\n      }\n\n      this.log('GRAFT: Add mesh link from %s in %s', id, topicID)\n      this.score.graft(id, topicID)\n      peersInMesh.add(id)\n\n      this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1)\n    })\n\n    if (!prune.length) {\n      return []\n    }\n\n    return await Promise.all(prune.map((topic) => this.makePrune(id, topic, doPX)))\n  }\n\n  /**\n   * Handles Prune messages\n   */\n  private async handlePrune(id: PeerIdStr, prune: RPC.IControlPrune[]): Promise<void> {\n    const score = this.score.score(id)\n\n    for (const { topicID, backoff, peers } of prune) {\n      if (topicID == null) {\n        continue\n      }\n\n      const peersInMesh = this.mesh.get(topicID)\n      if (!peersInMesh) {\n        return\n      }\n\n      this.log('PRUNE: Remove mesh link to %s in %s', id, topicID)\n      this.score.prune(id, topicID)\n      if (peersInMesh.has(id)) {\n        peersInMesh.delete(id)\n        this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Unsub, 1)\n      }\n\n      // is there a backoff specified by the peer? if so obey it\n      if (typeof backoff === 'number' && backoff > 0) {\n        this.doAddBackoff(id, topicID, backoff * 1000)\n      } else {\n        this.addBackoff(id, topicID)\n      }\n\n      // PX\n      if (peers && peers.length) {\n        // we ignore PX from peers with insufficient scores\n        if (score < this.opts.scoreThresholds.acceptPXThreshold) {\n          this.log(\n            'PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]',\n            id,\n            score,\n            topicID\n          )\n          continue\n        }\n        await this.pxConnect(peers)\n      }\n    }\n  }\n\n  /**\n   * Add standard backoff log for a peer in a topic\n   */\n  private addBackoff(id: PeerIdStr, topic: TopicStr): void {\n    this.doAddBackoff(id, topic, this.opts.pruneBackoff)\n  }\n\n  /**\n   * Add backoff expiry interval for a peer in a topic\n   *\n   * @param id\n   * @param topic\n   * @param interval - backoff duration in milliseconds\n   */\n  private doAddBackoff(id: PeerIdStr, topic: TopicStr, interval: number): void {\n    let backoff = this.backoff.get(topic)\n    if (!backoff) {\n      backoff = new Map()\n      this.backoff.set(topic, backoff)\n    }\n    const expire = Date.now() + interval\n    const existingExpire = backoff.get(id) ?? 0\n    if (existingExpire < expire) {\n      backoff.set(id, expire)\n    }\n  }\n\n  /**\n   * Apply penalties from broken IHAVE/IWANT promises\n   */\n  private applyIwantPenalties(): void {\n    this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n      this.log(\"peer %s didn't follow up in %d IWANT requests; adding penalty\", p, count)\n      this.score.addPenalty(p, count, ScorePenalty.BrokenPromise)\n    })\n  }\n\n  /**\n   * Clear expired backoff expiries\n   */\n  private clearBackoff(): void {\n    // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n    if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n      return\n    }\n\n    const now = Date.now()\n    this.backoff.forEach((backoff, topic) => {\n      backoff.forEach((expire, id) => {\n        if (expire < now) {\n          backoff.delete(id)\n        }\n      })\n      if (backoff.size === 0) {\n        this.backoff.delete(topic)\n      }\n    })\n  }\n\n  /**\n   * Maybe reconnect to direct peers\n   */\n  private async directConnect(): Promise<void> {\n    const toconnect: string[] = []\n    this.direct.forEach((id) => {\n      if (!this.streamsOutbound.has(id)) {\n        toconnect.push(id)\n      }\n    })\n\n    await Promise.all(toconnect.map(async (id) => await this.connect(id)))\n  }\n\n  /**\n   * Maybe attempt connection given signed peer records\n   */\n  private async pxConnect(peers: RPC.IPeerInfo[]): Promise<void> {\n    if (peers.length > this.opts.prunePeers) {\n      shuffle(peers)\n      peers = peers.slice(0, this.opts.prunePeers)\n    }\n    const toconnect: string[] = []\n\n    await Promise.all(\n      peers.map(async (pi) => {\n        if (!pi.peerID) {\n          return\n        }\n\n        const p = peerIdFromBytes(pi.peerID).toString()\n\n        if (this.peers.has(p)) {\n          return\n        }\n\n        if (!pi.signedPeerRecord) {\n          toconnect.push(p)\n          return\n        }\n\n        // The peer sent us a signed record\n        // This is not a record from the peer who sent the record, but another peer who is connected with it\n        // Ensure that it is valid\n        try {\n          const envelope = await RecordEnvelope.openAndCertify(pi.signedPeerRecord, 'libp2p-peer-record')\n          const eid = envelope.peerId\n          if (!envelope.peerId.equals(p)) {\n            this.log(\"bogus peer record obtained through px: peer ID %p doesn't match expected peer %p\", eid, p)\n            return\n          }\n          if (!(await this.components.peerStore.addressBook.consumePeerRecord(envelope))) {\n            this.log('bogus peer record obtained through px: could not add peer record to address book')\n            return\n          }\n          toconnect.push(p)\n        } catch (e) {\n          this.log('bogus peer record obtained through px: invalid signature or not a peer record')\n        }\n      })\n    )\n\n    if (!toconnect.length) {\n      return\n    }\n\n    await Promise.all(toconnect.map(async (id) => await this.connect(id)))\n  }\n\n  /**\n   * Connect to a peer using the gossipsub protocol\n   */\n  private async connect(id: PeerIdStr): Promise<void> {\n    this.log('Initiating connection with %s', id)\n    const peerId = peerIdFromString(id)\n    const connection = await this.components.connectionManager.openConnection(peerId)\n    for (const multicodec of this.multicodecs) {\n      for (const topology of this.components.registrar.getTopologies(multicodec)) {\n        topology.onConnect(peerId, connection)\n      }\n    }\n  }\n\n  /**\n   * Subscribes to a topic\n   */\n  subscribe(topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Pubsub has not started')\n    }\n\n    if (!this.subscriptions.has(topic)) {\n      this.subscriptions.add(topic)\n\n      for (const peerId of this.peers.keys()) {\n        this.sendSubscriptions(peerId, [topic], true)\n      }\n    }\n\n    this.join(topic)\n  }\n\n  /**\n   * Unsubscribe to a topic\n   */\n  unsubscribe(topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    const wasSubscribed = this.subscriptions.delete(topic)\n\n    this.log('unsubscribe from %s - am subscribed %s', topic, wasSubscribed)\n\n    if (wasSubscribed) {\n      for (const peerId of this.peers.keys()) {\n        this.sendSubscriptions(peerId, [topic], false)\n      }\n    }\n\n    this.leave(topic)\n  }\n\n  /**\n   * Join topic\n   */\n  private join(topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Gossipsub has not started')\n    }\n\n    // if we are already in the mesh, return\n    if (this.mesh.has(topic)) {\n      return\n    }\n\n    this.log('JOIN %s', topic)\n    this.metrics?.onJoin(topic)\n\n    const toAdd = new Set<PeerIdStr>()\n\n    // check if we have mesh_n peers in fanout[topic] and add them to the mesh if we do,\n    // removing the fanout entry.\n    const fanoutPeers = this.fanout.get(topic)\n    if (fanoutPeers) {\n      // Remove fanout entry and the last published time\n      this.fanout.delete(topic)\n      this.fanoutLastpub.delete(topic)\n\n      // remove explicit peers, peers with negative scores, and backoffed peers\n      fanoutPeers.forEach((id) => {\n        // TODO:rust-libp2p checks `self.backoffs.is_backoff_with_slack()`\n        if (!this.direct.has(id) && this.score.score(id) >= 0) {\n          toAdd.add(id)\n        }\n      })\n\n      this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size)\n    }\n\n    // check if we need to get more peers, which we randomly select\n    if (toAdd.size < this.opts.D) {\n      const fanoutCount = toAdd.size\n      const newPeers = this.getRandomGossipPeers(\n        topic,\n        this.opts.D,\n        (id: PeerIdStr): boolean =>\n          // filter direct peers and peers with negative score\n          !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0\n      )\n\n      newPeers.forEach((peer) => {\n        toAdd.add(peer)\n      })\n\n      this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount)\n    }\n\n    this.mesh.set(topic, toAdd)\n\n    toAdd.forEach((id) => {\n      this.log('JOIN: Add mesh link to %s in %s', id, topic)\n      this.sendGraft(id, topic)\n\n      // rust-libp2p\n      // - peer_score.graft()\n      // - Self::control_pool_add()\n      // - peer_added_to_mesh()\n    })\n  }\n\n  /**\n   * Leave topic\n   */\n  private leave(topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Gossipsub has not started')\n    }\n\n    this.log('LEAVE %s', topic)\n    this.metrics?.onLeave(topic)\n\n    // Send PRUNE to mesh peers\n    const meshPeers = this.mesh.get(topic)\n    if (meshPeers) {\n      Promise.all(\n        Array.from(meshPeers).map(async (id) => {\n          this.log('LEAVE: Remove mesh link to %s in %s', id, topic)\n          return await this.sendPrune(id, topic)\n        })\n      ).catch((err) => {\n        this.log('Error sending prunes to mesh peers', err)\n      })\n      this.mesh.delete(topic)\n    }\n  }\n\n  private selectPeersToForward(topic: TopicStr, propagationSource?: PeerIdStr, excludePeers?: Set<PeerIdStr>) {\n    const tosend = new Set<PeerIdStr>()\n\n    // Add explicit peers\n    const peersInTopic = this.topics.get(topic)\n    if (peersInTopic) {\n      this.direct.forEach((peer) => {\n        if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer)) {\n          tosend.add(peer)\n        }\n      })\n\n      // As of Mar 2022, spec + golang-libp2p include this while rust-libp2p does not\n      // rust-libp2p: https://github.com/libp2p/rust-libp2p/blob/6cc3b4ec52c922bfcf562a29b5805c3150e37c75/protocols/gossipsub/src/behaviour.rs#L2693\n      // spec: https://github.com/libp2p/specs/blob/10712c55ab309086a52eec7d25f294df4fa96528/pubsub/gossipsub/gossipsub-v1.0.md?plain=1#L361\n      this.floodsubPeers.forEach((peer) => {\n        if (\n          peersInTopic.has(peer) &&\n          propagationSource !== peer &&\n          !excludePeers?.has(peer) &&\n          this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold\n        ) {\n          tosend.add(peer)\n        }\n      })\n    }\n\n    // add mesh peers\n    const meshPeers = this.mesh.get(topic)\n    if (meshPeers && meshPeers.size > 0) {\n      meshPeers.forEach((peer) => {\n        if (propagationSource !== peer && !excludePeers?.has(peer)) {\n          tosend.add(peer)\n        }\n      })\n    }\n\n    return tosend\n  }\n\n  private selectPeersToPublish(topic: TopicStr): {\n    tosend: Set<PeerIdStr>\n    tosendCount: ToSendGroupCount\n  } {\n    const tosend = new Set<PeerIdStr>()\n    const tosendCount: ToSendGroupCount = {\n      direct: 0,\n      floodsub: 0,\n      mesh: 0,\n      fanout: 0\n    }\n\n    const peersInTopic = this.topics.get(topic)\n    if (peersInTopic) {\n      // flood-publish behavior\n      // send to direct peers and _all_ peers meeting the publishThreshold\n      if (this.opts.floodPublish) {\n        peersInTopic.forEach((id) => {\n          if (this.direct.has(id)) {\n            tosend.add(id)\n            tosendCount.direct++\n          } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n            tosend.add(id)\n            tosendCount.floodsub++\n          }\n        })\n      } else {\n        // non-flood-publish behavior\n        // send to direct peers, subscribed floodsub peers\n        // and some mesh peers above publishThreshold\n\n        // direct peers (if subscribed)\n        this.direct.forEach((id) => {\n          if (peersInTopic.has(id)) {\n            tosend.add(id)\n            tosendCount.direct++\n          }\n        })\n\n        // floodsub peers\n        // Note: if there are no floodsub peers, we save a loop through peersInTopic Map\n        this.floodsubPeers.forEach((id) => {\n          if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n            tosend.add(id)\n            tosendCount.floodsub++\n          }\n        })\n\n        // Gossipsub peers handling\n        const meshPeers = this.mesh.get(topic)\n        if (meshPeers && meshPeers.size > 0) {\n          meshPeers.forEach((peer) => {\n            tosend.add(peer)\n            tosendCount.mesh++\n          })\n        }\n\n        // We are not in the mesh for topic, use fanout peers\n        else {\n          const fanoutPeers = this.fanout.get(topic)\n          if (fanoutPeers && fanoutPeers.size > 0) {\n            fanoutPeers.forEach((peer) => {\n              tosend.add(peer)\n              tosendCount.fanout++\n            })\n          }\n\n          // We have no fanout peers, select mesh_n of them and add them to the fanout\n          else {\n            // If we are not in the fanout, then pick peers in topic above the publishThreshold\n            const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {\n              return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold\n            })\n\n            if (newFanoutPeers.size > 0) {\n              // eslint-disable-line max-depth\n              this.fanout.set(topic, newFanoutPeers)\n\n              newFanoutPeers.forEach((peer) => {\n                // eslint-disable-line max-depth\n                tosend.add(peer)\n                tosendCount.fanout++\n              })\n            }\n          }\n\n          // We are publishing to fanout peers - update the time we published\n          this.fanoutLastpub.set(topic, Date.now())\n        }\n      }\n    }\n\n    return { tosend, tosendCount }\n  }\n\n  /**\n   * Forwards a message from our peers.\n   *\n   * For messages published by us (the app layer), this class uses `publish`\n   */\n  private forwardMessage(\n    msgIdStr: string,\n    rawMsg: RPC.IMessage,\n    propagationSource?: PeerIdStr,\n    excludePeers?: Set<PeerIdStr>\n  ): void {\n    // message is fully validated inform peer_score\n    if (propagationSource) {\n      this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic)\n    }\n\n    const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers)\n\n    // Note: Don't throw if tosend is empty, we can have a mesh with a single peer\n\n    // forward the message to peers\n    tosend.forEach((id) => {\n      // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n      this.sendRpc(id, { messages: [rawMsg] })\n    })\n\n    this.metrics?.onForwardMsg(rawMsg.topic, tosend.size)\n  }\n\n  /**\n   * App layer publishes a message to peers, return number of peers this message is published to\n   * Note: `async` due to crypto only if `StrictSign`, otherwise it's a sync fn.\n   *\n   * For messages not from us, this class uses `forwardMessage`.\n   */\n  async publish(topic: TopicStr, data: Uint8Array, opts?: PublishOpts): Promise<PublishResult> {\n    const transformedData = this.dataTransform ? this.dataTransform.outboundTransform(topic, data) : data\n\n    if (this.publishConfig == null) {\n      throw Error('PublishError.Uninitialized')\n    }\n\n    // Prepare raw message with user's publishConfig\n    const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData)\n\n    // calculate the message id from the un-transformed data\n    const msgId = await this.msgIdFn(msg)\n    const msgIdStr = this.msgIdToStrFn(msgId)\n\n    // Current publish opt takes precedence global opts, while preserving false value\n    const ignoreDuplicatePublishError = opts?.ignoreDuplicatePublishError ?? this.opts.ignoreDuplicatePublishError\n\n    if (this.seenCache.has(msgIdStr)) {\n      // This message has already been seen. We don't re-publish messages that have already\n      // been published on the network.\n      if (ignoreDuplicatePublishError) {\n        this.metrics?.onPublishDuplicateMsg(topic)\n        return { recipients: [] }\n      }\n      throw Error('PublishError.Duplicate')\n    }\n\n    const { tosend, tosendCount } = this.selectPeersToPublish(topic)\n    const willSendToSelf = this.opts.emitSelf === true && this.subscriptions.has(topic)\n\n    // Current publish opt takes precedence global opts, while preserving false value\n    const allowPublishToZeroPeers = opts?.allowPublishToZeroPeers ?? this.opts.allowPublishToZeroPeers\n\n    if (tosend.size === 0 && !allowPublishToZeroPeers && !willSendToSelf) {\n      throw Error('PublishError.InsufficientPeers')\n    }\n\n    // If the message isn't a duplicate and we have sent it to some peers add it to the\n    // duplicate cache and memcache.\n    this.seenCache.put(msgIdStr)\n    // all published messages are valid\n    this.mcache.put({ msgId, msgIdStr }, rawMsg, true)\n\n    // If the message is anonymous or has a random author add it to the published message ids cache.\n    this.publishedMessageIds.put(msgIdStr)\n\n    // Send to set of peers aggregated from direct, mesh, fanout\n    for (const id of tosend) {\n      // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n      const sent = this.sendRpc(id, { messages: [rawMsg] })\n\n      // did not actually send the message\n      if (!sent) {\n        tosend.delete(id)\n      }\n    }\n\n    this.metrics?.onPublishMsg(topic, tosendCount, tosend.size, rawMsg.data != null ? rawMsg.data.length : 0)\n\n    // Dispatch the message to the user if we are subscribed to the topic\n    if (willSendToSelf) {\n      tosend.add(this.components.peerId.toString())\n\n      super.dispatchEvent(\n        new CustomEvent<GossipsubMessage>('gossipsub:message', {\n          detail: {\n            propagationSource: this.components.peerId,\n            msgId: msgIdStr,\n            msg\n          }\n        })\n      )\n      // TODO: Add option to switch between emit per topic or all messages in one\n      super.dispatchEvent(new CustomEvent<Message>('message', { detail: msg }))\n    }\n\n    return {\n      recipients: Array.from(tosend.values()).map((str) => peerIdFromString(str))\n    }\n  }\n\n  /**\n   * This function should be called when `asyncValidation` is `true` after\n   * the message got validated by the caller. Messages are stored in the `mcache` and\n   * validation is expected to be fast enough that the messages should still exist in the cache.\n   * There are three possible validation outcomes and the outcome is given in acceptance.\n   *\n   * If acceptance = `MessageAcceptance.Accept` the message will get propagated to the\n   * network. The `propagation_source` parameter indicates who the message was received by and\n   * will not be forwarded back to that peer.\n   *\n   * If acceptance = `MessageAcceptance.Reject` the message will be deleted from the memcache\n   * and the P₄ penalty will be applied to the `propagationSource`.\n   *\n   * If acceptance = `MessageAcceptance.Ignore` the message will be deleted from the memcache\n   * but no P₄ penalty will be applied.\n   *\n   * This function will return true if the message was found in the cache and false if was not\n   * in the cache anymore.\n   *\n   * This should only be called once per message.\n   */\n  reportMessageValidationResult(msgId: MsgIdStr, propagationSource: PeerId, acceptance: TopicValidatorResult): void {\n    if (acceptance === TopicValidatorResult.Accept) {\n      const cacheEntry = this.mcache.validate(msgId)\n      this.metrics?.onReportValidationMcacheHit(cacheEntry !== null)\n\n      if (cacheEntry != null) {\n        const { message: rawMsg, originatingPeers } = cacheEntry\n        // message is fully validated inform peer_score\n        this.score.deliverMessage(propagationSource.toString(), msgId, rawMsg.topic)\n\n        this.forwardMessage(msgId, cacheEntry.message, propagationSource.toString(), originatingPeers)\n        this.metrics?.onReportValidation(rawMsg.topic, acceptance)\n      }\n      // else, Message not in cache. Ignoring forwarding\n    }\n\n    // Not valid\n    else {\n      const cacheEntry = this.mcache.remove(msgId)\n      this.metrics?.onReportValidationMcacheHit(cacheEntry !== null)\n\n      if (cacheEntry) {\n        const rejectReason = rejectReasonFromAcceptance(acceptance)\n        const { message: rawMsg, originatingPeers } = cacheEntry\n\n        // Tell peer_score about reject\n        // Reject the original source, and any duplicates we've seen from other peers.\n        this.score.rejectMessage(propagationSource.toString(), msgId, rawMsg.topic, rejectReason)\n        for (const peer of originatingPeers) {\n          this.score.rejectMessage(peer, msgId, rawMsg.topic, rejectReason)\n        }\n\n        this.metrics?.onReportValidation(rawMsg.topic, acceptance)\n      }\n      // else, Message not in cache. Ignoring forwarding\n    }\n  }\n\n  /**\n   * Sends a GRAFT message to a peer\n   */\n  private sendGraft(id: PeerIdStr, topic: string): void {\n    const graft = [\n      {\n        topicID: topic\n      }\n    ]\n\n    this.sendRpc(id, { control: { graft } })\n  }\n\n  /**\n   * Sends a PRUNE message to a peer\n   */\n  private async sendPrune(id: PeerIdStr, topic: string): Promise<void> {\n    const prune = [await this.makePrune(id, topic, this.opts.doPX)]\n\n    this.sendRpc(id, { control: { prune } })\n  }\n\n  /**\n   * Send an rpc object to a peer\n   */\n  private sendRpc(id: PeerIdStr, rpc: IRPC): boolean {\n    const outboundStream = this.streamsOutbound.get(id)\n    if (!outboundStream) {\n      this.log(`Cannot send RPC to ${id} as there is no open stream to it available`)\n      return false\n    }\n\n    // piggyback control message retries\n    const ctrl = this.control.get(id)\n    if (ctrl) {\n      this.piggybackControl(id, rpc, ctrl)\n      this.control.delete(id)\n    }\n\n    // piggyback gossip\n    const ihave = this.gossip.get(id)\n    if (ihave) {\n      this.piggybackGossip(id, rpc, ihave)\n      this.gossip.delete(id)\n    }\n\n    const rpcBytes = RPC.encode(rpc).finish()\n    try {\n      outboundStream.push(rpcBytes)\n    } catch (e) {\n      this.log.error(`Cannot send rpc to ${id}`, e)\n\n      // if the peer had control messages or gossip, re-attach\n      if (ctrl) {\n        this.control.set(id, ctrl)\n      }\n      if (ihave) {\n        this.gossip.set(id, ihave)\n      }\n\n      return false\n    }\n\n    this.metrics?.onRpcSent(rpc, rpcBytes.length)\n\n    return true\n  }\n\n  /** Mutates `outRpc` adding graft and prune control messages */\n  public piggybackControl(id: PeerIdStr, outRpc: IRPC, ctrl: RPC.IControlMessage): void {\n    if (ctrl.graft) {\n      if (!outRpc.control) outRpc.control = {}\n      if (!outRpc.control.graft) outRpc.control.graft = []\n      for (const graft of ctrl.graft) {\n        if (graft.topicID && this.mesh.get(graft.topicID)?.has(id)) {\n          outRpc.control.graft.push(graft)\n        }\n      }\n    }\n\n    if (ctrl.prune) {\n      if (!outRpc.control) outRpc.control = {}\n      if (!outRpc.control.prune) outRpc.control.prune = []\n      for (const prune of ctrl.prune) {\n        if (prune.topicID && !this.mesh.get(prune.topicID)?.has(id)) {\n          outRpc.control.prune.push(prune)\n        }\n      }\n    }\n  }\n\n  /** Mutates `outRpc` adding ihave control messages */\n  private piggybackGossip(id: PeerIdStr, outRpc: IRPC, ihave: RPC.IControlIHave[]): void {\n    if (!outRpc.control) outRpc.control = {}\n    outRpc.control.ihave = ihave\n  }\n\n  /**\n   * Send graft and prune messages\n   *\n   * @param tograft - peer id => topic[]\n   * @param toprune - peer id => topic[]\n   */\n  private async sendGraftPrune(\n    tograft: Map<string, string[]>,\n    toprune: Map<string, string[]>,\n    noPX: Map<string, boolean>\n  ): Promise<void> {\n    const doPX = this.opts.doPX\n    for (const [id, topics] of tograft) {\n      const graft = topics.map((topicID) => ({ topicID }))\n      let prune: RPC.IControlPrune[] = []\n      // If a peer also has prunes, process them now\n      const pruning = toprune.get(id)\n      if (pruning) {\n        prune = await Promise.all(\n          pruning.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false)))\n        )\n        toprune.delete(id)\n      }\n\n      this.sendRpc(id, { control: { graft, prune } })\n    }\n    for (const [id, topics] of toprune) {\n      const prune = await Promise.all(\n        topics.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false)))\n      )\n      this.sendRpc(id, { control: { prune } })\n    }\n  }\n\n  /**\n   * Emits gossip - Send IHAVE messages to a random set of gossip peers\n   */\n  private emitGossip(peersToGossipByTopic: Map<string, Set<PeerIdStr>>): void {\n    const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()))\n    for (const [topic, peersToGossip] of peersToGossipByTopic) {\n      this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? [])\n    }\n  }\n\n  /**\n   * Send gossip messages to GossipFactor peers above threshold with a minimum of D_lazy\n   * Peers are randomly selected from the heartbeat which exclude mesh + fanout peers\n   * We also exclude direct peers, as there is no reason to emit gossip to them\n   * @param topic\n   * @param candidateToGossip - peers to gossip\n   * @param messageIDs - message ids to gossip\n   */\n  private doEmitGossip(topic: string, candidateToGossip: Set<PeerIdStr>, messageIDs: Uint8Array[]): void {\n    if (!messageIDs.length) {\n      return\n    }\n\n    // shuffle to emit in random order\n    shuffle(messageIDs)\n\n    // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n    if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n      // we do the truncation (with shuffling) per peer below\n      this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length)\n    }\n\n    if (!candidateToGossip.size) return\n    let target = this.opts.Dlazy\n    const factor = constants.GossipsubGossipFactor * candidateToGossip.size\n    let peersToGossip: Set<PeerIdStr> | PeerIdStr[] = candidateToGossip\n    if (factor > target) {\n      target = factor\n    }\n    if (target > peersToGossip.size) {\n      target = peersToGossip.size\n    } else {\n      // only shuffle if needed\n      peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target)\n    }\n\n    // Emit the IHAVE gossip to the selected peers up to the target\n    peersToGossip.forEach((id) => {\n      let peerMessageIDs = messageIDs\n      if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n        // shuffle and slice message IDs per peer so that we emit a different set for each peer\n        // we have enough reduncancy in the system that this will significantly increase the message\n        // coverage when we do truncate\n        peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength)\n      }\n      this.pushGossip(id, {\n        topicID: topic,\n        messageIDs: peerMessageIDs\n      })\n    })\n  }\n\n  /**\n   * Flush gossip and control messages\n   */\n  private flush(): void {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer)\n      this.sendRpc(peer, { control: { ihave } })\n    }\n    // send the remaining control messages\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer)\n      this.sendRpc(peer, { control: { graft: control.graft, prune: control.prune } })\n    }\n  }\n\n  /**\n   * Adds new IHAVE messages to pending gossip\n   */\n  private pushGossip(id: PeerIdStr, controlIHaveMsgs: RPC.IControlIHave): void {\n    this.log('Add gossip to %s', id)\n    const gossip = this.gossip.get(id) || []\n    this.gossip.set(id, gossip.concat(controlIHaveMsgs))\n  }\n\n  /**\n   * Make a PRUNE control message for a peer in a topic\n   */\n  private async makePrune(id: PeerIdStr, topic: string, doPX: boolean): Promise<RPC.IControlPrune> {\n    this.score.prune(id, topic)\n    if (this.streamsOutbound.get(id)!.protocol === constants.GossipsubIDv10) {\n      // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n      return {\n        topicID: topic,\n        peers: []\n      }\n    }\n    // backoff is measured in seconds\n    // GossipsubPruneBackoff is measured in milliseconds\n    // The protobuf has it as a uint64\n    const backoff = this.opts.pruneBackoff / 1000\n    if (!doPX) {\n      return {\n        topicID: topic,\n        peers: [],\n        backoff: backoff\n      }\n    }\n    // select peers for Peer eXchange\n    const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {\n      return xid !== id && this.score.score(xid) >= 0\n    })\n    const px = await Promise.all(\n      Array.from(peers).map(async (peerId) => {\n        // see if we have a signed record to send back; if we don't, just send\n        // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n        // unsigned address records through PX anyways\n        // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n        const id = peerIdFromString(peerId)\n\n        return {\n          peerID: id.toBytes(),\n          signedPeerRecord: await this.components.peerStore.addressBook.getRawEnvelope(id)\n        }\n      })\n    )\n    return {\n      topicID: topic,\n      peers: px,\n      backoff: backoff\n    }\n  }\n\n  private readonly runHeartbeat = () => {\n    const timer = this.metrics?.heartbeatDuration.startTimer()\n\n    this.heartbeat()\n      .catch((err) => {\n        this.log('Error running heartbeat', err)\n      })\n      .finally(() => {\n        if (timer != null) {\n          timer()\n        }\n\n        // Schedule the next run if still in started status\n        if (this.status.code === GossipStatusCode.started) {\n          // Clear previous timeout before overwriting `status.heartbeatTimeout`, it should be completed tho.\n          clearTimeout(this.status.heartbeatTimeout)\n\n          // NodeJS setInterval function is innexact, calls drift by a few miliseconds on each call.\n          // To run the heartbeat precisely setTimeout() must be used recomputing the delay on every loop.\n          let msToNextHeartbeat =\n            this.opts.heartbeatInterval - ((Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval)\n\n          // If too close to next heartbeat, skip one\n          if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {\n            msToNextHeartbeat += this.opts.heartbeatInterval\n            this.metrics?.heartbeatSkipped.inc()\n          }\n\n          this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat)\n        }\n      })\n  }\n\n  /**\n   * Maintains the mesh and fanout maps in gossipsub.\n   */\n  public async heartbeat(): Promise<void> {\n    const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts\n\n    this.heartbeatTicks++\n\n    // cache scores throught the heartbeat\n    const scores = new Map<string, number>()\n    const getScore = (id: string): number => {\n      let s = scores.get(id)\n      if (s === undefined) {\n        s = this.score.score(id)\n        scores.set(id, s)\n      }\n      return s\n    }\n\n    // peer id => topic[]\n    const tograft = new Map<string, string[]>()\n    // peer id => topic[]\n    const toprune = new Map<string, string[]>()\n    // peer id => don't px\n    const noPX = new Map<string, boolean>()\n\n    // clean up expired backoffs\n    this.clearBackoff()\n\n    // clean up peerhave/iasked counters\n    this.peerhave.clear()\n    this.metrics?.cacheSize.set({ cache: 'iasked' }, this.iasked.size)\n    this.iasked.clear()\n\n    // apply IWANT request penalties\n    this.applyIwantPenalties()\n\n    // ensure direct peers are connected\n    if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {\n      // we only do this every few ticks to allow pending connections to complete and account for restarts/downtime\n      await this.directConnect()\n    }\n\n    // EXTRA: Prune caches\n    this.fastMsgIdCache?.prune()\n    this.seenCache.prune()\n    this.gossipTracer.prune()\n    this.publishedMessageIds.prune()\n\n    /**\n     * Instead of calling getRandomGossipPeers multiple times to:\n     *   + get more mesh peers\n     *   + more outbound peers\n     *   + oppportunistic grafting\n     *   + emitGossip\n     *\n     * We want to loop through the topic peers only a single time and prepare gossip peers for all topics to improve the performance\n     */\n\n    const peersToGossipByTopic = new Map<string, Set<PeerIdStr>>()\n    // maintain the mesh for topics we have joined\n    this.mesh.forEach((peers, topic) => {\n      const peersInTopic = this.topics.get(topic)\n      const candidateMeshPeers = new Set<PeerIdStr>()\n      const peersToGossip = new Set<PeerIdStr>()\n      peersToGossipByTopic.set(topic, peersToGossip)\n\n      if (peersInTopic) {\n        const shuffledPeers = shuffle(Array.from(peersInTopic))\n        const backoff = this.backoff.get(topic)\n        for (const id of shuffledPeers) {\n          const peerStreams = this.streamsOutbound.get(id)\n          if (\n            peerStreams &&\n            this.multicodecs.includes(peerStreams.protocol) &&\n            !peers.has(id) &&\n            !this.direct.has(id)\n          ) {\n            const score = getScore(id)\n            if ((!backoff || !backoff.has(id)) && score >= 0) candidateMeshPeers.add(id)\n            // instead of having to find gossip peers after heartbeat which require another loop\n            // we prepare peers to gossip in a topic within heartbeat to improve performance\n            if (score >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id)\n          }\n        }\n      }\n\n      // prune/graft helper functions (defined per topic)\n      const prunePeer = (id: PeerIdStr, reason: ChurnReason): void => {\n        this.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic)\n        // no need to update peer score here as we do it in makePrune\n        // add prune backoff record\n        this.addBackoff(id, topic)\n        // remove peer from mesh\n        peers.delete(id)\n        // after pruning a peer from mesh, we want to gossip topic to it if its score meet the gossip threshold\n        if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id)\n        this.metrics?.onRemoveFromMesh(topic, reason, 1)\n        // add to toprune\n        const topics = toprune.get(id)\n        if (!topics) {\n          toprune.set(id, [topic])\n        } else {\n          topics.push(topic)\n        }\n      }\n\n      const graftPeer = (id: PeerIdStr, reason: InclusionReason): void => {\n        this.log('HEARTBEAT: Add mesh link to %s in %s', id, topic)\n        // update peer score\n        this.score.graft(id, topic)\n        // add peer to mesh\n        peers.add(id)\n        // when we add a new mesh peer, we don't want to gossip messages to it\n        peersToGossip.delete(id)\n        this.metrics?.onAddToMesh(topic, reason, 1)\n        // add to tograft\n        const topics = tograft.get(id)\n        if (!topics) {\n          tograft.set(id, [topic])\n        } else {\n          topics.push(topic)\n        }\n      }\n\n      // drop all peers with negative score, without PX\n      peers.forEach((id) => {\n        const score = getScore(id)\n\n        // Record the score\n\n        if (score < 0) {\n          this.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic)\n          prunePeer(id, ChurnReason.BadScore)\n          noPX.set(id, true)\n        }\n      })\n\n      // do we have enough peers?\n      if (peers.size < Dlo) {\n        const ineed = D - peers.size\n        // slice up to first `ineed` items and remove them from candidateMeshPeers\n        // same to `const newMeshPeers = candidateMeshPeers.slice(0, ineed)`\n        const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed)\n\n        newMeshPeers.forEach((p) => {\n          graftPeer(p, InclusionReason.NotEnough)\n        })\n      }\n\n      // do we have to many peers?\n      if (peers.size > Dhi) {\n        let peersArray = Array.from(peers)\n        // sort by score\n        peersArray.sort((a, b) => getScore(b) - getScore(a))\n        // We keep the first D_score peers by score and the remaining up to D randomly\n        // under the constraint that we keep D_out peers in the mesh (if we have that many)\n        peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)))\n\n        // count the outbound peers we are keeping\n        let outbound = 0\n        peersArray.slice(0, D).forEach((p) => {\n          if (this.outbound.get(p)) {\n            outbound++\n          }\n        })\n\n        // if it's less than D_out, bubble up some outbound peers from the random selection\n        if (outbound < Dout) {\n          const rotate = (i: number): void => {\n            // rotate the peersArray to the right and put the ith peer in the front\n            const p = peersArray[i]\n            for (let j = i; j > 0; j--) {\n              peersArray[j] = peersArray[j - 1]\n            }\n            peersArray[0] = p\n          }\n\n          // first bubble up all outbound peers already in the selection to the front\n          if (outbound > 0) {\n            let ihave = outbound\n            for (let i = 1; i < D && ihave > 0; i++) {\n              if (this.outbound.get(peersArray[i])) {\n                rotate(i)\n                ihave--\n              }\n            }\n          }\n\n          // now bubble up enough outbound peers outside the selection to the front\n          let ineed = D - outbound\n          for (let i = D; i < peersArray.length && ineed > 0; i++) {\n            if (this.outbound.get(peersArray[i])) {\n              rotate(i)\n              ineed--\n            }\n          }\n        }\n\n        // prune the excess peers\n        peersArray.slice(D).forEach((p) => {\n          prunePeer(p, ChurnReason.Excess)\n        })\n      }\n\n      // do we have enough outbound peers?\n      if (peers.size >= Dlo) {\n        // count the outbound peers we have\n        let outbound = 0\n        peers.forEach((p) => {\n          if (this.outbound.get(p)) {\n            outbound++\n          }\n        })\n\n        // if it's less than D_out, select some peers with outbound connections and graft them\n        if (outbound < Dout) {\n          const ineed = Dout - outbound\n          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true)\n\n          newMeshPeers.forEach((p) => {\n            graftPeer(p, InclusionReason.Outbound)\n          })\n        }\n      }\n\n      // should we try to improve the mesh with opportunistic grafting?\n      if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {\n        // Opportunistic grafting works as follows: we check the median score of peers in the\n        // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n        // random with score over the median.\n        // The intention is to (slowly) improve an underperforming mesh by introducing good\n        // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n        // situations where we are stuck with poor peers and also recover from churn of good peers.\n\n        // now compute the median peer score in the mesh\n        const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b))\n        const medianIndex = Math.floor(peers.size / 2)\n        const medianScore = getScore(peersList[medianIndex])\n\n        // if the median score is below the threshold, select a better peer (if any) and GRAFT\n        if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {\n          const ineed = this.opts.opportunisticGraftPeers\n          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore)\n          for (const id of newMeshPeers) {\n            this.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic)\n            graftPeer(id, InclusionReason.Opportunistic)\n          }\n        }\n      }\n    })\n\n    // expire fanout for topics we haven't published to in a while\n    const now = Date.now()\n    this.fanoutLastpub.forEach((lastpb, topic) => {\n      if (lastpb + fanoutTTL < now) {\n        this.fanout.delete(topic)\n        this.fanoutLastpub.delete(topic)\n      }\n    })\n\n    // maintain our fanout for topics we are publishing but we have not joined\n    this.fanout.forEach((fanoutPeers, topic) => {\n      // checks whether our peers are still in the topic and have a score above the publish threshold\n      const topicPeers = this.topics.get(topic)\n      fanoutPeers.forEach((id) => {\n        if (!topicPeers!.has(id) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {\n          fanoutPeers.delete(id)\n        }\n      })\n\n      const peersInTopic = this.topics.get(topic)\n      const candidateFanoutPeers = []\n      // the fanout map contains topics to which we are not subscribed.\n      const peersToGossip = new Set<PeerIdStr>()\n      peersToGossipByTopic.set(topic, peersToGossip)\n\n      if (peersInTopic) {\n        const shuffledPeers = shuffle(Array.from(peersInTopic))\n        for (const id of shuffledPeers) {\n          const peerStreams = this.streamsOutbound.get(id)\n          if (\n            peerStreams &&\n            this.multicodecs.includes(peerStreams.protocol) &&\n            !fanoutPeers.has(id) &&\n            !this.direct.has(id)\n          ) {\n            const score = getScore(id)\n            if (score >= this.opts.scoreThresholds.publishThreshold) candidateFanoutPeers.push(id)\n            // instead of having to find gossip peers after heartbeat which require another loop\n            // we prepare peers to gossip in a topic within heartbeat to improve performance\n            if (score >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id)\n          }\n        }\n      }\n\n      // do we need more peers?\n      if (fanoutPeers.size < D) {\n        const ineed = D - fanoutPeers.size\n        candidateFanoutPeers.slice(0, ineed).forEach((id) => {\n          fanoutPeers.add(id)\n          peersToGossip?.delete(id)\n        })\n      }\n    })\n\n    this.emitGossip(peersToGossipByTopic)\n\n    // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n    await this.sendGraftPrune(tograft, toprune, noPX)\n\n    // flush pending gossip that wasn't piggybacked above\n    this.flush()\n\n    // advance the message history window\n    this.mcache.shift()\n\n    this.dispatchEvent(new CustomEvent('gossipsub:heartbeat'))\n  }\n\n  /**\n   * Given a topic, returns up to count peers subscribed to that topic\n   * that pass an optional filter function\n   *\n   * @param topic\n   * @param count\n   * @param filter - a function to filter acceptable peers\n   */\n  private getRandomGossipPeers(\n    topic: string,\n    count: number,\n    filter: (id: string) => boolean = () => true\n  ): Set<string> {\n    const peersInTopic = this.topics.get(topic)\n\n    if (!peersInTopic) {\n      return new Set()\n    }\n\n    // Adds all peers using our protocol\n    // that also pass the filter function\n    let peers: string[] = []\n    peersInTopic.forEach((id) => {\n      const peerStreams = this.streamsOutbound.get(id)\n      if (!peerStreams) {\n        return\n      }\n      if (this.multicodecs.includes(peerStreams.protocol) && filter(id)) {\n        peers.push(id)\n      }\n    })\n\n    // Pseudo-randomly shuffles peers\n    peers = shuffle(peers)\n    if (count > 0 && peers.length > count) {\n      peers = peers.slice(0, count)\n    }\n\n    return new Set(peers)\n  }\n\n  private onScrapeMetrics(metrics: Metrics): void {\n    /* Data structure sizes */\n    metrics.mcacheSize.set(this.mcache.size)\n    metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount)\n    // Arbitrary size\n    metrics.cacheSize.set({ cache: 'direct' }, this.direct.size)\n    metrics.cacheSize.set({ cache: 'seenCache' }, this.seenCache.size)\n    metrics.cacheSize.set({ cache: 'fastMsgIdCache' }, this.fastMsgIdCache?.size ?? 0)\n    metrics.cacheSize.set({ cache: 'publishedMessageIds' }, this.publishedMessageIds.size)\n    metrics.cacheSize.set({ cache: 'mcache' }, this.mcache.size)\n    metrics.cacheSize.set({ cache: 'score' }, this.score.size)\n    metrics.cacheSize.set({ cache: 'gossipTracer.promises' }, this.gossipTracer.size)\n    metrics.cacheSize.set({ cache: 'gossipTracer.requests' }, this.gossipTracer.requestMsByMsgSize)\n    // Bounded by topic\n    metrics.cacheSize.set({ cache: 'topics' }, this.topics.size)\n    metrics.cacheSize.set({ cache: 'subscriptions' }, this.subscriptions.size)\n    metrics.cacheSize.set({ cache: 'mesh' }, this.mesh.size)\n    metrics.cacheSize.set({ cache: 'fanout' }, this.fanout.size)\n    // Bounded by peer\n    metrics.cacheSize.set({ cache: 'peers' }, this.peers.size)\n    metrics.cacheSize.set({ cache: 'streamsOutbound' }, this.streamsOutbound.size)\n    metrics.cacheSize.set({ cache: 'streamsInbound' }, this.streamsInbound.size)\n    metrics.cacheSize.set({ cache: 'acceptFromWhitelist' }, this.acceptFromWhitelist.size)\n    metrics.cacheSize.set({ cache: 'gossip' }, this.gossip.size)\n    metrics.cacheSize.set({ cache: 'control' }, this.control.size)\n    metrics.cacheSize.set({ cache: 'peerhave' }, this.peerhave.size)\n    metrics.cacheSize.set({ cache: 'outbound' }, this.outbound.size)\n    // 2D nested data structure\n    let backoffSize = 0\n    for (const backoff of this.backoff.values()) {\n      backoffSize += backoff.size\n    }\n    metrics.cacheSize.set({ cache: 'backoff' }, backoffSize)\n\n    // Peer counts\n\n    for (const [topicStr, peers] of this.topics) {\n      metrics.topicPeersCount.set({ topicStr }, peers.size)\n    }\n\n    for (const [topicStr, peers] of this.mesh) {\n      metrics.meshPeerCounts.set({ topicStr }, peers.size)\n    }\n\n    // Peer scores\n\n    const scores: number[] = []\n    const scoreByPeer = new Map<PeerIdStr, number>()\n    metrics.behaviourPenalty.reset()\n\n    for (const peerIdStr of this.peers.keys()) {\n      const score = this.score.score(peerIdStr)\n      scores.push(score)\n      scoreByPeer.set(peerIdStr, score)\n      metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0)\n    }\n\n    metrics.registerScores(scores, this.opts.scoreThresholds)\n\n    // Breakdown score per mesh topicLabel\n\n    metrics.registerScorePerMesh(this.mesh, scoreByPeer)\n\n    // Breakdown on each score weight\n\n    const sw = computeAllPeersScoreWeights(\n      this.peers.keys(),\n      this.score.peerStats,\n      this.score.params,\n      this.score.peerIPs,\n      metrics.topicStrToLabel\n    )\n\n    metrics.registerScoreWeights(sw)\n  }\n}\n\nexport function gossipsub(\n  init: Partial<GossipsubOpts> = {}\n): (components: GossipSubComponents) => PubSub<GossipsubEvents> {\n  return (components: GossipSubComponents) => new GossipSub(components, init)\n}\n"]},"metadata":{},"sourceType":"module"}