{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { DUMP_SESSION_KEYS } from './constants.js';\nconst log = logger('libp2p:noise');\nexport { log as logger };\nlet keyLogger;\n\nif (DUMP_SESSION_KEYS) {\n  keyLogger = log;\n} else {\n  keyLogger = Object.assign(() => {}, {\n    enabled: false,\n    trace: () => {},\n    error: () => {}\n  });\n}\n\nexport function logLocalStaticKeys(s) {\n  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${uint8ArrayToString(s.publicKey, 'hex')}`);\n  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${uint8ArrayToString(s.privateKey, 'hex')}`);\n}\nexport function logLocalEphemeralKeys(e) {\n  if (e) {\n    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${uint8ArrayToString(e.publicKey, 'hex')}`);\n    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${uint8ArrayToString(e.privateKey, 'hex')}`);\n  } else {\n    keyLogger('Missing local ephemeral keys.');\n  }\n}\nexport function logRemoteStaticKey(rs) {\n  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${uint8ArrayToString(rs, 'hex')}`);\n}\nexport function logRemoteEphemeralKey(re) {\n  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${uint8ArrayToString(re, 'hex')}`);\n}\nexport function logCipherState(session) {\n  if (session.cs1 && session.cs2) {\n    keyLogger(`CIPHER_STATE_1 ${session.cs1.n.getUint64()} ${uint8ArrayToString(session.cs1.k, 'hex')}`);\n    keyLogger(`CIPHER_STATE_2 ${session.cs2.n.getUint64()} ${uint8ArrayToString(session.cs2.k, 'hex')}`);\n  } else {\n    keyLogger('Missing cipher state.');\n  }\n}","map":{"version":3,"mappings":"AAAA,SAAiBA,MAAjB,QAA+B,gBAA/B;AACA,SAASC,QAAQ,IAAIC,kBAArB,QAA+C,uBAA/C;AAGA,SAASC,iBAAT,QAAkC,gBAAlC;AAEA,MAAMC,GAAG,GAAGJ,MAAM,CAAC,cAAD,CAAlB;AAEA,SAASI,GAAG,IAAIJ,MAAhB;AAEA,IAAIK,SAAJ;;AACA,IAAIF,iBAAJ,EAAuB;AACrBE,WAAS,GAAGD,GAAZ;AACD,CAFD,MAEO;AACLC,WAAS,GAAGC,MAAM,CAACC,MAAP,CAAc,MAAK,CAAqB,CAAxC,EAA0C;AACpDC,WAAO,EAAE,KAD2C;AAEpDC,SAAK,EAAE,MAAK,CAAG,CAFqC;AAGpDC,SAAK,EAAE,MAAK,CAAG;AAHqC,GAA1C,CAAZ;AAKD;;AAED,OAAM,SAAUC,kBAAV,CAA8BC,CAA9B,EAAwC;AAC5CP,WAAS,CAAC,2BAA2BH,kBAAkB,CAACU,CAAC,CAACC,SAAH,EAAc,KAAd,CAAoB,EAAlE,CAAT;AACAR,WAAS,CAAC,4BAA4BH,kBAAkB,CAACU,CAAC,CAACE,UAAH,EAAe,KAAf,CAAqB,EAApE,CAAT;AACD;AAED,OAAM,SAAUC,qBAAV,CAAiCC,CAAjC,EAAuD;AAC3D,MAAIA,CAAJ,EAAO;AACLX,aAAS,CAAC,8BAA8BH,kBAAkB,CAACc,CAAC,CAACH,SAAH,EAAc,KAAd,CAAoB,EAArE,CAAT;AACAR,aAAS,CAAC,+BAA+BH,kBAAkB,CAACc,CAAC,CAACF,UAAH,EAAe,KAAf,CAAqB,EAAvE,CAAT;AACD,GAHD,MAGO;AACLT,aAAS,CAAC,+BAAD,CAAT;AACD;AACF;AAED,OAAM,SAAUY,kBAAV,CAA8BC,EAA9B,EAA4C;AAChDb,WAAS,CAAC,4BAA4BH,kBAAkB,CAACgB,EAAD,EAAK,KAAL,CAAW,EAA1D,CAAT;AACD;AAED,OAAM,SAAUC,qBAAV,CAAiCC,EAAjC,EAA+C;AACnDf,WAAS,CAAC,+BAA+BH,kBAAkB,CAACkB,EAAD,EAAK,KAAL,CAAW,EAA7D,CAAT;AACD;AAED,OAAM,SAAUC,cAAV,CAA0BC,OAA1B,EAA+C;AACnD,MAAIA,OAAO,CAACC,GAAR,IAAeD,OAAO,CAACE,GAA3B,EAAgC;AAC9BnB,aAAS,CAAC,kBAAkBiB,OAAO,CAACC,GAAR,CAAYE,CAAZ,CAAcC,SAAd,EAAyB,IAAIxB,kBAAkB,CAACoB,OAAO,CAACC,GAAR,CAAYI,CAAb,EAAgB,KAAhB,CAAsB,EAAxF,CAAT;AACAtB,aAAS,CAAC,kBAAkBiB,OAAO,CAACE,GAAR,CAAYC,CAAZ,CAAcC,SAAd,EAAyB,IAAIxB,kBAAkB,CAACoB,OAAO,CAACE,GAAR,CAAYG,CAAb,EAAgB,KAAhB,CAAsB,EAAxF,CAAT;AACD,GAHD,MAGO;AACLtB,aAAS,CAAC,uBAAD,CAAT;AACD;AACF","names":["logger","toString","uint8ArrayToString","DUMP_SESSION_KEYS","log","keyLogger","Object","assign","enabled","trace","error","logLocalStaticKeys","s","publicKey","privateKey","logLocalEphemeralKeys","e","logRemoteStaticKey","rs","logRemoteEphemeralKey","re","logCipherState","session","cs1","cs2","n","getUint64","k"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@chainsafe\\libp2p-noise\\src\\logger.ts"],"sourcesContent":["import { Logger, logger } from '@libp2p/logger'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { NoiseSession } from './@types/handshake.js'\nimport type { KeyPair } from './@types/libp2p.js'\nimport { DUMP_SESSION_KEYS } from './constants.js'\n\nconst log = logger('libp2p:noise')\n\nexport { log as logger }\n\nlet keyLogger: Logger\nif (DUMP_SESSION_KEYS) {\n  keyLogger = log\n} else {\n  keyLogger = Object.assign(() => { /* do nothing */ }, {\n    enabled: false,\n    trace: () => {},\n    error: () => {}\n  })\n}\n\nexport function logLocalStaticKeys (s: KeyPair): void {\n  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${uint8ArrayToString(s.publicKey, 'hex')}`)\n  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${uint8ArrayToString(s.privateKey, 'hex')}`)\n}\n\nexport function logLocalEphemeralKeys (e: KeyPair | undefined): void {\n  if (e) {\n    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${uint8ArrayToString(e.publicKey, 'hex')}`)\n    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${uint8ArrayToString(e.privateKey, 'hex')}`)\n  } else {\n    keyLogger('Missing local ephemeral keys.')\n  }\n}\n\nexport function logRemoteStaticKey (rs: Uint8Array): void {\n  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${uint8ArrayToString(rs, 'hex')}`)\n}\n\nexport function logRemoteEphemeralKey (re: Uint8Array): void {\n  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${uint8ArrayToString(re, 'hex')}`)\n}\n\nexport function logCipherState (session: NoiseSession): void {\n  if (session.cs1 && session.cs2) {\n    keyLogger(`CIPHER_STATE_1 ${session.cs1.n.getUint64()} ${uint8ArrayToString(session.cs1.k, 'hex')}`)\n    keyLogger(`CIPHER_STATE_2 ${session.cs2.n.getUint64()} ${uint8ArrayToString(session.cs2.k, 'hex')}`)\n  } else {\n    keyLogger('Missing cipher state.')\n  }\n}\n"]},"metadata":{},"sourceType":"module"}