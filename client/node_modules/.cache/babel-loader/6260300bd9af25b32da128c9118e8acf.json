{"ast":null,"code":"import { Uint8ArrayList } from 'uint8arraylist';\nimport defer from 'p-defer';\nconst DEFAULT_BATCH_SIZE = 1024 * 1024;\n\nconst DEFAULT_SERIALIZE = (buf, list) => {\n  list.append(buf);\n};\n\nasync function* batchedBytes(source) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let buffer = new Uint8ArrayList();\n  let ended = false;\n  let deferred = defer();\n  let size = Number(options.size ?? DEFAULT_BATCH_SIZE);\n\n  if (isNaN(size) || size === 0 || size < 0) {\n    size = DEFAULT_BATCH_SIZE;\n  }\n\n  const yieldAfter = options.yieldAfter ?? 0;\n  const serialize = options.serialize ?? DEFAULT_SERIALIZE;\n  void Promise.resolve().then(async () => {\n    try {\n      let timeout;\n\n      for await (const buf of source) {\n        serialize(buf, buffer);\n\n        if (buffer.byteLength >= size) {\n          clearTimeout(timeout);\n          deferred.resolve();\n          continue;\n        }\n\n        timeout = setTimeout(() => {\n          deferred.resolve();\n        }, yieldAfter);\n      }\n\n      clearTimeout(timeout);\n      deferred.resolve();\n    } catch (err) {\n      deferred.reject(err);\n    } finally {\n      ended = true;\n    }\n  });\n\n  while (!ended) {\n    // eslint-disable-line no-unmodified-loop-condition\n    await deferred.promise;\n    deferred = defer();\n\n    if (buffer.byteLength > 0) {\n      const b = buffer;\n      buffer = new Uint8ArrayList();\n      yield b.subarray();\n    }\n  }\n}\n\nexport default batchedBytes;","map":{"version":3,"mappings":"AAAA,SAASA,cAAT,QAA+B,gBAA/B;AACA,OAAOC,KAAP,MAAkB,SAAlB;AAGA,MAAMC,kBAAkB,GAAG,OAAO,IAAlC;;AACA,MAAMC,iBAAiB,GAAG,CAACC,GAAD,EAAmCC,IAAnC,KAAiE;AAAGA,MAAI,CAACC,MAAL,CAAYF,GAAZ;AAAkB,CAAhH;;AAyCA,gBAAiBG,YAAjB,CAA+BC,MAA/B,EAAqE;AAAA,MAAjBC,OAAiB,uEAAF,EAAE;AACnE,MAAIC,MAAM,GAAG,IAAIV,cAAJ,EAAb;AACA,MAAIW,KAAK,GAAG,KAAZ;AACA,MAAIC,QAAQ,GAAGX,KAAK,EAApB;AAEA,MAAIY,IAAI,GAAGC,MAAM,CAACL,OAAO,CAACI,IAAR,IAAgBX,kBAAjB,CAAjB;;AAEA,MAAIa,KAAK,CAACF,IAAD,CAAL,IAAeA,IAAI,KAAK,CAAxB,IAA6BA,IAAI,GAAG,CAAxC,EAA2C;AACzCA,QAAI,GAAGX,kBAAP;AACD;;AAED,QAAMc,UAAU,GAAGP,OAAO,CAACO,UAAR,IAAsB,CAAzC;AACA,QAAMC,SAAS,GAAGR,OAAO,CAACQ,SAAR,IAAqBd,iBAAvC;AAEA,OAAKe,OAAO,CAACC,OAAR,GAAkBC,IAAlB,CAAuB,YAAW;AACrC,QAAI;AACF,UAAIC,OAAJ;;AAEA,iBAAW,MAAMjB,GAAjB,IAAwBI,MAAxB,EAAgC;AAC9BS,iBAAS,CAACb,GAAD,EAAMM,MAAN,CAAT;;AAEA,YAAIA,MAAM,CAACY,UAAP,IAAqBT,IAAzB,EAA+B;AAC7BU,sBAAY,CAACF,OAAD,CAAZ;AACAT,kBAAQ,CAACO,OAAT;AACA;AACD;;AAEDE,eAAO,GAAGG,UAAU,CAAC,MAAK;AACxBZ,kBAAQ,CAACO,OAAT;AACD,SAFmB,EAEjBH,UAFiB,CAApB;AAGD;;AAEDO,kBAAY,CAACF,OAAD,CAAZ;AACAT,cAAQ,CAACO,OAAT;AACD,KAnBD,CAmBE,OAAOM,GAAP,EAAY;AACZb,cAAQ,CAACc,MAAT,CAAgBD,GAAhB;AACD,KArBD,SAqBU;AACRd,WAAK,GAAG,IAAR;AACD;AACF,GAzBI,CAAL;;AA2BA,SAAO,CAACA,KAAR,EAAe;AAAE;AACf,UAAMC,QAAQ,CAACe,OAAf;AACAf,YAAQ,GAAGX,KAAK,EAAhB;;AACA,QAAIS,MAAM,CAACY,UAAP,GAAoB,CAAxB,EAA2B;AACzB,YAAMM,CAAC,GAAGlB,MAAV;AACAA,YAAM,GAAG,IAAIV,cAAJ,EAAT;AACA,YAAM4B,CAAC,CAACC,QAAF,EAAN;AACD;AACF;AACF;;AAED,eAAetB,YAAf","names":["Uint8ArrayList","defer","DEFAULT_BATCH_SIZE","DEFAULT_SERIALIZE","buf","list","append","batchedBytes","source","options","buffer","ended","deferred","size","Number","isNaN","yieldAfter","serialize","Promise","resolve","then","timeout","byteLength","clearTimeout","setTimeout","err","reject","promise","b","subarray"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-batched-bytes\\src\\index.ts"],"sourcesContent":["import { Uint8ArrayList } from 'uint8arraylist'\nimport defer from 'p-defer'\nimport type { Source } from 'it-stream-types'\n\nconst DEFAULT_BATCH_SIZE = 1024 * 1024\nconst DEFAULT_SERIALIZE = (buf: Uint8Array | Uint8ArrayList, list: Uint8ArrayList): void => { list.append(buf) }\n\nexport interface BatchedBytesOptions {\n  /**\n   * The minimum number of bytes that should be in a batch (default: 1MB)\n   */\n  size?: number\n\n  /**\n   * If this amount of time passes, yield all the bytes in the batch even\n   * if they are below `size` (default: 0 - e.g. on every tick)\n   */\n  yieldAfter?: number\n}\n\nexport interface BatchedOptions<T> {\n  /**\n   * The minimum number of bytes that should be in a batch (default: 1MB)\n   */\n  size?: number\n\n  /**\n   * If this amount of time passes, yield all the bytes in the batch even\n   * if they are below `size` (default: 0 - e.g. on every tick)\n   */\n  yieldAfter?: number\n\n  /**\n   * If passed, this function should serialize the object and append the\n   * result to the passed list\n   */\n  serialize: (object: T, list: Uint8ArrayList) => void\n}\n\n/**\n * Takes a stream of Uint8Arrays and/or Uint8ArrayLists and store them in\n * an internal buffer. Either once the buffer reaches the requested size\n * or the next event loop tick occurs, yield any bytes from the buffer.\n */\nfunction batchedBytes (source: Source<Uint8Array | Uint8ArrayList>, options?: BatchedBytesOptions): Source<Uint8Array>\nfunction batchedBytes <T> (source: Source<T>, options: BatchedOptions<T>): Source<Uint8Array>\nasync function * batchedBytes (source: Source<any>, options: any = {}): any {\n  let buffer = new Uint8ArrayList()\n  let ended = false\n  let deferred = defer()\n\n  let size = Number(options.size ?? DEFAULT_BATCH_SIZE)\n\n  if (isNaN(size) || size === 0 || size < 0) {\n    size = DEFAULT_BATCH_SIZE\n  }\n\n  const yieldAfter = options.yieldAfter ?? 0\n  const serialize = options.serialize ?? DEFAULT_SERIALIZE\n\n  void Promise.resolve().then(async () => {\n    try {\n      let timeout\n\n      for await (const buf of source) {\n        serialize(buf, buffer)\n\n        if (buffer.byteLength >= size) {\n          clearTimeout(timeout)\n          deferred.resolve()\n          continue\n        }\n\n        timeout = setTimeout(() => { // eslint-disable-line no-loop-func\n          deferred.resolve()\n        }, yieldAfter)\n      }\n\n      clearTimeout(timeout)\n      deferred.resolve()\n    } catch (err) {\n      deferred.reject(err)\n    } finally {\n      ended = true\n    }\n  })\n\n  while (!ended) { // eslint-disable-line no-unmodified-loop-condition\n    await deferred.promise\n    deferred = defer()\n    if (buffer.byteLength > 0) {\n      const b = buffer\n      buffer = new Uint8ArrayList()\n      yield b.subarray()\n    }\n  }\n}\n\nexport default batchedBytes\n"]},"metadata":{},"sourceType":"module"}