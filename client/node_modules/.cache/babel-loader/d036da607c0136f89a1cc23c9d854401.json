{"ast":null,"code":"import { Uint8ArrayList } from 'uint8arraylist';\n/**\n * @type {import('../types').Chunker}\n */\n\nasync function* fixedSizeChunker(source, options) {\n  let list = new Uint8ArrayList();\n  let currentLength = 0;\n  let emitted = false;\n  const maxChunkSize = options.maxChunkSize;\n\n  for await (const buffer of source) {\n    list.append(buffer);\n    currentLength += buffer.length;\n\n    while (currentLength >= maxChunkSize) {\n      yield list.slice(0, maxChunkSize);\n      emitted = true; // throw away consumed bytes\n\n      if (maxChunkSize === list.length) {\n        list = new Uint8ArrayList();\n        currentLength = 0;\n      } else {\n        const newBl = new Uint8ArrayList();\n        newBl.append(list.sublist(maxChunkSize));\n        list = newBl; // update our offset\n\n        currentLength -= maxChunkSize;\n      }\n    }\n  }\n\n  if (!emitted || currentLength) {\n    // return any remaining bytes or an empty buffer\n    yield list.subarray(0, currentLength);\n  }\n}\n\nexport default fixedSizeChunker;","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-unixfs-importer/src/chunker/fixed-size.js"],"names":["Uint8ArrayList","fixedSizeChunker","source","options","list","currentLength","emitted","maxChunkSize","buffer","append","length","slice","newBl","sublist","subarray"],"mappings":"AAAA,SAASA,cAAT,QAA+B,gBAA/B;AAEA;AACA;AACA;;AACA,gBAAiBC,gBAAjB,CAAmCC,MAAnC,EAA2CC,OAA3C,EAAoD;AAClD,MAAIC,IAAI,GAAG,IAAIJ,cAAJ,EAAX;AACA,MAAIK,aAAa,GAAG,CAApB;AACA,MAAIC,OAAO,GAAG,KAAd;AACA,QAAMC,YAAY,GAAGJ,OAAO,CAACI,YAA7B;;AAEA,aAAW,MAAMC,MAAjB,IAA2BN,MAA3B,EAAmC;AACjCE,IAAAA,IAAI,CAACK,MAAL,CAAYD,MAAZ;AAEAH,IAAAA,aAAa,IAAIG,MAAM,CAACE,MAAxB;;AAEA,WAAOL,aAAa,IAAIE,YAAxB,EAAsC;AACpC,YAAMH,IAAI,CAACO,KAAL,CAAW,CAAX,EAAcJ,YAAd,CAAN;AACAD,MAAAA,OAAO,GAAG,IAAV,CAFoC,CAIpC;;AACA,UAAIC,YAAY,KAAKH,IAAI,CAACM,MAA1B,EAAkC;AAChCN,QAAAA,IAAI,GAAG,IAAIJ,cAAJ,EAAP;AACAK,QAAAA,aAAa,GAAG,CAAhB;AACD,OAHD,MAGO;AACL,cAAMO,KAAK,GAAG,IAAIZ,cAAJ,EAAd;AACAY,QAAAA,KAAK,CAACH,MAAN,CAAaL,IAAI,CAACS,OAAL,CAAaN,YAAb,CAAb;AACAH,QAAAA,IAAI,GAAGQ,KAAP,CAHK,CAKL;;AACAP,QAAAA,aAAa,IAAIE,YAAjB;AACD;AACF;AACF;;AAED,MAAI,CAACD,OAAD,IAAYD,aAAhB,EAA+B;AAC7B;AACA,UAAMD,IAAI,CAACU,QAAL,CAAc,CAAd,EAAiBT,aAAjB,CAAN;AACD;AACF;;AAED,eAAeJ,gBAAf","sourcesContent":["import { Uint8ArrayList } from 'uint8arraylist'\n\n/**\n * @type {import('../types').Chunker}\n */\nasync function * fixedSizeChunker (source, options) {\n  let list = new Uint8ArrayList()\n  let currentLength = 0\n  let emitted = false\n  const maxChunkSize = options.maxChunkSize\n\n  for await (const buffer of source) {\n    list.append(buffer)\n\n    currentLength += buffer.length\n\n    while (currentLength >= maxChunkSize) {\n      yield list.slice(0, maxChunkSize)\n      emitted = true\n\n      // throw away consumed bytes\n      if (maxChunkSize === list.length) {\n        list = new Uint8ArrayList()\n        currentLength = 0\n      } else {\n        const newBl = new Uint8ArrayList()\n        newBl.append(list.sublist(maxChunkSize))\n        list = newBl\n\n        // update our offset\n        currentLength -= maxChunkSize\n      }\n    }\n  }\n\n  if (!emitted || currentLength) {\n    // return any remaining bytes or an empty buffer\n    yield list.subarray(0, currentLength)\n  }\n}\n\nexport default fixedSizeChunker\n"]},"metadata":{},"sourceType":"module"}