{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport * as mss from '@libp2p/multistream-select';\nimport { codes } from './errors.js';\nimport { createConnection } from './connection/index.js';\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { DEFAULT_MAX_INBOUND_STREAMS, DEFAULT_MAX_OUTBOUND_STREAMS } from './registrar.js';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { abortableDuplex } from 'abortable-iterator';\nimport { setMaxListeners } from 'events';\nconst log = logger('libp2p:upgrader');\n\nfunction findIncomingStreamLimit(protocol, registrar) {\n  try {\n    const {\n      options\n    } = registrar.getHandler(protocol);\n    return options.maxInboundStreams;\n  } catch (err) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err;\n    }\n  }\n\n  return DEFAULT_MAX_INBOUND_STREAMS;\n}\n\nfunction findOutgoingStreamLimit(protocol, registrar) {\n  try {\n    const {\n      options\n    } = registrar.getHandler(protocol);\n    return options.maxOutboundStreams;\n  } catch (err) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err;\n    }\n  }\n\n  return DEFAULT_MAX_OUTBOUND_STREAMS;\n}\n\nfunction countStreams(protocol, direction, connection) {\n  let streamCount = 0;\n  connection.streams.forEach(stream => {\n    if (stream.stat.direction === direction && stream.stat.protocol === protocol) {\n      streamCount++;\n    }\n  });\n  return streamCount;\n}\n\nexport class DefaultUpgrader extends EventEmitter {\n  constructor(components, init) {\n    super();\n    this.components = components;\n    this.connectionEncryption = new Map();\n    init.connectionEncryption.forEach(encrypter => {\n      this.connectionEncryption.set(encrypter.protocol, encrypter);\n    });\n    this.muxers = new Map();\n    init.muxers.forEach(muxer => {\n      this.muxers.set(muxer.protocol, muxer);\n    });\n    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout;\n  }\n  /**\n   * Upgrades an inbound connection\n   */\n\n\n  async upgradeInbound(maConn, opts) {\n    const accept = await this.components.connectionManager.acceptIncomingConnection(maConn);\n\n    if (!accept) {\n      throw errCode(new Error('connection denied'), codes.ERR_CONNECTION_DENIED);\n    }\n\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let muxerFactory;\n    let cryptoProtocol;\n    const timeoutController = new TimeoutController(this.inboundUpgradeTimeout);\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, timeoutController.signal);\n    } catch {}\n\n    try {\n      const abortableStream = abortableDuplex(maConn, timeoutController.signal);\n      maConn.source = abortableStream.source;\n      maConn.sink = abortableStream.sink;\n\n      if (await this.components.connectionGater.denyInboundConnection(maConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n      }\n\n      this.components.metrics?.trackMultiaddrConnection(maConn);\n      log('starting the inbound connection upgrade'); // Protect\n\n      let protectedConn = maConn;\n\n      if (opts?.skipProtection !== true) {\n        const protector = this.components.connectionProtector;\n\n        if (protector != null) {\n          log('protecting the inbound connection');\n          protectedConn = await protector.protect(maConn);\n        }\n      }\n\n      try {\n        // Encrypt the connection\n        encryptedConn = protectedConn;\n\n        if (opts?.skipEncryption !== true) {\n          ({\n            conn: encryptedConn,\n            remotePeer,\n            protocol: cryptoProtocol\n          } = await this._encryptInbound(protectedConn));\n\n          if (await this.components.connectionGater.denyInboundEncryptedConnection(remotePeer, { ...protectedConn,\n            ...encryptedConn\n          })) {\n            throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n          }\n        } else {\n          const idStr = maConn.remoteAddr.getPeerId();\n\n          if (idStr == null) {\n            throw errCode(new Error('inbound connection that skipped encryption must have a peer id'), codes.ERR_INVALID_MULTIADDR);\n          }\n\n          const remotePeerId = peerIdFromString(idStr);\n          cryptoProtocol = 'native';\n          remotePeer = remotePeerId;\n        }\n\n        upgradedConn = encryptedConn;\n\n        if (opts?.muxerFactory != null) {\n          muxerFactory = opts.muxerFactory;\n        } else if (this.muxers.size > 0) {\n          // Multiplex the connection\n          const multiplexed = await this._multiplexInbound({ ...protectedConn,\n            ...encryptedConn\n          }, this.muxers);\n          muxerFactory = multiplexed.muxerFactory;\n          upgradedConn = multiplexed.stream;\n        }\n      } catch (err) {\n        log.error('Failed to upgrade inbound connection', err);\n        throw err;\n      }\n\n      if (await this.components.connectionGater.denyInboundUpgradedConnection(remotePeer, { ...protectedConn,\n        ...encryptedConn\n      })) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n      }\n\n      log('Successfully upgraded inbound connection');\n      return this._createConnection({\n        cryptoProtocol,\n        direction: 'inbound',\n        maConn,\n        upgradedConn,\n        muxerFactory,\n        remotePeer\n      });\n    } finally {\n      this.components.connectionManager.afterUpgradeInbound();\n      timeoutController.clear();\n    }\n  }\n  /**\n   * Upgrades an outbound connection\n   */\n\n\n  async upgradeOutbound(maConn, opts) {\n    const idStr = maConn.remoteAddr.getPeerId();\n    let remotePeerId;\n\n    if (idStr != null) {\n      remotePeerId = peerIdFromString(idStr);\n\n      if (await this.components.connectionGater.denyOutboundConnection(remotePeerId, maConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by connectionGater.denyOutboundConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n      }\n    }\n\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let cryptoProtocol;\n    let muxerFactory;\n    this.components.metrics?.trackMultiaddrConnection(maConn);\n    log('Starting the outbound connection upgrade'); // If the transport natively supports encryption, skip connection\n    // protector and encryption\n    // Protect\n\n    let protectedConn = maConn;\n\n    if (opts?.skipProtection !== true) {\n      const protector = this.components.connectionProtector;\n\n      if (protector != null) {\n        protectedConn = await protector.protect(maConn);\n      }\n    }\n\n    try {\n      // Encrypt the connection\n      encryptedConn = protectedConn;\n\n      if (opts?.skipEncryption !== true) {\n        ({\n          conn: encryptedConn,\n          remotePeer,\n          protocol: cryptoProtocol\n        } = await this._encryptOutbound(protectedConn, remotePeerId));\n\n        if (await this.components.connectionGater.denyOutboundEncryptedConnection(remotePeer, { ...protectedConn,\n          ...encryptedConn\n        })) {\n          throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n        }\n      } else {\n        if (remotePeerId == null) {\n          throw errCode(new Error('Encryption was skipped but no peer id was passed'), codes.ERR_INVALID_PEER);\n        }\n\n        cryptoProtocol = 'native';\n        remotePeer = remotePeerId;\n      }\n\n      upgradedConn = encryptedConn;\n\n      if (opts?.muxerFactory != null) {\n        muxerFactory = opts.muxerFactory;\n      } else if (this.muxers.size > 0) {\n        // Multiplex the connection\n        const multiplexed = await this._multiplexOutbound({ ...protectedConn,\n          ...encryptedConn\n        }, this.muxers);\n        muxerFactory = multiplexed.muxerFactory;\n        upgradedConn = multiplexed.stream;\n      }\n    } catch (err) {\n      log.error('Failed to upgrade outbound connection', err);\n      await maConn.close(err);\n      throw err;\n    }\n\n    if (await this.components.connectionGater.denyOutboundUpgradedConnection(remotePeer, { ...protectedConn,\n      ...encryptedConn\n    })) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n    }\n\n    log('Successfully upgraded outbound connection');\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      muxerFactory,\n      remotePeer\n    });\n  }\n  /**\n   * A convenience method for generating a new `Connection`\n   */\n\n\n  _createConnection(opts) {\n    var _this = this;\n\n    const {\n      cryptoProtocol,\n      direction,\n      maConn,\n      upgradedConn,\n      remotePeer,\n      muxerFactory\n    } = opts;\n    let muxer;\n    let newStream;\n    let connection; // eslint-disable-line prefer-const\n\n    if (muxerFactory != null) {\n      // Create the muxer\n      muxer = muxerFactory.createStreamMuxer({\n        direction,\n        // Run anytime a remote stream is created\n        onIncomingStream: muxedStream => {\n          if (connection == null) {\n            return;\n          }\n\n          void Promise.resolve().then(async () => {\n            const protocols = this.components.registrar.getProtocols();\n            const {\n              stream,\n              protocol\n            } = await mss.handle(muxedStream, protocols);\n            log('%s: incoming stream opened on %s', direction, protocol);\n\n            if (connection == null) {\n              return;\n            }\n\n            const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);\n            const streamCount = countStreams(protocol, 'inbound', connection);\n\n            if (streamCount === incomingLimit) {\n              muxedStream.abort(errCode(new Error(`Too many inbound protocol streams for protocol \"${protocol}\" - limit ${incomingLimit}`), codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS));\n              return;\n            } // after the handshake the returned stream can have early data so override\n            // the souce/sink\n\n\n            muxedStream.source = stream.source;\n            muxedStream.sink = stream.sink;\n            muxedStream.stat.protocol = protocol; // If a protocol stream has been successfully negotiated and is to be passed to the application,\n            // the peerstore should ensure that the peer is registered with that protocol\n\n            this.components.peerStore.protoBook.add(remotePeer, [protocol]).catch(err => log.error(err));\n            connection.addStream(muxedStream);\n            this.components.metrics?.trackProtocolStream(muxedStream, connection);\n\n            this._onStream({\n              connection,\n              stream: muxedStream,\n              protocol\n            });\n          }).catch(err => {\n            log.error(err);\n\n            if (muxedStream.stat.timeline.close == null) {\n              muxedStream.close();\n            }\n          });\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection?.removeStream(muxedStream.id);\n        }\n      });\n\n      newStream = async function (protocols) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        if (muxer == null) {\n          throw errCode(new Error('Stream is not multiplexed'), codes.ERR_MUXER_UNAVAILABLE);\n        }\n\n        log('%s: starting new stream on %s', direction, protocols);\n        const muxedStream = await muxer.newStream();\n        let controller;\n\n        try {\n          if (options.signal == null) {\n            log('No abort signal was passed while trying to negotiate protocols %s falling back to default timeout', protocols);\n            controller = new TimeoutController(30000);\n            options.signal = controller.signal;\n\n            try {\n              // fails on node < 15.4\n              setMaxListeners?.(Infinity, controller.signal);\n            } catch {}\n          }\n\n          const {\n            stream,\n            protocol\n          } = await mss.select(muxedStream, protocols, options);\n          const outgoingLimit = findOutgoingStreamLimit(protocol, _this.components.registrar);\n          const streamCount = countStreams(protocol, 'outbound', connection);\n\n          if (streamCount === outgoingLimit) {\n            const err = errCode(new Error(`Too many outbound protocol streams for protocol \"${protocol}\" - limit ${outgoingLimit}`), codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);\n            muxedStream.abort(err);\n            throw err;\n          } // If a protocol stream has been successfully negotiated and is to be passed to the application,\n          // the peerstore should ensure that the peer is registered with that protocol\n\n\n          _this.components.peerStore.protoBook.add(remotePeer, [protocol]).catch(err => log.error(err)); // after the handshake the returned stream can have early data so override\n          // the souce/sink\n\n\n          muxedStream.source = stream.source;\n          muxedStream.sink = stream.sink;\n          muxedStream.stat.protocol = protocol;\n          _this.components.metrics?.trackProtocolStream(muxedStream, connection);\n          return muxedStream;\n        } catch (err) {\n          log.error('could not create new stream', err);\n\n          if (muxedStream.stat.timeline.close == null) {\n            muxedStream.close();\n          }\n\n          if (err.code != null) {\n            throw err;\n          }\n\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL);\n        } finally {\n          if (controller != null) {\n            controller.clear();\n          }\n        }\n      }; // Pipe all data through the muxer\n\n\n      void Promise.all([muxer.sink(upgradedConn.source), upgradedConn.sink(muxer.source)]).catch(err => {\n        log.error(err);\n      });\n    }\n\n    const _timeline = maConn.timeline;\n    maConn.timeline = new Proxy(_timeline, {\n      set: function () {\n        if (connection != null && (arguments.length <= 1 ? undefined : arguments[1]) === 'close' && (arguments.length <= 2 ? undefined : arguments[2]) != null && _timeline.close == null) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.stat.status === 'OPEN') {\n                await connection.close();\n              }\n            } catch (err) {\n              log.error(err);\n            } finally {\n              _this.dispatchEvent(new CustomEvent('connectionEnd', {\n                detail: connection\n              }));\n            }\n          })().catch(err => {\n            log.error(err);\n          });\n        }\n\n        return Reflect.set(...arguments);\n      }\n    });\n    maConn.timeline.upgraded = Date.now();\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), codes.ERR_CONNECTION_NOT_MULTIPLEXED);\n    }; // Create the connection\n\n\n    connection = createConnection({\n      remoteAddr: maConn.remoteAddr,\n      remotePeer: remotePeer,\n      stat: {\n        status: 'OPEN',\n        direction,\n        timeline: maConn.timeline,\n        multiplexer: muxer?.protocol,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream ?? errConnectionNotMultiplexed,\n      getStreams: () => muxer != null ? muxer.streams : errConnectionNotMultiplexed(),\n      close: async () => {\n        await maConn.close(); // Ensure remaining streams are closed\n\n        if (muxer != null) {\n          muxer.close();\n        }\n      }\n    });\n    this.dispatchEvent(new CustomEvent('connection', {\n      detail: connection\n    }));\n    return connection;\n  }\n  /**\n   * Routes incoming streams to the correct handler\n   */\n\n\n  _onStream(opts) {\n    const {\n      connection,\n      stream,\n      protocol\n    } = opts;\n    const {\n      handler\n    } = this.components.registrar.getHandler(protocol);\n    handler({\n      connection,\n      stream\n    });\n  }\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`\n   */\n\n\n  async _encryptInbound(connection) {\n    const protocols = Array.from(this.connectionEncryption.keys());\n    log('handling inbound crypto protocol selection', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.handle(connection, protocols, {\n        writeBytes: true\n      });\n      const encrypter = this.connectionEncryption.get(protocol);\n\n      if (encrypter == null) {\n        throw new Error(`no crypto module found for ${protocol}`);\n      }\n\n      log('encrypting inbound connection...');\n      return { ...(await encrypter.secureInbound(this.components.peerId, stream)),\n        protocol\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Attempts to encrypt the given `connection` with the provided connection encrypters.\n   * The first `ConnectionEncrypter` module to succeed will be used\n   */\n\n\n  async _encryptOutbound(connection, remotePeerId) {\n    const protocols = Array.from(this.connectionEncryption.keys());\n    log('selecting outbound crypto protocol', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.select(connection, protocols, {\n        writeBytes: true\n      });\n      const encrypter = this.connectionEncryption.get(protocol);\n\n      if (encrypter == null) {\n        throw new Error(`no crypto module found for ${protocol}`);\n      }\n\n      log('encrypting outbound connection to %p', remotePeerId);\n      return { ...(await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId)),\n        protocol\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   */\n\n\n  async _multiplexOutbound(connection, muxers) {\n    const protocols = Array.from(muxers.keys());\n    log('outbound selecting muxer %s', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.select(connection, protocols, {\n        writeBytes: true\n      });\n      log('%s selected as muxer protocol', protocol);\n      const muxerFactory = muxers.get(protocol);\n      return {\n        stream,\n        muxerFactory\n      };\n    } catch (err) {\n      log.error('error multiplexing outbound stream', err);\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   */\n\n\n  async _multiplexInbound(connection, muxers) {\n    const protocols = Array.from(muxers.keys());\n    log('inbound handling muxers %s', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.handle(connection, protocols, {\n        writeBytes: true\n      });\n      const muxerFactory = muxers.get(protocol);\n      return {\n        stream,\n        muxerFactory\n      };\n    } catch (err) {\n      log.error('error multiplexing inbound stream', err);\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["logger","errCode","mss","codes","createConnection","CustomEvent","EventEmitter","peerIdFromString","DEFAULT_MAX_INBOUND_STREAMS","DEFAULT_MAX_OUTBOUND_STREAMS","TimeoutController","abortableDuplex","setMaxListeners","log","findIncomingStreamLimit","protocol","registrar","options","getHandler","maxInboundStreams","err","code","ERR_NO_HANDLER_FOR_PROTOCOL","findOutgoingStreamLimit","maxOutboundStreams","countStreams","direction","connection","streamCount","streams","forEach","stream","stat","DefaultUpgrader","constructor","components","init","connectionEncryption","Map","encrypter","set","muxers","muxer","inboundUpgradeTimeout","upgradeInbound","maConn","opts","accept","connectionManager","acceptIncomingConnection","Error","ERR_CONNECTION_DENIED","encryptedConn","remotePeer","upgradedConn","muxerFactory","cryptoProtocol","timeoutController","Infinity","signal","abortableStream","source","sink","connectionGater","denyInboundConnection","ERR_CONNECTION_INTERCEPTED","metrics","trackMultiaddrConnection","protectedConn","skipProtection","protector","connectionProtector","protect","skipEncryption","conn","_encryptInbound","denyInboundEncryptedConnection","idStr","remoteAddr","getPeerId","ERR_INVALID_MULTIADDR","remotePeerId","size","multiplexed","_multiplexInbound","error","denyInboundUpgradedConnection","_createConnection","afterUpgradeInbound","clear","upgradeOutbound","denyOutboundConnection","_encryptOutbound","denyOutboundEncryptedConnection","ERR_INVALID_PEER","_multiplexOutbound","close","denyOutboundUpgradedConnection","newStream","createStreamMuxer","onIncomingStream","muxedStream","Promise","resolve","then","protocols","getProtocols","handle","incomingLimit","abort","ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS","peerStore","protoBook","add","catch","addStream","trackProtocolStream","_onStream","timeline","onStreamEnd","removeStream","id","ERR_MUXER_UNAVAILABLE","controller","select","outgoingLimit","ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS","ERR_UNSUPPORTED_PROTOCOL","all","_timeline","Proxy","status","dispatchEvent","detail","Reflect","upgraded","Date","now","errConnectionNotMultiplexed","ERR_CONNECTION_NOT_MULTIPLEXED","multiplexer","encryption","getStreams","handler","Array","from","keys","writeBytes","get","secureInbound","peerId","ERR_ENCRYPTION_FAILED","secureOutbound"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\libp2p\\src\\upgrader.ts"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport * as mss from '@libp2p/multistream-select'\nimport { codes } from './errors.js'\nimport { createConnection } from './connection/index.js'\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport type { MultiaddrConnection, Connection, Stream, ConnectionGater, ConnectionProtector } from '@libp2p/interface-connection'\nimport type { ConnectionEncrypter, SecuredConnection } from '@libp2p/interface-connection-encrypter'\nimport type { StreamMuxer, StreamMuxerFactory } from '@libp2p/interface-stream-muxer'\nimport type { PeerId } from '@libp2p/interface-peer-id'\nimport type { Upgrader, UpgraderEvents, UpgraderOptions } from '@libp2p/interface-transport'\nimport type { Duplex } from 'it-stream-types'\nimport type { AbortOptions } from '@libp2p/interfaces'\nimport type { Registrar } from '@libp2p/interface-registrar'\nimport { DEFAULT_MAX_INBOUND_STREAMS, DEFAULT_MAX_OUTBOUND_STREAMS } from './registrar.js'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { abortableDuplex } from 'abortable-iterator'\nimport { setMaxListeners } from 'events'\nimport type { Metrics } from '@libp2p/interface-metrics'\nimport type { ConnectionManager } from '@libp2p/interface-connection-manager'\nimport type { PeerStore } from '@libp2p/interface-peer-store'\n\nconst log = logger('libp2p:upgrader')\n\ninterface CreateConectionOptions {\n  cryptoProtocol: string\n  direction: 'inbound' | 'outbound'\n  maConn: MultiaddrConnection\n  upgradedConn: Duplex<Uint8Array>\n  remotePeer: PeerId\n  muxerFactory?: StreamMuxerFactory\n}\n\ninterface OnStreamOptions {\n  connection: Connection\n  stream: Stream\n  protocol: string\n}\n\nexport interface CryptoResult extends SecuredConnection {\n  protocol: string\n}\n\nexport interface UpgraderInit {\n  connectionEncryption: ConnectionEncrypter[]\n  muxers: StreamMuxerFactory[]\n\n  /**\n   * An amount of ms by which an inbound connection upgrade\n   * must complete\n   */\n  inboundUpgradeTimeout: number\n}\n\nfunction findIncomingStreamLimit (protocol: string, registrar: Registrar) {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    return options.maxInboundStreams\n  } catch (err: any) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err\n    }\n  }\n\n  return DEFAULT_MAX_INBOUND_STREAMS\n}\n\nfunction findOutgoingStreamLimit (protocol: string, registrar: Registrar) {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    return options.maxOutboundStreams\n  } catch (err: any) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err\n    }\n  }\n\n  return DEFAULT_MAX_OUTBOUND_STREAMS\n}\n\nfunction countStreams (protocol: string, direction: 'inbound' | 'outbound', connection: Connection) {\n  let streamCount = 0\n\n  connection.streams.forEach(stream => {\n    if (stream.stat.direction === direction && stream.stat.protocol === protocol) {\n      streamCount++\n    }\n  })\n\n  return streamCount\n}\n\nexport interface DefaultUpgraderComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  connectionManager: ConnectionManager\n  connectionGater: ConnectionGater\n  connectionProtector?: ConnectionProtector\n  registrar: Registrar\n  peerStore: PeerStore\n}\n\nexport class DefaultUpgrader extends EventEmitter<UpgraderEvents> implements Upgrader {\n  private readonly components: DefaultUpgraderComponents\n  private readonly connectionEncryption: Map<string, ConnectionEncrypter>\n  private readonly muxers: Map<string, StreamMuxerFactory>\n  private readonly inboundUpgradeTimeout: number\n\n  constructor (components: DefaultUpgraderComponents, init: UpgraderInit) {\n    super()\n\n    this.components = components\n    this.connectionEncryption = new Map()\n\n    init.connectionEncryption.forEach(encrypter => {\n      this.connectionEncryption.set(encrypter.protocol, encrypter)\n    })\n\n    this.muxers = new Map()\n\n    init.muxers.forEach(muxer => {\n      this.muxers.set(muxer.protocol, muxer)\n    })\n\n    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout\n  }\n\n  /**\n   * Upgrades an inbound connection\n   */\n  async upgradeInbound (maConn: MultiaddrConnection, opts?: UpgraderOptions): Promise<Connection> {\n    const accept = await this.components.connectionManager.acceptIncomingConnection(maConn)\n\n    if (!accept) {\n      throw errCode(new Error('connection denied'), codes.ERR_CONNECTION_DENIED)\n    }\n\n    let encryptedConn\n    let remotePeer\n    let upgradedConn: Duplex<Uint8Array>\n    let muxerFactory: StreamMuxerFactory | undefined\n    let cryptoProtocol\n\n    const timeoutController = new TimeoutController(this.inboundUpgradeTimeout)\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, timeoutController.signal)\n    } catch {}\n\n    try {\n      const abortableStream = abortableDuplex(maConn, timeoutController.signal)\n      maConn.source = abortableStream.source\n      maConn.sink = abortableStream.sink\n\n      if (await this.components.connectionGater.denyInboundConnection(maConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n      }\n\n      this.components.metrics?.trackMultiaddrConnection(maConn)\n\n      log('starting the inbound connection upgrade')\n\n      // Protect\n      let protectedConn = maConn\n\n      if (opts?.skipProtection !== true) {\n        const protector = this.components.connectionProtector\n\n        if (protector != null) {\n          log('protecting the inbound connection')\n          protectedConn = await protector.protect(maConn)\n        }\n      }\n\n      try {\n        // Encrypt the connection\n        encryptedConn = protectedConn\n        if (opts?.skipEncryption !== true) {\n          ({\n            conn: encryptedConn,\n            remotePeer,\n            protocol: cryptoProtocol\n          } = await this._encryptInbound(protectedConn))\n\n          if (await this.components.connectionGater.denyInboundEncryptedConnection(remotePeer, {\n            ...protectedConn,\n            ...encryptedConn\n          })) {\n            throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n          }\n        } else {\n          const idStr = maConn.remoteAddr.getPeerId()\n\n          if (idStr == null) {\n            throw errCode(new Error('inbound connection that skipped encryption must have a peer id'), codes.ERR_INVALID_MULTIADDR)\n          }\n\n          const remotePeerId = peerIdFromString(idStr)\n\n          cryptoProtocol = 'native'\n          remotePeer = remotePeerId\n        }\n\n        upgradedConn = encryptedConn\n        if (opts?.muxerFactory != null) {\n          muxerFactory = opts.muxerFactory\n        } else if (this.muxers.size > 0) {\n          // Multiplex the connection\n          const multiplexed = await this._multiplexInbound({\n            ...protectedConn,\n            ...encryptedConn\n          }, this.muxers)\n          muxerFactory = multiplexed.muxerFactory\n          upgradedConn = multiplexed.stream\n        }\n      } catch (err: any) {\n        log.error('Failed to upgrade inbound connection', err)\n        throw err\n      }\n\n      if (await this.components.connectionGater.denyInboundUpgradedConnection(remotePeer, {\n        ...protectedConn,\n        ...encryptedConn\n      })) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n      }\n\n      log('Successfully upgraded inbound connection')\n\n      return this._createConnection({\n        cryptoProtocol,\n        direction: 'inbound',\n        maConn,\n        upgradedConn,\n        muxerFactory,\n        remotePeer\n      })\n    } finally {\n      this.components.connectionManager.afterUpgradeInbound()\n      timeoutController.clear()\n    }\n  }\n\n  /**\n   * Upgrades an outbound connection\n   */\n  async upgradeOutbound (maConn: MultiaddrConnection, opts?: UpgraderOptions): Promise<Connection> {\n    const idStr = maConn.remoteAddr.getPeerId()\n    let remotePeerId: PeerId | undefined\n\n    if (idStr != null) {\n      remotePeerId = peerIdFromString(idStr)\n\n      if (await this.components.connectionGater.denyOutboundConnection(remotePeerId, maConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by connectionGater.denyOutboundConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n      }\n    }\n\n    let encryptedConn\n    let remotePeer: PeerId\n    let upgradedConn\n    let cryptoProtocol\n    let muxerFactory\n\n    this.components.metrics?.trackMultiaddrConnection(maConn)\n\n    log('Starting the outbound connection upgrade')\n\n    // If the transport natively supports encryption, skip connection\n    // protector and encryption\n\n    // Protect\n    let protectedConn = maConn\n    if (opts?.skipProtection !== true) {\n      const protector = this.components.connectionProtector\n\n      if (protector != null) {\n        protectedConn = await protector.protect(maConn)\n      }\n    }\n\n    try {\n      // Encrypt the connection\n      encryptedConn = protectedConn\n      if (opts?.skipEncryption !== true) {\n        ({\n          conn: encryptedConn,\n          remotePeer,\n          protocol: cryptoProtocol\n        } = await this._encryptOutbound(protectedConn, remotePeerId))\n\n        if (await this.components.connectionGater.denyOutboundEncryptedConnection(remotePeer, {\n          ...protectedConn,\n          ...encryptedConn\n        })) {\n          throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n        }\n      } else {\n        if (remotePeerId == null) {\n          throw errCode(new Error('Encryption was skipped but no peer id was passed'), codes.ERR_INVALID_PEER)\n        }\n\n        cryptoProtocol = 'native'\n        remotePeer = remotePeerId\n      }\n\n      upgradedConn = encryptedConn\n      if (opts?.muxerFactory != null) {\n        muxerFactory = opts.muxerFactory\n      } else if (this.muxers.size > 0) {\n        // Multiplex the connection\n        const multiplexed = await this._multiplexOutbound({\n          ...protectedConn,\n          ...encryptedConn\n        }, this.muxers)\n        muxerFactory = multiplexed.muxerFactory\n        upgradedConn = multiplexed.stream\n      }\n    } catch (err: any) {\n      log.error('Failed to upgrade outbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (await this.components.connectionGater.denyOutboundUpgradedConnection(remotePeer, {\n      ...protectedConn,\n      ...encryptedConn\n    })) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n    }\n\n    log('Successfully upgraded outbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      muxerFactory,\n      remotePeer\n    })\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   */\n  _createConnection (opts: CreateConectionOptions): Connection {\n    const {\n      cryptoProtocol,\n      direction,\n      maConn,\n      upgradedConn,\n      remotePeer,\n      muxerFactory\n    } = opts\n\n    let muxer: StreamMuxer | undefined\n    let newStream: ((multicodecs: string[], options?: AbortOptions) => Promise<Stream>) | undefined\n    let connection: Connection // eslint-disable-line prefer-const\n\n    if (muxerFactory != null) {\n      // Create the muxer\n      muxer = muxerFactory.createStreamMuxer({\n        direction,\n        // Run anytime a remote stream is created\n        onIncomingStream: muxedStream => {\n          if (connection == null) {\n            return\n          }\n\n          void Promise.resolve()\n            .then(async () => {\n              const protocols = this.components.registrar.getProtocols()\n              const { stream, protocol } = await mss.handle(muxedStream, protocols)\n              log('%s: incoming stream opened on %s', direction, protocol)\n\n              if (connection == null) {\n                return\n              }\n\n              const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar)\n              const streamCount = countStreams(protocol, 'inbound', connection)\n\n              if (streamCount === incomingLimit) {\n                muxedStream.abort(errCode(new Error(`Too many inbound protocol streams for protocol \"${protocol}\" - limit ${incomingLimit}`), codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS))\n\n                return\n              }\n\n              // after the handshake the returned stream can have early data so override\n              // the souce/sink\n              muxedStream.source = stream.source\n              muxedStream.sink = stream.sink\n              muxedStream.stat.protocol = protocol\n\n              // If a protocol stream has been successfully negotiated and is to be passed to the application,\n              // the peerstore should ensure that the peer is registered with that protocol\n              this.components.peerStore.protoBook.add(remotePeer, [protocol]).catch(err => log.error(err))\n\n              connection.addStream(muxedStream)\n              this.components.metrics?.trackProtocolStream(muxedStream, connection)\n\n              this._onStream({ connection, stream: muxedStream, protocol })\n            })\n            .catch(err => {\n              log.error(err)\n\n              if (muxedStream.stat.timeline.close == null) {\n                muxedStream.close()\n              }\n            })\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection?.removeStream(muxedStream.id)\n        }\n      })\n\n      newStream = async (protocols: string[], options: AbortOptions = {}): Promise<Stream> => {\n        if (muxer == null) {\n          throw errCode(new Error('Stream is not multiplexed'), codes.ERR_MUXER_UNAVAILABLE)\n        }\n\n        log('%s: starting new stream on %s', direction, protocols)\n        const muxedStream = await muxer.newStream()\n        let controller: TimeoutController | undefined\n\n        try {\n          if (options.signal == null) {\n            log('No abort signal was passed while trying to negotiate protocols %s falling back to default timeout', protocols)\n\n            controller = new TimeoutController(30000)\n            options.signal = controller.signal\n\n            try {\n              // fails on node < 15.4\n              setMaxListeners?.(Infinity, controller.signal)\n            } catch {}\n          }\n\n          const { stream, protocol } = await mss.select(muxedStream, protocols, options)\n\n          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar)\n          const streamCount = countStreams(protocol, 'outbound', connection)\n\n          if (streamCount === outgoingLimit) {\n            const err = errCode(new Error(`Too many outbound protocol streams for protocol \"${protocol}\" - limit ${outgoingLimit}`), codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS)\n            muxedStream.abort(err)\n\n            throw err\n          }\n\n          // If a protocol stream has been successfully negotiated and is to be passed to the application,\n          // the peerstore should ensure that the peer is registered with that protocol\n          this.components.peerStore.protoBook.add(remotePeer, [protocol]).catch(err => log.error(err))\n\n          // after the handshake the returned stream can have early data so override\n          // the souce/sink\n          muxedStream.source = stream.source\n          muxedStream.sink = stream.sink\n          muxedStream.stat.protocol = protocol\n\n          this.components.metrics?.trackProtocolStream(muxedStream, connection)\n\n          return muxedStream\n        } catch (err: any) {\n          log.error('could not create new stream', err)\n\n          if (muxedStream.stat.timeline.close == null) {\n            muxedStream.close()\n          }\n\n          if (err.code != null) {\n            throw err\n          }\n\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL)\n        } finally {\n          if (controller != null) {\n            controller.clear()\n          }\n        }\n      }\n\n      // Pipe all data through the muxer\n      void Promise.all([\n        muxer.sink(upgradedConn.source),\n        upgradedConn.sink(muxer.source)\n      ]).catch(err => {\n        log.error(err)\n      })\n    }\n\n    const _timeline = maConn.timeline\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection != null && args[1] === 'close' && args[2] != null && _timeline.close == null) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.stat.status === 'OPEN') {\n                await connection.close()\n              }\n            } catch (err: any) {\n              log.error(err)\n            } finally {\n              this.dispatchEvent(new CustomEvent<Connection>('connectionEnd', {\n                detail: connection\n              }))\n            }\n          })().catch(err => {\n            log.error(err)\n          })\n        }\n\n        return Reflect.set(...args)\n      }\n    })\n    maConn.timeline.upgraded = Date.now()\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), codes.ERR_CONNECTION_NOT_MULTIPLEXED)\n    }\n\n    // Create the connection\n    connection = createConnection({\n      remoteAddr: maConn.remoteAddr,\n      remotePeer: remotePeer,\n      stat: {\n        status: 'OPEN',\n        direction,\n        timeline: maConn.timeline,\n        multiplexer: muxer?.protocol,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream ?? errConnectionNotMultiplexed,\n      getStreams: () => muxer != null ? muxer.streams : errConnectionNotMultiplexed(),\n      close: async () => {\n        await maConn.close()\n        // Ensure remaining streams are closed\n        if (muxer != null) {\n          muxer.close()\n        }\n      }\n    })\n\n    this.dispatchEvent(new CustomEvent<Connection>('connection', {\n      detail: connection\n    }))\n\n    return connection\n  }\n\n  /**\n   * Routes incoming streams to the correct handler\n   */\n  _onStream (opts: OnStreamOptions): void {\n    const { connection, stream, protocol } = opts\n    const { handler } = this.components.registrar.getHandler(protocol)\n\n    handler({ connection, stream })\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`\n   */\n  async _encryptInbound (connection: Duplex<Uint8Array>): Promise<CryptoResult> {\n    const protocols = Array.from(this.connectionEncryption.keys())\n    log('handling inbound crypto protocol selection', protocols)\n\n    try {\n      const { stream, protocol } = await mss.handle(connection, protocols, {\n        writeBytes: true\n      })\n      const encrypter = this.connectionEncryption.get(protocol)\n\n      if (encrypter == null) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      log('encrypting inbound connection...')\n\n      return {\n        ...await encrypter.secureInbound(this.components.peerId, stream),\n        protocol\n      }\n    } catch (err: any) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided connection encrypters.\n   * The first `ConnectionEncrypter` module to succeed will be used\n   */\n  async _encryptOutbound (connection: MultiaddrConnection, remotePeerId?: PeerId): Promise<CryptoResult> {\n    const protocols = Array.from(this.connectionEncryption.keys())\n    log('selecting outbound crypto protocol', protocols)\n\n    try {\n      const { stream, protocol } = await mss.select(connection, protocols, {\n        writeBytes: true\n      })\n      const encrypter = this.connectionEncryption.get(protocol)\n\n      if (encrypter == null) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      log('encrypting outbound connection to %p', remotePeerId)\n\n      return {\n        ...await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId),\n        protocol\n      }\n    } catch (err: any) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   */\n  async _multiplexOutbound (connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>): Promise<{stream: Duplex<Uint8Array>, muxerFactory?: StreamMuxerFactory}> {\n    const protocols = Array.from(muxers.keys())\n    log('outbound selecting muxer %s', protocols)\n    try {\n      const { stream, protocol } = await mss.select(connection, protocols, {\n        writeBytes: true\n      })\n      log('%s selected as muxer protocol', protocol)\n      const muxerFactory = muxers.get(protocol)\n      return { stream, muxerFactory }\n    } catch (err: any) {\n      log.error('error multiplexing outbound stream', err)\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   */\n  async _multiplexInbound (connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>): Promise<{stream: Duplex<Uint8Array>, muxerFactory?: StreamMuxerFactory}> {\n    const protocols = Array.from(muxers.keys())\n    log('inbound handling muxers %s', protocols)\n    try {\n      const { stream, protocol } = await mss.handle(connection, protocols, {\n        writeBytes: true\n      })\n      const muxerFactory = muxers.get(protocol)\n      return { stream, muxerFactory }\n    } catch (err: any) {\n      log.error('error multiplexing inbound stream', err)\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}