{"ast":null,"code":"import { CID } from 'multiformats/cid';\nimport { createUnsafe } from 'multiformats/block';\nimport { CarWriter } from '@ipld/car/writer';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { logger } from '@libp2p/logger';\nimport * as raw from 'multiformats/codecs/raw';\nimport * as json from 'multiformats/codecs/json';\nimport { walk } from 'multiformats/traversal';\nconst log = logger('ipfs:components:dag:import'); // blocks that we're OK with not inspecting for links\n\n/** @type {number[]} */\n\nconst NO_LINKS_CODECS = [raw.code, // raw\njson.code // JSON\n];\n/**\n * @typedef {import('../../types').Preload} Preload\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('@ipld/car/api').BlockWriter} BlockWriter\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @template T\n * @template C\n * @template A\n * @template V\n * @typedef {import('multiformats/block').Block<T, C, A, V>} Block\n */\n\n/**\n * @param {object} config\n * @param {IPFSRepo} config.repo\n * @param {Preload} config.preload\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n */\n\nexport function createExport(_ref) {\n  let {\n    repo,\n    preload,\n    codecs\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/dag').API<{}>[\"export\"]}\n   */\n  async function* dagExport(root) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.preload !== false) {\n      preload(root);\n    }\n\n    const cid = CID.asCID(root);\n\n    if (!cid) {\n      throw new Error(`Unexpected error converting CID type: ${root}`);\n    }\n\n    log(`Exporting ${cid} as car`);\n    const {\n      writer,\n      out\n    } = await CarWriter.create([cid]); // we need to write with one async channel and send the CarWriter output\n    // with another to the caller, but if the write causes an error we capture\n    // that and make sure it gets propagated\n\n    /** @type {Error|null} */\n\n    let err = null;\n\n    (async () => {\n      try {\n        const load = makeLoader(repo, writer, {\n          signal: options.signal,\n          timeout: options.timeout\n        }, codecs);\n        await walk({\n          cid,\n          load\n        });\n      } catch (\n      /** @type {any} */\n      e) {\n        err = e;\n      } finally {\n        writer.close();\n      }\n    })();\n\n    for await (const chunk of out) {\n      if (err) {\n        break;\n      }\n\n      yield chunk;\n    }\n\n    if (err) {\n      throw err;\n    }\n  }\n\n  return withTimeoutOption(dagExport);\n}\n/**\n * @param {IPFSRepo} repo\n * @param {BlockWriter} writer\n * @param {AbortOptions} options\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @returns {(cid:CID)=>Promise<ReturnType<createUnsafe>|null>}\n */\n\nfunction makeLoader(repo, writer, options, codecs) {\n  return async cid => {\n    const codec = await codecs.getCodec(cid.code);\n\n    if (!codec) {\n      throw new Error(`Can't decode links in block with codec 0x${cid.code.toString(16)} to form complete DAG`);\n    }\n\n    const bytes = await repo.blocks.get(cid, options);\n    log(`Adding block ${cid} to car`);\n    await writer.put({\n      cid,\n      bytes\n    });\n\n    if (NO_LINKS_CODECS.includes(cid.code)) {\n      return null; // skip this block, no need to look inside\n    }\n\n    return createUnsafe({\n      bytes,\n      cid,\n      codec\n    });\n  };\n}","map":{"version":3,"sources":["C:/Users/Akshay Mishra/OneDrive/Desktop/twitter-clone-dapp/node_modules/ipfs-core/src/components/dag/export.js"],"names":["CID","createUnsafe","CarWriter","withTimeoutOption","logger","raw","json","walk","log","NO_LINKS_CODECS","code","createExport","repo","preload","codecs","dagExport","root","options","cid","asCID","Error","writer","out","create","err","load","makeLoader","signal","timeout","e","close","chunk","codec","getCodec","toString","bytes","blocks","get","put","includes"],"mappings":"AAAA,SAASA,GAAT,QAAoB,kBAApB;AACA,SAASC,YAAT,QAA6B,oBAA7B;AACA,SAASC,SAAT,QAA0B,kBAA1B;AACA,SAASC,iBAAT,QAAkC,qCAAlC;AACA,SAASC,MAAT,QAAuB,gBAAvB;AACA,OAAO,KAAKC,GAAZ,MAAqB,yBAArB;AACA,OAAO,KAAKC,IAAZ,MAAsB,0BAAtB;AACA,SAASC,IAAT,QAAqB,wBAArB;AAEA,MAAMC,GAAG,GAAGJ,MAAM,CAAC,4BAAD,CAAlB,C,CAEA;;AACA;;AACA,MAAMK,eAAe,GAAG,CACtBJ,GAAG,CAACK,IADkB,EACZ;AACVJ,IAAI,CAACI,IAFiB,CAEZ;AAFY,CAAxB;AAKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,YAAT,OAAkD;AAAA,MAA3B;AAAEC,IAAAA,IAAF;AAAQC,IAAAA,OAAR;AAAiBC,IAAAA;AAAjB,GAA2B;;AACvD;AACF;AACA;AACE,kBAAiBC,SAAjB,CAA4BC,IAA5B,EAAgD;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAC9C,QAAIA,OAAO,CAACJ,OAAR,KAAoB,KAAxB,EAA+B;AAC7BA,MAAAA,OAAO,CAACG,IAAD,CAAP;AACD;;AAED,UAAME,GAAG,GAAGlB,GAAG,CAACmB,KAAJ,CAAUH,IAAV,CAAZ;;AACA,QAAI,CAACE,GAAL,EAAU;AACR,YAAM,IAAIE,KAAJ,CAAW,yCAAwCJ,IAAK,EAAxD,CAAN;AACD;;AAEDR,IAAAA,GAAG,CAAE,aAAYU,GAAI,SAAlB,CAAH;AACA,UAAM;AAAEG,MAAAA,MAAF;AAAUC,MAAAA;AAAV,QAAkB,MAAMpB,SAAS,CAACqB,MAAV,CAAiB,CAACL,GAAD,CAAjB,CAA9B,CAX8C,CAa9C;AACA;AACA;;AACA;;AACA,QAAIM,GAAG,GAAG,IAAV;;AACC,KAAC,YAAY;AACZ,UAAI;AACF,cAAMC,IAAI,GAAGC,UAAU,CAACd,IAAD,EAAOS,MAAP,EAAe;AACpCM,UAAAA,MAAM,EAAEV,OAAO,CAACU,MADoB;AAEpCC,UAAAA,OAAO,EAAEX,OAAO,CAACW;AAFmB,SAAf,EAGpBd,MAHoB,CAAvB;AAIA,cAAMP,IAAI,CAAC;AAAEW,UAAAA,GAAF;AAAOO,UAAAA;AAAP,SAAD,CAAV;AACD,OAND,CAME;AAAO;AAAmBI,MAAAA,CAA1B,EAA6B;AAC7BL,QAAAA,GAAG,GAAGK,CAAN;AACD,OARD,SAQU;AACRR,QAAAA,MAAM,CAACS,KAAP;AACD;AACF,KAZA;;AAcD,eAAW,MAAMC,KAAjB,IAA0BT,GAA1B,EAA+B;AAC7B,UAAIE,GAAJ,EAAS;AACP;AACD;;AACD,YAAMO,KAAN;AACD;;AACD,QAAIP,GAAJ,EAAS;AACP,YAAMA,GAAN;AACD;AACF;;AAED,SAAOrB,iBAAiB,CAACY,SAAD,CAAxB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASW,UAAT,CAAqBd,IAArB,EAA2BS,MAA3B,EAAmCJ,OAAnC,EAA4CH,MAA5C,EAAoD;AAClD,SAAO,MAAOI,GAAP,IAAe;AACpB,UAAMc,KAAK,GAAG,MAAMlB,MAAM,CAACmB,QAAP,CAAgBf,GAAG,CAACR,IAApB,CAApB;;AAEA,QAAI,CAACsB,KAAL,EAAY;AACV,YAAM,IAAIZ,KAAJ,CAAW,4CAA2CF,GAAG,CAACR,IAAJ,CAASwB,QAAT,CAAkB,EAAlB,CAAsB,uBAA5E,CAAN;AACD;;AAED,UAAMC,KAAK,GAAG,MAAMvB,IAAI,CAACwB,MAAL,CAAYC,GAAZ,CAAgBnB,GAAhB,EAAqBD,OAArB,CAApB;AAEAT,IAAAA,GAAG,CAAE,gBAAeU,GAAI,SAArB,CAAH;AACA,UAAMG,MAAM,CAACiB,GAAP,CAAW;AAAEpB,MAAAA,GAAF;AAAOiB,MAAAA;AAAP,KAAX,CAAN;;AAEA,QAAI1B,eAAe,CAAC8B,QAAhB,CAAyBrB,GAAG,CAACR,IAA7B,CAAJ,EAAwC;AACtC,aAAO,IAAP,CADsC,CAC1B;AACb;;AAED,WAAOT,YAAY,CAAC;AAAEkC,MAAAA,KAAF;AAASjB,MAAAA,GAAT;AAAcc,MAAAA;AAAd,KAAD,CAAnB;AACD,GAjBD;AAkBD","sourcesContent":["import { CID } from 'multiformats/cid'\nimport { createUnsafe } from 'multiformats/block'\nimport { CarWriter } from '@ipld/car/writer'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { logger } from '@libp2p/logger'\nimport * as raw from 'multiformats/codecs/raw'\nimport * as json from 'multiformats/codecs/json'\nimport { walk } from 'multiformats/traversal'\n\nconst log = logger('ipfs:components:dag:import')\n\n// blocks that we're OK with not inspecting for links\n/** @type {number[]} */\nconst NO_LINKS_CODECS = [\n  raw.code, // raw\n  json.code // JSON\n]\n\n/**\n * @typedef {import('../../types').Preload} Preload\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('@ipld/car/api').BlockWriter} BlockWriter\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @template T\n * @template C\n * @template A\n * @template V\n * @typedef {import('multiformats/block').Block<T, C, A, V>} Block\n */\n\n/**\n * @param {object} config\n * @param {IPFSRepo} config.repo\n * @param {Preload} config.preload\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n */\nexport function createExport ({ repo, preload, codecs }) {\n  /**\n   * @type {import('ipfs-core-types/src/dag').API<{}>[\"export\"]}\n   */\n  async function * dagExport (root, options = {}) {\n    if (options.preload !== false) {\n      preload(root)\n    }\n\n    const cid = CID.asCID(root)\n    if (!cid) {\n      throw new Error(`Unexpected error converting CID type: ${root}`)\n    }\n\n    log(`Exporting ${cid} as car`)\n    const { writer, out } = await CarWriter.create([cid])\n\n    // we need to write with one async channel and send the CarWriter output\n    // with another to the caller, but if the write causes an error we capture\n    // that and make sure it gets propagated\n    /** @type {Error|null} */\n    let err = null\n    ;(async () => {\n      try {\n        const load = makeLoader(repo, writer, {\n          signal: options.signal,\n          timeout: options.timeout\n        }, codecs)\n        await walk({ cid, load })\n      } catch (/** @type {any} */ e) {\n        err = e\n      } finally {\n        writer.close()\n      }\n    })()\n\n    for await (const chunk of out) {\n      if (err) {\n        break\n      }\n      yield chunk\n    }\n    if (err) {\n      throw err\n    }\n  }\n\n  return withTimeoutOption(dagExport)\n}\n\n/**\n * @param {IPFSRepo} repo\n * @param {BlockWriter} writer\n * @param {AbortOptions} options\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @returns {(cid:CID)=>Promise<ReturnType<createUnsafe>|null>}\n */\nfunction makeLoader (repo, writer, options, codecs) {\n  return async (cid) => {\n    const codec = await codecs.getCodec(cid.code)\n\n    if (!codec) {\n      throw new Error(`Can't decode links in block with codec 0x${cid.code.toString(16)} to form complete DAG`)\n    }\n\n    const bytes = await repo.blocks.get(cid, options)\n\n    log(`Adding block ${cid} to car`)\n    await writer.put({ cid, bytes })\n\n    if (NO_LINKS_CODECS.includes(cid.code)) {\n      return null // skip this block, no need to look inside\n    }\n\n    return createUnsafe({ bytes, cid, codec })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}