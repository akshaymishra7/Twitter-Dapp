{"ast":null,"code":"import { pushable } from 'it-pushable';\nimport merge from 'it-merge';\nexport const rawPipe = function () {\n  let res;\n\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  while (fns.length > 0) {\n    res = fns.shift()(res);\n  }\n\n  return res;\n};\nexport const isIterable = obj => {\n  return obj != null && (typeof obj[Symbol.asyncIterator] === 'function' || typeof obj[Symbol.iterator] === 'function' || typeof obj.next === 'function' // Probably, right?\n  );\n};\nexport const isDuplex = obj => {\n  return obj != null && typeof obj.sink === 'function' && isIterable(obj.source);\n};\n\nconst duplexPipelineFn = duplex => {\n  return source => {\n    const p = duplex.sink(source);\n\n    if (p.then != null) {\n      const stream = pushable({\n        objectMode: true\n      });\n      p.then(() => {\n        stream.end();\n      }, err => {\n        stream.end(err);\n      });\n\n      const sourceWrap = async function* () {\n        yield* duplex.source;\n        stream.end();\n      };\n\n      return merge(stream, sourceWrap());\n    }\n\n    return duplex.source;\n  };\n};\n\nexport function pipe(first) {\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(first)) {\n    const duplex = first;\n\n    first = () => duplex.source; // Iterable at start: wrap in function\n\n  } else if (isIterable(first)) {\n    const source = first;\n\n    first = () => source;\n  }\n\n  for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    rest[_key2 - 1] = arguments[_key2];\n  }\n\n  const fns = [first, ...rest];\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink;\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i]);\n      }\n    }\n  }\n\n  return rawPipe(...fns);\n}","map":{"version":3,"mappings":"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","names":["pushable","merge","rawPipe","res","fns","length","shift","isIterable","obj","Symbol","asyncIterator","iterator","next","isDuplex","sink","source","duplexPipelineFn","duplex","p","then","stream","objectMode","end","err","sourceWrap","pipe","first","rest","i"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\it-pipe\\src\\index.ts"],"sourcesContent":["import { pushable } from 'it-pushable'\nimport merge from 'it-merge'\nimport type * as it from 'it-stream-types'\n\nexport const rawPipe = (...fns: any) => {\n  let res\n  while (fns.length > 0) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nexport const isIterable = (obj: any): obj is it.Source<any> => {\n  return obj != null && (\n    typeof obj[Symbol.asyncIterator] === 'function' ||\n    typeof obj[Symbol.iterator] === 'function' ||\n    typeof obj.next === 'function' // Probably, right?\n  )\n}\n\nexport const isDuplex = <TSource, TSink = TSource, RSink = Promise<void>> (obj: any): obj is it.Duplex<TSource, TSink, RSink> => {\n  return obj != null && typeof obj.sink === 'function' && isIterable(obj.source)\n}\n\nconst duplexPipelineFn = <TSource> (duplex: it.Duplex<TSource>) => {\n  return (source: any): it.Source<TSource> => {\n    const p = duplex.sink(source)\n\n    if (p.then != null) {\n      const stream = pushable<TSource>({\n        objectMode: true\n      })\n      p.then(() => {\n        stream.end()\n      }, (err: Error) => {\n        stream.end(err)\n      })\n\n      const sourceWrap = async function * () {\n        yield * duplex.source\n        stream.end()\n      }\n\n      return merge(stream, sourceWrap())\n    }\n\n    return duplex.source\n  }\n}\n\nexport type Source<A> = it.Source<A> | (() => it.Source<A>) | it.Duplex<A, any, any>\nexport type Transform<A, B> = it.Transform<A, B> | it.Duplex<B, A, any>\nexport type Sink<A, B> = it.Sink<A, B> | it.Duplex<any, A, B>\n\nexport function pipe<A> (\n  first: Source<A>\n): it.Source<A>\n\nexport function pipe<A, B> (\n  first: Source<A>,\n  second: Sink<A, B>\n): B\n\nexport function pipe<A, B, C> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Sink<B, C>\n): C\n\nexport function pipe<A, B, C, D> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Sink<C, D>\n): D\n\nexport function pipe<A, B, C, D, E> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Transform<C, D>,\n  fifth: Sink<D, E>\n): E\n\nexport function pipe<A, B, C, D, E, F> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Transform<C, D>,\n  fifth: Transform<D, E>,\n  sixth: Sink<E, F>\n): F\n\nexport function pipe<A, B, C, D, E, F, G> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Transform<C, D>,\n  fifth: Transform<D, E>,\n  sixth: Transform<E, F>,\n  seventh: Sink<F, G>\n): G\n\nexport function pipe<A, B, C, D, E, F, G, H> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Transform<C, D>,\n  fifth: Transform<D, E>,\n  sixth: Transform<E, F>,\n  seventh: Transform<F, G>,\n  eighth: Sink<G, H>\n): H\n\nexport function pipe<A, B, C, D, E, F, G, H, I> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Transform<C, D>,\n  fifth: Transform<D, E>,\n  sixth: Transform<E, F>,\n  seventh: Transform<F, G>,\n  eighth: Transform<G, H>,\n  ninth: Sink<H, I>\n): I\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J> (\n  first: Source<A>,\n  second: Transform<A, B>,\n  third: Transform<B, C>,\n  fourth: Transform<C, D>,\n  fifth: Transform<D, E>,\n  sixth: Transform<E, F>,\n  seventh: Transform<F, G>,\n  eighth: Transform<G, H>,\n  ninth: Transform<H, I>,\n  tenth: Sink<I, J>\n): J\n\nexport function pipe (first: any, ...rest: any[]): any {\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(first)) {\n    const duplex = first\n    first = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(first)) {\n    const source = first\n    first = () => source\n  }\n\n  const fns = [first, ...rest]\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n"]},"metadata":{},"sourceType":"module"}