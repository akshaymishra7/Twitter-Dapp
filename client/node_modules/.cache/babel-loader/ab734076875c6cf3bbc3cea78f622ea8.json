{"ast":null,"code":"import { peerIdFromBytes } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { Libp2pRecord } from '@libp2p/record';\nimport { Message as PBMessage } from './dht.js';\nexport const MESSAGE_TYPE = PBMessage.MessageType;\nexport const CONNECTION_TYPE = PBMessage.ConnectionType;\nexport const MESSAGE_TYPE_LOOKUP = Object.keys(MESSAGE_TYPE);\n/**\n * Represents a single DHT control message.\n */\n\nexport class Message {\n  constructor(type, key, level) {\n    if (!(key instanceof Uint8Array)) {\n      throw new Error('Key must be a Uint8Array');\n    }\n\n    this.type = type;\n    this.key = key;\n    this.clusterLevelRaw = level;\n    this.closerPeers = [];\n    this.providerPeers = [];\n    this.record = undefined;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  get clusterLevel() {\n    const level = this.clusterLevelRaw - 1;\n\n    if (level < 0) {\n      return 0;\n    }\n\n    return level;\n  }\n\n  set clusterLevel(level) {\n    this.clusterLevelRaw = level;\n  }\n  /**\n   * Encode into protobuf\n   */\n\n\n  serialize() {\n    return PBMessage.encode({\n      key: this.key,\n      type: this.type,\n      clusterLevelRaw: this.clusterLevelRaw,\n      closerPeers: this.closerPeers.map(toPbPeer),\n      providerPeers: this.providerPeers.map(toPbPeer),\n      record: this.record == null ? undefined : this.record.serialize().subarray()\n    });\n  }\n  /**\n   * Decode from protobuf\n   */\n\n\n  static deserialize(raw) {\n    const dec = PBMessage.decode(raw);\n    const msg = new Message(dec.type ?? PBMessage.MessageType.PUT_VALUE, dec.key ?? Uint8Array.from([]), dec.clusterLevelRaw ?? 0);\n    msg.closerPeers = dec.closerPeers.map(fromPbPeer);\n    msg.providerPeers = dec.providerPeers.map(fromPbPeer);\n\n    if (dec.record?.length != null) {\n      msg.record = Libp2pRecord.deserialize(dec.record);\n    }\n\n    return msg;\n  }\n\n}\n\nfunction toPbPeer(peer) {\n  const output = {\n    id: peer.id.toBytes(),\n    addrs: (peer.multiaddrs ?? []).map(m => m.bytes),\n    connection: CONNECTION_TYPE.CONNECTED\n  };\n  return output;\n}\n\nfunction fromPbPeer(peer) {\n  if (peer.id == null) {\n    throw new Error('Invalid peer in message');\n  }\n\n  return {\n    id: peerIdFromBytes(peer.id),\n    multiaddrs: (peer.addrs ?? []).map(a => multiaddr(a)),\n    protocols: []\n  };\n}","map":{"version":3,"mappings":"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","names":["peerIdFromBytes","multiaddr","Libp2pRecord","Message","PBMessage","MESSAGE_TYPE","MessageType","CONNECTION_TYPE","ConnectionType","MESSAGE_TYPE_LOOKUP","Object","keys","constructor","type","key","level","Uint8Array","Error","clusterLevelRaw","closerPeers","providerPeers","record","undefined","clusterLevel","serialize","encode","map","toPbPeer","subarray","deserialize","raw","dec","decode","msg","PUT_VALUE","from","fromPbPeer","length","peer","output","id","toBytes","addrs","multiaddrs","m","bytes","connection","CONNECTED","a","protocols"],"sources":["C:\\Users\\Akshay Mishra\\OneDrive\\Desktop\\twitter-clone-dapp\\node_modules\\@libp2p\\kad-dht\\src\\message\\index.ts"],"sourcesContent":["import { peerIdFromBytes } from '@libp2p/peer-id'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { Libp2pRecord } from '@libp2p/record'\nimport { Message as PBMessage } from './dht.js'\nimport type { PeerInfo } from '@libp2p/interface-peer-info'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport const MESSAGE_TYPE = PBMessage.MessageType\nexport const CONNECTION_TYPE = PBMessage.ConnectionType\nexport const MESSAGE_TYPE_LOOKUP = Object.keys(MESSAGE_TYPE)\n\ninterface PBPeer {\n  id: Uint8Array\n  addrs: Uint8Array[]\n  connection: PBMessage.ConnectionType\n}\n\n/**\n * Represents a single DHT control message.\n */\nexport class Message {\n  public type: PBMessage.MessageType\n  public key: Uint8Array\n  private clusterLevelRaw: number\n  public closerPeers: PeerInfo[]\n  public providerPeers: PeerInfo[]\n  public record?: Libp2pRecord\n\n  constructor (type: PBMessage.MessageType, key: Uint8Array, level: number) {\n    if (!(key instanceof Uint8Array)) {\n      throw new Error('Key must be a Uint8Array')\n    }\n\n    this.type = type\n    this.key = key\n    this.clusterLevelRaw = level\n    this.closerPeers = []\n    this.providerPeers = []\n    this.record = undefined\n  }\n\n  /**\n   * @type {number}\n   */\n  get clusterLevel (): number {\n    const level = this.clusterLevelRaw - 1\n    if (level < 0) {\n      return 0\n    }\n\n    return level\n  }\n\n  set clusterLevel (level) {\n    this.clusterLevelRaw = level\n  }\n\n  /**\n   * Encode into protobuf\n   */\n  serialize (): Uint8Array {\n    return PBMessage.encode({\n      key: this.key,\n      type: this.type,\n      clusterLevelRaw: this.clusterLevelRaw,\n      closerPeers: this.closerPeers.map(toPbPeer),\n      providerPeers: this.providerPeers.map(toPbPeer),\n      record: this.record == null ? undefined : this.record.serialize().subarray()\n    })\n  }\n\n  /**\n   * Decode from protobuf\n   */\n  static deserialize (raw: Uint8ArrayList | Uint8Array): Message {\n    const dec = PBMessage.decode(raw)\n\n    const msg = new Message(dec.type ?? PBMessage.MessageType.PUT_VALUE, dec.key ?? Uint8Array.from([]), dec.clusterLevelRaw ?? 0)\n    msg.closerPeers = dec.closerPeers.map(fromPbPeer)\n    msg.providerPeers = dec.providerPeers.map(fromPbPeer)\n\n    if (dec.record?.length != null) {\n      msg.record = Libp2pRecord.deserialize(dec.record)\n    }\n\n    return msg\n  }\n}\n\nfunction toPbPeer (peer: PeerInfo): PBPeer {\n  const output: PBPeer = {\n    id: peer.id.toBytes(),\n    addrs: (peer.multiaddrs ?? []).map((m) => m.bytes),\n    connection: CONNECTION_TYPE.CONNECTED\n  }\n\n  return output\n}\n\nfunction fromPbPeer (peer: PBMessage.Peer): PeerInfo {\n  if (peer.id == null) {\n    throw new Error('Invalid peer in message')\n  }\n\n  return {\n    id: peerIdFromBytes(peer.id),\n    multiaddrs: (peer.addrs ?? []).map((a) => multiaddr(a)),\n    protocols: []\n  }\n}\n"]},"metadata":{},"sourceType":"module"}